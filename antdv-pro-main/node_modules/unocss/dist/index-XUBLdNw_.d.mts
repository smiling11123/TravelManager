import MagicString from "magic-string";
import { LoadConfigResult } from "unconfig";
import { CustomIconLoader, IconCustomizations, IconifyLoaderOptions, InlineCollection, UniversalIconLoader } from "@iconify/utils";
import { IconifyJSON } from "@iconify/types";
import { encodeSvgForCss } from "@iconify/utils/lib/svg/encode-svg-for-css";

//#region ../../packages-engine/core/src/utils/basic.d.ts
declare function toArray<T>(value?: T | T[]): T[];
declare function uniq<T>(value: T[]): T[];
declare function uniqueBy<T>(array: readonly T[], equalFn: (a: T, b: T) => boolean): T[];
declare function isString(s: any): s is string;
//#endregion
//#region ../../packages-engine/core/src/utils/countable-set.d.ts
declare class CountableSet<K$1> extends Set<K$1> {
  _map: Map<K$1, number>;
  constructor(values?: Iterable<K$1>);
  add(key: K$1): this;
  delete(key: K$1): boolean;
  clear(): void;
  getCount(key: K$1): number;
  setCount(key: K$1, count: number): this;
}
declare function isCountableSet<T = string>(value: any): value is CountableSet<T>;
//#endregion
//#region ../../packages-engine/core/src/utils/escape.d.ts
declare function escapeRegExp(string: string): string;
/**
 * CSS Selector Escape
 */
declare function escapeSelector(str: string): string;
declare const e: typeof escapeSelector;
//#endregion
//#region ../../packages-engine/core/src/utils/events.d.ts
type EventsMap = Record<string, any>;
interface DefaultEvents extends EventsMap {
  [event: string]: (...args: any) => void;
}
interface Unsubscribe {
  (): void;
}
declare class Emitter<Events extends EventsMap = DefaultEvents> {
  /**
   * Event names in keys and arrays with listeners in values.
   *
   * ```js
   * emitter1.events = emitter2.events
   * emitter2.events = { }
   * ```
   */
  events: Partial<{ [E in keyof Events]: Events[E][] }>;
  /**
   * Add a listener for a given event.
   *
   * ```js
   * const unbind = ee.on('tick', (tickType, tickDuration) => {
   *   count += 1
   * })
   *
   * disable () {
   *   unbind()
   * }
   * ```
   *
   * @param event The event name.
   * @param cb The listener function.
   * @returns Unbind listener from event.
   */
  on<K$1 extends keyof Events>(this: this, event: K$1, cb: Events[K$1]): Unsubscribe;
  /**
   * Calls each of the listeners registered for a given event.
   *
   * ```js
   * ee.emit('tick', tickType, tickDuration)
   * ```
   *
   * @param event The event name.
   * @param args The arguments for listeners.
   */
  emit<K$1 extends keyof Events>(this: this, event: K$1, ...args: Parameters<Events[K$1]>): void;
}
/**
 * Create event emitter.
 *
 * ```js
 * import { createNanoEvents } from 'nanoevents'
 *
 * class Ticker {
 *   constructor() {
 *     this.emitter = createNanoEvents()
 *   }
 *   on(...args) {
 *     return this.emitter.on(...args)
 *   }
 *   tick() {
 *     this.emitter.emit('tick')
 *   }
 * }
 * ```
 */
declare function createNanoEvents<Events extends EventsMap = DefaultEvents>(): Emitter<Events>;
//#endregion
//#region ../../packages-engine/core/src/utils/helpers.d.ts
declare const attributifyRE: RegExp;
declare const cssIdRE: RegExp;
declare const validateFilterRE: RegExp;
declare function isAttributifySelector(selector: string): RegExpMatchArray | null;
declare function isValidSelector(selector?: string): selector is string;
declare function normalizeVariant(variant: Variant<any>): VariantObject<any>;
declare function isRawUtil(util: ParsedUtil | RawUtil | StringifiedUtil): util is RawUtil;
declare function notNull<T>(value: T | null | undefined): value is T;
declare function noop(): void;
//#endregion
//#region ../../packages-engine/core/src/utils/layer.d.ts
declare function withLayer<T extends object>(layer: string, rules: Rule<T>[]): Rule<T>[];
//#endregion
//#region ../../packages-engine/core/src/utils/map.d.ts
declare class TwoKeyMap<K1, K2, V> {
  _map: Map<K1, Map<K2, V>>;
  get(key1: K1, key2: K2): V | undefined;
  getFallback(key1: K1, key2: K2, fallback: V): V;
  set(key1: K1, key2: K2, value: V): this;
  has(key1: K1, key2: K2): boolean | undefined;
  delete(key1: K1, key2: K2): boolean;
  deleteTop(key1: K1): boolean;
  map<T>(fn: (v: V, k1: K1, k2: K2) => T): T[];
}
declare class BetterMap<K$1, V> extends Map<K$1, V> {
  getFallback(key: K$1, fallback: V): V;
  map<R>(mapFn: (value: V, key: K$1) => R): R[];
  flatMap<R extends readonly unknown[]>(mapFn: (value: V, key: K$1) => R): R[number][];
}
//#endregion
//#region ../../packages-engine/core/src/utils/object.d.ts
declare function normalizeCSSEntries(obj: string | CSSEntriesInput | CSSObjectInput): string | CSSEntries;
declare function normalizeCSSValues(obj: CSSValueInput | string | (CSSValueInput | string)[]): (string | CSSEntries)[];
declare function clearIdenticalEntries(entry: CSSEntries): CSSEntries;
declare const VirtualKey = "__virtual_key__";
declare function entriesToCss(arr?: CSSEntries): string;
declare function isObject(item: any): item is Record<string, any>;
/**
 * Deep merge two objects
 */
declare function mergeDeep<T>(original: T, patch: DeepPartial<T>, mergeArray?: boolean): T;
declare function clone<T>(val: T): T;
declare function isStaticRule(rule: Rule<any>): rule is StaticRule;
declare function isStaticShortcut(sc: Shortcut<any>): sc is StaticShortcut;
//#endregion
//#region ../../packages-engine/core/src/utils/variant-group.d.ts
declare function makeRegexClassGroup(separators?: string[]): RegExp;
interface VariantGroup {
  length: number;
  items: HighlightAnnotation[];
}
declare function parseVariantGroup(str: string | MagicString, separators?: string[], depth?: number): {
  prefixes: string[];
  hasChanged: boolean;
  groupsByOffset: Map<number, VariantGroup>;
  readonly expanded: string;
};
declare function collapseVariantGroup(str: string, prefixes: string[]): string;
declare function expandVariantGroup(str: string, separators?: string[], depth?: number): string;
declare function expandVariantGroup(str: MagicString, separators?: string[], depth?: number): MagicString;
//#endregion
//#region ../../packages-engine/core/src/utils/warn.d.ts
declare function warnOnce(msg: string): void;
//#endregion
//#region ../../packages-engine/core/src/generator.d.ts
declare const symbols: ControlSymbols;
declare class UnoGeneratorInternal<Theme$2 extends object = object> {
  userConfig: UserConfig<Theme$2>;
  defaults: UserConfigDefaults<Theme$2>;
  readonly version: string;
  readonly events: Emitter<{
    config: (config: ResolvedConfig<Theme$2>) => void;
  }>;
  config: ResolvedConfig<Theme$2>;
  cache: Map<string, StringifiedUtil<Theme$2>[] | null>;
  blocked: Set<string>;
  parentOrders: Map<string, number>;
  activatedRules: Set<Rule<Theme$2>>;
  protected constructor(userConfig?: UserConfig<Theme$2>, defaults?: UserConfigDefaults<Theme$2>);
  static create<Theme$2 extends object = object>(userConfig?: UserConfig<Theme$2>, defaults?: UserConfigDefaults<Theme$2>): Promise<UnoGeneratorInternal<Theme$2>>;
  setConfig(userConfig?: UserConfig<Theme$2>, defaults?: UserConfigDefaults<Theme$2>): Promise<void>;
  applyExtractors(code: string, id?: string, extracted?: Set<string>): Promise<Set<string>>;
  applyExtractors(code: string, id?: string, extracted?: CountableSet<string>): Promise<CountableSet<string>>;
  makeContext(raw: string, applied: VariantMatchedResult<Theme$2>): RuleContext<Theme$2>;
  parseToken(raw: string, alias?: string): Promise<StringifiedUtil<Theme$2>[] | undefined | null>;
  generate(input: string | Set<string> | CountableSet<string> | string[], options?: GenerateOptions<false>): Promise<GenerateResult<Set<string>>>;
  generate(input: string | Set<string> | CountableSet<string> | string[], options?: GenerateOptions<true>): Promise<GenerateResult<Map<string, ExtendedTokenInfo<Theme$2>>>>;
  matchVariants(raw: string, current?: string): Promise<readonly VariantMatchedResult<Theme$2>[]>;
  private applyVariants;
  constructCustomCSS(context: Readonly<RuleContext<Theme$2>>, body: CSSObject | CSSEntries, overrideSelector?: string): string;
  parseUtil(input: string | VariantMatchedResult<Theme$2>, context: RuleContext<Theme$2>, internal?: boolean, shortcutPrefix?: string | string[] | undefined): Promise<(ParsedUtil | RawUtil)[] | undefined>;
  private resolveCSSResult;
  stringifyUtil(parsed?: ParsedUtil | RawUtil, context?: RuleContext<Theme$2>): StringifiedUtil<Theme$2>[] | undefined;
  expandShortcut(input: string, context: RuleContext<Theme$2>, depth?: number): Promise<[(string | ShortcutInlineValue)[], RuleMeta | undefined] | undefined>;
  stringifyShortcuts(parent: VariantMatchedResult<Theme$2>, context: RuleContext<Theme$2>, expanded: (string | ShortcutInlineValue)[], meta?: RuleMeta): Promise<StringifiedUtil<Theme$2>[] | undefined>;
  isBlocked(raw: string): boolean;
  getBlocked(raw: string): [BlocklistValue, BlocklistMeta | undefined] | undefined;
}
declare class UnoGenerator<Theme$2 extends object = object> extends UnoGeneratorInternal<Theme$2> {
  /**
   * @deprecated `new UnoGenerator` is deprecated, please use `createGenerator()` instead
   */
  constructor(userConfig?: UserConfig<Theme$2>, defaults?: UserConfigDefaults<Theme$2>);
}
declare function createGenerator<Theme$2 extends object = object>(config?: UserConfig<Theme$2>, defaults?: UserConfigDefaults<Theme$2>): Promise<UnoGenerator<Theme$2>>;
declare const regexScopePlaceholder: RegExp;
declare function hasScopePlaceholder(css: string): boolean;
declare function toEscapedSelector(raw: string): string;
//#endregion
//#region ../../packages-engine/core/src/types.d.ts
type Awaitable<T> = T | Promise<T>;
type Arrayable<T> = T | T[];
type ToArray<T> = T extends (infer U)[] ? U[] : T[];
type ArgumentType<T> = T extends ((...args: infer A) => any) ? A : never;
type Shift<T> = T extends [_: any, ...args: infer A] ? A : never;
type RestArgs<T> = Shift<ArgumentType<T>>;
type DeepPartial<T> = { [P in keyof T]?: DeepPartial<T[P]> };
type FlatObjectTuple<T> = { [K in keyof T]: T[K] };
type PartialByKeys<T, K$1 extends keyof T = keyof T> = FlatObjectTuple<Partial<Pick<T, Extract<keyof T, K$1>>> & Omit<T, K$1>>;
type RequiredByKey<T, K$1 extends keyof T = keyof T> = FlatObjectTuple<Required<Pick<T, Extract<keyof T, K$1>>> & Omit<T, K$1>>;
type CSSObject = Record<string, string | number | undefined>;
/**
 * [property, value, operators?]
 *
 * - operators: Used to perform specific operations on value or property.
 */
type CSSEntry = [string, string | number | undefined, Arrayable<string>?];
type CSSEntries = CSSEntry[];
type CSSObjectInput = CSSObject | Partial<ControlSymbolsValue>;
type CSSEntriesInput = (CSSEntry | ControlSymbolsEntry)[];
type CSSValueInput = CSSObjectInput | CSSEntriesInput | CSSValue;
type PresetOptions = Record<string, any>;
interface RuleContext<Theme$2 extends object = object> {
  /**
   * Unprocessed selector from user input.
   * Useful for generating CSS rule.
   */
  rawSelector: string;
  /**
   * Current selector for rule matching
   */
  currentSelector: string;
  /**
   * UnoCSS generator instance
   */
  generator: UnoGenerator<Theme$2>;
  /**
   * Symbols for special handling
   */
  symbols: ControlSymbols;
  /**
   * The theme object
   */
  theme: Theme$2;
  /**
   * Matched variants handlers for this rule.
   */
  variantHandlers: VariantHandler[];
  /**
   * The result of variant matching.
   */
  variantMatch: VariantMatchedResult<Theme$2>;
  /**
   * Construct a custom CSS rule.
   * Variants and selector escaping will be handled automatically.
   */
  constructCSS: (body: CSSEntries | CSSObject, overrideSelector?: string) => string;
  /**
   * Available only when `details` option is enabled.
   */
  rules?: Rule<Theme$2>[];
  /**
   * Available only when `details` option is enabled.
   */
  shortcuts?: Shortcut<Theme$2>[];
  /**
   * Available only when `details` option is enabled.
   */
  variants?: Variant<Theme$2>[];
}
declare const SymbolShortcutsNoMerge: unique symbol;
declare const SymbolNoMerge: unique symbol;
declare const SymbolVariants: unique symbol;
declare const SymbolParent: unique symbol;
declare const SymbolSelector: unique symbol;
declare const SymbolLayer: unique symbol;
declare const SymbolSort: unique symbol;
declare const SymbolBody: unique symbol;
interface ControlSymbols {
  /**
   * Prevent merging in shortcuts
   */
  shortcutsNoMerge: typeof SymbolShortcutsNoMerge;
  /**
   * Prevent merging in rules
   */
  noMerge: typeof SymbolNoMerge;
  /**
   * Additional variants applied to this rule
   */
  variants: typeof SymbolVariants;
  /**
   * Parent selector (`@media`, `@supports`, etc.)
   */
  parent: typeof SymbolParent;
  /**
   * Selector modifier
   */
  selector: typeof SymbolSelector;
  /**
   * Layer modifier
   */
  layer: typeof SymbolLayer;
  /**
   * Sort modifier
   */
  sort: typeof SymbolSort;
  /**
   * Custom css body modifier
   */
  body: typeof SymbolBody;
}
interface ControlSymbolsValue {
  [SymbolShortcutsNoMerge]: true;
  [SymbolNoMerge]: true;
  [SymbolVariants]: VariantHandler[] | ((handlers: VariantHandler[]) => VariantHandler[]);
  [SymbolParent]: string;
  [SymbolSelector]: (selector: string) => string;
  [SymbolLayer]: string;
  [SymbolSort]: number;
  [SymbolBody]: string;
}
type ObjectToEntry<T> = { [K in keyof T]: [K, T[K]] }[keyof T];
type ControlSymbolsEntry = ObjectToEntry<ControlSymbolsValue>;
interface VariantContext<Theme$2 extends object = object> {
  /**
   * Unprocessed selector from user input.
   */
  rawSelector: string;
  /**
   * UnoCSS generator instance
   */
  generator: UnoGenerator<Theme$2>;
  /**
   * The theme object
   */
  theme: Theme$2;
}
interface ExtractorContext {
  readonly original: string;
  code: string;
  id?: string;
  extracted: Set<string> | CountableSet<string>;
  envMode?: 'dev' | 'build';
}
interface BaseContext<Theme$2 extends object = object> {
  /**
   * UnoCSS generator instance
   */
  generator: UnoGenerator<Theme$2>;
  /**
   * The theme object
   */
  theme: Theme$2;
}
interface PreflightContext<Theme$2 extends object = object> extends BaseContext<Theme$2> {}
interface SafeListContext<Theme$2 extends object = object> extends BaseContext<Theme$2> {}
interface Extractor {
  name: string;
  order?: number;
  /**
   * Extract the code and return a list of selectors.
   *
   * Return `undefined` to skip this extractor.
   */
  extract?: (ctx: ExtractorContext) => Awaitable<Set<string> | CountableSet<string> | string[] | undefined | void>;
}
interface RuleMeta {
  /**
   * The layer name of this rule.
   * @default 'default'
   */
  layer?: string;
  /**
   * Option to not merge this selector even if the body are the same.
   * @default false
   */
  noMerge?: boolean;
  /**
   * Fine tune sort
   */
  sort?: number;
  /**
   * Templates to provide autocomplete suggestions
   */
  autocomplete?: Arrayable<AutoCompleteTemplate>;
  /**
   * Matching prefix before this util
   */
  prefix?: string | string[];
  /**
   * Internal rules will only be matched for shortcuts but not the user code.
   * @default false
   */
  internal?: boolean;
  /**
   * Store the hash of the rule boy
   *
   * @internal
   * @private
   */
  __hash?: string;
  /**
   * Internal index of the rulelist
   * @internal
   * @private
   */
  __index?: number;
  /**
   * Custom metadata
   */
  custom?: Record<string, any>;
}
type CSSValue = CSSObject | CSSEntries;
type CSSValues = CSSValue | CSSValue[];
type DynamicMatcher<Theme$2 extends object = object> = (match: RegExpMatchArray, context: Readonly<RuleContext<Theme$2>>) => Awaitable<CSSValueInput | string | (CSSValueInput | string)[] | undefined> | Generator<CSSValueInput | string | undefined> | AsyncGenerator<CSSValueInput | string | undefined>;
type DynamicRule<Theme$2 extends object = object> = [RegExp, DynamicMatcher<Theme$2>, RuleMeta?];
type StaticRule = [string, CSSObject | CSSEntries | (CSSValueInput | string)[], RuleMeta?];
type Rule<Theme$2 extends object = object> = DynamicRule<Theme$2> | StaticRule;
type DynamicShortcutMatcher<Theme$2 extends object = object> = ((match: RegExpMatchArray, context: Readonly<RuleContext<Theme$2>>) => (string | ShortcutValue[] | undefined));
type StaticShortcut = [string, string | ShortcutValue[], RuleMeta?];
type StaticShortcutMap = Record<string, string | ShortcutValue[]>;
type DynamicShortcut<Theme$2 extends object = object> = [RegExp, DynamicShortcutMatcher<Theme$2>, RuleMeta?];
type UserShortcuts<Theme$2 extends object = object> = StaticShortcutMap | (StaticShortcut | DynamicShortcut<Theme$2> | StaticShortcutMap)[];
type Shortcut<Theme$2 extends object = object> = StaticShortcut | DynamicShortcut<Theme$2>;
interface ShortcutInlineValue {
  handles: VariantHandler[];
  value: ShortcutValue;
}
type ShortcutValue = string | CSSValue;
type FilterPattern$1 = ReadonlyArray<string | RegExp> | string | RegExp | null;
interface Preflight<Theme$2 extends object = object> {
  getCSS: (context: PreflightContext<Theme$2>) => Promise<string | undefined> | string | undefined;
  layer?: string;
}
interface BlocklistMeta {
  /**
   * Custom message to show why this selector is blocked.
   */
  message?: string | ((selector: string) => string);
}
type BlocklistValue = string | RegExp | ((selector: string) => boolean | null | undefined);
type BlocklistRule = BlocklistValue | [BlocklistValue, BlocklistMeta];
interface VariantHandlerContext {
  /**
   * Rewrite the output selector. Often be used to append parents.
   */
  prefix: string;
  /**
   * Rewrite the output selector. Often be used to append pseudo classes.
   */
  selector: string;
  /**
   * Rewrite the output selector. Often be used to append pseudo elements.
   */
  pseudo: string;
  /**
   * Rewrite the output css body. The input come in [key,value][] pairs.
   */
  entries: CSSEntries;
  /**
   * Provide a parent selector(e.g. media query) to the output css.
   */
  parent?: string;
  /**
   * Provide order to the `parent` parent selector within layer.
   */
  parentOrder?: number;
  /**
   * Override layer to the output css.
   */
  layer?: string;
  /**
   * Order in which the variant is sorted within single rule.
   */
  sort?: number;
  /**
   * Option to not merge the resulting entries even if the body are the same.
   * @default false
   */
  noMerge?: boolean;
}
interface VariantHandler {
  /**
   * Callback to process the handler.
   */
  handle?: (input: VariantHandlerContext, next: (input: VariantHandlerContext) => VariantHandlerContext) => VariantHandlerContext;
  /**
   * The result rewritten selector for the next round of matching
   */
  matcher?: string;
  /**
   * Order in which the variant is applied to selector.
   */
  order?: number;
  /**
   * Rewrite the output selector. Often be used to append pseudo classes or parents.
   */
  selector?: (input: string, body: CSSEntries) => string | undefined;
  /**
   * Rewrite the output css body. The input come in [key,value][] pairs.
   */
  body?: (body: CSSEntries) => CSSEntries | undefined;
  /**
   * Provide a parent selector(e.g. media query) to the output css.
   */
  parent?: string | [string, number] | undefined;
  /**
   * Order in which the variant is sorted within single rule.
   */
  sort?: number;
  /**
   * Override layer to the output css.
   */
  layer?: string | undefined;
}
type VariantFunction<Theme$2 extends object = object> = (matcher: string, context: Readonly<VariantContext<Theme$2>>) => Awaitable<string | VariantHandler | VariantHandler[] | undefined>;
interface VariantObject<Theme$2 extends object = object> {
  /**
   * The name of the variant.
   */
  name?: string;
  /**
   * The entry function to match and rewrite the selector for further processing.
   */
  match: VariantFunction<Theme$2>;
  /**
   * Sort for when the match is applied.
   */
  order?: number;
  /**
   * Allows this variant to be used more than once in matching a single rule
   *
   * @default false
   */
  multiPass?: boolean;
  /**
   * Custom function for auto complete
   */
  autocomplete?: Arrayable<AutoCompleteFunction | AutoCompleteTemplate>;
}
type Variant<Theme$2 extends object = object> = VariantFunction<Theme$2> | VariantObject<Theme$2>;
type Preprocessor = (matcher: string) => string | undefined;
type Postprocessor = (util: UtilObject) => void | UtilObject | (UtilObject | null | undefined)[];
type ThemeExtender<Theme$2 extends object = object> = (theme: Theme$2, config: Readonly<ResolvedConfig<Theme$2>>) => Theme$2 | void;
interface ConfigBase<Theme$2 extends object = object> {
  /**
   * Rules to generate CSS utilities.
   *
   * Later entries have higher priority.
   */
  rules?: Rule<Theme$2>[];
  /**
   * Variant separator
   *
   * @default [':', '-']
   */
  separators?: Arrayable<string>;
  /**
   * Variants that preprocess the selectors,
   * having the ability to rewrite the CSS object.
   */
  variants?: Variant<Theme$2>[];
  /**
   * Similar to Windi CSS's shortcuts,
   * allows you have create new utilities by combining existing ones.
   *
   * Later entries have higher priority.
   */
  shortcuts?: UserShortcuts<Theme$2>;
  /**
   * Rules to exclude the selectors for your design system (to narrow down the possibilities).
   * Combining `warnExcluded` options it can also help you identify wrong usages.
   */
  blocklist?: BlocklistRule[];
  /**
   * Utilities that always been included
   */
  safelist?: (string | ((context: SafeListContext<Theme$2>) => Arrayable<string>))[];
  /**
   * Extractors to handle the source file and outputs possible classes/selectors
   * Can be language-aware.
   */
  extractors?: Extractor[];
  /**
   * Default extractor that are always applied.
   * By default it split the source code by whitespace and quotes.
   *
   * It maybe be replaced by preset or user config,
   * only one default extractor can be presented,
   * later one will override the previous one.
   *
   * Pass `null` or `false` to disable the default extractor.
   *
   * @see https://github.com/unocss/unocss/blob/main/packages-engine/core/src/extractors/split.ts
   * @default import('@unocss/core').defaultExtractor
   */
  extractorDefault?: Extractor | null | false;
  /**
   * Raw CSS injections.
   */
  preflights?: Preflight<Theme$2>[];
  /**
   * Theme object for shared configuration between rules
   */
  theme?: Theme$2;
  /**
   * Layer orders. Default to 0.
   */
  layers?: Record<string, number>;
  /**
   * Output the internal layers as CSS Cascade Layers.
   */
  outputToCssLayers?: boolean | OutputCssLayersOptions;
  /**
   * Custom function to sort layers.
   */
  sortLayers?: (layers: string[]) => string[];
  /**
   * Preprocess the incoming utilities, return falsy value to exclude
   */
  preprocess?: Arrayable<Preprocessor>;
  /**
   * Postprocess the generate utils object
   */
  postprocess?: Arrayable<Postprocessor>;
  /**
   * Custom functions mutate the theme object.
   *
   * It's also possible to return a new theme object to completely replace the original one.
   */
  extendTheme?: Arrayable<ThemeExtender<Theme$2>>;
  /**
   * Presets
   */
  presets?: (PresetOrFactoryAwaitable<Theme$2> | PresetOrFactoryAwaitable<Theme$2>[])[];
  /**
   * Additional options for auto complete
   */
  autocomplete?: {
    /**
     * Custom functions / templates to provide autocomplete suggestions
     */
    templates?: Arrayable<AutoCompleteFunction | AutoCompleteTemplate>;
    /**
     * Custom extractors to pickup possible classes and
     * transform class-name style suggestions to the correct format
     */
    extractors?: Arrayable<AutoCompleteExtractor>;
    /**
     * Custom shorthands to provide autocomplete suggestions.
     * if values is an array, it will be joined with `|` and wrapped with `()`
     */
    shorthands?: Record<string, string | string[]>;
  };
  /**
   * Hook to modify the resolved config.
   *
   * First presets runs first and the user config
   */
  configResolved?: (config: ResolvedConfig<Theme$2>) => void;
  /**
   * Expose internal details for debugging / inspecting
   *
   * Added `rules`, `shortcuts`, `variants` to the context and expose the context object in `StringifiedUtil`
   *
   * You don't usually need to set this.
   *
   * @default `true` when `envMode` is `dev`, otherwise `false`
   */
  details?: boolean;
  /**
   * Options for sources to be extracted as utilities usages.
   *
   */
  content?: ContentOptions;
  /**
   * Custom transformers to the source code.
   */
  transformers?: SourceCodeTransformer[];
}
interface OutputCssLayersOptions {
  /**
   * Specify the css layer that the internal layer should be output to.
   *
   * Return `null` to specify that the layer should not be output to any css layer.
   */
  cssLayerName?: (internalLayer: string) => string | undefined | null;
}
type AutoCompleteTemplate = string;
type AutoCompleteFunction = (input: string) => Awaitable<string[]>;
interface AutoCompleteExtractorContext {
  content: string;
  cursor: number;
}
interface Replacement {
  /**
   * The range of the original text
   */
  start: number;
  end: number;
  /**
   * The text used to replace
   */
  replacement: string;
}
interface SuggestResult {
  /**
   * The generated suggestions
   *
   * `[original, formatted]`
   */
  suggestions: [string, string][];
  /**
   * The function to convert the selected suggestion back.
   * Needs to pass in the original one.
   */
  resolveReplacement: (suggestion: string) => Replacement;
}
interface AutoCompleteExtractorResult {
  /**
   * The extracted string
   */
  extracted: string;
  /**
   * The function to convert the selected suggestion back
   */
  resolveReplacement: (suggestion: string) => Replacement;
  /**
   * The function to format suggestions
   */
  transformSuggestions?: (suggestions: string[]) => string[];
}
interface AutoCompleteExtractor {
  name: string;
  extract: (context: AutoCompleteExtractorContext) => Awaitable<AutoCompleteExtractorResult | null>;
  order?: number;
}
interface Preset<Theme$2 extends object = object> extends ConfigBase<Theme$2> {
  name: string;
  /**
   * Enforce the preset to be applied before or after other presets
   */
  enforce?: 'pre' | 'post';
  /**
   * Preset options for other tools like IDE to consume
   */
  options?: PresetOptions;
  /**
   * Apply prefix to all utilities and shortcuts
   */
  prefix?: string | string[];
  /**
   * Apply layer to all utilities and shortcuts
   */
  layer?: string;
  /**
   * Custom API endpoint for cross-preset communication
   */
  api?: any;
  /**
   * Custom metadata for the preset
   */
  meta?: Record<string, any>;
}
type PresetFactory<Theme$2 extends object = object, PresetOptions$1 extends object | undefined = undefined> = (options?: PresetOptions$1) => Preset<Theme$2>;
type PresetFactoryAwaitable<Theme$2 extends object = object, PresetOptions$1 extends object | undefined = undefined> = (options?: PresetOptions$1) => Awaitable<Preset<Theme$2>>;
type PresetOrFactory<Theme$2 extends object = object> = Preset<Theme$2> | PresetFactory<Theme$2, any>;
type PresetOrFactoryAwaitable<Theme$2 extends object = object> = PresetOrFactory<Theme$2> | Promise<Preset<Theme$2>> | PresetFactoryAwaitable<Theme$2>;
interface GeneratorOptions {
  /**
   * Merge utilities with the exact same body to save the file size
   *
   * @default true
   */
  mergeSelectors?: boolean;
  /**
   * Emit warning when matched selectors are presented in blocklist
   *
   * @default true
   */
  warn?: boolean;
}
interface UserOnlyOptions<Theme$2 extends object = object> {
  /**
   * The theme object, will be merged with the theme provides by presets
   */
  theme?: Theme$2;
  /**
   * Layout name of shortcuts
   *
   * @default 'shortcuts'
   */
  shortcutsLayer?: string;
  /**
   * Environment mode
   *
   * @default 'build'
   */
  envMode?: 'dev' | 'build';
  /**
   * legacy.renderModernChunks need to be consistent with @vitejs/plugin-legacy
   */
  legacy?: {
    renderModernChunks: boolean;
  };
  /**
   * Custom prefix for virtual modules
   *
   * @default '__uno'
   */
  virtualModulePrefix?: string;
}
/**
 * For unocss-cli config
 */
interface CliOptions {
  cli?: {
    entry?: Arrayable<CliEntryItem>;
  };
}
interface UnocssPluginContext<Config extends UserConfig = UserConfig> {
  /**
   * Singleton promise for config loading
   */
  ready: Promise<LoadConfigResult<Config>>;
  /**
   * The UnoCSS generator instance. Should be used after `ready` resolved.
   */
  uno: UnoGenerator;
  /**
   * All tokens scanned
   */
  tokens: Set<string>;
  /**
   * Map for all module's raw content
   */
  modules: BetterMap<string, string>;
  /**
   * Module IDs that been affected by UnoCSS
   */
  affectedModules: Set<string>;
  /**
   *  Pending promises
   */
  tasks: Promise<any>[];
  /**
   * Await all pending tasks
   */
  flushTasks: () => Promise<any>;
  filter: (code: string, id: string) => boolean;
  extract: (code: string, id?: string) => Promise<void>;
  reloadConfig: () => Promise<LoadConfigResult<Config>>;
  getConfig: () => Promise<Config>;
  onReload: (fn: () => void) => void;
  invalidate: () => void;
  onInvalidate: (fn: () => void) => void;
  root: string;
  updateRoot: (root: string) => Promise<LoadConfigResult<Config>>;
  getConfigFileList: () => string[];
  /**
   * Get regexes to match virtual module ids
   */
  getVMPRegexes: () => Promise<{
    prefix: string;
    RESOLVED_ID_WITH_QUERY_RE: RegExp;
    RESOLVED_ID_RE: RegExp;
  }>;
}
interface SourceMap {
  file?: string;
  mappings?: string;
  names?: string[];
  sources?: string[];
  sourcesContent?: string[];
  version?: number;
}
interface HighlightAnnotation {
  offset: number;
  length: number;
  className: string;
}
type SourceCodeTransformerEnforce = 'pre' | 'post' | 'default';
interface SourceCodeTransformer {
  name: string;
  /**
   * The order of transformer
   */
  enforce?: SourceCodeTransformerEnforce;
  /**
   * Custom id filter, if not provided, the extraction filter will be applied
   */
  idFilter?: (id: string) => boolean;
  /**
   * The transform function
   */
  transform: (code: MagicString, id: string, ctx: UnocssPluginContext) => Awaitable<{
    highlightAnnotations?: HighlightAnnotation[];
  } | void>;
}
interface ContentOptions {
  /**
   * Glob patterns to extract from the file system, in addition to other content sources.
   *
   * In dev mode, the files will be watched and trigger HMR.
   *
   * @default []
   */
  filesystem?: string[];
  /**
   * Inline text to be extracted
   */
  inline?: (string | {
    code: string;
    id?: string;
  } | (() => Awaitable<string | {
    code: string;
    id?: string;
  }>))[];
  /**
   * Filters to determine whether to extract certain modules from the build tools' transformation pipeline.
   *
   * Currently only works for Vite and Webpack integration.
   *
   * Set `false` to disable.
   */
  pipeline?: false | {
    /**
     * Patterns that filter the files being extracted.
     * Supports regular expressions and `picomatch` glob patterns.
     *
     * By default, `.ts` and `.js` files are NOT extracted.
     *
     * @see https://www.npmjs.com/package/picomatch
     * @default [/\.(vue|svelte|[jt]sx|vine.ts|mdx?|astro|elm|php|phtml|marko|html)($|\?)/]
     */
    include?: FilterPattern$1;
    /**
     * Patterns that filter the files NOT being extracted.
     * Supports regular expressions and `picomatch` glob patterns.
     *
     * By default, `node_modules` and `dist` are also extracted.
     *
     * @see https://www.npmjs.com/package/picomatch
     * @default [/\.(css|postcss|sass|scss|less|stylus|styl)($|\?)/]
     */
    exclude?: FilterPattern$1;
  };
}
/**
 * For other modules to aggregate the options
 */
interface PluginOptions {
  /**
   * Load from configs files
   *
   * set `false` to disable
   */
  configFile?: string | false;
  /**
   * List of files that will also trigger config reloads
   */
  configDeps?: string[];
  /**
   * Custom transformers to the source code
   */
  transformers?: SourceCodeTransformer[];
  /**
   * Options for sources to be extracted as utilities usages
   *
   * Supported sources:
   * - `filesystem` - extract from file system
   * - `inline` - extract from plain inline text
   * - `pipeline` - extract from build tools' transformation pipeline, such as Vite and Webpack
   *
   * The usage extracted from each source will be **merged** together.
   */
  content?: ContentOptions;
}
interface UserConfig<Theme$2 extends object = object> extends ConfigBase<Theme$2>, UserOnlyOptions<Theme$2>, GeneratorOptions, PluginOptions, CliOptions {}
interface UserConfigDefaults<Theme$2 extends object = object> extends ConfigBase<Theme$2>, UserOnlyOptions<Theme$2> {}
interface ResolvedConfig<Theme$2 extends object = object> extends Omit<RequiredByKey<UserConfig<Theme$2>, 'mergeSelectors' | 'theme' | 'rules' | 'variants' | 'layers' | 'extractors' | 'blocklist' | 'safelist' | 'preflights' | 'sortLayers'>, 'rules' | 'shortcuts' | 'autocomplete' | 'presets'> {
  presets: Preset<Theme$2>[];
  shortcuts: Shortcut<Theme$2>[];
  variants: VariantObject<Theme$2>[];
  preprocess: Preprocessor[];
  postprocess: Postprocessor[];
  rulesSize: number;
  rules: readonly Rule<Theme$2>[];
  rulesDynamic: readonly DynamicRule<Theme$2>[];
  rulesStaticMap: Record<string, StaticRule | undefined>;
  autocomplete: {
    templates: (AutoCompleteFunction | AutoCompleteTemplate)[];
    extractors: AutoCompleteExtractor[];
    shorthands: Record<string, string>;
  };
  separators: string[];
}
interface GenerateResult<T = Set<string>> {
  css: string;
  layers: string[];
  getLayer: (name?: string) => string | undefined;
  getLayers: (includes?: string[], excludes?: string[]) => string;
  setLayer: (layer: string, callback: (content: string) => Promise<string>) => Promise<string>;
  matched: T;
}
type VariantMatchedResult<Theme$2 extends object = object> = [raw: string, current: string, variantHandlers: VariantHandler[], variants: Set<Variant<Theme$2>>];
type ParsedUtil = readonly [index: number, raw: string, entries: CSSEntries, meta: RuleMeta | undefined, variantHandlers: VariantHandler[]];
type RawUtil = readonly [index: number, rawCSS: string, meta: RuleMeta | undefined];
type StringifiedUtil<Theme$2 extends object = object> = readonly [index: number, selector: string | undefined, body: string, parent: string | undefined, meta: RuleMeta | undefined, context: RuleContext<Theme$2> | undefined, noMerge: boolean | undefined];
type PreparedRule = readonly [selector: [string, number][], body: string, noMerge: boolean];
interface CliEntryItem {
  patterns: string[];
  outFile: string;
}
interface UtilObject {
  selector: string;
  entries: CSSEntries;
  parent: string | undefined;
  layer: string | undefined;
  sort: number | undefined;
  noMerge: boolean | undefined;
}
/**
 * Returned from `uno.generate()` when `extendedInfo` option is enabled.
 */
interface ExtendedTokenInfo<Theme$2 extends object = object> {
  /**
   * Stringified util data
   */
  data: StringifiedUtil<Theme$2>[];
  /**
   * Return -1 if the data structure is not countable
   */
  count: number;
}
interface GenerateOptions<T extends boolean> {
  /**
   * Filepath of the file being processed.
   */
  id?: string;
  /**
   * Generate preflights (if defined)
   *
   * @default true
   */
  preflights?: boolean;
  /**
   * Includes safelist
   */
  safelist?: boolean;
  /**
   * Generate minified CSS
   * @default false
   */
  minify?: boolean;
  /**
   * @experimental
   */
  scope?: string;
  /**
   * If return extended "matched" with payload and count
   */
  extendedInfo?: T;
}
//#endregion
//#region ../../packages-engine/core/src/config.d.ts
declare function resolveShortcuts<Theme$2 extends object = object>(shortcuts: UserShortcuts<Theme$2>): Shortcut<Theme$2>[];
/**
 * Resolve a single preset, nested presets are ignored
 */
declare function resolvePreset<Theme$2 extends object = object>(presetInput: PresetOrFactoryAwaitable<Theme$2>): Promise<Preset<Theme$2>>;
/**
 * Resolve presets with nested presets
 */
declare function resolvePresets<Theme$2 extends object = object>(preset: PresetOrFactoryAwaitable<Theme$2>): Promise<Preset<Theme$2>[]>;
declare function resolveConfig<Theme$2 extends object = object>(userConfig?: UserConfig<Theme$2>, defaults?: UserConfigDefaults<Theme$2>): Promise<ResolvedConfig<Theme$2>>;
/**
 * Merge multiple configs into one, later ones have higher priority
 */
declare function mergeConfigs<Theme$2 extends object = object>(configs: UserConfig<Theme$2>[]): UserConfig<Theme$2>;
declare function definePreset<Options extends object | undefined = undefined, Theme$2 extends object = object>(preset: PresetFactory<Theme$2, Options>): PresetFactory<Theme$2, Options>;
declare function definePreset<Options extends object | undefined = undefined, Theme$2 extends object = object>(preset: PresetFactoryAwaitable<Theme$2, Options>): PresetFactoryAwaitable<Theme$2, Options>;
declare function definePreset<Theme$2 extends object = object>(preset: Preset<Theme$2>): Preset<Theme$2>;
//#endregion
//#region ../../packages-engine/core/src/constants.d.ts
declare const LAYER_DEFAULT = "default";
declare const LAYER_PREFLIGHTS = "preflights";
declare const LAYER_SHORTCUTS = "shortcuts";
declare const LAYER_IMPORTS = "imports";
declare const DEFAULT_LAYERS: {
  imports: number;
  preflights: number;
  shortcuts: number;
  default: number;
};
//#endregion
//#region ../../packages-engine/core/src/extractors/split.d.ts
declare const defaultSplitRE: RegExp;
declare const splitWithVariantGroupRE: RegExp;
declare const extractorSplit: Extractor;
//#endregion
//#region ../preset-mini/src/_theme/types.d.ts
interface ThemeAnimation$1 {
  keyframes?: Record<string, string>;
  durations?: Record<string, string>;
  timingFns?: Record<string, string>;
  properties?: Record<string, object>;
  counts?: Record<string, string | number>;
  category?: Record<string, string>;
}
interface Colors$1 {
  [key: string]: Colors$1 & {
    DEFAULT?: string;
  } | string;
}
interface Theme$1 {
  width?: Record<string, string>;
  height?: Record<string, string>;
  maxWidth?: Record<string, string>;
  maxHeight?: Record<string, string>;
  minWidth?: Record<string, string>;
  minHeight?: Record<string, string>;
  inlineSize?: Record<string, string>;
  blockSize?: Record<string, string>;
  maxInlineSize?: Record<string, string>;
  maxBlockSize?: Record<string, string>;
  minInlineSize?: Record<string, string>;
  minBlockSize?: Record<string, string>;
  borderRadius?: Record<string, string>;
  breakpoints?: Record<string, string>;
  verticalBreakpoints?: Record<string, string>;
  colors?: Colors$1;
  borderColor?: Colors$1;
  backgroundColor?: Colors$1;
  textColor?: Colors$1;
  shadowColor?: Colors$1;
  accentColor?: Colors$1;
  fontFamily?: Record<string, string>;
  fontSize?: Record<string, string | [string, string | CSSObject] | [string, string, string]>;
  fontWeight?: Record<string, string>;
  lineHeight?: Record<string, string>;
  letterSpacing?: Record<string, string>;
  wordSpacing?: Record<string, string>;
  boxShadow?: Record<string, string | string[]>;
  textIndent?: Record<string, string>;
  textShadow?: Record<string, string | string[]>;
  textStrokeWidth?: Record<string, string>;
  ringWidth?: Record<string, string>;
  lineWidth?: Record<string, string>;
  spacing?: Record<string, string>;
  duration?: Record<string, string>;
  aria?: Record<string, string>;
  data?: Record<string, string>;
  zIndex?: Record<string, string>;
  blur?: Record<string, string>;
  dropShadow?: Record<string, string | string[]>;
  easing?: Record<string, string>;
  transitionProperty?: Record<string, string>;
  media?: Record<string, string>;
  supports?: Record<string, string>;
  containers?: Record<string, string>;
  animation?: ThemeAnimation$1;
  gridAutoColumn?: Record<string, string>;
  gridAutoRow?: Record<string, string>;
  gridColumn?: Record<string, string>;
  gridRow?: Record<string, string>;
  gridTemplateColumn?: Record<string, string>;
  gridTemplateRow?: Record<string, string>;
  container?: {
    center?: boolean;
    padding?: string | Record<string, string>;
    maxWidth?: Record<string, string>;
  };
  /** Used to generate CSS custom properties placeholder in preflight */
  preflightRoot?: Arrayable<string>;
  preflightBase?: Record<string, string | number>;
}
//#endregion
//#region ../preset-mini/src/preflights.d.ts
declare function preflights$1(options: PresetMiniOptions): Preflight<Theme$1>[] | undefined;
//#endregion
//#region ../preset-mini/src/index.d.ts
interface DarkModeSelectors$1 {
  /**
   * Selectors for light variant.
   *
   * @default '.light'
   */
  light?: string | string[];
  /**
   * Selectors for dark variant.
   *
   * @default '.dark'
   */
  dark?: string | string[];
}
interface PresetMiniOptions extends PresetOptions {
  /**
   * Dark mode options
   *
   * @default 'class'
   */
  dark?: 'class' | 'media' | DarkModeSelectors$1;
  /**
   * Generate tagged pseudo selector as `[group=""]` instead of `.group`
   *
   * @default false
   */
  attributifyPseudo?: boolean;
  /**
   * Prefix for CSS variables.
   *
   * @default 'un-'
   */
  variablePrefix?: string;
  /**
   * Utils prefix. When using tagged pseudo selector, only the first truthy prefix will be used.
   *
   * @default undefined
   */
  prefix?: string | string[];
  /**
   * Generate preflight
   *
   * @default true
   */
  preflight?: boolean | 'on-demand';
  /**
   * Enable arbitrary variants, for example `<div class="[&>*]:m-1 [&[open]]:p-2"></div>`.
   *
   * Disable this might slightly improve the performance.
   *
   * @default true
   */
  arbitraryVariants?: boolean;
}
/**
 * The basic preset for UnoCSS, with only the most essential utilities.
 *
 * @see https://unocss.dev/presets/mini
 */
declare const presetMini: PresetFactory<Theme$1, PresetMiniOptions>;
declare function VarPrefixPostprocessor(prefix: string): Postprocessor | undefined;
//#endregion
//#region ../preset-wind3/src/shortcuts.d.ts
declare const shortcuts: Shortcut<Theme$1>[];
//#endregion
//#region ../preset-wind3/src/theme.d.ts
declare const theme: Theme$1;
//#endregion
//#region ../preset-wind3/src/index.d.ts
interface PresetWind3Options extends PresetMiniOptions {
  /**
   * The important option lets you control whether UnoCSSâ€™s utilities should be marked with `!important`.
   *
   * This can be really useful when using UnoCSS with existing CSS that has high specificity selectors.
   *
   * You can also set `important` to a selector like `#app` instead, which will generate `#app :is(.m-1) { ... }`
   *
   * Also check out the compatibility with [:is()](https://caniuse.com/?search=%3Ais())
   *
   * @default false
   */
  important?: boolean | string;
}
/**
 * The Tailwind CSS v3 / Windi CSS compact preset for UnoCSS.
 *
 * @see https://unocss.dev/presets/wind3
 */
declare const presetWind3: PresetFactory<Theme$1, PresetWind3Options>;
//#endregion
//#region ../../packages-deprecated/preset-uno/src/index.d.ts
interface PresetUnoOptions extends PresetWind3Options {}
/**
 * @deprecated Use `presetWind3` from `@unocss/preset-wind3` instead
 */
declare const presetUno: PresetFactory<Theme$1, PresetUnoOptions>;
//#endregion
//#region ../preset-attributify/src/types.d.ts
interface AttributifyOptions extends PresetOptions {
  /**
   * Only generate CSS for attributify or class
   *
   * @default false
   */
  strict?: boolean;
  /**
   * @default 'un-'
   */
  prefix?: string;
  /**
   * Only match for prefixed attributes
   *
   * @default false
   */
  prefixedOnly?: boolean;
  /**
   * Support matching non-valued attributes
   *
   * For example
   * ```html
   * <div mt-2 />
   * ```
   *
   * @default true
   */
  nonValuedAttribute?: boolean;
  /**
   * A list of attributes to be ignored from extracting.
   */
  ignoreAttributes?: string[];
  /**
   * Non-valued attributes will also match if the actual value represented in DOM is `true`.
   * This option exists for supporting frameworks that encodes non-valued attributes as `true`.
   * Enabling this option will break rules that ends with `true`.
   *
   * @default false
   */
  trueToNonValued?: boolean;
}
//#endregion
//#region ../preset-attributify/src/autocomplete.d.ts
declare function autocompleteExtractorAttributify(options?: AttributifyOptions): AutoCompleteExtractor;
//#endregion
//#region ../preset-attributify/src/extractor.d.ts
declare const defaultIgnoreAttributes: string[];
declare function extractorAttributify(options?: AttributifyOptions): Extractor;
//#endregion
//#region ../preset-attributify/src/jsx.d.ts
type TwoStringsCompositionPrefix = 'm' | 'p';
type TwoStringsCompositionSuffix = 'r' | 'b' | 'l' | 't' | 'a' | 'x' | 'y';
/** Some words can compose with two strings to become a complete unocss rule such as ha, mr, mb */
type TwoStringsComposition = `${TwoStringsCompositionPrefix}${TwoStringsCompositionSuffix}` | 'ha' | 'wa';
/** Some words can be a complete unocss rule by itself */
type SpecialSingleWord = 'container' | 'flex' | 'block' | 'inline' | 'table' | 'isolate' | 'absolute' | 'relative' | 'fixed' | 'sticky' | 'static' | 'visible' | 'invisible' | 'grow' | 'shrink' | 'antialiased' | 'italic' | 'ordinal' | 'overline' | 'underline' | 'uppercase' | 'lowercase' | 'capitalize' | 'truncate' | 'border' | 'rounded' | 'outline' | 'ring' | 'shadow' | 'blur' | 'grayscale' | 'invert' | 'sepia' | 'transition' | 'resize' | 'transform' | 'filter';
type PseudoPrefix = 'active' | 'before' | 'after' | 'dark' | 'light' | 'first' | 'last' | 'focus' | 'hover' | 'link' | 'root' | 'sm' | 'md' | 'lg' | 'xl' | '2xl' | 'enabled' | 'disabled' | 'all' | 'children';
/** Some words can be used to separate utilities, such as font="mono light", text="sm white" */
type SeparateEnabled = 'align' | 'animate' | 'backdrop' | 'bg' | 'blend' | 'border' | 'box' | 'container' | 'content' | 'cursor' | 'display' | 'divide' | 'filter' | 'flex' | 'font' | 'fw' | 'gap' | 'gradient' | 'grid' | 'h' | 'icon' | 'items' | 'justify' | 'list' | 'm' | 'op' | 'opacity' | 'order' | 'outline' | 'overflow' | 'p' | 'place' | 'pos' | 'position' | 'ring' | 'select' | 'shadow' | 'size' | 'space' | 'table' | 'text' | 'transform' | 'transition' | 'underline' | 'w' | 'z' | PseudoPrefix;
type BasicAttributes = SpecialSingleWord | TwoStringsComposition | SeparateEnabled;
type AttributifyNames<Prefix extends string = ''> = `${Prefix}${BasicAttributes}` | `${Prefix}${PseudoPrefix}:${BasicAttributes}`;
interface AttributifyAttributes extends Partial<Record<AttributifyNames, string | boolean>> {}
//#endregion
//#region ../preset-attributify/src/variant.d.ts
declare const variantsRE: RegExp;
declare function variantAttributify(options?: AttributifyOptions): VariantObject;
//#endregion
//#region ../preset-attributify/src/index.d.ts
/**
 * This enables the attributify mode for other presets.
 *
 * @example
 *
 * ```html
 * <button
 *   bg="blue-400 hover:blue-500 dark:blue-500 dark:hover:blue-600"
 *   text="sm white"
 *   font="mono light"
 *   p="y-2 x-4"
 *   border="2 rounded blue-200"
 * >
 *   Button
 * </button>
 * ```
 *
 * @see https://unocss.dev/presets/attributify
 */
declare const presetAttributify: PresetFactory<object, AttributifyOptions>;
//#endregion
//#region ../preset-icons/src/types.d.ts
interface IconMeta {
  collection: string;
  name: string;
  svg: string;
  mode?: IconsOptions['mode'];
  /**
   * @deprecated renamed to `name`
   */
  icon: string;
}
interface IconsOptions {
  /**
   * Scale related to the current font size (1em).
   *
   * @default 1
   */
  scale?: number;
  /**
   * Mode of generated CSS icons.
   *
   * - `mask` - use background color and the `mask` property for monochrome icons
   * - `background-img` - use background image for the icons, colors are static
   * - `auto` - smartly decide mode between `mask` and `background-img` per icon based on its style
   *
   * @default 'auto'
   * @see https://antfu.me/posts/icons-in-pure-css
   */
  mode?: 'mask' | 'bg' | 'auto';
  /**
   * Class prefix for matching icon rules.
   *
   * @default `i-`
   */
  prefix?: string | string[];
  /**
   * Extra CSS properties applied to the generated CSS
   *
   * @default {}
   */
  extraProperties?: Record<string, string>;
  /**
   * Emit warning when missing icons are matched
   *
   * @default false
   */
  warn?: boolean;
  /**
   * `@iconify-json` collections to use (will be also auto installed when missing and `autoInstall` enabled).
   *
   * This option should be used only when there are new `@iconify-json` collections not listed in the default icons preset collection names.
   *
   * Adding external collections will not work, you should use `FileSystemIconLoader` from
   * `@iconify/utils/lib/loader/fs` or `createExternalPackageIconLoader` from
   * `@iconify/utils/lib/loader/external-pkg` instead.
   *
   * @see https://unocss.dev/presets/icons#filesystemiconloader
   * @see https://unocss.dev/presets/icons#externalpackageiconloader
   */
  iconifyCollectionsNames?: string[];
  /**
   * In Node.js environment, the preset will search for the installed iconify dataset automatically.
   * When using in the browser, this options is provided to provide dataset with custom loading mechanism.
   */
  collections?: Record<string, (() => Awaitable<IconifyJSON>) | undefined | CustomIconLoader | InlineCollection>;
  /**
   * Rule layer
   *
   * @default 'icons'
   */
  layer?: string;
  /**
   * Custom icon customizations.
   */
  customizations?: Omit<IconCustomizations, 'additionalProps' | 'trimCustomSvg'>;
  /**
   * Auto install icon sources package when the usages is detected
   *
   * Only effective in Node.js environment.
   *
   * @default false
   */
  autoInstall?: boolean;
  /**
   * Path to resolve the iconify collections in Node.js environment.
   *
   * @default process.cwd()
   */
  collectionsNodeResolvePath?: string | string[];
  /**
   * Custom icon unit.
   *
   * @default `em`
   */
  unit?: string;
  /**
   * Load icons from CDN. Should starts with `https://` and ends with `/`
   *
   * Recommends:
   * - https://esm.sh/
   * - https://cdn.skypack.dev/
   */
  cdn?: string;
  /**
   * Custom fetch function to provide the icon data.
   */
  customFetch?: (url: string) => Promise<any>;
  /**
   * Processor for the CSS object before stringify
   */
  processor?: (cssObject: CSSObject, meta: Required<IconMeta>) => void;
}
//#endregion
//#region ../preset-icons/src/collections.d.ts
declare const _default: string[];
//#endregion
//#region ../preset-icons/src/core.d.ts
/**
 * API for preset-icons
 */
interface IconsAPI {
  encodeSvgForCss: typeof encodeSvgForCss;
  parseIconWithLoader: typeof parseIconWithLoader;
  /**
   * This API only available for preset-icons created on Node.js environment
   */
  createNodeLoader?: () => Promise<UniversalIconLoader | undefined>;
}
declare function createPresetIcons(lookupIconLoader: (options: IconsOptions) => Promise<UniversalIconLoader>): PresetFactory<object, IconsOptions>;
declare function combineLoaders(loaders: UniversalIconLoader[]): UniversalIconLoader;
declare function createCDNFetchLoader(fetcher: (url: string) => Promise<any>, cdnBase: string, cacheMap?: Map<string, IconifyJSON | Promise<IconifyJSON>>): UniversalIconLoader;
declare function parseIconWithLoader(body: string, loader: UniversalIconLoader, options?: IconifyLoaderOptions, safeCollectionsNames?: string[]): Promise<{
  collection: string;
  name: string;
  svg: string;
} | undefined>;
//#endregion
//#region ../preset-icons/src/index.d.ts
/**
 * Use any icon with Pure CSS for UnoCSS.
 *
 * @example
 *
 * ```html
 * <div class="i-mdi-alarm"></div>
 * <div class="i-logos-vue text-3xl"></div>
 * <button class="i-carbon-sun dark:i-carbon-moon"></div>
 * ```
 *
 * @see https://unocss.dev/presets/icons
 */
declare const presetIcons: PresetFactory<object, IconsOptions>;
declare function createNodeLoader(): Promise<UniversalIconLoader | undefined>;
//#endregion
//#region ../preset-tagify/src/types.d.ts
interface TagifyOptions {
  /**
   * The prefix to use for the tagify variant.
   */
  prefix?: string;
  /**
   * Tags excluded from processing.
   * @default ['b', /^h\d+$/, 'table']
   */
  excludedTags?: (string | RegExp)[];
  /**
   * Extra CSS properties to apply to matched rules
   */
  extraProperties?: Record<string, string> | ((matched: string) => Partial<Record<string, string>>);
  /**
   * Enable default extractor
   * @default true
   */
  defaultExtractor?: boolean;
}
//#endregion
//#region ../preset-tagify/src/extractor.d.ts
declare const MARKER = "__TAGIFY__";
declare const htmlTagRE: RegExp;
declare function extractorTagify(options: TagifyOptions): Extractor;
//#endregion
//#region ../preset-tagify/src/variant.d.ts
declare function variantTagify(options: TagifyOptions): VariantObject;
//#endregion
//#region ../preset-tagify/src/index.d.ts
/**
 * @see https://unocss.dev/presets/tagify
 */
declare const presetTagify: PresetFactory<object, TagifyOptions>;
//#endregion
//#region ../preset-typography/src/types.d.ts
interface TypographyCompatibilityOptions {
  noColonWhere?: boolean;
  noColonIs?: boolean;
  noColonNot?: boolean;
}
interface TypographyTheme {
  colors?: Record<string, any>;
}
interface TypographyColorScheme {
  'body'?: Arrayable<string | number>;
  'headings'?: Arrayable<string | number>;
  'lead'?: Arrayable<string | number>;
  'links'?: Arrayable<string | number>;
  'bold'?: Arrayable<string | number>;
  'counters'?: Arrayable<string | number>;
  'bullets'?: Arrayable<string | number>;
  'hr'?: Arrayable<string | number>;
  'quotes'?: Arrayable<string | number>;
  'quote-borders'?: Arrayable<string | number>;
  'captions'?: Arrayable<string | number>;
  'kbd'?: Arrayable<string | number>;
  'kbd-shadows'?: Arrayable<string | number>;
  'code'?: Arrayable<string | number>;
  'pre-code'?: Arrayable<string | number>;
  'pre-bg'?: Arrayable<string | number>;
  'th-borders'?: Arrayable<string | number>;
  'td-borders'?: Arrayable<string | number>;
}
interface TypographyCSSObject extends Record<string, CSSObject | string | number> {}
interface TypographySizeScheme extends Record<string, TypographyCSSObject> {}
interface TypographyOptions<T extends TypographyTheme = TypographyTheme> {
  /**
   * The selector name to use the typographic utilities.
   * To undo the styles to the elements, use it like
   * `not-${selectorName}` which is by default `not-prose`.
   *
   * Note: `not` utility is only available in class mode.
   *
   * @default `prose`
   */
  selectorName?: string;
  /**
   * Extend or override CSS selectors with CSS declaration block.
   *
   * @default undefined
   */
  cssExtend?: Record<string, CSSObject> | ((theme: T) => Record<string, CSSObject>);
  /**
   * Compatibility option. Notice that it will affect some features.
   * For more instructions, see
   * [README](https://github.com/unocss/unocss/tree/main/packages-presets/preset-typography)
   *
   * @default undefined
   */
  compatibility?: TypographyCompatibilityOptions;
  /**
   * Control whether prose's utilities should be marked with !important.
   *
   * @default false
   */
  important?: boolean | string;
  /**
   * Color scheme for typography elements.
   *
   * Each key represents a typographic element (e.g., 'body', 'headings', 'links').
   *
   * Type: [light, dark] => [color, invert-color]
   *
   * @default
   *
   * {
   *   'body': [700, 300],
   *   'headings': [900, 'white'],
   *   'lead': [600, 400],
   *   'links': [900, 'white'],
   *   'bold': [900, 'white'],
   *   'counters': [500, 400],
   *   'bullets': [300, 600],
   *   'hr': [200, 700],
   *   'quotes': [900, 100],
   *   'quote-borders': [200, 700],
   *   'captions': [500, 400],
   *   'kbd': [900, 'white'],
   *   'kbd-shadows': [900, 'white'],
   *   'code': [900, 'white'],
   *   'pre-code': [200, 300],
   *   'pre-bg': [800, 'rgb(0 0 0 / 50%)'],
   *   'th-borders': [300, 600],
   *   'td-borders': [200, 700],
   * }
   */
  colorScheme?: TypographyColorScheme;
  /**
   * Size scheme for typography elements.
   *
   * Allows you to customize the CSS styles of various typographic elements.
   * Similar to {@link cssExtend}, but it applies granular overlays to different sizes of text.
   *
   * Example:
   *
   * {
   *
   *   'sm': {@link TypographyCSSObject}
   *
   *   'base': {@link TypographyCSSObject}
   *
   *   'lg': {@link TypographyCSSObject}
   *
   *   'xl': {@link TypographyCSSObject}
   *
   *   '2xl': {@link TypographyCSSObject}
   *
   * }
   *
   */
  sizeScheme?: TypographySizeScheme;
  /**
   * Prefix for generated css vars.
   *
   * @default '--un-prose'
   */
  cssVarPrefix?: string;
}
//#endregion
//#region ../preset-typography/src/index.d.ts
/**
 * UnoCSS Preset for Typography
 *
 * ```js
 * // uno.config.ts
 * import { presetAttributify, presetWind3/4, defineConfig, presetTypography } from 'unocss'
 *
 * export default defineConfig({
 *   presets: [
 *     presetWind3/4(), // required!
 *     presetAttributify(), // required if using attributify mode
 *     presetTypography()
 *   ]
 * })
 * ```
 *
 * @see https://unocss.dev/presets/typography
 * @returns typography preset
 * @public
 */
declare const presetTypography: <Theme$2 extends TypographyTheme = TypographyTheme>(options?: TypographyOptions<Theme$2> | undefined) => Preset<Theme$2>;
//#endregion
//#region ../preset-web-fonts/src/types.d.ts
type WebFontsProviders = 'google' | 'bunny' | 'fontshare' | 'fontsource' | 'coollabs' | 'none' | Provider;
interface WebFontMeta {
  /**
   * The name of the font family
   * @example 'Fira Code'
   */
  name: string;
  /**
   * Font weight(s) to include, and respect the weight order
   * @example [400, 700]
   */
  weights?: (string | number)[];
  /**
   * Use italic style
   */
  italic?: boolean;
  /**
   * Font width(s) to include, and respect the width order
   * @example [62.5, 125]
   */
  widths?: (string | number)[];
  /**
   * Variable font settings
   * @example
   * ```ts
   * variable: {
   *   wght: { default: '400', min: '100', max: '900', step: '100' },
   *   wdth: { default: '100', min: '50', max: '200', step: '10' },
   *   slnt: { default: '0', min: '-20', max: '20', step: '1' },
   * }
   */
  variable?: Record<string, Partial<Axes>>;
  /**
   * The font subsets to include
   * @example ['latin', 'cyrillic']
   */
  subsets?: string[];
  /**
   * Prefer static font files over variable
   */
  preferStatic?: boolean;
  /**
   * Override the provider
   * @default <matches root config>
   */
  provider?: WebFontsProviders;
}
interface WebFontProcessor {
  getCSS?: (fonts: ResolvedWebFontMeta[], providers: Provider[], getCSSDefault: (fonts: ResolvedWebFontMeta[], providers: Provider[]) => Awaitable<string>) => Awaitable<string | undefined>;
  transformCSS?: (css: string) => Promise<string | undefined>;
}
interface ResolvedWebFontMeta extends Omit<WebFontMeta, 'provider'> {
  provider: Provider;
}
interface WebFontsOptions {
  /**
   * Provider service of the web fonts
   * @default 'google'
   */
  provider?: WebFontsProviders;
  /**
   * The fonts
   */
  fonts?: Record<string, WebFontMeta | string | (WebFontMeta | string)[]>;
  /**
   * Extend fonts to the theme object
   * @default true
   */
  extendTheme?: boolean;
  /**
   * Key for the theme object
   *
   * Automatically detect the key based on the preset used
   *
   * @default
   * `preset-wind3` -> 'fontFamily'
   * `preset-wind4` -> 'font'
   */
  themeKey?: string;
  /**
   * Inline CSS @import()
   *
   * @default true
   */
  inlineImports?: boolean;
  /**
   * Custom fetch function
   *
   * @default undefined
   */
  customFetch?: (url: string) => Promise<any>;
  /**
   * Custom processor for the font CSS
   */
  processors?: Arrayable<WebFontProcessor>;
  /**
   * Timeouts for fetching web fonts
   */
  timeouts?: false | {
    /**
     * Timeout for printing warning message
     *
     * @default 500
     */
    warning?: number;
    /**
     * Timeout for failing the fetch
     *
     * @default 2000
     */
    failure?: number;
  };
}
interface Provider {
  name: WebFontsProviders;
  getPreflight?: (fonts: WebFontMeta[], fetcher: (url: string) => Promise<any>) => Awaitable<string | undefined>;
  getImportUrl?: (fonts: WebFontMeta[]) => string | undefined;
  getFontName?: (font: WebFontMeta) => string;
}
interface Axes {
  default: string;
  min: string;
  max: string;
  step: string;
}
//#endregion
//#region ../preset-web-fonts/src/preset.d.ts
declare function normalizedFontMeta(meta: WebFontMeta | string, defaultProvider: WebFontsProviders): ResolvedWebFontMeta;
//#endregion
//#region ../preset-web-fonts/src/providers/google.d.ts
declare function createGoogleCompatibleProvider(name: WebFontsProviders, host: string): Provider;
//#endregion
//#region ../preset-web-fonts/src/index.d.ts
/**
 * Preset for using web fonts by provide just the names.
 *
 * @see https://unocss.dev/presets/web-fonts
 */
declare const presetWebFonts: PresetFactory<any, WebFontsOptions>;
//#endregion
//#region ../../packages-deprecated/preset-wind/src/index.d.ts
interface PresetWindOptions extends PresetWind3Options {}
/**
 * @deprecated Use `presetWind3` from `@unocss/preset-wind3` instead
 */
declare const presetWind: PresetFactory<Theme$1, PresetWindOptions>;
//#endregion
//#region ../preset-wind4/src/theme/types.d.ts
interface Colors {
  [key: string]: Colors & {
    DEFAULT?: string;
  } | string;
}
interface ThemeAnimation {
  keyframes?: Record<string, string>;
  durations?: Record<string, string>;
  timingFns?: Record<string, string>;
  properties?: Record<string, object>;
  counts?: Record<string, string | number>;
  category?: Record<string, string>;
}
interface Theme {
  font?: Record<string, string>;
  colors?: Colors;
  spacing?: Record<string, string>;
  breakpoint?: Record<string, string>;
  verticalBreakpoint?: Record<string, string>;
  container?: Record<string, string>;
  text?: Record<string, {
    fontSize?: string;
    lineHeight?: string;
    letterSpacing?: string;
  }>;
  fontWeight?: Record<string, string>;
  tracking?: Record<string, string>;
  leading?: Record<string, string>;
  radius?: Record<string, string>;
  shadow?: Record<string, string | string[]>;
  insetShadow?: Record<string, string | string[]>;
  dropShadow?: Record<string, string | string[]>;
  textShadow?: Record<string, string | string[]>;
  ease?: Record<string, string>;
  animate?: Record<string, string>;
  blur?: Record<string, string>;
  perspective?: Record<string, string>;
  textStrokeWidth?: Record<string, string>;
  property?: Record<string, string>;
  default?: Record<string, Record<string, string>>;
  animation?: ThemeAnimation;
  duration?: Record<string, string>;
  containers?: {
    center?: boolean;
    padding?: string | Record<string, string>;
    maxWidth?: Record<string, string>;
  };
  aria?: Record<string, string>;
  data?: Record<string, string>;
  media?: Record<string, string>;
  supports?: Record<string, string>;
}
//#endregion
//#region ../preset-wind4/src/preflights/index.d.ts
declare const preflights: (options: PresetWind4Options) => Preflight<Theme>[];
//#endregion
//#region ../preset-wind4/src/shorthands.d.ts
declare const shorthands: {
  position: string[];
  globalKeyword: string[];
};
//#endregion
//#region ../preset-wind4/src/index.d.ts
interface DarkModeSelectors {
  /**
   * Selector for light variant.
   *
   * @default '.light'
   */
  light?: string;
  /**
   * Selector for dark variant.
   *
   * @default '.dark'
   */
  dark?: string;
}
interface PreflightsTheme {
  /**
   * Generate theme keys as CSS variables.
   *
   * - `true`: Generate theme keys fully.
   * - `false`: Disable theme keys. (Not recommended âš ï¸)
   * - `'on-demand'`: Generate theme keys only when used.
   *
   * @default 'on-demand'
   */
  mode?: boolean | 'on-demand';
  /**
   * Process the theme keys.
   */
  process?: Arrayable<(entry: CSSEntry, ctx: PreflightContext<Theme>) => void>;
}
interface PresetWind4Options extends PresetOptions {
  /**
   * Dark mode options
   *
   * @default 'class'
   */
  dark?: 'class' | 'media' | DarkModeSelectors;
  /**
   * Generate tagged pseudo selector as `[group=""]` instead of `.group`
   *
   * @default false
   */
  attributifyPseudo?: boolean;
  /**
   * Prefix for CSS variables.
   *
   * @default 'un-'
   */
  variablePrefix?: string;
  /**
   * Utils prefix. When using tagged pseudo selector, only the first truthy prefix will be used.
   *
   * @default undefined
   */
  prefix?: string | string[];
  /**
   * Enable arbitrary variants, for example `<div class="[&>*]:m-1 [&[open]]:p-2"></div>`.
   *
   * Disable this might slightly improve the performance.
   *
   * @default true
   */
  arbitraryVariants?: boolean;
  /**
   * The important option lets you control whether UnoCSSâ€™s utilities should be marked with `!important`.
   *
   * This can be really useful when using UnoCSS with existing CSS that has high specificity selectors.
   *
   * You can also set `important` to a selector like `#app` instead, which will generate `#app :is(.m-1) { ... }`
   *
   * Also check out the compatibility with [:is()](https://caniuse.com/?search=%3Ais())
   *
   * @default false
   */
  important?: boolean | string;
  /**
   * Control the preflight styles.
   */
  preflights?: {
    /**
     * Reset the default preflight styles.
     *
     * @default true
     */
    reset?: boolean;
    /**
     * Theme configuration for preflight styles.
     *
     * This can either be a specific mode from `PreflightsTheme['mode']` or a full `PreflightsTheme` object.
     *
     * The theme defines the base styles applied to elements and can be customized
     * to match the design system or requirements of your project.
     */
    theme?: PreflightsTheme['mode'] | PreflightsTheme;
    /**
     * Configuration for property preflight generation.
     *
     * - `false`: Disable property preflight
     * - `true` or `undefined`: Enable with default configuration
     * - `object`: Enable with custom configuration
     */
    property?: boolean | {
      /**
       * Custom parent selector (e.g., @supports query or @layer).
       *
       * - `string`: Use custom parent selector
       * - `false`: No parent wrapper, apply properties directly to selector
       * - `undefined`: Use default @supports query
       *
       * @default '@supports ((-webkit-hyphens: none) and (not (margin-trim: inline))) or ((-moz-orient: inline) and (not (color:rgb(from red r g b))))'
       */
      parent?: string | false;
      /**
       * Custom selector for applying properties.
       *
       * @default '*, ::before, ::after, ::backdrop'
       */
      selector?: string;
    };
  };
}
declare const presetWind4: PresetFactory<Theme, PresetWind4Options>;
//#endregion
//#region ../transformer-attributify-jsx/src/index.d.ts
type FilterPattern = Array<string | RegExp> | string | RegExp | null;
interface TransformerAttributifyJsxOptions {
  /**
   * the list of attributes to ignore
   * @default []
   */
  blocklist?: (string | RegExp)[];
  /**
   * Regex of modules to be included from processing
   * @default [/\.[jt]sx$/, /\.mdx$/]
   */
  include?: FilterPattern;
  /**
   * Regex of modules to exclude from processing
   *
   * @default []
   */
  exclude?: FilterPattern;
}
declare function transformerAttributifyJsx(options?: TransformerAttributifyJsxOptions): SourceCodeTransformer;
//#endregion
//#region ../transformer-compile-class/src/index.d.ts
interface CompileClassOptions {
  /**
   * Trigger regex literal. The default trigger regex literal matches `:uno:`,
   * for example: `<div class=":uno: font-bold text-white">`.
   *
   * @example
   * The trigger additionally allows defining a capture group named `name`, which
   * allows custom class names. One possible regex would be:
   *
   * ```
   * export default defineConfig({
   *   transformers: [
   *     transformerCompileClass({
   *       trigger: /(["'`]):uno(?:-)?(?<name>[^\s\1]+)?:\s([^\1]*?)\1/g
   *     }),
   *   ],
   * })
   * ```
   *
   * This regular expression matches `:uno-MYNAME:` and uses `MYNAME` in
   * combination with the class prefix as the final class name, for example:
   * `.uno-MYNAME`. It should be noted that the regex literal needs to include
   * the global flag `/g`.
   *
   * @note
   * This parameter is backwards compatible. It accepts string only trigger
   * words, like `:uno:` or a regex literal.
   *
   * @default `/(["'`]):uno(?:-)?(?<name>[^\s\1]+)?:\s([^\1]*?)\1/g`
   */
  trigger?: string | RegExp;
  /**
   * Prefix for compile class name
   * @default 'uno-'
   */
  classPrefix?: string;
  /**
   * Hash function
   */
  hashFn?: (str: string) => string;
  /**
   * Allow add hash to class name even if the class name is explicitly defined
   *
   * @default false
   */
  alwaysHash?: boolean;
  /**
   * Left unknown classes inside the string
   *
   * @default true
   */
  keepUnknown?: boolean;
  /**
   * The layer name of generated rules
   */
  layer?: string;
}
declare function transformerCompileClass(options?: CompileClassOptions): SourceCodeTransformer;
//#endregion
//#region ../transformer-directives/src/types.d.ts
interface TransformerDirectivesOptions {
  enforce?: SourceCodeTransformer['enforce'];
  /**
   * Throw an error if utils or themes are not found.
   *
   * @default true
   */
  throwOnMissing?: boolean;
  /**
   * Treat CSS custom properties as @apply directives for CSS syntax compatibility.
   *
   * Pass `false` to disable.
   *
   * @default ['--at-apply', '--uno-apply', '--uno']
   */
  applyVariable?: false | string | string[];
  /**
   * Treat CSS custom properties as directives for CSS syntax compatibility.
   *
   * Pass `false` to disable, or a string to use as a prefix.
   *
   * @deprecated use `applyVariable` to specify the full var name instead.
   * @default '--at-'
   */
  varStyle?: false | string;
}
//#endregion
//#region ../transformer-directives/src/index.d.ts
declare function transformerDirectives(options?: TransformerDirectivesOptions): SourceCodeTransformer;
//#endregion
//#region ../transformer-variant-group/src/index.d.ts
interface TransformerVariantGroupOptions {
  /**
   * Separators to expand.
   *
   * ```
   * foo-(bar baz) -> foo-bar foo-baz
   *    ^
   *    separator
   * ```
   *
   * You may set it to `[':']` for strictness.
   *
   * @default [':', '-']
   * @see https://github.com/unocss/unocss/pull/1231
   */
  separators?: (':' | '-')[];
}
declare function transformerVariantGroup(options?: TransformerVariantGroupOptions): SourceCodeTransformer;
//#endregion
//#region src/index.d.ts
/**
 * Define UnoCSS config
 */
declare function defineConfig<T extends object = Theme$1>(config: UserConfig<T>): UserConfig<T>;
//#endregion
export { PseudoPrefix as $, SourceCodeTransformer as $n, notNull as $r, CSSObjectInput as $t, TypographySizeScheme as A, Preflight as An, expandVariantGroup as Ar, LAYER_SHORTCUTS as At, IconsAPI as B, RawUtil as Bn, mergeDeep as Br, AutoCompleteExtractorContext as Bt, WebFontsOptions as C, HighlightAnnotation as Cn, createGenerator as Cr, defaultSplitRE as Ct, TypographyColorScheme as D, PartialByKeys as Dn, toEscapedSelector as Dr, LAYER_DEFAULT as Dt, TypographyCSSObject as E, ParsedUtil as En, symbols as Er, DEFAULT_LAYERS as Et, extractorTagify as F, PresetFactory as Fn, clone as Fr, resolvePresets as Ft, _default as G, Rule as Gn, withLayer as Gr, BaseContext as Gt, createCDNFetchLoader as H, RequiredByKey as Hn, normalizeCSSValues as Hr, AutoCompleteFunction as Ht, htmlTagRE as I, PresetFactoryAwaitable as In, entriesToCss as Ir, resolveShortcuts as It, variantAttributify as J, SafeListContext as Jn, isAttributifySelector as Jr, BlocklistValue as Jt, IconsOptions as K, RuleContext as Kn, attributifyRE as Kr, BlocklistMeta as Kt, TagifyOptions as L, PresetOptions as Ln, isObject as Lr, ArgumentType as Lt, presetTagify as M, PreparedRule as Mn, parseVariantGroup as Mr, mergeConfigs as Mt, variantTagify as N, Preprocessor as Nn, VirtualKey as Nr, resolveConfig as Nt, TypographyCompatibilityOptions as O, PluginOptions as On, warnOnce as Or, LAYER_IMPORTS as Ot, MARKER as P, Preset as Pn, clearIdenticalEntries as Pr, resolvePreset as Pt, BasicAttributes as Q, ShortcutValue as Qn, normalizeVariant as Qr, CSSObject as Qt, createNodeLoader as R, PresetOrFactory as Rn, isStaticRule as Rr, Arrayable as Rt, WebFontProcessor as S, GeneratorOptions as Sn, UnoGenerator as Sr, ThemeAnimation$1 as St, presetTypography as T, OutputCssLayersOptions as Tn, regexScopePlaceholder as Tr, splitWithVariantGroupRE as Tt, createPresetIcons as U, ResolvedConfig as Un, BetterMap as Ur, AutoCompleteTemplate as Ut, combineLoaders as V, Replacement as Vn, normalizeCSSEntries as Vr, AutoCompleteExtractorResult as Vt, parseIconWithLoader as W, RestArgs as Wn, TwoKeyMap as Wr, Awaitable as Wt, AttributifyAttributes as X, Shortcut as Xn, isValidSelector as Xr, CSSEntriesInput as Xt, variantsRE as Y, Shift as Yn, isRawUtil as Yr, CSSEntries as Yt, AttributifyNames as Z, ShortcutInlineValue as Zn, noop as Zr, CSSEntry as Zt, normalizedFontMeta as _, ExtractorContext as _n, VariantFunction as _r, VarPrefixPostprocessor as _t, transformerAttributifyJsx as a, escapeRegExp as ai, ConfigBase as an, StringifiedUtil as ar, defaultIgnoreAttributes as at, ResolvedWebFontMeta as b, GenerateOptions as bn, VariantMatchedResult as br, Colors$1 as bt, PresetWind4Options as c, isCountableSet as ci, ControlSymbolsEntry as cn, ToArray as cr, AttributifyOptions as ct, preflights as d, uniq as di, DynamicMatcher as dn, UserConfigDefaults as dr, PresetWind3Options as dt, validateFilterRE as ei, CSSValue as en, SourceCodeTransformerEnforce as er, SeparateEnabled as et, Theme as f, uniqueBy as fi, DynamicRule as fn, UserOnlyOptions as fr, presetWind3 as ft, createGoogleCompatibleProvider as g, Extractor as gn, VariantContext as gr, PresetMiniOptions as gt, presetWebFonts as h, ExtendedTokenInfo as hn, Variant as hr, DarkModeSelectors$1 as ht, transformerCompileClass as i, e as ii, CliOptions as in, StaticShortcutMap as ir, TwoStringsCompositionSuffix as it, TypographyTheme as j, PreflightContext as jn, makeRegexClassGroup as jr, definePreset as jt, TypographyOptions as k, Postprocessor as kn, collapseVariantGroup as kr, LAYER_PREFLIGHTS as kt, presetWind4 as l, isString as li, ControlSymbolsValue as ln, UnocssPluginContext as lr, PresetUnoOptions as lt, presetWind as m, DynamicShortcutMatcher as mn, UtilObject as mr, shortcuts as mt, transformerVariantGroup as n, Unsubscribe as ni, CSSValues as nn, StaticRule as nr, TwoStringsComposition as nt, DarkModeSelectors as o, escapeSelector as oi, ContentOptions as on, SuggestResult as or, extractorAttributify as ot, PresetWindOptions as p, DynamicShortcut as pn, UserShortcuts as pr, theme as pt, presetAttributify as q, RuleMeta as qn, cssIdRE as qr, BlocklistRule as qt, transformerDirectives as r, createNanoEvents as ri, CliEntryItem as rn, StaticShortcut as rr, TwoStringsCompositionPrefix as rt, PreflightsTheme as s, CountableSet as si, ControlSymbols as sn, ThemeExtender as sr, autocompleteExtractorAttributify as st, defineConfig as t, Emitter as ti, CSSValueInput as tn, SourceMap as tr, SpecialSingleWord as tt, shorthands as u, toArray as ui, DeepPartial as un, UserConfig as ur, presetUno as ut, Axes as v, FilterPattern$1 as vn, VariantHandler as vr, presetMini as vt, WebFontsProviders as w, ObjectToEntry as wn, hasScopePlaceholder as wr, extractorSplit as wt, WebFontMeta as x, GenerateResult as xn, VariantObject as xr, Theme$1 as xt, Provider as y, FlatObjectTuple as yn, VariantHandlerContext as yr, preflights$1 as yt, presetIcons as z, PresetOrFactoryAwaitable as zn, isStaticShortcut as zr, AutoCompleteExtractor as zt };