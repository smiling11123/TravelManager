import MagicString from "magic-string";
import { LoadConfigResult } from "unconfig";

//#region ../../packages-engine/core/src/utils/countable-set.d.ts
declare class CountableSet<K$1> extends Set<K$1> {
  _map: Map<K$1, number>;
  constructor(values?: Iterable<K$1>);
  add(key: K$1): this;
  delete(key: K$1): boolean;
  clear(): void;
  getCount(key: K$1): number;
  setCount(key: K$1, count: number): this;
}
//#endregion
//#region ../../packages-engine/core/src/utils/events.d.ts
type EventsMap = Record<string, any>;
interface DefaultEvents extends EventsMap {
  [event: string]: (...args: any) => void;
}
interface Unsubscribe {
  (): void;
}
declare class Emitter<Events extends EventsMap = DefaultEvents> {
  /**
   * Event names in keys and arrays with listeners in values.
   *
   * ```js
   * emitter1.events = emitter2.events
   * emitter2.events = { }
   * ```
   */
  events: Partial<{ [E in keyof Events]: Events[E][] }>;
  /**
   * Add a listener for a given event.
   *
   * ```js
   * const unbind = ee.on('tick', (tickType, tickDuration) => {
   *   count += 1
   * })
   *
   * disable () {
   *   unbind()
   * }
   * ```
   *
   * @param event The event name.
   * @param cb The listener function.
   * @returns Unbind listener from event.
   */
  on<K$1 extends keyof Events>(this: this, event: K$1, cb: Events[K$1]): Unsubscribe;
  /**
   * Calls each of the listeners registered for a given event.
   *
   * ```js
   * ee.emit('tick', tickType, tickDuration)
   * ```
   *
   * @param event The event name.
   * @param args The arguments for listeners.
   */
  emit<K$1 extends keyof Events>(this: this, event: K$1, ...args: Parameters<Events[K$1]>): void;
}
//#endregion
//#region ../../packages-engine/core/src/utils/map.d.ts
declare class BetterMap<K$1, V> extends Map<K$1, V> {
  getFallback(key: K$1, fallback: V): V;
  map<R>(mapFn: (value: V, key: K$1) => R): R[];
  flatMap<R extends readonly unknown[]>(mapFn: (value: V, key: K$1) => R): R[number][];
}
//#endregion
//#region ../../packages-engine/core/src/generator.d.ts
declare class UnoGeneratorInternal<Theme$1 extends object = object> {
  userConfig: UserConfig<Theme$1>;
  defaults: UserConfigDefaults<Theme$1>;
  readonly version: string;
  readonly events: Emitter<{
    config: (config: ResolvedConfig<Theme$1>) => void;
  }>;
  config: ResolvedConfig<Theme$1>;
  cache: Map<string, StringifiedUtil<Theme$1>[] | null>;
  blocked: Set<string>;
  parentOrders: Map<string, number>;
  activatedRules: Set<Rule<Theme$1>>;
  protected constructor(userConfig?: UserConfig<Theme$1>, defaults?: UserConfigDefaults<Theme$1>);
  static create<Theme$1 extends object = object>(userConfig?: UserConfig<Theme$1>, defaults?: UserConfigDefaults<Theme$1>): Promise<UnoGeneratorInternal<Theme$1>>;
  setConfig(userConfig?: UserConfig<Theme$1>, defaults?: UserConfigDefaults<Theme$1>): Promise<void>;
  applyExtractors(code: string, id?: string, extracted?: Set<string>): Promise<Set<string>>;
  applyExtractors(code: string, id?: string, extracted?: CountableSet<string>): Promise<CountableSet<string>>;
  makeContext(raw: string, applied: VariantMatchedResult<Theme$1>): RuleContext<Theme$1>;
  parseToken(raw: string, alias?: string): Promise<StringifiedUtil<Theme$1>[] | undefined | null>;
  generate(input: string | Set<string> | CountableSet<string> | string[], options?: GenerateOptions<false>): Promise<GenerateResult<Set<string>>>;
  generate(input: string | Set<string> | CountableSet<string> | string[], options?: GenerateOptions<true>): Promise<GenerateResult<Map<string, ExtendedTokenInfo<Theme$1>>>>;
  matchVariants(raw: string, current?: string): Promise<readonly VariantMatchedResult<Theme$1>[]>;
  private applyVariants;
  constructCustomCSS(context: Readonly<RuleContext<Theme$1>>, body: CSSObject | CSSEntries, overrideSelector?: string): string;
  parseUtil(input: string | VariantMatchedResult<Theme$1>, context: RuleContext<Theme$1>, internal?: boolean, shortcutPrefix?: string | string[] | undefined): Promise<(ParsedUtil | RawUtil)[] | undefined>;
  private resolveCSSResult;
  stringifyUtil(parsed?: ParsedUtil | RawUtil, context?: RuleContext<Theme$1>): StringifiedUtil<Theme$1>[] | undefined;
  expandShortcut(input: string, context: RuleContext<Theme$1>, depth?: number): Promise<[(string | ShortcutInlineValue)[], RuleMeta | undefined] | undefined>;
  stringifyShortcuts(parent: VariantMatchedResult<Theme$1>, context: RuleContext<Theme$1>, expanded: (string | ShortcutInlineValue)[], meta?: RuleMeta): Promise<StringifiedUtil<Theme$1>[] | undefined>;
  isBlocked(raw: string): boolean;
  getBlocked(raw: string): [BlocklistValue, BlocklistMeta | undefined] | undefined;
}
declare class UnoGenerator<Theme$1 extends object = object> extends UnoGeneratorInternal<Theme$1> {
  /**
   * @deprecated `new UnoGenerator` is deprecated, please use `createGenerator()` instead
   */
  constructor(userConfig?: UserConfig<Theme$1>, defaults?: UserConfigDefaults<Theme$1>);
}
//#endregion
//#region ../../packages-engine/core/src/types.d.ts
type Awaitable<T> = T | Promise<T>;
type Arrayable<T> = T | T[];
type FlatObjectTuple<T> = { [K in keyof T]: T[K] };
type RequiredByKey<T, K$1 extends keyof T = keyof T> = FlatObjectTuple<Required<Pick<T, Extract<keyof T, K$1>>> & Omit<T, K$1>>;
type CSSObject = Record<string, string | number | undefined>;
/**
 * [property, value, operators?]
 *
 * - operators: Used to perform specific operations on value or property.
 */
type CSSEntry = [string, string | number | undefined, Arrayable<string>?];
type CSSEntries = CSSEntry[];
type CSSObjectInput = CSSObject | Partial<ControlSymbolsValue>;
type CSSEntriesInput = (CSSEntry | ControlSymbolsEntry)[];
type CSSValueInput = CSSObjectInput | CSSEntriesInput | CSSValue;
type PresetOptions = Record<string, any>;
interface RuleContext<Theme$1 extends object = object> {
  /**
   * Unprocessed selector from user input.
   * Useful for generating CSS rule.
   */
  rawSelector: string;
  /**
   * Current selector for rule matching
   */
  currentSelector: string;
  /**
   * UnoCSS generator instance
   */
  generator: UnoGenerator<Theme$1>;
  /**
   * Symbols for special handling
   */
  symbols: ControlSymbols;
  /**
   * The theme object
   */
  theme: Theme$1;
  /**
   * Matched variants handlers for this rule.
   */
  variantHandlers: VariantHandler[];
  /**
   * The result of variant matching.
   */
  variantMatch: VariantMatchedResult<Theme$1>;
  /**
   * Construct a custom CSS rule.
   * Variants and selector escaping will be handled automatically.
   */
  constructCSS: (body: CSSEntries | CSSObject, overrideSelector?: string) => string;
  /**
   * Available only when `details` option is enabled.
   */
  rules?: Rule<Theme$1>[];
  /**
   * Available only when `details` option is enabled.
   */
  shortcuts?: Shortcut<Theme$1>[];
  /**
   * Available only when `details` option is enabled.
   */
  variants?: Variant<Theme$1>[];
}
declare const SymbolShortcutsNoMerge: unique symbol;
declare const SymbolNoMerge: unique symbol;
declare const SymbolVariants: unique symbol;
declare const SymbolParent: unique symbol;
declare const SymbolSelector: unique symbol;
declare const SymbolLayer: unique symbol;
declare const SymbolSort: unique symbol;
declare const SymbolBody: unique symbol;
interface ControlSymbols {
  /**
   * Prevent merging in shortcuts
   */
  shortcutsNoMerge: typeof SymbolShortcutsNoMerge;
  /**
   * Prevent merging in rules
   */
  noMerge: typeof SymbolNoMerge;
  /**
   * Additional variants applied to this rule
   */
  variants: typeof SymbolVariants;
  /**
   * Parent selector (`@media`, `@supports`, etc.)
   */
  parent: typeof SymbolParent;
  /**
   * Selector modifier
   */
  selector: typeof SymbolSelector;
  /**
   * Layer modifier
   */
  layer: typeof SymbolLayer;
  /**
   * Sort modifier
   */
  sort: typeof SymbolSort;
  /**
   * Custom css body modifier
   */
  body: typeof SymbolBody;
}
interface ControlSymbolsValue {
  [SymbolShortcutsNoMerge]: true;
  [SymbolNoMerge]: true;
  [SymbolVariants]: VariantHandler[] | ((handlers: VariantHandler[]) => VariantHandler[]);
  [SymbolParent]: string;
  [SymbolSelector]: (selector: string) => string;
  [SymbolLayer]: string;
  [SymbolSort]: number;
  [SymbolBody]: string;
}
type ObjectToEntry<T> = { [K in keyof T]: [K, T[K]] }[keyof T];
type ControlSymbolsEntry = ObjectToEntry<ControlSymbolsValue>;
interface VariantContext<Theme$1 extends object = object> {
  /**
   * Unprocessed selector from user input.
   */
  rawSelector: string;
  /**
   * UnoCSS generator instance
   */
  generator: UnoGenerator<Theme$1>;
  /**
   * The theme object
   */
  theme: Theme$1;
}
interface ExtractorContext {
  readonly original: string;
  code: string;
  id?: string;
  extracted: Set<string> | CountableSet<string>;
  envMode?: 'dev' | 'build';
}
interface BaseContext<Theme$1 extends object = object> {
  /**
   * UnoCSS generator instance
   */
  generator: UnoGenerator<Theme$1>;
  /**
   * The theme object
   */
  theme: Theme$1;
}
interface PreflightContext<Theme$1 extends object = object> extends BaseContext<Theme$1> {}
interface SafeListContext<Theme$1 extends object = object> extends BaseContext<Theme$1> {}
interface Extractor {
  name: string;
  order?: number;
  /**
   * Extract the code and return a list of selectors.
   *
   * Return `undefined` to skip this extractor.
   */
  extract?: (ctx: ExtractorContext) => Awaitable<Set<string> | CountableSet<string> | string[] | undefined | void>;
}
interface RuleMeta {
  /**
   * The layer name of this rule.
   * @default 'default'
   */
  layer?: string;
  /**
   * Option to not merge this selector even if the body are the same.
   * @default false
   */
  noMerge?: boolean;
  /**
   * Fine tune sort
   */
  sort?: number;
  /**
   * Templates to provide autocomplete suggestions
   */
  autocomplete?: Arrayable<AutoCompleteTemplate>;
  /**
   * Matching prefix before this util
   */
  prefix?: string | string[];
  /**
   * Internal rules will only be matched for shortcuts but not the user code.
   * @default false
   */
  internal?: boolean;
  /**
   * Store the hash of the rule boy
   *
   * @internal
   * @private
   */
  __hash?: string;
  /**
   * Internal index of the rulelist
   * @internal
   * @private
   */
  __index?: number;
  /**
   * Custom metadata
   */
  custom?: Record<string, any>;
}
type CSSValue = CSSObject | CSSEntries;
type DynamicMatcher<Theme$1 extends object = object> = (match: RegExpMatchArray, context: Readonly<RuleContext<Theme$1>>) => Awaitable<CSSValueInput | string | (CSSValueInput | string)[] | undefined> | Generator<CSSValueInput | string | undefined> | AsyncGenerator<CSSValueInput | string | undefined>;
type DynamicRule<Theme$1 extends object = object> = [RegExp, DynamicMatcher<Theme$1>, RuleMeta?];
type StaticRule = [string, CSSObject | CSSEntries | (CSSValueInput | string)[], RuleMeta?];
type Rule<Theme$1 extends object = object> = DynamicRule<Theme$1> | StaticRule;
type DynamicShortcutMatcher<Theme$1 extends object = object> = ((match: RegExpMatchArray, context: Readonly<RuleContext<Theme$1>>) => (string | ShortcutValue[] | undefined));
type StaticShortcut = [string, string | ShortcutValue[], RuleMeta?];
type StaticShortcutMap = Record<string, string | ShortcutValue[]>;
type DynamicShortcut<Theme$1 extends object = object> = [RegExp, DynamicShortcutMatcher<Theme$1>, RuleMeta?];
type UserShortcuts<Theme$1 extends object = object> = StaticShortcutMap | (StaticShortcut | DynamicShortcut<Theme$1> | StaticShortcutMap)[];
type Shortcut<Theme$1 extends object = object> = StaticShortcut | DynamicShortcut<Theme$1>;
interface ShortcutInlineValue {
  handles: VariantHandler[];
  value: ShortcutValue;
}
type ShortcutValue = string | CSSValue;
type FilterPattern = ReadonlyArray<string | RegExp> | string | RegExp | null;
interface Preflight<Theme$1 extends object = object> {
  getCSS: (context: PreflightContext<Theme$1>) => Promise<string | undefined> | string | undefined;
  layer?: string;
}
interface BlocklistMeta {
  /**
   * Custom message to show why this selector is blocked.
   */
  message?: string | ((selector: string) => string);
}
type BlocklistValue = string | RegExp | ((selector: string) => boolean | null | undefined);
type BlocklistRule = BlocklistValue | [BlocklistValue, BlocklistMeta];
interface VariantHandlerContext {
  /**
   * Rewrite the output selector. Often be used to append parents.
   */
  prefix: string;
  /**
   * Rewrite the output selector. Often be used to append pseudo classes.
   */
  selector: string;
  /**
   * Rewrite the output selector. Often be used to append pseudo elements.
   */
  pseudo: string;
  /**
   * Rewrite the output css body. The input come in [key,value][] pairs.
   */
  entries: CSSEntries;
  /**
   * Provide a parent selector(e.g. media query) to the output css.
   */
  parent?: string;
  /**
   * Provide order to the `parent` parent selector within layer.
   */
  parentOrder?: number;
  /**
   * Override layer to the output css.
   */
  layer?: string;
  /**
   * Order in which the variant is sorted within single rule.
   */
  sort?: number;
  /**
   * Option to not merge the resulting entries even if the body are the same.
   * @default false
   */
  noMerge?: boolean;
}
interface VariantHandler {
  /**
   * Callback to process the handler.
   */
  handle?: (input: VariantHandlerContext, next: (input: VariantHandlerContext) => VariantHandlerContext) => VariantHandlerContext;
  /**
   * The result rewritten selector for the next round of matching
   */
  matcher?: string;
  /**
   * Order in which the variant is applied to selector.
   */
  order?: number;
  /**
   * Rewrite the output selector. Often be used to append pseudo classes or parents.
   */
  selector?: (input: string, body: CSSEntries) => string | undefined;
  /**
   * Rewrite the output css body. The input come in [key,value][] pairs.
   */
  body?: (body: CSSEntries) => CSSEntries | undefined;
  /**
   * Provide a parent selector(e.g. media query) to the output css.
   */
  parent?: string | [string, number] | undefined;
  /**
   * Order in which the variant is sorted within single rule.
   */
  sort?: number;
  /**
   * Override layer to the output css.
   */
  layer?: string | undefined;
}
type VariantFunction<Theme$1 extends object = object> = (matcher: string, context: Readonly<VariantContext<Theme$1>>) => Awaitable<string | VariantHandler | VariantHandler[] | undefined>;
interface VariantObject<Theme$1 extends object = object> {
  /**
   * The name of the variant.
   */
  name?: string;
  /**
   * The entry function to match and rewrite the selector for further processing.
   */
  match: VariantFunction<Theme$1>;
  /**
   * Sort for when the match is applied.
   */
  order?: number;
  /**
   * Allows this variant to be used more than once in matching a single rule
   *
   * @default false
   */
  multiPass?: boolean;
  /**
   * Custom function for auto complete
   */
  autocomplete?: Arrayable<AutoCompleteFunction | AutoCompleteTemplate>;
}
type Variant<Theme$1 extends object = object> = VariantFunction<Theme$1> | VariantObject<Theme$1>;
type Preprocessor = (matcher: string) => string | undefined;
type Postprocessor = (util: UtilObject) => void | UtilObject | (UtilObject | null | undefined)[];
type ThemeExtender<Theme$1 extends object = object> = (theme: Theme$1, config: Readonly<ResolvedConfig<Theme$1>>) => Theme$1 | void;
interface ConfigBase<Theme$1 extends object = object> {
  /**
   * Rules to generate CSS utilities.
   *
   * Later entries have higher priority.
   */
  rules?: Rule<Theme$1>[];
  /**
   * Variant separator
   *
   * @default [':', '-']
   */
  separators?: Arrayable<string>;
  /**
   * Variants that preprocess the selectors,
   * having the ability to rewrite the CSS object.
   */
  variants?: Variant<Theme$1>[];
  /**
   * Similar to Windi CSS's shortcuts,
   * allows you have create new utilities by combining existing ones.
   *
   * Later entries have higher priority.
   */
  shortcuts?: UserShortcuts<Theme$1>;
  /**
   * Rules to exclude the selectors for your design system (to narrow down the possibilities).
   * Combining `warnExcluded` options it can also help you identify wrong usages.
   */
  blocklist?: BlocklistRule[];
  /**
   * Utilities that always been included
   */
  safelist?: (string | ((context: SafeListContext<Theme$1>) => Arrayable<string>))[];
  /**
   * Extractors to handle the source file and outputs possible classes/selectors
   * Can be language-aware.
   */
  extractors?: Extractor[];
  /**
   * Default extractor that are always applied.
   * By default it split the source code by whitespace and quotes.
   *
   * It maybe be replaced by preset or user config,
   * only one default extractor can be presented,
   * later one will override the previous one.
   *
   * Pass `null` or `false` to disable the default extractor.
   *
   * @see https://github.com/unocss/unocss/blob/main/packages-engine/core/src/extractors/split.ts
   * @default import('@unocss/core').defaultExtractor
   */
  extractorDefault?: Extractor | null | false;
  /**
   * Raw CSS injections.
   */
  preflights?: Preflight<Theme$1>[];
  /**
   * Theme object for shared configuration between rules
   */
  theme?: Theme$1;
  /**
   * Layer orders. Default to 0.
   */
  layers?: Record<string, number>;
  /**
   * Output the internal layers as CSS Cascade Layers.
   */
  outputToCssLayers?: boolean | OutputCssLayersOptions;
  /**
   * Custom function to sort layers.
   */
  sortLayers?: (layers: string[]) => string[];
  /**
   * Preprocess the incoming utilities, return falsy value to exclude
   */
  preprocess?: Arrayable<Preprocessor>;
  /**
   * Postprocess the generate utils object
   */
  postprocess?: Arrayable<Postprocessor>;
  /**
   * Custom functions mutate the theme object.
   *
   * It's also possible to return a new theme object to completely replace the original one.
   */
  extendTheme?: Arrayable<ThemeExtender<Theme$1>>;
  /**
   * Presets
   */
  presets?: (PresetOrFactoryAwaitable<Theme$1> | PresetOrFactoryAwaitable<Theme$1>[])[];
  /**
   * Additional options for auto complete
   */
  autocomplete?: {
    /**
     * Custom functions / templates to provide autocomplete suggestions
     */
    templates?: Arrayable<AutoCompleteFunction | AutoCompleteTemplate>;
    /**
     * Custom extractors to pickup possible classes and
     * transform class-name style suggestions to the correct format
     */
    extractors?: Arrayable<AutoCompleteExtractor>;
    /**
     * Custom shorthands to provide autocomplete suggestions.
     * if values is an array, it will be joined with `|` and wrapped with `()`
     */
    shorthands?: Record<string, string | string[]>;
  };
  /**
   * Hook to modify the resolved config.
   *
   * First presets runs first and the user config
   */
  configResolved?: (config: ResolvedConfig<Theme$1>) => void;
  /**
   * Expose internal details for debugging / inspecting
   *
   * Added `rules`, `shortcuts`, `variants` to the context and expose the context object in `StringifiedUtil`
   *
   * You don't usually need to set this.
   *
   * @default `true` when `envMode` is `dev`, otherwise `false`
   */
  details?: boolean;
  /**
   * Options for sources to be extracted as utilities usages.
   *
   */
  content?: ContentOptions;
  /**
   * Custom transformers to the source code.
   */
  transformers?: SourceCodeTransformer[];
}
interface OutputCssLayersOptions {
  /**
   * Specify the css layer that the internal layer should be output to.
   *
   * Return `null` to specify that the layer should not be output to any css layer.
   */
  cssLayerName?: (internalLayer: string) => string | undefined | null;
}
type AutoCompleteTemplate = string;
type AutoCompleteFunction = (input: string) => Awaitable<string[]>;
interface AutoCompleteExtractorContext {
  content: string;
  cursor: number;
}
interface Replacement {
  /**
   * The range of the original text
   */
  start: number;
  end: number;
  /**
   * The text used to replace
   */
  replacement: string;
}
interface AutoCompleteExtractorResult {
  /**
   * The extracted string
   */
  extracted: string;
  /**
   * The function to convert the selected suggestion back
   */
  resolveReplacement: (suggestion: string) => Replacement;
  /**
   * The function to format suggestions
   */
  transformSuggestions?: (suggestions: string[]) => string[];
}
interface AutoCompleteExtractor {
  name: string;
  extract: (context: AutoCompleteExtractorContext) => Awaitable<AutoCompleteExtractorResult | null>;
  order?: number;
}
interface Preset<Theme$1 extends object = object> extends ConfigBase<Theme$1> {
  name: string;
  /**
   * Enforce the preset to be applied before or after other presets
   */
  enforce?: 'pre' | 'post';
  /**
   * Preset options for other tools like IDE to consume
   */
  options?: PresetOptions;
  /**
   * Apply prefix to all utilities and shortcuts
   */
  prefix?: string | string[];
  /**
   * Apply layer to all utilities and shortcuts
   */
  layer?: string;
  /**
   * Custom API endpoint for cross-preset communication
   */
  api?: any;
  /**
   * Custom metadata for the preset
   */
  meta?: Record<string, any>;
}
type PresetFactory<Theme$1 extends object = object, PresetOptions$1 extends object | undefined = undefined> = (options?: PresetOptions$1) => Preset<Theme$1>;
type PresetFactoryAwaitable<Theme$1 extends object = object, PresetOptions$1 extends object | undefined = undefined> = (options?: PresetOptions$1) => Awaitable<Preset<Theme$1>>;
type PresetOrFactory<Theme$1 extends object = object> = Preset<Theme$1> | PresetFactory<Theme$1, any>;
type PresetOrFactoryAwaitable<Theme$1 extends object = object> = PresetOrFactory<Theme$1> | Promise<Preset<Theme$1>> | PresetFactoryAwaitable<Theme$1>;
interface GeneratorOptions {
  /**
   * Merge utilities with the exact same body to save the file size
   *
   * @default true
   */
  mergeSelectors?: boolean;
  /**
   * Emit warning when matched selectors are presented in blocklist
   *
   * @default true
   */
  warn?: boolean;
}
interface UserOnlyOptions<Theme$1 extends object = object> {
  /**
   * The theme object, will be merged with the theme provides by presets
   */
  theme?: Theme$1;
  /**
   * Layout name of shortcuts
   *
   * @default 'shortcuts'
   */
  shortcutsLayer?: string;
  /**
   * Environment mode
   *
   * @default 'build'
   */
  envMode?: 'dev' | 'build';
  /**
   * legacy.renderModernChunks need to be consistent with @vitejs/plugin-legacy
   */
  legacy?: {
    renderModernChunks: boolean;
  };
  /**
   * Custom prefix for virtual modules
   *
   * @default '__uno'
   */
  virtualModulePrefix?: string;
}
/**
 * For unocss-cli config
 */
interface CliOptions {
  cli?: {
    entry?: Arrayable<CliEntryItem>;
  };
}
interface UnocssPluginContext<Config extends UserConfig = UserConfig> {
  /**
   * Singleton promise for config loading
   */
  ready: Promise<LoadConfigResult<Config>>;
  /**
   * The UnoCSS generator instance. Should be used after `ready` resolved.
   */
  uno: UnoGenerator;
  /**
   * All tokens scanned
   */
  tokens: Set<string>;
  /**
   * Map for all module's raw content
   */
  modules: BetterMap<string, string>;
  /**
   * Module IDs that been affected by UnoCSS
   */
  affectedModules: Set<string>;
  /**
   *  Pending promises
   */
  tasks: Promise<any>[];
  /**
   * Await all pending tasks
   */
  flushTasks: () => Promise<any>;
  filter: (code: string, id: string) => boolean;
  extract: (code: string, id?: string) => Promise<void>;
  reloadConfig: () => Promise<LoadConfigResult<Config>>;
  getConfig: () => Promise<Config>;
  onReload: (fn: () => void) => void;
  invalidate: () => void;
  onInvalidate: (fn: () => void) => void;
  root: string;
  updateRoot: (root: string) => Promise<LoadConfigResult<Config>>;
  getConfigFileList: () => string[];
  /**
   * Get regexes to match virtual module ids
   */
  getVMPRegexes: () => Promise<{
    prefix: string;
    RESOLVED_ID_WITH_QUERY_RE: RegExp;
    RESOLVED_ID_RE: RegExp;
  }>;
}
interface HighlightAnnotation {
  offset: number;
  length: number;
  className: string;
}
type SourceCodeTransformerEnforce = 'pre' | 'post' | 'default';
interface SourceCodeTransformer {
  name: string;
  /**
   * The order of transformer
   */
  enforce?: SourceCodeTransformerEnforce;
  /**
   * Custom id filter, if not provided, the extraction filter will be applied
   */
  idFilter?: (id: string) => boolean;
  /**
   * The transform function
   */
  transform: (code: MagicString, id: string, ctx: UnocssPluginContext) => Awaitable<{
    highlightAnnotations?: HighlightAnnotation[];
  } | void>;
}
interface ContentOptions {
  /**
   * Glob patterns to extract from the file system, in addition to other content sources.
   *
   * In dev mode, the files will be watched and trigger HMR.
   *
   * @default []
   */
  filesystem?: string[];
  /**
   * Inline text to be extracted
   */
  inline?: (string | {
    code: string;
    id?: string;
  } | (() => Awaitable<string | {
    code: string;
    id?: string;
  }>))[];
  /**
   * Filters to determine whether to extract certain modules from the build tools' transformation pipeline.
   *
   * Currently only works for Vite and Webpack integration.
   *
   * Set `false` to disable.
   */
  pipeline?: false | {
    /**
     * Patterns that filter the files being extracted.
     * Supports regular expressions and `picomatch` glob patterns.
     *
     * By default, `.ts` and `.js` files are NOT extracted.
     *
     * @see https://www.npmjs.com/package/picomatch
     * @default [/\.(vue|svelte|[jt]sx|vine.ts|mdx?|astro|elm|php|phtml|marko|html)($|\?)/]
     */
    include?: FilterPattern;
    /**
     * Patterns that filter the files NOT being extracted.
     * Supports regular expressions and `picomatch` glob patterns.
     *
     * By default, `node_modules` and `dist` are also extracted.
     *
     * @see https://www.npmjs.com/package/picomatch
     * @default [/\.(css|postcss|sass|scss|less|stylus|styl)($|\?)/]
     */
    exclude?: FilterPattern;
  };
}
/**
 * For other modules to aggregate the options
 */
interface PluginOptions {
  /**
   * Load from configs files
   *
   * set `false` to disable
   */
  configFile?: string | false;
  /**
   * List of files that will also trigger config reloads
   */
  configDeps?: string[];
  /**
   * Custom transformers to the source code
   */
  transformers?: SourceCodeTransformer[];
  /**
   * Options for sources to be extracted as utilities usages
   *
   * Supported sources:
   * - `filesystem` - extract from file system
   * - `inline` - extract from plain inline text
   * - `pipeline` - extract from build tools' transformation pipeline, such as Vite and Webpack
   *
   * The usage extracted from each source will be **merged** together.
   */
  content?: ContentOptions;
}
interface UserConfig<Theme$1 extends object = object> extends ConfigBase<Theme$1>, UserOnlyOptions<Theme$1>, GeneratorOptions, PluginOptions, CliOptions {}
interface UserConfigDefaults<Theme$1 extends object = object> extends ConfigBase<Theme$1>, UserOnlyOptions<Theme$1> {}
interface ResolvedConfig<Theme$1 extends object = object> extends Omit<RequiredByKey<UserConfig<Theme$1>, 'mergeSelectors' | 'theme' | 'rules' | 'variants' | 'layers' | 'extractors' | 'blocklist' | 'safelist' | 'preflights' | 'sortLayers'>, 'rules' | 'shortcuts' | 'autocomplete' | 'presets'> {
  presets: Preset<Theme$1>[];
  shortcuts: Shortcut<Theme$1>[];
  variants: VariantObject<Theme$1>[];
  preprocess: Preprocessor[];
  postprocess: Postprocessor[];
  rulesSize: number;
  rules: readonly Rule<Theme$1>[];
  rulesDynamic: readonly DynamicRule<Theme$1>[];
  rulesStaticMap: Record<string, StaticRule | undefined>;
  autocomplete: {
    templates: (AutoCompleteFunction | AutoCompleteTemplate)[];
    extractors: AutoCompleteExtractor[];
    shorthands: Record<string, string>;
  };
  separators: string[];
}
interface GenerateResult<T = Set<string>> {
  css: string;
  layers: string[];
  getLayer: (name?: string) => string | undefined;
  getLayers: (includes?: string[], excludes?: string[]) => string;
  setLayer: (layer: string, callback: (content: string) => Promise<string>) => Promise<string>;
  matched: T;
}
type VariantMatchedResult<Theme$1 extends object = object> = [raw: string, current: string, variantHandlers: VariantHandler[], variants: Set<Variant<Theme$1>>];
type ParsedUtil = readonly [index: number, raw: string, entries: CSSEntries, meta: RuleMeta | undefined, variantHandlers: VariantHandler[]];
type RawUtil = readonly [index: number, rawCSS: string, meta: RuleMeta | undefined];
type StringifiedUtil<Theme$1 extends object = object> = readonly [index: number, selector: string | undefined, body: string, parent: string | undefined, meta: RuleMeta | undefined, context: RuleContext<Theme$1> | undefined, noMerge: boolean | undefined];
interface CliEntryItem {
  patterns: string[];
  outFile: string;
}
interface UtilObject {
  selector: string;
  entries: CSSEntries;
  parent: string | undefined;
  layer: string | undefined;
  sort: number | undefined;
  noMerge: boolean | undefined;
}
/**
 * Returned from `uno.generate()` when `extendedInfo` option is enabled.
 */
interface ExtendedTokenInfo<Theme$1 extends object = object> {
  /**
   * Stringified util data
   */
  data: StringifiedUtil<Theme$1>[];
  /**
   * Return -1 if the data structure is not countable
   */
  count: number;
}
interface GenerateOptions<T extends boolean> {
  /**
   * Filepath of the file being processed.
   */
  id?: string;
  /**
   * Generate preflights (if defined)
   *
   * @default true
   */
  preflights?: boolean;
  /**
   * Includes safelist
   */
  safelist?: boolean;
  /**
   * Generate minified CSS
   * @default false
   */
  minify?: boolean;
  /**
   * @experimental
   */
  scope?: string;
  /**
   * If return extended "matched" with payload and count
   */
  extendedInfo?: T;
}
//#endregion
//#region src/_theme/types.d.ts
interface ThemeAnimation {
  keyframes?: Record<string, string>;
  durations?: Record<string, string>;
  timingFns?: Record<string, string>;
  properties?: Record<string, object>;
  counts?: Record<string, string | number>;
  category?: Record<string, string>;
}
interface Colors {
  [key: string]: Colors & {
    DEFAULT?: string;
  } | string;
}
interface Theme {
  width?: Record<string, string>;
  height?: Record<string, string>;
  maxWidth?: Record<string, string>;
  maxHeight?: Record<string, string>;
  minWidth?: Record<string, string>;
  minHeight?: Record<string, string>;
  inlineSize?: Record<string, string>;
  blockSize?: Record<string, string>;
  maxInlineSize?: Record<string, string>;
  maxBlockSize?: Record<string, string>;
  minInlineSize?: Record<string, string>;
  minBlockSize?: Record<string, string>;
  borderRadius?: Record<string, string>;
  breakpoints?: Record<string, string>;
  verticalBreakpoints?: Record<string, string>;
  colors?: Colors;
  borderColor?: Colors;
  backgroundColor?: Colors;
  textColor?: Colors;
  shadowColor?: Colors;
  accentColor?: Colors;
  fontFamily?: Record<string, string>;
  fontSize?: Record<string, string | [string, string | CSSObject] | [string, string, string]>;
  fontWeight?: Record<string, string>;
  lineHeight?: Record<string, string>;
  letterSpacing?: Record<string, string>;
  wordSpacing?: Record<string, string>;
  boxShadow?: Record<string, string | string[]>;
  textIndent?: Record<string, string>;
  textShadow?: Record<string, string | string[]>;
  textStrokeWidth?: Record<string, string>;
  ringWidth?: Record<string, string>;
  lineWidth?: Record<string, string>;
  spacing?: Record<string, string>;
  duration?: Record<string, string>;
  aria?: Record<string, string>;
  data?: Record<string, string>;
  zIndex?: Record<string, string>;
  blur?: Record<string, string>;
  dropShadow?: Record<string, string | string[]>;
  easing?: Record<string, string>;
  transitionProperty?: Record<string, string>;
  media?: Record<string, string>;
  supports?: Record<string, string>;
  containers?: Record<string, string>;
  animation?: ThemeAnimation;
  gridAutoColumn?: Record<string, string>;
  gridAutoRow?: Record<string, string>;
  gridColumn?: Record<string, string>;
  gridRow?: Record<string, string>;
  gridTemplateColumn?: Record<string, string>;
  gridTemplateRow?: Record<string, string>;
  container?: {
    center?: boolean;
    padding?: string | Record<string, string>;
    maxWidth?: Record<string, string>;
  };
  /** Used to generate CSS custom properties placeholder in preflight */
  preflightRoot?: Arrayable<string>;
  preflightBase?: Record<string, string | number>;
}
//#endregion
//#region src/_theme/colors.d.ts
declare const colors: {
  inherit: string;
  current: string;
  transparent: string;
  black: string;
  white: string;
  rose: {
    50: string;
    100: string;
    200: string;
    300: string;
    400: string;
    500: string;
    600: string;
    700: string;
    800: string;
    900: string;
    950: string;
  };
  pink: {
    50: string;
    100: string;
    200: string;
    300: string;
    400: string;
    500: string;
    600: string;
    700: string;
    800: string;
    900: string;
    950: string;
  };
  fuchsia: {
    50: string;
    100: string;
    200: string;
    300: string;
    400: string;
    500: string;
    600: string;
    700: string;
    800: string;
    900: string;
    950: string;
  };
  purple: {
    50: string;
    100: string;
    200: string;
    300: string;
    400: string;
    500: string;
    600: string;
    700: string;
    800: string;
    900: string;
    950: string;
  };
  violet: {
    50: string;
    100: string;
    200: string;
    300: string;
    400: string;
    500: string;
    600: string;
    700: string;
    800: string;
    900: string;
    950: string;
  };
  indigo: {
    50: string;
    100: string;
    200: string;
    300: string;
    400: string;
    500: string;
    600: string;
    700: string;
    800: string;
    900: string;
    950: string;
  };
  blue: {
    50: string;
    100: string;
    200: string;
    300: string;
    400: string;
    500: string;
    600: string;
    700: string;
    800: string;
    900: string;
    950: string;
  };
  sky: {
    50: string;
    100: string;
    200: string;
    300: string;
    400: string;
    500: string;
    600: string;
    700: string;
    800: string;
    900: string;
    950: string;
  };
  cyan: {
    50: string;
    100: string;
    200: string;
    300: string;
    400: string;
    500: string;
    600: string;
    700: string;
    800: string;
    900: string;
    950: string;
  };
  teal: {
    50: string;
    100: string;
    200: string;
    300: string;
    400: string;
    500: string;
    600: string;
    700: string;
    800: string;
    900: string;
    950: string;
  };
  emerald: {
    50: string;
    100: string;
    200: string;
    300: string;
    400: string;
    500: string;
    600: string;
    700: string;
    800: string;
    900: string;
    950: string;
  };
  green: {
    50: string;
    100: string;
    200: string;
    300: string;
    400: string;
    500: string;
    600: string;
    700: string;
    800: string;
    900: string;
    950: string;
  };
  lime: {
    50: string;
    100: string;
    200: string;
    300: string;
    400: string;
    500: string;
    600: string;
    700: string;
    800: string;
    900: string;
    950: string;
  };
  yellow: {
    50: string;
    100: string;
    200: string;
    300: string;
    400: string;
    500: string;
    600: string;
    700: string;
    800: string;
    900: string;
    950: string;
  };
  amber: {
    50: string;
    100: string;
    200: string;
    300: string;
    400: string;
    500: string;
    600: string;
    700: string;
    800: string;
    900: string;
    950: string;
  };
  orange: {
    50: string;
    100: string;
    200: string;
    300: string;
    400: string;
    500: string;
    600: string;
    700: string;
    800: string;
    900: string;
    950: string;
  };
  red: {
    50: string;
    100: string;
    200: string;
    300: string;
    400: string;
    500: string;
    600: string;
    700: string;
    800: string;
    900: string;
    950: string;
  };
  gray: {
    50: string;
    100: string;
    200: string;
    300: string;
    400: string;
    500: string;
    600: string;
    700: string;
    800: string;
    900: string;
    950: string;
  };
  slate: {
    50: string;
    100: string;
    200: string;
    300: string;
    400: string;
    500: string;
    600: string;
    700: string;
    800: string;
    900: string;
    950: string;
  };
  zinc: {
    50: string;
    100: string;
    200: string;
    300: string;
    400: string;
    500: string;
    600: string;
    700: string;
    800: string;
    900: string;
    950: string;
  };
  neutral: {
    50: string;
    100: string;
    200: string;
    300: string;
    400: string;
    500: string;
    600: string;
    700: string;
    800: string;
    900: string;
    950: string;
  };
  stone: {
    50: string;
    100: string;
    200: string;
    300: string;
    400: string;
    500: string;
    600: string;
    700: string;
    800: string;
    900: string;
    950: string;
  };
  light: {
    50: string;
    100: string;
    200: string;
    300: string;
    400: string;
    500: string;
    600: string;
    700: string;
    800: string;
    900: string;
    950: string;
  };
  dark: {
    50: string;
    100: string;
    200: string;
    300: string;
    400: string;
    500: string;
    600: string;
    700: string;
    800: string;
    900: string;
    950: string;
  };
  readonly lightblue: string | (Colors & {
    DEFAULT?: string;
  });
  readonly lightBlue: string | (Colors & {
    DEFAULT?: string;
  });
  readonly warmgray: string | (Colors & {
    DEFAULT?: string;
  });
  readonly warmGray: string | (Colors & {
    DEFAULT?: string;
  });
  readonly truegray: string | (Colors & {
    DEFAULT?: string;
  });
  readonly trueGray: string | (Colors & {
    DEFAULT?: string;
  });
  readonly coolgray: string | (Colors & {
    DEFAULT?: string;
  });
  readonly coolGray: string | (Colors & {
    DEFAULT?: string;
  });
  readonly bluegray: string | (Colors & {
    DEFAULT?: string;
  });
  readonly blueGray: string | (Colors & {
    DEFAULT?: string;
  });
};
//#endregion
export { VariantHandlerContext as _, Arrayable as a, DynamicMatcher as c, PresetFactory as d, PresetOptions as f, VariantContext as g, Variant as h, ThemeAnimation as i, Postprocessor as l, StaticRule as m, Colors as n, CSSEntries as o, Rule as p, Theme as r, CSSObject as s, colors as t, Preflight as u, VariantObject as v };