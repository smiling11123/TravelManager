import { _ as VariantHandlerContext, a as Arrayable, c as DynamicMatcher, g as VariantContext, m as StaticRule, r as Theme, s as CSSObject, v as VariantObject } from "./colors-CdGFctaC.mjs";

//#region ../rule-utils/src/colors.d.ts
interface CSSColorValue {
  type: string;
  components: (string | number)[];
  alpha: string | number | undefined;
}
type RGBAColorValue = [number, number, number, number] | [number, number, number];
interface ParsedColorValue {
  /**
   * Parsed color value.
   */
  color?: string;
  /**
   * Parsed opacity value.
   */
  opacity: string;
  /**
   * Color name.
   */
  name: string;
  /**
   * Color scale, preferably 000 - 999.
   */
  no: string;
  /**
   * {@link CSSColorValue}
   */
  cssColor: CSSColorValue | undefined;
  /**
   * Parsed alpha value from opacity
   */
  alpha: string | number | undefined;
}
declare const cssColorFunctions: string[];
declare const rectangularColorSpace: string[];
declare const polarColorSpace: string[];
declare const hueInterpolationMethods: string[];
declare const alphaPlaceholders: string[];
declare const alphaPlaceholdersRE: RegExp;
declare function isInterpolatedMethod(type?: string): boolean;
declare function hex2rgba(hex?: string): RGBAColorValue | undefined;
declare function parseCssColor(str?: string): CSSColorValue | undefined;
declare function colorOpacityToString(color: CSSColorValue): string | number;
declare function colorToString(color: CSSColorValue | string, alphaOverride?: string | number): string;
//#endregion
//#region ../rule-utils/src/directive.d.ts
declare const themeFnRE: RegExp;
declare function hasThemeFn(str: string): boolean;
declare function transformThemeFn(code: string, theme: Record<string, any>, throwOnMissing?: boolean): string;
declare function transformThemeString(code: string, theme: Record<string, any>, throwOnMissing?: boolean): string | undefined;
declare function calcMaxWidthBySize(size: string): string;
//#endregion
//#region ../rule-utils/src/handlers.d.ts
type ValueHandlerCallback<T extends object> = (str: string, theme?: T) => string | number | undefined;
type ValueHandler<K extends string, T extends object> = { [S in K]: ValueHandler<K, T> } & {
  (str: string, theme?: T): string | undefined;
  __options: {
    sequence: K[];
  };
};
declare function createValueHandler<K extends string, T extends object>(handlers: Record<K, ValueHandlerCallback<T>>): ValueHandler<K, T>;
//#endregion
//#region ../rule-utils/src/icon.d.ts
declare const iconFnRE: RegExp;
declare function hasIconFn(str: string): boolean;
//#endregion
//#region ../rule-utils/src/utilities.d.ts
declare function getBracket(str: string, open: string, close: string): string[] | undefined;
declare function getStringComponent(str: string, open: string, close: string, separators: string | string[]): string[] | undefined;
declare function getStringComponents(str: string, separators: string | string[], limit?: number, open?: string, close?: string): string[] | undefined;
//#endregion
//#region ../rule-utils/src/variants.d.ts
declare function variantMatcher<T extends object = object>(name: string, handler: Arrayable<(input: VariantHandlerContext) => Record<string, any>>, options?: Omit<VariantObject<T>, 'match'>): VariantObject<T>;
declare function variantParentMatcher<T extends object = object>(name: string, parent: string): VariantObject<T>;
declare function variantGetBracket(prefix: string, matcher: string, separators: string[]): string[] | undefined;
declare function variantGetParameter(prefix: Arrayable<string>, matcher: string, separators: string[]): string[] | undefined;
//#endregion
//#region ../rule-utils/src/pseudo.d.ts
/**
 * Note: the order of following pseudo classes will affect the order of generated css.
 *
 * Reference: https://github.com/tailwindlabs/tailwindcss/blob/main/src/corePlugins.js#L83
 */
declare const PseudoClasses: Record<string, string>;
declare const PseudoClassesKeys: string[];
declare const PseudoClassesColon: Record<string, string>;
declare const PseudoClassesColonKeys: string[];
declare const PseudoClassFunctions: string[];
declare const PseudoClassesMulti: Record<string, string[]>;
declare const PseudoClassesStr: string;
declare const PseudoClassesColonStr: string;
declare const PseudoClassFunctionsStr: string;
declare const PseudoClassesMultiStr: string;
declare const excludedPseudo: string[];
declare const PseudoClassesAndElementsStr: string;
declare const PseudoClassesAndElementsColonStr: string;
interface PseudoVariantOptions {
  /**
   * Generate tagged pseudo selector as `[group=""]` instead of `.group`
   *
   * @default false
   */
  attributifyPseudo?: boolean;
  /**
   * Utils prefix
   */
  prefix?: string | string[];
}
interface PseudoVariantUtilities<Theme$1 extends object = object> {
  getBracket: typeof getBracket;
  h: {
    bracket: (s: string, theme?: Theme$1) => string | undefined;
  };
  variantGetBracket: typeof variantGetBracket;
}
declare function createTaggedPseudoClassMatcher<T extends object = object>(tag: string, parent: string, combinator: string, utils: PseudoVariantUtilities): VariantObject<T>;
declare function createPseudoClassesAndElements<T extends object = object>(utils: PseudoVariantUtilities): VariantObject<T>[];
declare function createPseudoClassFunctions<T extends object = object>(utils: PseudoVariantUtilities): VariantObject<T>;
declare function createTaggedPseudoClasses<T extends object = object>(options: PseudoVariantOptions, utils: PseudoVariantUtilities): VariantObject<T>[];
declare function createPartClasses<T extends object = object>(): VariantObject<T>;
declare namespace handlers_d_exports {
  export { auto, bracket, bracketOfColor, bracketOfLength, bracketOfPosition, cssvar, degree, fraction, global, number, numberWithUnit, percent, position, properties, px, rem, time };
}
declare function numberWithUnit(str: string): string | undefined;
declare function auto(str: string): "auto" | undefined;
declare function rem(str: string): string | undefined;
declare function px(str: string): string | undefined;
declare function number(str: string): number | undefined;
declare function percent(str: string): string | undefined;
declare function fraction(str: string): string | undefined;
declare function bracket(str: string): string | undefined;
declare function bracketOfColor(str: string): string | undefined;
declare function bracketOfLength(str: string): string | undefined;
declare function bracketOfPosition(str: string): string | undefined;
declare function cssvar(str: string): string | undefined;
declare function time(str: string): string | undefined;
declare function degree(str: string): string | undefined;
declare function global(str: string): string | undefined;
declare function properties(str: string): string | undefined;
declare function position(str: string): string | undefined;
//#endregion
//#region src/_utils/handlers/index.d.ts
declare const handler: ValueHandler<"number" | "auto" | "position" | "numberWithUnit" | "rem" | "px" | "percent" | "fraction" | "bracket" | "bracketOfColor" | "bracketOfLength" | "bracketOfPosition" | "cssvar" | "time" | "degree" | "global" | "properties", object>;
declare const h: ValueHandler<"number" | "auto" | "position" | "numberWithUnit" | "rem" | "px" | "percent" | "fraction" | "bracket" | "bracketOfColor" | "bracketOfLength" | "bracketOfPosition" | "cssvar" | "time" | "degree" | "global" | "properties", object>;
//#endregion
//#region src/_utils/mappings.d.ts
declare const directionMap: Record<string, string[]>;
declare const insetMap: Record<string, string[]>;
declare const cornerMap: Record<string, string[]>;
declare const xyzMap: Record<string, string[]>;
declare const xyzArray: string[];
declare const positionMap: Record<string, string>;
declare const globalKeywords: string[];
declare const cssMathFnRE: RegExp;
declare const cssVarFnRE: RegExp;
//#endregion
//#region src/_utils/utilities.d.ts
declare const CONTROL_MINI_NO_NEGATIVE = "$$mini-no-negative";
/**
 * Provide {@link DynamicMatcher} function returning spacing definition. See spacing rules.
 *
 * @param propertyPrefix - Property for the css value to be created. Postfix will be appended according to direction matched.
 * @see {@link directionMap}
 */
declare function directionSize(propertyPrefix: string): DynamicMatcher;
type ThemeColorKeys = 'colors' | 'borderColor' | 'backgroundColor' | 'textColor' | 'shadowColor' | 'accentColor';
/**
 * Split utility shorthand delimited by / or :
 */
declare function splitShorthand(body: string, type: string): string[] | undefined;
/**
 * Parse color string into {@link ParsedColorValue} (if possible). Color value will first be matched to theme object before parsing.
 * See also color.tests.ts for more examples.
 *
 * @example Parseable strings:
 * 'red' // From theme, if 'red' is available
 * 'red-100' // From theme, plus scale
 * 'red-100/20' // From theme, plus scale/opacity
 * '[rgb(100 2 3)]/[var(--op)]' // Bracket with rgb color and bracket with opacity
 *
 * @param body - Color string to be parsed.
 * @param theme - {@link Theme} object.
 * @return object if string is parseable.
 */
declare function parseColor(body: string, theme: Theme, key?: ThemeColorKeys): ParsedColorValue | undefined;
/**
 * Provide {@link DynamicMatcher} function to produce color value matched from rule.
 *
 * @see {@link parseColor}
 *
 * @example Resolving 'red' from theme:
 * colorResolver('background-color', 'background')('', 'red')
 * return { 'background-color': '#f12' }
 *
 * @example Resolving 'red-100' from theme:
 * colorResolver('background-color', 'background')('', 'red-100')
 * return { '--un-background-opacity': '1', 'background-color': 'rgb(254 226 226 / var(--un-background-opacity))' }
 *
 * @example Resolving 'red-100/20' from theme:
 * colorResolver('background-color', 'background')('', 'red-100/20')
 * return { 'background-color': 'rgb(204 251 241 / 0.22)' }
 *
 * @example Resolving 'hex-124':
 * colorResolver('color', 'text')('', 'hex-124')
 * return { '--un-text-opacity': '1', 'color': 'rgb(17 34 68 / var(--un-text-opacity))' }
 *
 * @param property - Property for the css value to be created.
 * @param varName - Base name for the opacity variable.
 * @param [key] - Theme key to select the color from.
 * @param [shouldPass] - Function to decide whether to pass the css.
 * @return object.
 */
declare function colorResolver(property: string, varName: string, key?: ThemeColorKeys, shouldPass?: (css: CSSObject) => boolean): DynamicMatcher;
declare function colorableShadows(shadows: string | string[], colorVar: string): string[];
declare function hasParseableColor(color: string | undefined, theme: Theme, key: ThemeColorKeys): boolean;
declare function resolveBreakpoints({
  theme,
  generator
}: Readonly<VariantContext<Theme>>, key?: 'breakpoints' | 'verticalBreakpoints'): {
  point: string;
  size: string;
}[] | undefined;
declare function resolveVerticalBreakpoints(context: Readonly<VariantContext<Theme>>): {
  point: string;
  size: string;
}[] | undefined;
declare function makeGlobalStaticRules(prefix: string, property?: string): StaticRule[];
declare function isCSSMathFn(value: string | undefined): boolean;
declare function isSize(str: string): boolean;
declare function transformXYZ(d: string, v: string, name: string): [string, string][];
//#endregion
export { hasIconFn as $, PseudoClassesAndElementsStr as A, createPartClasses as B, h as C, PseudoClassFunctionsStr as D, PseudoClassFunctions as E, PseudoClassesMulti as F, excludedPseudo as G, createPseudoClassesAndElements as H, PseudoClassesMultiStr as I, variantMatcher as J, variantGetBracket as K, PseudoClassesStr as L, PseudoClassesColonKeys as M, PseudoClassesColonStr as N, PseudoClasses as O, PseudoClassesKeys as P, getStringComponents as Q, PseudoVariantOptions as R, xyzMap as S, rectangularColorSpace as St, handlers_d_exports as T, createTaggedPseudoClassMatcher as U, createPseudoClassFunctions as V, createTaggedPseudoClasses as W, getBracket as X, variantParentMatcher as Y, getStringComponent as Z, directionMap as _, hex2rgba as _t, hasParseableColor as a, hasThemeFn as at, positionMap as b, parseCssColor as bt, makeGlobalStaticRules as c, transformThemeString as ct, resolveVerticalBreakpoints as d, RGBAColorValue as dt, iconFnRE as et, splitShorthand as f, alphaPlaceholders as ft, cssVarFnRE as g, cssColorFunctions as gt, cssMathFnRE as h, colorToString as ht, directionSize as i, calcMaxWidthBySize as it, PseudoClassesColon as j, PseudoClassesAndElementsColonStr as k, parseColor as l, CSSColorValue as lt, cornerMap as m, colorOpacityToString as mt, colorResolver as n, ValueHandlerCallback as nt, isCSSMathFn as o, themeFnRE as ot, transformXYZ as p, alphaPlaceholdersRE as pt, variantGetParameter as q, colorableShadows as r, createValueHandler as rt, isSize as s, transformThemeFn as st, CONTROL_MINI_NO_NEGATIVE as t, ValueHandler as tt, resolveBreakpoints as u, ParsedColorValue as ut, globalKeywords as v, hueInterpolationMethods as vt, handler as w, xyzArray as x, polarColorSpace as xt, insetMap as y, isInterpolatedMethod as yt, PseudoVariantUtilities as z };