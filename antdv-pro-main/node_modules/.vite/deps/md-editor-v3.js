import { Fragment, Teleport, cloneVNode, computed, createApp, createVNode, defineComponent, h as h$4, inject, isVNode, nextTick, onBeforeUnmount, onMounted, provide, reactive, ref, shallowRef, toRef, useId, watch } from "./vue.runtime.esm-bundler-CYunRHQt.js";
import { lib_default } from "./markdown-it-CPudIgfQ.js";
import { Annotation, ChangeDesc, ChangeSet, CharCategory, Compartment, Decoration, Direction, EditorSelection, EditorState, EditorView, Facet, HighlightStyle, IndentContext, LanguageDescription, LanguageSupport, NodeProp, Prec, RangeSetBuilder, StateEffect, StateField, StreamLanguage, Text, Transaction, ViewPlugin, WidgetType, codePointAt, codePointSize, combineConfig, countColumn, crelt, drawSelection, findClusterBreak, fromCodePoint, getIndentUnit, getIndentation, getPanel, indentString, indentUnit, keymap, matchBrackets, placeholder, runScopeHandlers, showPanel, showTooltip, syntaxHighlighting, syntaxTree, tags } from "./dist-BSjRk5ij.js";
import { autocompletion } from "./dist-C4Wus0z5.js";
import { markdown } from "./dist-BFuXW3Vg.js";
import "./dist-CWGCtyW4.js";
import "./dist-Dh21ZLBs.js";
import "./dist-B6-BhQV2.js";

//#region node_modules/@vavt/util/lib/es/index.mjs
var M$2 = (e$1) => {
	const n$3 = typeof e$1;
	return n$3 !== "function" && n$3 !== "object" || e$1 === null;
}, k$1 = (e$1) => {
	const n$3 = e$1.flags === "" ? void 0 : e$1.flags;
	return new RegExp(e$1.source, n$3);
}, u$3 = (e$1, n$3 = /* @__PURE__ */ new WeakMap()) => {
	if (e$1 === null || M$2(e$1)) return e$1;
	if (n$3.has(e$1)) return n$3.get(e$1);
	if (e$1 instanceof RegExp) return k$1(e$1);
	if (e$1 instanceof Date) return new Date(e$1.getTime());
	if (e$1 instanceof Function) return e$1;
	if (e$1 instanceof Map) {
		const r$2 = /* @__PURE__ */ new Map();
		return n$3.set(e$1, r$2), e$1.forEach((o$2, s$2) => {
			r$2.set(s$2, u$3(o$2, n$3));
		}), r$2;
	}
	if (e$1 instanceof Set) {
		const r$2 = /* @__PURE__ */ new Set();
		n$3.set(e$1, r$2);
		for (const o$2 of e$1) r$2.add(u$3(o$2, n$3));
		return r$2;
	}
	if (Array.isArray(e$1)) {
		const r$2 = [];
		return n$3.set(e$1, r$2), e$1.forEach((o$2) => {
			r$2.push(u$3(o$2, n$3));
		}), r$2;
	}
	const t$1 = {};
	n$3.set(e$1, t$1);
	for (const r$2 in e$1) Object.prototype.hasOwnProperty.call(e$1, r$2) && (t$1[r$2] = u$3(e$1[r$2], n$3));
	return t$1;
}, x = (e$1, n$3 = 200) => {
	let t$1 = 0;
	return (...r$2) => new Promise((o$2) => {
		t$1 && (clearTimeout(t$1), o$2("cancel")), t$1 = window.setTimeout(() => {
			e$1.apply(void 0, r$2), t$1 = 0, o$2("done");
		}, n$3);
	});
}, L = (e$1, n$3 = {
	_blank: !0,
	nofollow: !0
}) => {
	const t$1 = document.createElement("a");
	t$1.href = e$1, n$3._blank && (t$1.target = "_blank"), n$3.nofollow && (t$1.rel = "noopener noreferrer"), t$1.click();
}, R$3 = (e$1, n$3 = "") => {
	const t$1 = document.createElement("a");
	t$1.setAttribute("href", e$1), t$1.setAttribute("download", n$3), t$1.click();
}, C = () => {
	let e$1 = -1;
	return (t$1, r$2, o$2, s$2 = 100) => {
		const c$2 = () => {
			o$2 && (typeof s$2 == "number" ? setTimeout(o$2, s$2) : o$2());
		};
		e$1 !== -1 && (cancelAnimationFrame(e$1), c$2());
		let i$3 = t$1.scrollTop;
		const l$2 = () => {
			e$1 = -1;
			const a$2 = r$2 - i$3;
			i$3 = i$3 + a$2 / 5, Math.abs(a$2) < 1 ? (t$1.scrollTo(0, r$2), c$2()) : (t$1.scrollTo(0, i$3), e$1 = requestAnimationFrame(l$2));
		};
		e$1 = requestAnimationFrame(l$2);
	};
}, $ = C(), F = (e$1, n$3 = 200) => {
	let t$1 = 0, r$2 = null;
	const o$2 = (s$2) => {
		t$1 === 0 && (t$1 = s$2), s$2 - t$1 >= n$3 ? (e$1.apply(void 0, r$2), r$2 = null, t$1 = 0) : window.requestAnimationFrame(o$2);
	};
	return (...s$2) => {
		r$2 === null && window.requestAnimationFrame(o$2), r$2 = s$2;
	};
}, O$2 = (e$1, n$3 = !0) => {
	if (!e$1) return {};
	const t$1 = {};
	return e$1.replace(/^\?/, "").split("&").forEach((r$2) => {
		const [o$2, s$2] = r$2.split("=");
		if (o$2) {
			const c$2 = n$3 ? decodeURIComponent(o$2) : o$2, i$3 = n$3 ? decodeURIComponent(s$2) : s$2;
			t$1[c$2] !== void 0 ? (Array.isArray(t$1[c$2]) || (t$1[c$2] = [t$1[c$2]]), t$1[c$2].push(i$3)) : t$1[c$2] = i$3;
		}
	}), t$1;
}, H$1 = (e$1, n$3 = !0) => e$1 ? Object.keys(e$1).map((t$1) => {
	const r$2 = n$3 ? encodeURIComponent(t$1) : t$1;
	if (Array.isArray(e$1[t$1])) return e$1[t$1].map((o$2) => {
		return `${r$2}=${n$3 ? encodeURIComponent(o$2) : o$2}`;
	}).join("&");
	{
		const o$2 = n$3 ? encodeURIComponent(e$1[t$1]) : e$1[t$1];
		return `${r$2}=${o$2}`;
	}
}).join("&") : "", P$1 = (e$1, n$3, t$1 = "asc") => e$1.sort((r$2, o$2) => {
	const s$2 = n$3(r$2), c$2 = n$3(o$2);
	return s$2 === void 0 && c$2 !== void 0 || s$2 === null && c$2 !== void 0 ? t$1 === "asc" ? -1 : 1 : s$2 == null && c$2 === void 0 || c$2 == null ? t$1 === "asc" ? 1 : -1 : v$1(s$2) && v$1(c$2) ? t$1 == "asc" ? s$2 - c$2 : c$2 - s$2 : t$1 == "asc" ? String(s$2).localeCompare(String(c$2), void 0, { numeric: !0 }) : String(c$2).localeCompare(String(s$2), void 0, { numeric: !0 });
}), U$1 = (e$1) => {
	const n$3 = (t$1) => {
		const { scrollHeight: r$2, scrollWidth: o$2, offsetHeight: s$2, offsetWidth: c$2, scrollLeft: i$3, scrollTop: l$2 } = e$1, a$2 = t$1.x, S$2 = t$1.y, A$2 = (g$4) => {
			const d$2 = l$2 + S$2 - g$4.y, m$2 = i$3 + a$2 - g$4.x, T$1 = r$2 - s$2, E = o$2 - c$2, p$3 = {};
			m$2 >= 0 && m$2 <= E && (p$3.left = m$2), d$2 >= 0 && d$2 <= T$1 && (p$3.top = d$2), e$1.scroll(p$3);
		};
		document.addEventListener("mousemove", A$2);
		const w$3 = () => {
			document.removeEventListener("mousemove", A$2), document.removeEventListener("mouseup", w$3);
		};
		document.addEventListener("mouseup", w$3);
	};
	return e$1.addEventListener("mousedown", n$3), () => {
		e$1.removeEventListener("mousedown", n$3);
	};
}, W$1 = () => `${Date.now().toString(36)}${Math.random().toString(36).substring(2)}`, v$1 = (e$1) => {
	if (e$1 == null || ["boolean", "symbol"].includes(typeof e$1) || /^\s*$/.test(e$1.toString())) return !1;
	const n$3 = Number(e$1);
	return !isNaN(n$3) && isFinite(n$3);
}, f$2 = (e$1) => e$1 !== null && typeof e$1 == "object" && !Array.isArray(e$1), h$5 = (e$1, n$3, t$1 = {}) => {
	if (Array.isArray(e$1) && Array.isArray(n$3)) return y$1(e$1, n$3, t$1);
	const { excludeKeys: r$2 } = t$1;
	for (const o$2 in n$3) {
		const s$2 = n$3[o$2], c$2 = e$1[o$2];
		r$2 && r$2(o$2) ? e$1[o$2] = s$2 : Array.isArray(s$2) && Array.isArray(c$2) ? e$1[o$2] = y$1(c$2, s$2, t$1) : f$2(s$2) && f$2(c$2) ? e$1[o$2] = h$5(c$2, s$2, t$1) : e$1[o$2] = s$2;
	}
	return e$1;
}, y$1 = (e$1, n$3, t$1) => {
	const r$2 = e$1.slice();
	return n$3.forEach((o$2, s$2) => {
		const c$2 = r$2[s$2];
		Array.isArray(o$2) && Array.isArray(c$2) ? r$2[s$2] = y$1(c$2, o$2, t$1) : f$2(o$2) && f$2(c$2) ? r$2[s$2] = h$5(c$2, o$2, t$1) : r$2[s$2] = o$2;
	}), r$2;
}, _$1 = (e$1, n$3 = document.body) => {
	let t$1 = e$1.offsetParent, r$2 = e$1.offsetTop, o$2 = e$1.offsetLeft;
	for (; t$1 !== null && t$1 !== n$3;) r$2 += t$1.offsetTop, o$2 += t$1.offsetLeft, t$1 = t$1.offsetParent;
	return {
		offsetTop: r$2,
		offsetLeft: o$2
	};
}, N$2 = (e$1 = {}) => {
	const { forceScreenWidth: n$3 = !1, threshold: t$1 = 768, fallbackToScreenWidth: r$2 = !0 } = e$1, o$2 = navigator.userAgent, s$2 = /android|ipad|iphone|ipod|windows phone|blackberry/i.test(o$2), c$2 = "ontouchstart" in window || navigator.maxTouchPoints > 0, i$3 = window.matchMedia(`(max-width: ${t$1}px)`).matches;
	return n$3 ? i$3 : s$2 && c$2 ? !0 : r$2 ? i$3 : !1;
};

//#endregion
//#region node_modules/md-editor-v3/lib/es/chunks/config.mjs
var p$1 = "md-editor", u = "MdEditor", s$1 = "https://unpkg.com", n$2 = `${s$1}/@highlightjs/cdn-assets@11.10.0/highlight.min.js`, i$2 = {
	main: `${s$1}/prettier@3.3.3/standalone.js`,
	markdown: `${s$1}/prettier@3.3.3/plugins/markdown.js`
}, a$1 = {
	css: `${s$1}/cropperjs@1.6.2/dist/cropper.min.css`,
	js: `${s$1}/cropperjs@1.6.2/dist/cropper.min.js`
}, o$1 = `${s$1}/screenfull@5.2.0/dist/screenfull.js`, l$1 = `${s$1}/mermaid@11.9.0/dist/mermaid.min.js`, c$1 = {
	js: `${s$1}/katex@0.16.22/dist/katex.min.js`,
	css: `${s$1}/katex@0.16.22/dist/katex.min.css`
}, g$1 = {
	a11y: {
		light: `${s$1}/@highlightjs/cdn-assets@11.10.0/styles/a11y-light.min.css`,
		dark: `${s$1}/@highlightjs/cdn-assets@11.10.0/styles/a11y-dark.min.css`
	},
	atom: {
		light: `${s$1}/@highlightjs/cdn-assets@11.10.0/styles/atom-one-light.min.css`,
		dark: `${s$1}/@highlightjs/cdn-assets@11.10.0/styles/atom-one-dark.min.css`
	},
	github: {
		light: `${s$1}/@highlightjs/cdn-assets@11.10.0/styles/github.min.css`,
		dark: `${s$1}/@highlightjs/cdn-assets@11.10.0/styles/github-dark.min.css`
	},
	gradient: {
		light: `${s$1}/@highlightjs/cdn-assets@11.10.0/styles/gradient-light.min.css`,
		dark: `${s$1}/@highlightjs/cdn-assets@11.10.0/styles/gradient-dark.min.css`
	},
	kimbie: {
		light: `${s$1}/@highlightjs/cdn-assets@11.10.0/styles/kimbie-light.min.css`,
		dark: `${s$1}/@highlightjs/cdn-assets@11.10.0/styles/kimbie-dark.min.css`
	},
	paraiso: {
		light: `${s$1}/@highlightjs/cdn-assets@11.10.0/styles/paraiso-light.min.css`,
		dark: `${s$1}/@highlightjs/cdn-assets@11.10.0/styles/paraiso-dark.min.css`
	},
	qtcreator: {
		light: `${s$1}/@highlightjs/cdn-assets@11.10.0/styles/qtcreator-light.min.css`,
		dark: `${s$1}/@highlightjs/cdn-assets@11.10.0/styles/qtcreator-dark.min.css`
	},
	stackoverflow: {
		light: `${s$1}/@highlightjs/cdn-assets@11.10.0/styles/stackoverflow-light.min.css`,
		dark: `${s$1}/@highlightjs/cdn-assets@11.10.0/styles/stackoverflow-dark.min.css`
	}
}, d$1 = `${s$1}/echarts@6.0.0/dist/echarts.min.js`, y = {
	highlight: {
		js: {
			integrity: "sha384-GdEWAbCjn+ghjX0gLx7/N1hyTVmPAjdC2OvoAA0RyNcAOhqwtT8qnbCxWle2+uJX",
			crossOrigin: "anonymous"
		},
		css: {
			a11y: {
				light: {
					integrity: "sha384-qdZDAN3jffvh670RHw1wxLekabidEFaNRninYgIzBvMbL6WlHdXeHS/Bt+vx33lN",
					crossOrigin: "anonymous"
				},
				dark: {
					integrity: "sha384-2QAAjX8pqaM5azX68KWI2wExF6Q13kY4kEiQFY4b/1zPe6rpgmTByNpDEllH3sb+",
					crossOrigin: "anonymous"
				}
			},
			atom: {
				light: {
					integrity: "sha384-w6Ujm1VWa9HYFqGc89oAPn/DWDi2gUamjNrq9DRvEYm2X3ClItg9Y9xs1ViVo5b5",
					crossOrigin: "anonymous"
				},
				dark: {
					integrity: "sha384-oaMLBGEzBOJx3UHwac0cVndtX5fxGQIfnAeFZ35RTgqPcYlbprH9o9PUV/F8Le07",
					crossOrigin: "anonymous"
				}
			},
			github: {
				light: {
					integrity: "sha384-eFTL69TLRZTkNfYZOLM+G04821K1qZao/4QLJbet1pP4tcF+fdXq/9CdqAbWRl/L",
					crossOrigin: "anonymous"
				},
				dark: {
					integrity: "sha384-wH75j6z1lH97ZOpMOInqhgKzFkAInZPPSPlZpYKYTOqsaizPvhQZmAtLcPKXpLyH",
					crossOrigin: "anonymous"
				}
			},
			gradient: {
				light: {
					integrity: "sha384-yErHBR8aEZPxRl3XmR8dGSRAclMlnSRRw8sXQLcmPWzWUvb56BzQmBw3EWHl7QGI",
					crossOrigin: "anonymous"
				},
				dark: {
					integrity: "sha384-lUCvtSOdvDbp5hLWKgwz/taFu1HxlpqES2OVP5UG2JMTfnU481gXcBhGF9lAGoSr",
					crossOrigin: "anonymous"
				}
			},
			kimbie: {
				light: {
					integrity: "sha384-tloeSLUPczAvoZ48TUz+OxRie0oYLCRwlkadUXovGzzJEIbNQB2TkfUuvJ6SW5Mi",
					crossOrigin: "anonymous"
				},
				dark: {
					integrity: "sha384-o5F1vUaMNOmou1sQrsWiFo4/QUGSV0svqNZW+EesmKxWC8MpFJcveBhAyfvTHbGb",
					crossOrigin: "anonymous"
				}
			},
			paraiso: {
				light: {
					integrity: "sha384-5j6QHU2Hwg1ehtlIQNDebhETDB8bga3/88hzBFsMRaGmgQHCftqIN7GZNDNw0vTL",
					crossOrigin: "anonymous"
				},
				dark: {
					integrity: "sha384-I5vnnMQu0LWDQnHpT61xyoMwKarAB8jpZkB2ioFOlmzUFnIFaV4QbUwlBBOMKhTH",
					crossOrigin: "anonymous"
				}
			},
			qtcreator: {
				light: {
					integrity: "sha384-iEBgHrwi8Hv4dSZBz+MOGvS05rF7I7fGKM2fASQyE9jn2Istg9Qd5dSoK18WyRTB",
					crossOrigin: "anonymous"
				},
				dark: {
					integrity: "sha384-D6LXJGWNR4QV7gnpuP3ccbvOYoR02td3cU0y7lESABPg/tzCSC4m+y+M2TtrmpHc",
					crossOrigin: "anonymous"
				}
			},
			stackoverflow: {
				light: {
					integrity: "sha384-FMwt7cTGo4aLxZnno5k0xTj0W4gmi48Kwept+y/oQmE6cFk36Kr+QJZOKNOQwORe",
					crossOrigin: "anonymous"
				},
				dark: {
					integrity: "sha384-iL+x+BroCyHm/p2c6sMA9umXhdCWp2cKe4QUjPeMzHgwXAk+ZxHyIGP3NZTZensU",
					crossOrigin: "anonymous"
				}
			}
		}
	},
	prettier: {
		standaloneJs: {
			integrity: "sha384-92h6ALm8/lHpNGn6MfGlgZ+I8c/4yn/nSN8dV9ZmDxqbP9L93gk/Jj2i0LtV+AVd",
			crossOrigin: "anonymous"
		},
		parserMarkdownJs: {
			integrity: "sha384-5ufuUgoSsr/2oihBZ5d+c+yt0qaUmzLtUz41VZNJ4txtyJ6mBve3ZwuKoq/IygYX",
			crossOrigin: "anonymous"
		}
	},
	cropper: {
		js: {
			integrity: "sha384-jrOgQzBlDeUNdmQn3rUt/PZD+pdcRBdWd/HWRqRo+n2OR2QtGyjSaJC0GiCeH+ir",
			crossOrigin: "anonymous"
		},
		css: {
			integrity: "sha384-6LFfkTKLRlzFtgx8xsWyBdKGpcMMQTkv+dB7rAbugeJAu1Ym2q1Aji1cjHBG12Xh",
			crossOrigin: "anonymous"
		}
	},
	screenfull: { js: {
		integrity: "sha384-Qfbv8upMDu/ikv42M0Jnym2hahbDQ77Nm8PGU0G+iA6UIwt1+scE6P1qKXA0anWU",
		crossOrigin: "anonymous"
	} },
	mermaid: { js: {
		integrity: "sha384-UzWEhMP22MxNnr2bzqAdmtf1FDy5iKDUq6hLXJFLqC7dfGkc6W/hshbx9m71zyt5",
		crossOrigin: "anonymous"
	} },
	katex: {
		js: {
			integrity: "sha384-cMkvdD8LoxVzGF/RPUKAcvmm49FQ0oxwDF3BGKtDXcEc+T1b2N+teh/OJfpU0jr6",
			crossOrigin: "anonymous"
		},
		css: {
			integrity: "sha384-5TcZemv2l/9On385z///+d7MSYlvIEw9FuZTIdZ14vJLqWphw7e7ZPuOiCHJcFCP",
			crossOrigin: "anonymous"
		}
	},
	echarts: { js: {
		integrity: "sha384-F07Cpw5v8spSU0H113F33m2NQQ/o6GqPTnTjf45ssG4Q6q58ZwhxBiQtIaqvnSpR",
		crossOrigin: "anonymous"
	} }
}, k = [
	"bold",
	"underline",
	"italic",
	"strikeThrough",
	"-",
	"title",
	"sub",
	"sup",
	"quote",
	"unorderedList",
	"orderedList",
	"task",
	"-",
	"codeRow",
	"code",
	"link",
	"image",
	"table",
	"mermaid",
	"katex",
	"-",
	"revoke",
	"next",
	"save",
	"=",
	"prettier",
	"pageFullscreen",
	"fullscreen",
	"preview",
	"previewOnly",
	"htmlPreview",
	"catalog",
	"github"
], b = [
	"markdownTotal",
	"=",
	"scrollSwitch"
], v = {
	"zh-CN": {
		toolbarTips: {
			bold: "加粗",
			underline: "下划线",
			italic: "斜体",
			strikeThrough: "删除线",
			title: "标题",
			sub: "下标",
			sup: "上标",
			quote: "引用",
			unorderedList: "无序列表",
			orderedList: "有序列表",
			task: "任务列表",
			codeRow: "行内代码",
			code: "块级代码",
			link: "链接",
			image: "图片",
			table: "表格",
			mermaid: "mermaid图",
			katex: "katex公式",
			revoke: "后退",
			next: "前进",
			save: "保存",
			prettier: "美化",
			pageFullscreen: "浏览器全屏",
			fullscreen: "屏幕全屏",
			preview: "预览",
			previewOnly: "仅预览",
			htmlPreview: "html代码预览",
			catalog: "目录",
			github: "源码地址"
		},
		titleItem: {
			h1: "一级标题",
			h2: "二级标题",
			h3: "三级标题",
			h4: "四级标题",
			h5: "五级标题",
			h6: "六级标题"
		},
		imgTitleItem: {
			link: "添加链接",
			upload: "上传图片",
			clip2upload: "裁剪上传"
		},
		linkModalTips: {
			linkTitle: "添加链接",
			imageTitle: "添加图片",
			descLabel: "链接描述：",
			descLabelPlaceHolder: "请输入描述...",
			urlLabel: "链接地址：",
			urlLabelPlaceHolder: "请输入链接...",
			buttonOK: "确定"
		},
		clipModalTips: {
			title: "裁剪图片上传",
			buttonUpload: "上传"
		},
		copyCode: {
			text: "复制代码",
			successTips: "已复制！",
			failTips: "复制失败！"
		},
		mermaid: {
			flow: "流程图",
			sequence: "时序图",
			gantt: "甘特图",
			class: "类图",
			state: "状态图",
			pie: "饼图",
			relationship: "关系图",
			journey: "旅程图"
		},
		katex: {
			inline: "行内公式",
			block: "块级公式"
		},
		footer: {
			markdownTotal: "字数",
			scrollAuto: "同步滚动"
		}
	},
	"en-US": {
		toolbarTips: {
			bold: "bold",
			underline: "underline",
			italic: "italic",
			strikeThrough: "strikeThrough",
			title: "title",
			sub: "subscript",
			sup: "superscript",
			quote: "quote",
			unorderedList: "unordered list",
			orderedList: "ordered list",
			task: "task list",
			codeRow: "inline code",
			code: "block-level code",
			link: "link",
			image: "image",
			table: "table",
			mermaid: "mermaid",
			katex: "formula",
			revoke: "revoke",
			next: "undo revoke",
			save: "save",
			prettier: "prettier",
			pageFullscreen: "fullscreen in page",
			fullscreen: "fullscreen",
			preview: "preview",
			previewOnly: "preview only",
			htmlPreview: "html preview",
			catalog: "catalog",
			github: "source code"
		},
		titleItem: {
			h1: "Lv1 Heading",
			h2: "Lv2 Heading",
			h3: "Lv3 Heading",
			h4: "Lv4 Heading",
			h5: "Lv5 Heading",
			h6: "Lv6 Heading"
		},
		imgTitleItem: {
			link: "Add Image Link",
			upload: "Upload Images",
			clip2upload: "Crop And Upload"
		},
		linkModalTips: {
			linkTitle: "Add Link",
			imageTitle: "Add Image",
			descLabel: "Desc:",
			descLabelPlaceHolder: "Enter a description...",
			urlLabel: "Link:",
			urlLabelPlaceHolder: "Enter a link...",
			buttonOK: "OK"
		},
		clipModalTips: {
			title: "Crop Image",
			buttonUpload: "Upload"
		},
		copyCode: {
			text: "Copy",
			successTips: "Copied!",
			failTips: "Copy failed!"
		},
		mermaid: {
			flow: "flow",
			sequence: "sequence",
			gantt: "gantt",
			class: "class",
			state: "state",
			pie: "pie",
			relationship: "relationship",
			journey: "journey"
		},
		katex: {
			inline: "inline",
			block: "block"
		},
		footer: {
			markdownTotal: "Character Count",
			scrollAuto: "Scroll Auto"
		}
	}
}, h$1 = {
	editorExtensions: {
		highlight: {
			js: n$2,
			css: g$1
		},
		prettier: {
			standaloneJs: i$2.main,
			parserMarkdownJs: i$2.markdown
		},
		cropper: { ...a$1 },
		screenfull: { js: o$1 },
		mermaid: {
			js: l$1,
			enableZoom: !0
		},
		katex: { ...c$1 },
		echarts: { js: d$1 }
	},
	editorExtensionsAttrs: {},
	editorConfig: {
		languageUserDefined: {},
		mermaidTemplate: {},
		renderDelay: 500,
		zIndex: 2e4
	},
	codeMirrorExtensions: (e$1) => e$1,
	markdownItConfig: () => {},
	markdownItPlugins: (e$1) => e$1,
	mermaidConfig: (e$1) => e$1,
	katexConfig: (e$1) => e$1,
	echartsConfig: (e$1) => e$1
}, j = (e$1) => h$5(h$1, e$1, { excludeKeys(t$1) {
	return /[iI]{1}nstance/.test(t$1);
} }), w$1 = .1;

//#endregion
//#region node_modules/md-editor-v3/lib/es/chunks/vue-tsx.mjs
var g = ({ instance: o$2, ctx: l$2, props: r$2 = {} }, t$1 = "default") => {
	const s$2 = o$2?.$slots[t$1] || l$2?.slots[t$1];
	return (s$2 ? s$2(o$2) : "") || r$2[t$1];
};

//#endregion
//#region node_modules/md-editor-v3/lib/es/chunks/index.mjs
var O$1 = {
	overlay: {
		type: [String, Object],
		default: ""
	},
	visible: {
		type: Boolean,
		default: !1
	},
	onChange: {
		type: Function,
		default: () => {}
	},
	relative: {
		type: String,
		default: "html"
	},
	disabled: {
		type: Boolean,
		default: void 0
	}
}, j$2 = /* @__PURE__ */ defineComponent({
	name: `${p$1}-dropdown`,
	props: O$1,
	setup(e$1, a$2) {
		const d$2 = `${p$1}-dropdown-hidden`, t$1 = reactive({
			overlayClass: [d$2],
			overlayStyle: {},
			triggerHover: !1,
			overlayHover: !1
		}), o$2 = ref(), l$2 = ref(), u$4 = () => {
			if (e$1.disabled) return !1;
			t$1.triggerHover = !0;
			const n$3 = o$2.value, r$2 = l$2.value;
			if (!n$3 || !r$2) return;
			const g$4 = n$3.getBoundingClientRect(), y$2 = n$3.offsetTop, L$2 = n$3.offsetLeft, E = g$4.height, T$1 = g$4.width, p$3 = n$3.getRootNode(), m$2 = p$3.querySelector(e$1.relative)?.scrollLeft || 0, C$2 = p$3.querySelector(e$1.relative)?.clientWidth || 0;
			let s$2 = L$2 - r$2.offsetWidth / 2 + T$1 / 2 - m$2;
			s$2 + r$2.offsetWidth > m$2 + C$2 && (s$2 = m$2 + C$2 - r$2.offsetWidth), s$2 < 0 && (s$2 = 0), t$1.overlayStyle = {
				...t$1.overlayStyle,
				insetBlockStart: y$2 + E + "px",
				insetInlineStart: s$2 + "px"
			}, e$1.onChange(!0);
		}, b$2 = () => {
			if (e$1.disabled) return !1;
			t$1.overlayHover = !0;
		};
		watch(() => e$1.visible, (n$3) => {
			n$3 ? t$1.overlayClass = t$1.overlayClass.filter((r$2) => r$2 !== d$2) : t$1.overlayClass.push(d$2);
		});
		let S$2 = -1;
		const v$2 = (n$3) => {
			o$2.value === n$3.target ? t$1.triggerHover = !1 : t$1.overlayHover = !1, clearTimeout(S$2), S$2 = window.setTimeout(() => {
				!t$1.overlayHover && !t$1.triggerHover && e$1.onChange(!1);
			}, 10);
		};
		return onMounted(() => {
			o$2.value.addEventListener("mouseenter", u$4), o$2.value.addEventListener("mouseleave", v$2), l$2.value.addEventListener("mouseenter", b$2), l$2.value.addEventListener("mouseleave", v$2);
		}), onBeforeUnmount(() => {
			o$2.value.removeEventListener("mouseenter", u$4), o$2.value.removeEventListener("mouseleave", v$2), l$2.value.removeEventListener("mouseenter", b$2), l$2.value.removeEventListener("mouseleave", v$2);
		}), () => {
			const n$3 = g({ ctx: a$2 }), r$2 = g({
				props: e$1,
				ctx: a$2
			}, "overlay"), g$4 = cloneVNode(n$3 instanceof Array ? n$3[0] : n$3, {
				ref: o$2,
				key: "cloned-dropdown-trigger"
			}), y$2 = createVNode("div", {
				class: [`${p$1}-dropdown`, t$1.overlayClass],
				style: t$1.overlayStyle,
				ref: l$2
			}, [createVNode("div", { class: `${p$1}-dropdown-overlay` }, [r$2 instanceof Array ? r$2[0] : r$2])]);
			return [g$4, y$2];
		};
	}
}), R$2 = {
	title: {
		type: String,
		default: ""
	},
	visible: {
		type: Boolean,
		default: void 0
	},
	trigger: {
		type: [String, Object],
		default: void 0
	},
	onChange: {
		type: Function,
		default: void 0
	},
	overlay: {
		type: [String, Object],
		default: void 0
	},
	insert: {
		type: Function,
		default: void 0
	},
	language: {
		type: String,
		default: void 0
	},
	theme: {
		type: String,
		default: void 0
	},
	previewTheme: {
		type: String,
		default: void 0
	},
	codeTheme: {
		type: String,
		default: void 0
	},
	disabled: {
		type: Boolean,
		default: void 0
	},
	showToolbarName: {
		type: Boolean,
		default: void 0
	}
}, h = /* @__PURE__ */ defineComponent({
	name: "DropdownToolbar",
	props: R$2,
	emits: ["onChange"],
	setup(e$1, a$2) {
		const d$2 = inject("editorId"), t$1 = (o$2) => {
			e$1.onChange?.(o$2), a$2.emit("onChange", o$2);
		};
		return () => {
			const o$2 = g({
				props: e$1,
				ctx: a$2
			}, "trigger"), l$2 = g({
				props: e$1,
				ctx: a$2
			}, "overlay"), u$4 = g({
				props: e$1,
				ctx: a$2
			});
			return createVNode(j$2, {
				relative: `#${d$2}-toolbar-wrapper`,
				visible: e$1.visible,
				onChange: t$1,
				overlay: l$2,
				disabled: e$1.disabled
			}, { default: () => [createVNode("button", {
				class: [`${p$1}-toolbar-item`, e$1.disabled && `${p$1}-disabled`],
				title: e$1.title || "",
				disabled: e$1.disabled,
				type: "button"
			}, [u$4 || o$2])] });
		};
	}
});
h.install = (e$1) => (e$1.component(h.name, h), e$1);

//#endregion
//#region node_modules/md-editor-v3/lib/es/chunks/event-bus.mjs
var i = "onSave", C$1 = "changeCatalogVisible", h$2 = "changeFullscreen", _ = "pageFullscreenChanged", r = "fullscreenChanged", A$1 = "previewChanged", R = "previewOnlyChanged", p$2 = "htmlPreviewChanged", g$2 = "catalogVisibleChanged", L$1 = "buildFinished", N$1 = "errorCatcher", G = "replace", I = "uploadImage", T = "ctrlZ", d = "ctrlShiftZ", S$1 = "catalogChanged", H = "pushCatalog", D = "rerender", V = "eventListener", O = "taskStateChanged", u$1 = "sendEditorView", f = "getEditorView";
var c = class {
	pools = {};
	remove(s$2, o$2, a$2) {
		const t$1 = this.pools[s$2] && this.pools[s$2][o$2];
		t$1 && (this.pools[s$2][o$2] = t$1.filter((e$1) => e$1 !== a$2));
	}
	clear(s$2) {
		this.pools[s$2] = {};
	}
	on(s$2, o$2) {
		return this.pools[s$2] || (this.pools[s$2] = {}), this.pools[s$2][o$2.name] || (this.pools[s$2][o$2.name] = []), this.pools[s$2][o$2.name].push(o$2.callback), this.pools[s$2][o$2.name].includes(o$2.callback);
	}
	emit(s$2, o$2, ...a$2) {
		this.pools[s$2] || (this.pools[s$2] = {});
		const t$1 = this.pools[s$2][o$2];
		t$1 && t$1.forEach((e$1) => {
			try {
				e$1(...a$2);
			} catch (E) {
				console.error(`${o$2} monitor event exception！`, E);
			}
		});
	}
};
var F$1 = new c();

//#endregion
//#region node_modules/md-editor-v3/lib/es/chunks/index5.mjs
var u$2 = (t$1, e$1 = "image.png") => {
	const r$2 = t$1.split(","), n$3 = r$2[0].match(/:(.*?);/);
	if (n$3) {
		const c$2 = n$3[1], o$2 = atob(r$2[1]);
		let s$2 = o$2.length;
		const a$2 = new Uint8Array(s$2);
		for (; s$2--;) a$2[s$2] = o$2.charCodeAt(s$2);
		return new File([a$2], e$1, { type: c$2 });
	}
	return null;
}, l = (t$1, e$1) => {
	if (!t$1) return t$1;
	const r$2 = e$1.split(`
`), n$3 = ["<span rn-wrapper aria-hidden=\"true\">"];
	return r$2.forEach(() => {
		n$3.push("<span></span>");
	}), n$3.push("</span>"), `<span class="${p$1}-code-block">${t$1}</span>${n$3.join("")}`;
}, g$3 = (t$1, e$1) => {
	if (!t$1 || !e$1) return 0;
	const r$2 = t$1?.getBoundingClientRect();
	if (e$1 === document.documentElement) return r$2.top - e$1.clientTop;
	const n$3 = e$1?.getBoundingClientRect();
	return r$2.top - n$3.top;
}, m$1 = /* @__PURE__ */ (() => {
	let t$1 = 0;
	return () => ++t$1;
})();

//#endregion
//#region node_modules/md-editor-v3/lib/es/chunks/index4.mjs
var ce$1 = `.${p$1}-preview > [data-line]`, w$2 = (e$1, l$2) => +getComputedStyle(e$1).getPropertyValue(l$2).replace("px", ""), ve$2 = (e$1, l$2) => {
	const p$3 = x(() => {
		e$1.removeEventListener("scroll", n$3), e$1.addEventListener("scroll", n$3), l$2.removeEventListener("scroll", n$3), l$2.addEventListener("scroll", n$3);
	}, 50), n$3 = (E) => {
		const m$2 = e$1.clientHeight, y$2 = l$2.clientHeight, f$3 = e$1.scrollHeight, s$2 = l$2.scrollHeight, r$2 = (f$3 - m$2) / (s$2 - y$2);
		E.target === e$1 ? (l$2.removeEventListener("scroll", n$3), l$2.scrollTo({ top: e$1.scrollTop / r$2 }), p$3()) : (e$1.removeEventListener("scroll", n$3), e$1.scrollTo({ top: l$2.scrollTop * r$2 }), p$3());
	};
	return [() => {
		p$3().finally(() => {
			e$1.dispatchEvent(new Event("scroll"));
		});
	}, () => {
		e$1.removeEventListener("scroll", n$3), l$2.removeEventListener("scroll", n$3);
	}];
}, he$1 = (e$1, l$2, p$3) => {
	const { view: n$3 } = p$3, E = C(), m$2 = (c$2) => n$3.lineBlockAt(n$3.state.doc.line(c$2 + 1).from).top, y$2 = (c$2) => n$3.lineBlockAt(n$3.state.doc.line(c$2 + 1).from).bottom;
	let f$3 = [], s$2 = [], r$2 = [];
	const L$2 = () => {
		f$3 = [], s$2 = Array.from(l$2.querySelectorAll(ce$1)), r$2 = s$2.map((o$2) => Number(o$2.dataset.line));
		const c$2 = [...r$2], { lines: h$6 } = n$3.state.doc;
		let H$2 = c$2.shift() || 0, t$1 = c$2.shift() || h$6;
		for (let o$2 = 0; o$2 < h$6; o$2++) o$2 === t$1 && (H$2 = o$2, t$1 = c$2.shift() || h$6), f$3.push({
			start: H$2,
			end: t$1 - 1
		});
	}, R$4 = (c$2, h$6) => {
		let H$2 = 1;
		for (let t$1 = s$2.length - 1; t$1 - 1 >= 0; t$1--) {
			const o$2 = s$2[t$1], a$2 = s$2[t$1 - 1];
			if (o$2.offsetTop + o$2.offsetHeight > h$6 && a$2.offsetTop < h$6) {
				H$2 = Number(a$2.dataset.line);
				break;
			}
		}
		for (let t$1 = f$3.length - 1; t$1 >= 0; t$1--) {
			const o$2 = y$2(f$3[t$1].end), a$2 = m$2(f$3[t$1].start);
			if (o$2 > c$2 && a$2 <= c$2) {
				H$2 = H$2 < f$3[t$1].start ? H$2 : f$3[t$1].start;
				break;
			}
		}
		return H$2;
	};
	let x$1 = 0, B$1 = 0;
	const _$2 = () => {
		if (B$1 !== 0) return !1;
		x$1++;
		const { scrollDOM: c$2, contentHeight: h$6 } = n$3;
		let H$2 = w$2(l$2, "padding-block-start");
		const t$1 = n$3.lineBlockAtHeight(c$2.scrollTop), { number: o$2 } = n$3.state.doc.lineAt(t$1.from), a$2 = f$3[o$2 - 1];
		if (!a$2) return !1;
		let u$4 = 1;
		const k$2 = l$2.querySelector(`[data-line="${a$2.start}"]`) || l$2.firstElementChild?.firstElementChild, d$2 = l$2.querySelector(`[data-line="${a$2.end + 1}"]`) || l$2.lastElementChild?.lastElementChild, i$3 = c$2.scrollHeight - c$2.clientHeight, I$1 = l$2.scrollHeight - l$2.clientHeight;
		let g$4 = m$2(a$2.start), v$2 = y$2(a$2.end), C$2 = k$2.offsetTop, S$2 = d$2.offsetTop - C$2;
		g$4 === 0 && (C$2 = 0, k$2 === d$2 ? (H$2 = 0, v$2 = h$6 - c$2.offsetHeight, S$2 = I$1) : S$2 = d$2.offsetTop), u$4 = (c$2.scrollTop - g$4) / (v$2 - g$4);
		const A$2 = d$2 == l$2.lastElementChild?.lastElementChild ? d$2.offsetTop + d$2.clientHeight : d$2.offsetTop;
		if (v$2 >= i$3 || A$2 > I$1) {
			const b$2 = R$4(i$3, I$1);
			g$4 = m$2(b$2), u$4 = (c$2.scrollTop - g$4) / (i$3 - g$4);
			const P$2 = l$2.querySelector(`[data-line="${b$2}"]`);
			g$4 > 0 && P$2 && (C$2 = P$2.offsetTop), S$2 = I$1 - C$2 + w$2(l$2, "padding-block-start");
		}
		const T$1 = C$2 - H$2 + S$2 * u$4;
		E(l$2, T$1, () => {
			x$1--;
		});
	}, F$2 = () => {
		if (x$1 !== 0) return;
		B$1++;
		const { scrollDOM: c$2 } = n$3, h$6 = l$2.scrollTop, H$2 = l$2.scrollHeight, t$1 = c$2.scrollHeight - c$2.clientHeight, o$2 = l$2.scrollHeight - l$2.clientHeight;
		let a$2 = l$2.firstElementChild?.firstElementChild, u$4 = l$2.firstElementChild?.lastElementChild;
		if (r$2.length > 0) {
			let A$2 = Math.ceil(r$2[r$2.length - 1] * (h$6 / H$2)), T$1 = r$2.findLastIndex((b$2) => b$2 <= A$2);
			T$1 = T$1 === -1 ? 0 : T$1, A$2 = r$2[T$1];
			for (let b$2 = T$1; b$2 >= 0 && b$2 < r$2.length;) if (s$2[b$2].offsetTop > h$6) {
				if (b$2 - 1 >= 0) {
					b$2--;
					continue;
				}
				A$2 = -1, T$1 = b$2;
				break;
			} else {
				if (b$2 + 1 < r$2.length && s$2[b$2 + 1].offsetTop < h$6) {
					b$2++;
					continue;
				}
				A$2 = r$2[b$2], T$1 = b$2;
				break;
			}
			switch (T$1) {
				case -1:
					a$2 = l$2.firstElementChild?.firstElementChild, u$4 = s$2[T$1];
					break;
				case r$2.length - 1:
					a$2 = s$2[T$1], u$4 = l$2.firstElementChild?.lastElementChild;
					break;
				default: a$2 = s$2[T$1], u$4 = s$2[T$1 + 1 === s$2.length ? T$1 : T$1 + 1];
			}
		}
		let k$2 = a$2 === l$2.firstElementChild?.firstElementChild ? 0 : a$2.offsetTop - w$2(a$2, "margin-block-start"), d$2 = u$4.offsetTop, i$3 = 0;
		const { start: I$1, end: g$4 } = f$3[Number(a$2.dataset.line || 0)];
		let v$2 = m$2(I$1);
		const C$2 = m$2(g$4 + 1 === n$3.state.doc.lines ? g$4 : g$4 + 1);
		let S$2 = 0;
		if (C$2 > t$1 || u$4.offsetTop + u$4.offsetHeight > o$2) {
			const A$2 = R$4(t$1, o$2), T$1 = l$2.querySelector(`[data-line="${A$2}"]`);
			k$2 = T$1 ? T$1.offsetTop - w$2(T$1, "margin-block-start") : k$2, v$2 = m$2(A$2), i$3 = (h$6 - k$2) / (o$2 - k$2), S$2 = t$1 - v$2;
		} else a$2 === l$2.firstElementChild?.firstElementChild ? (a$2 === u$4 && (d$2 = u$4.offsetTop + u$4.offsetHeight + w$2(u$4, "margin-block-end")), S$2 = C$2, i$3 = Math.max(h$6 / d$2, 0)) : (i$3 = Math.max((h$6 - k$2) / (d$2 - k$2), 0), S$2 = C$2 - v$2);
		E(e$1, v$2 + S$2 * i$3, () => {
			B$1--;
		});
	}, M$3 = (c$2) => {
		const { scrollDOM: h$6, contentHeight: H$2 } = n$3, t$1 = h$6.clientHeight;
		if (H$2 <= t$1 || l$2.firstElementChild.clientHeight <= l$2.clientHeight || n$3.state.doc.lines <= f$3[f$3.length - 1]?.end) return !1;
		c$2.target === e$1 ? _$2() : F$2();
	};
	return [() => {
		L$2(), e$1.addEventListener("scroll", M$3), l$2.addEventListener("scroll", M$3), e$1.dispatchEvent(new Event("scroll"));
	}, () => {
		e$1.removeEventListener("scroll", M$3), l$2.removeEventListener("scroll", M$3);
	}];
}, se$3 = {
	tocItem: {
		type: Object,
		default: () => ({})
	},
	mdHeadingId: {
		type: Function,
		default: () => {}
	},
	onActive: {
		type: Function,
		default: () => {}
	},
	onClick: {
		type: Function,
		default: () => {}
	},
	scrollElementOffsetTop: {
		type: Number,
		default: 0
	}
}, Q$2 = /* @__PURE__ */ defineComponent({
	props: se$3,
	setup(e$1) {
		const l$2 = inject("scrollElementRef"), p$3 = inject("roorNodeRef"), n$3 = ref();
		watch(() => e$1.tocItem.active, (m$2) => {
			m$2 && e$1.onActive(e$1.tocItem, n$3.value);
		}), onMounted(() => {
			e$1.tocItem.active && e$1.onActive(e$1.tocItem, n$3.value);
		});
		const E = (m$2) => {
			if (m$2.stopPropagation(), e$1.onClick(m$2, e$1.tocItem), m$2.defaultPrevented) return;
			const y$2 = e$1.mdHeadingId({
				text: e$1.tocItem.text,
				level: e$1.tocItem.level,
				index: e$1.tocItem.index,
				currentToken: e$1.tocItem.currentToken,
				nextToken: e$1.tocItem.nextToken
			}), f$3 = p$3.value.getElementById(y$2), s$2 = l$2.value;
			if (f$3 && s$2) {
				let r$2 = f$3.offsetParent, L$2 = f$3.offsetTop;
				if (s$2.contains(r$2)) for (; r$2 && s$2 != r$2;) L$2 += r$2?.offsetTop, r$2 = r$2?.offsetParent;
				const R$4 = f$3.previousElementSibling;
				let x$1 = 0;
				R$4 || (x$1 = w$2(f$3, "margin-block-start")), s$2?.scrollTo({
					top: L$2 - e$1.scrollElementOffsetTop - x$1,
					behavior: "smooth"
				});
			}
		};
		return () => createVNode("div", {
			ref: n$3,
			class: [`${p$1}-catalog-link`, e$1.tocItem.active && `${p$1}-catalog-active`],
			onClick: E
		}, [createVNode("span", { title: e$1.tocItem.text }, [e$1.tocItem.text]), e$1.tocItem.children && e$1.tocItem.children.length > 0 && createVNode("div", { class: `${p$1}-catalog-wrapper` }, [e$1.tocItem.children.map((m$2) => createVNode(Q$2, {
			mdHeadingId: e$1.mdHeadingId,
			key: `${e$1.tocItem.text}-link-${m$2.level}-${m$2.text}`,
			tocItem: m$2,
			onActive: e$1.onActive,
			onClick: e$1.onClick,
			scrollElementOffsetTop: e$1.scrollElementOffsetTop
		}, null))])]);
	}
}), re$1 = {
	editorId: {
		type: String,
		default: void 0
	},
	class: {
		type: String,
		default: ""
	},
	mdHeadingId: {
		type: Function,
		default: ({ text: e$1 }) => e$1
	},
	scrollElement: {
		type: [String, Object],
		default: void 0
	},
	theme: {
		type: String,
		default: "light"
	},
	offsetTop: {
		type: Number,
		default: 20
	},
	scrollElementOffsetTop: {
		type: Number,
		default: 0
	},
	onClick: {
		type: Function,
		default: void 0
	},
	onActive: {
		type: Function,
		default: void 0
	},
	isScrollElementInShadow: {
		type: Boolean,
		default: !1
	},
	syncWith: {
		type: String,
		default: "preview"
	},
	catalogMaxDepth: {
		type: Number,
		default: void 0
	}
}, W = /* @__PURE__ */ defineComponent({
	name: "MdCatalog",
	props: re$1,
	emits: ["onClick", "onActive"],
	setup(e$1, l$2) {
		const p$3 = e$1.editorId, n$3 = `#${p$3}-preview-wrapper`, E = reactive({
			list: [],
			show: !1,
			scrollElement: e$1.scrollElement || n$3
		}), m$2 = shallowRef(), y$2 = ref(), f$3 = ref(), s$2 = ref(), r$2 = ref(), L$2 = shallowRef(), R$4 = ref({});
		provide("scrollElementRef", f$3), provide("roorNodeRef", r$2);
		const x$1 = computed(() => {
			const t$1 = [];
			return E.list.forEach((o$2, a$2) => {
				if (e$1.catalogMaxDepth && o$2.level > e$1.catalogMaxDepth) return;
				const { text: u$4, level: k$2, line: d$2 } = o$2, i$3 = {
					level: k$2,
					text: u$4,
					line: d$2,
					index: a$2 + 1,
					active: m$2.value === o$2
				};
				if (t$1.length === 0) t$1.push(i$3);
				else {
					let I$1 = t$1[t$1.length - 1];
					if (i$3.level > I$1.level) for (let g$4 = I$1.level + 1; g$4 <= 6; g$4++) {
						const { children: v$2 } = I$1;
						if (!v$2) {
							I$1.children = [i$3];
							break;
						}
						if (I$1 = v$2[v$2.length - 1], i$3.level <= I$1.level) {
							v$2.push(i$3);
							break;
						}
					}
					else t$1.push(i$3);
				}
			}), t$1;
		}), B$1 = () => {
			if (E.scrollElement instanceof HTMLElement) return E.scrollElement;
			let t$1 = document;
			return (E.scrollElement === n$3 || e$1.isScrollElementInShadow) && (t$1 = y$2.value?.getRootNode()), t$1.querySelector(E.scrollElement);
		}, _$2 = (t$1) => {
			if (t$1.length === 0) return m$2.value = void 0, E.list = [], !1;
			const { activeHead: o$2, activeIndex: a$2 } = t$1.reduce((d$2, i$3, I$1) => {
				let g$4 = 0;
				if (e$1.syncWith === "preview") {
					const v$2 = r$2.value?.getElementById(e$1.mdHeadingId({
						text: i$3.text,
						level: i$3.level,
						index: I$1 + 1,
						currentToken: i$3.currentToken,
						nextToken: i$3.nextToken
					}));
					v$2 instanceof HTMLElement && (g$4 = g$3(v$2, f$3.value));
				} else {
					const v$2 = L$2.value;
					if (v$2) {
						const C$2 = v$2.lineBlockAt(v$2.state.doc.line(i$3.line + 1).from).top, S$2 = v$2.scrollDOM.scrollTop;
						g$4 = C$2 - S$2;
					}
				}
				return g$4 < e$1.offsetTop && g$4 > d$2.minTop ? {
					activeHead: i$3,
					activeIndex: I$1,
					minTop: g$4
				} : d$2;
			}, {
				activeHead: t$1[0],
				activeIndex: 0,
				minTop: Number.MIN_SAFE_INTEGER
			});
			let u$4 = o$2;
			const { catalogMaxDepth: k$2 } = e$1;
			if (k$2 && u$4.level > k$2) {
				for (let d$2 = a$2; d$2 >= 0; d$2--) {
					const i$3 = t$1[d$2];
					if (i$3.level <= k$2) {
						u$4 = i$3;
						break;
					}
				}
				if (u$4.level > k$2) {
					const d$2 = t$1.find((i$3) => i$3.level <= k$2);
					d$2 && (u$4 = d$2);
				}
			}
			m$2.value = u$4, E.list = t$1;
		}, F$2 = (t$1, o$2) => {
			R$4.value.top = o$2.offsetTop + w$2(o$2, "padding-block-start") + "px", e$1.onActive?.(t$1, o$2), l$2.emit("onActive", t$1, o$2);
		}, M$3 = () => {
			_$2(E.list);
		}, c$2 = (t$1) => {
			if (s$2.value?.removeEventListener("scroll", M$3), e$1.syncWith === "editor") s$2.value = L$2.value?.scrollDOM;
			else {
				const o$2 = B$1();
				f$3.value = o$2, s$2.value = o$2 === document.documentElement ? document : o$2;
			}
			_$2(t$1), s$2.value?.addEventListener("scroll", M$3);
		}, h$6 = (t$1) => {
			L$2.value = t$1;
		};
		watch([
			() => e$1.syncWith,
			L$2,
			() => e$1.catalogMaxDepth
		], () => {
			c$2(E.list);
		}), onMounted(() => {
			r$2.value = y$2.value.getRootNode(), F$1.on(p$3, {
				name: S$1,
				callback: c$2
			}), F$1.on(p$3, {
				name: f,
				callback: h$6
			}), F$1.emit(p$3, H), F$1.emit(p$3, u$1);
		}), onBeforeUnmount(() => {
			F$1.remove(p$3, S$1, c$2), F$1.remove(p$3, f, h$6), s$2.value?.removeEventListener("scroll", M$3);
		});
		const H$2 = (t$1, o$2) => {
			e$1.onClick?.(t$1, o$2), l$2.emit("onClick", t$1, o$2);
		};
		return () => createVNode("div", {
			class: [
				`${p$1}-catalog`,
				e$1.theme === "dark" && `${p$1}-catalog-dark`,
				e$1.class || ""
			],
			ref: y$2
		}, [x$1.value.length > 0 && createVNode(Fragment, null, [createVNode("div", {
			class: `${p$1}-catalog-indicator`,
			style: R$4.value
		}, null), createVNode("div", { class: `${p$1}-catalog-container` }, [x$1.value.map((t$1) => createVNode(Q$2, {
			mdHeadingId: e$1.mdHeadingId,
			tocItem: t$1,
			key: `link-${t$1.level}-${t$1.text}`,
			onActive: F$2,
			onClick: H$2,
			scrollElementOffsetTop: e$1.scrollElementOffsetTop
		}, null))])])]);
	}
});
W.install = (e$1) => (e$1.component(W.name, W), e$1);

//#endregion
//#region node_modules/@vavt/copy2clipboard/index.mjs
async function copy2Clipboard(text) {
	if (typeof text !== "string") return;
	if (window.isSecureContext && navigator.clipboard) return await navigator.clipboard.writeText(text);
	else {
		const textarea = document.createElement("textarea");
		let successed = false;
		textarea.value = text;
		textarea.style.position = "fixed";
		textarea.style.opacity = 0;
		textarea.style.zIndex = "-10000";
		textarea.style.top = "-10000";
		document.body.appendChild(textarea);
		textarea.select();
		successed = document.execCommand("copy");
		document.body.removeChild(textarea);
		if (successed) return;
		throw new Error("Failed to copy content via \"execCommand\"!");
	}
}
var copy2clipboard_default = copy2Clipboard;

//#endregion
//#region node_modules/md-editor-v3/lib/es/chunks/dom.mjs
var j$3 = {
	copy: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-copy ${p$1}-icon"><rect width="14" height="14" x="8" y="8" rx="2" ry="2"/><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/></svg>`,
	"collapse-tips": `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-circle-chevron-left ${p$1}-icon"><circle cx="12" cy="12" r="10"/><path d="m14 16-4-4 4-4"/></svg>`,
	pin: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-pin ${p$1}-icon"><path d="M12 17v5"/><path d="M9 10.76a2 2 0 0 1-1.11 1.79l-1.78.9A2 2 0 0 0 5 15.24V16a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-.76a2 2 0 0 0-1.11-1.79l-1.78-.9A2 2 0 0 1 15 10.76V7a1 1 0 0 1 1-1 2 2 0 0 0 0-4H8a2 2 0 0 0 0 4 1 1 0 0 1 1 1z"/></svg>`,
	"pin-off": `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-pin-off ${p$1}-icon"><path d="M12 17v5"/><path d="M15 9.34V7a1 1 0 0 1 1-1 2 2 0 0 0 0-4H7.89"/><path d="m2 2 20 20"/><path d="M9 9v1.76a2 2 0 0 1-1.11 1.79l-1.78.9A2 2 0 0 0 5 15.24V16a1 1 0 0 0 1 1h11"/></svg>`,
	check: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-check ${p$1}-icon"><path d="M20 6 9 17l-5-5"/></svg>`
}, p = (d$2, s$2) => typeof s$2[d$2] == "string" ? s$2[d$2] : j$3[d$2], z$1 = (d$2, s$2) => {
	const e$1 = (c$2) => {
		const t$1 = d$2.parentElement || document.body, n$3 = t$1.offsetWidth, r$2 = t$1.offsetHeight, { clientWidth: l$2, clientHeight: u$4 } = document.documentElement, a$2 = c$2.offsetX, w$3 = c$2.offsetY, g$4 = (y$2) => {
			let h$6 = y$2.x + document.body.scrollLeft - document.body.clientLeft - a$2, m$2 = y$2.y + document.body.scrollTop - document.body.clientTop - w$3;
			h$6 = h$6 < 1 ? 1 : h$6 < l$2 - n$3 - 1 ? h$6 : l$2 - n$3 - 1, m$2 = m$2 < 1 ? 1 : m$2 < u$4 - r$2 - 1 ? m$2 : u$4 - r$2 - 1, s$2 ? s$2(h$6, m$2) : (t$1.style.left = `${h$6}px`, t$1.style.top = `${m$2}px`);
		};
		document.addEventListener("mousemove", g$4);
		const v$2 = () => {
			document.removeEventListener("mousemove", g$4), document.removeEventListener("mouseup", v$2);
		};
		document.addEventListener("mouseup", v$2);
	};
	return d$2.addEventListener("mousedown", e$1), () => {
		d$2.removeEventListener("mousedown", e$1);
	};
}, A = (d$2, s$2, e$1 = "") => {
	const c$2 = document.getElementById(s$2.id);
	if (c$2) e$1 !== "" && (Reflect.get(window, e$1) ? s$2.onload?.call(c$2, new Event("load")) : s$2.onload && c$2.addEventListener("load", s$2.onload));
	else {
		const t$1 = { ...s$2 };
		t$1.onload = null;
		const n$3 = D$1(d$2, t$1);
		s$2.onload && n$3.addEventListener("load", s$2.onload), document.head.appendChild(n$3);
	}
}, b$1 = (d$2, s$2) => {
	document.getElementById(s$2.id)?.remove(), A(d$2, s$2);
}, D$1 = (d$2, s$2) => {
	const e$1 = document.createElement(d$2);
	return Object.keys(s$2).forEach((c$2) => {
		s$2[c$2] !== void 0 && (e$1[c$2] = s$2[c$2]);
	}), e$1;
}, V$1 = (d$2, s$2) => {
	const e$1 = /* @__PURE__ */ new Map();
	return d$2?.forEach((c$2) => {
		let t$1 = c$2.querySelector(`.${p$1}-mermaid-action`);
		t$1 ? t$1.querySelector(`.${p$1}-mermaid-copy`) || t$1.insertAdjacentHTML("beforeend", `<span class="${p$1}-mermaid-copy">${p("copy", s$2.customIcon)}</span>`) : (c$2.insertAdjacentHTML("beforeend", `<div class="${p$1}-mermaid-action"><span class="${p$1}-mermaid-copy">${p("copy", s$2.customIcon)}</span></div>`), t$1 = c$2.querySelector(`.${p$1}-mermaid-action`));
		const n$3 = t$1.querySelector(`.${p$1}-mermaid-copy`);
		let r$2 = -1;
		const l$2 = () => {
			clearTimeout(r$2), copy2clipboard_default(c$2.dataset.content || "").then(() => {
				n$3.innerHTML = p("check", s$2.customIcon);
			}).catch(() => {
				n$3.innerHTML = p("copy", s$2.customIcon);
			}).finally(() => {
				r$2 = window.setTimeout(() => {
					n$3.innerHTML = p("copy", s$2.customIcon);
				}, 1500);
			});
		};
		n$3.addEventListener("click", l$2), e$1.set(c$2, { removeClick: () => {
			n$3.removeEventListener("click", l$2);
		} });
	}), () => {
		e$1.forEach(({ removeClick: c$2 }) => {
			c$2?.();
		}), e$1.clear();
	};
}, R$1 = /* @__PURE__ */ (() => {
	const d$2 = (e$1) => {
		if (!e$1) return () => {};
		const c$2 = e$1.firstChild;
		let t$1 = 1, n$3 = 0, r$2 = 0, l$2 = !1, u$4, a$2, w$3, g$4 = 1;
		const v$2 = () => {
			c$2.style.transform = `translate(${n$3}px, ${r$2}px) scale(${t$1})`;
		}, y$2 = (o$2) => {
			o$2.touches.length === 1 ? (l$2 = !0, u$4 = o$2.touches[0].clientX - n$3, a$2 = o$2.touches[0].clientY - r$2) : o$2.touches.length === 2 && (w$3 = Math.hypot(o$2.touches[0].clientX - o$2.touches[1].clientX, o$2.touches[0].clientY - o$2.touches[1].clientY), g$4 = t$1);
		}, h$6 = (o$2) => {
			if (o$2.preventDefault(), l$2 && o$2.touches.length === 1) n$3 = o$2.touches[0].clientX - u$4, r$2 = o$2.touches[0].clientY - a$2, v$2();
			else if (o$2.touches.length === 2) {
				const E = Math.hypot(o$2.touches[0].clientX - o$2.touches[1].clientX, o$2.touches[0].clientY - o$2.touches[1].clientY) / w$3, f$3 = t$1;
				t$1 = g$4 * (1 + (E - 1));
				const M$3 = (o$2.touches[0].clientX + o$2.touches[1].clientX) / 2, k$2 = (o$2.touches[0].clientY + o$2.touches[1].clientY) / 2, H$2 = c$2.getBoundingClientRect(), X$1 = (M$3 - H$2.left) / f$3, S$2 = (k$2 - H$2.top) / f$3;
				n$3 -= X$1 * (t$1 - f$3), r$2 -= S$2 * (t$1 - f$3), v$2();
			}
		}, m$2 = () => {
			l$2 = !1;
		}, $$1 = (o$2) => {
			o$2.preventDefault();
			const L$2 = .02, E = t$1;
			o$2.deltaY < 0 ? t$1 += L$2 : t$1 = Math.max(.1, t$1 - L$2);
			const f$3 = c$2.getBoundingClientRect(), M$3 = o$2.clientX - f$3.left, k$2 = o$2.clientY - f$3.top;
			n$3 -= M$3 / E * (t$1 - E), r$2 -= k$2 / E * (t$1 - E), v$2();
		}, x$1 = (o$2) => {
			l$2 = !0, u$4 = o$2.clientX - n$3, a$2 = o$2.clientY - r$2;
		}, C$2 = (o$2) => {
			l$2 && (n$3 = o$2.clientX - u$4, r$2 = o$2.clientY - a$2, v$2());
		}, T$1 = () => {
			l$2 = !1;
		}, Y$2 = () => {
			l$2 = !1;
		};
		return e$1.addEventListener("touchstart", y$2, { passive: !1 }), e$1.addEventListener("touchmove", h$6, { passive: !1 }), e$1.addEventListener("touchend", m$2), e$1.addEventListener("wheel", $$1, { passive: !1 }), e$1.addEventListener("mousedown", x$1), e$1.addEventListener("mousemove", C$2), e$1.addEventListener("mouseup", T$1), e$1.addEventListener("mouseleave", Y$2), () => {
			e$1.removeEventListener("touchstart", y$2), e$1.removeEventListener("touchmove", h$6), e$1.removeEventListener("touchend", m$2), e$1.removeEventListener("wheel", $$1), e$1.removeEventListener("mousedown", x$1), e$1.removeEventListener("mousemove", C$2), e$1.removeEventListener("mouseup", T$1), e$1.removeEventListener("mouseleave", Y$2);
		};
	};
	return (e$1, c$2) => {
		const t$1 = /* @__PURE__ */ new Map();
		return e$1?.forEach((n$3) => {
			let r$2 = n$3.querySelector(`.${p$1}-mermaid-action`);
			r$2 ? r$2.querySelector(`.${p$1}-mermaid-zoom`) || r$2.insertAdjacentHTML("beforeend", `<span class="${p$1}-mermaid-zoom">${p("pin-off", c$2.customIcon)}</span>`) : (n$3.insertAdjacentHTML("beforeend", `<div class="${p$1}-mermaid-action"><span class="${p$1}-mermaid-zoom">${p("pin-off", c$2.customIcon)}</span></div>`), r$2 = n$3.querySelector(`.${p$1}-mermaid-action`));
			const l$2 = r$2.querySelector(`.${p$1}-mermaid-zoom`), u$4 = () => {
				const a$2 = t$1.get(n$3);
				if (a$2?.removeEvent) a$2.removeEvent(), n$3.removeAttribute("data-grab"), t$1.set(n$3, { removeClick: a$2.removeClick }), l$2.innerHTML = p("pin-off", c$2.customIcon);
				else {
					const w$3 = d$2(n$3);
					n$3.setAttribute("data-grab", ""), t$1.set(n$3, {
						removeEvent: w$3,
						removeClick: a$2?.removeClick
					}), l$2.innerHTML = p("pin", c$2.customIcon);
				}
			};
			l$2.addEventListener("click", u$4), t$1.set(n$3, { removeClick: () => l$2.removeEventListener("click", u$4) });
		}), () => {
			t$1.forEach(({ removeEvent: n$3, removeClick: r$2 }) => {
				n$3?.(), r$2?.();
			}), t$1.clear();
		};
	};
})();

//#endregion
//#region node_modules/markdown-it-image-figures/dist/markdown-it-images-figures.mjs
var t = new Set([
	!0,
	!1,
	"alt",
	"title"
]);
function e(t$1, e$1) {
	return (Array.isArray(t$1) ? t$1 : []).filter(([t$2]) => t$2 !== e$1);
}
function n$1(t$1, n$3) {
	t$1 && t$1.attrs && (t$1.attrs = e(t$1.attrs, n$3));
}
function i$1(e$1, i$3) {
	if (!t.has(e$1)) throw new TypeError(`figcaption must be one of: ${[...t]}.`);
	if ("alt" === e$1) return i$3.content;
	const r$2 = i$3.attrs.find(([t$1]) => "title" === t$1);
	return Array.isArray(r$2) && r$2[1] ? (n$1(i$3, "title"), r$2[1]) : void 0;
}
function r$1(t$1, r$2) {
	r$2 = r$2 || {}, t$1.core.ruler.before("linkify", "image_figures", function(s$2) {
		let a$2 = 1;
		for (let o$2 = 1, c$2 = s$2.tokens.length; o$2 < c$2 - 1; ++o$2) {
			const l$2 = s$2.tokens[o$2];
			if ("inline" !== l$2.type) continue;
			if (!l$2.children || 1 !== l$2.children.length && 3 !== l$2.children.length) continue;
			if (1 === l$2.children.length && "image" !== l$2.children[0].type) continue;
			if (3 === l$2.children.length) {
				const [t$2, e$1, n$3] = l$2.children;
				if ("link_open" !== t$2.type || "image" !== e$1.type || "link_close" !== n$3.type) continue;
			}
			if (0 !== o$2 && "paragraph_open" !== s$2.tokens[o$2 - 1].type) continue;
			if (o$2 !== c$2 - 1 && "paragraph_close" !== s$2.tokens[o$2 + 1].type) continue;
			const f$3 = s$2.tokens[o$2 - 1];
			let h$6;
			if (f$3.type = "figure_open", f$3.tag = "figure", s$2.tokens[o$2 + 1].type = "figure_close", s$2.tokens[o$2 + 1].tag = "figure", r$2.dataType && s$2.tokens[o$2 - 1].attrPush(["data-type", "image"]), r$2.link && 1 === l$2.children.length) {
				[h$6] = l$2.children;
				const t$2 = new s$2.Token("link_open", "a", 1);
				t$2.attrPush(["href", h$6.attrGet("src")]), l$2.children.unshift(t$2), l$2.children.push(new s$2.Token("link_close", "a", -1));
			}
			if (h$6 = 1 === l$2.children.length ? l$2.children[0] : l$2.children[1], r$2.figcaption) {
				const n$3 = i$1(r$2.figcaption, h$6);
				if (n$3) {
					const [i$3] = t$1.parseInline(n$3, s$2.env);
					l$2.children.push(new s$2.Token("figcaption_open", "figcaption", 1)), l$2.children.push(...i$3.children), l$2.children.push(new s$2.Token("figcaption_close", "figcaption", -1)), h$6.attrs && (h$6.attrs = e(h$6.attrs, "title"));
				}
			}
			if (r$2.copyAttrs && h$6.attrs) {
				const t$2 = !0 === r$2.copyAttrs ? "" : r$2.copyAttrs;
				f$3.attrs = h$6.attrs.filter(([e$1]) => e$1.match(t$2)).map((t$3) => Array.from(t$3));
			}
			if (r$2.tabindex && (s$2.tokens[o$2 - 1].attrPush(["tabindex", a$2]), a$2++), r$2.lazy && (h$6.attrs.some(([t$2]) => "loading" === t$2) || h$6.attrs.push(["loading", "lazy"])), r$2.async && (h$6.attrs.some(([t$2]) => "decoding" === t$2) || h$6.attrs.push(["decoding", "async"])), r$2.classes && "string" == typeof r$2.classes) {
				let t$2 = !1;
				for (let e$1 = 0, n$3 = h$6.attrs.length; e$1 < n$3 && !t$2; e$1++) {
					const n$4 = h$6.attrs[e$1];
					"class" === n$4[0] && (n$4[1] = `${n$4[1]} ${r$2.classes}`, t$2 = !0);
				}
				t$2 || h$6.attrs.push(["class", r$2.classes]);
			}
			if (r$2.removeSrc) {
				const t$2 = h$6.attrs.find(([t$3]) => "src" === t$3);
				h$6.attrs.push(["data-src", t$2[1]]), n$1(h$6, "src");
			}
		}
	});
}

//#endregion
//#region node_modules/markdown-it-sub/index.mjs
var UNESCAPE_RE$1 = /\\([ \\!"#$%&'()*+,./:;<=>?@[\]^_`{|}~-])/g;
function subscript(state, silent) {
	const max = state.posMax;
	const start = state.pos;
	if (state.src.charCodeAt(start) !== 126) return false;
	if (silent) return false;
	if (start + 2 >= max) return false;
	state.pos = start + 1;
	let found = false;
	while (state.pos < max) {
		if (state.src.charCodeAt(state.pos) === 126) {
			found = true;
			break;
		}
		state.md.inline.skipToken(state);
	}
	if (!found || start + 1 === state.pos) {
		state.pos = start;
		return false;
	}
	const content = state.src.slice(start + 1, state.pos);
	if (content.match(/(^|[^\\])(\\\\)*\s/)) {
		state.pos = start;
		return false;
	}
	state.posMax = state.pos;
	state.pos = start + 1;
	const token_so = state.push("sub_open", "sub", 1);
	token_so.markup = "~";
	const token_t = state.push("text", "", 0);
	token_t.content = content.replace(UNESCAPE_RE$1, "$1");
	const token_sc = state.push("sub_close", "sub", -1);
	token_sc.markup = "~";
	state.pos = state.posMax + 1;
	state.posMax = max;
	return true;
}
function sub_plugin(md) {
	md.inline.ruler.after("emphasis", "sub", subscript);
}

//#endregion
//#region node_modules/markdown-it-sup/index.mjs
var UNESCAPE_RE = /\\([ \\!"#$%&'()*+,./:;<=>?@[\]^_`{|}~-])/g;
function superscript(state, silent) {
	const max = state.posMax;
	const start = state.pos;
	if (state.src.charCodeAt(start) !== 94) return false;
	if (silent) return false;
	if (start + 2 >= max) return false;
	state.pos = start + 1;
	let found = false;
	while (state.pos < max) {
		if (state.src.charCodeAt(state.pos) === 94) {
			found = true;
			break;
		}
		state.md.inline.skipToken(state);
	}
	if (!found || start + 1 === state.pos) {
		state.pos = start;
		return false;
	}
	const content = state.src.slice(start + 1, state.pos);
	if (content.match(/(^|[^\\])(\\\\)*\s/)) {
		state.pos = start;
		return false;
	}
	state.posMax = state.pos;
	state.pos = start + 1;
	const token_so = state.push("sup_open", "sup", 1);
	token_so.markup = "^";
	const token_t = state.push("text", "", 0);
	token_t.content = content.replace(UNESCAPE_RE, "$1");
	const token_sc = state.push("sup_close", "sup", -1);
	token_sc.markup = "^";
	state.pos = state.posMax + 1;
	state.posMax = max;
	return true;
}
function sup_plugin(md) {
	md.inline.ruler.after("emphasis", "sup", superscript);
}

//#endregion
//#region node_modules/md-editor-v3/node_modules/lru-cache/dist/esm/index.js
/**
* @module LRUCache
*/
var defaultPerf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
var warned = /* @__PURE__ */ new Set();
/* c8 ignore start */
var PROCESS = typeof process === "object" && !!process ? process : {};
/* c8 ignore start */
var emitWarning = (msg, type, code, fn) => {
	typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
};
var AC = globalThis.AbortController;
var AS = globalThis.AbortSignal;
/* c8 ignore start */
if (typeof AC === "undefined") {
	AS = class AbortSignal {
		onabort;
		_onabort = [];
		reason;
		aborted = false;
		addEventListener(_$2, fn) {
			this._onabort.push(fn);
		}
	};
	AC = class AbortController {
		constructor() {
			warnACPolyfill();
		}
		signal = new AS();
		abort(reason) {
			if (this.signal.aborted) return;
			this.signal.reason = reason;
			this.signal.aborted = true;
			for (const fn of this.signal._onabort) fn(reason);
			this.signal.onabort?.(reason);
		}
	};
	let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
	const warnACPolyfill = () => {
		if (!printACPolyfillWarning) return;
		printACPolyfillWarning = false;
		emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
	};
}
/* c8 ignore stop */
var shouldWarn = (code) => !warned.has(code);
var isPosInt = (n$3) => n$3 && n$3 === Math.floor(n$3) && n$3 > 0 && isFinite(n$3);
/* c8 ignore start */
var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
/* c8 ignore stop */
var ZeroArray = class extends Array {
	constructor(size) {
		super(size);
		this.fill(0);
	}
};
var Stack = class Stack {
	heap;
	length;
	static #constructing = false;
	static create(max) {
		const HeapCls = getUintArray(max);
		if (!HeapCls) return [];
		Stack.#constructing = true;
		const s$2 = new Stack(max, HeapCls);
		Stack.#constructing = false;
		return s$2;
	}
	constructor(max, HeapCls) {
		/* c8 ignore start */
		if (!Stack.#constructing) throw new TypeError("instantiate Stack using Stack.create(n)");
		/* c8 ignore stop */
		this.heap = new HeapCls(max);
		this.length = 0;
	}
	push(n$3) {
		this.heap[this.length++] = n$3;
	}
	pop() {
		return this.heap[--this.length];
	}
};
/**
* Default export, the thing you're using this module to get.
*
* The `K` and `V` types define the key and value types, respectively. The
* optional `FC` type defines the type of the `context` object passed to
* `cache.fetch()` and `cache.memo()`.
*
* Keys and values **must not** be `null` or `undefined`.
*
* All properties from the options object (with the exception of `max`,
* `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are
* added as normal public members. (The listed options are read-only getters.)
*
* Changing any of these will alter the defaults for subsequent method calls.
*/
var LRUCache = class LRUCache {
	#max;
	#maxSize;
	#dispose;
	#onInsert;
	#disposeAfter;
	#fetchMethod;
	#memoMethod;
	#perf;
	/**
	* {@link LRUCache.OptionsBase.perf}
	*/
	get perf() {
		return this.#perf;
	}
	/**
	* {@link LRUCache.OptionsBase.ttl}
	*/
	ttl;
	/**
	* {@link LRUCache.OptionsBase.ttlResolution}
	*/
	ttlResolution;
	/**
	* {@link LRUCache.OptionsBase.ttlAutopurge}
	*/
	ttlAutopurge;
	/**
	* {@link LRUCache.OptionsBase.updateAgeOnGet}
	*/
	updateAgeOnGet;
	/**
	* {@link LRUCache.OptionsBase.updateAgeOnHas}
	*/
	updateAgeOnHas;
	/**
	* {@link LRUCache.OptionsBase.allowStale}
	*/
	allowStale;
	/**
	* {@link LRUCache.OptionsBase.noDisposeOnSet}
	*/
	noDisposeOnSet;
	/**
	* {@link LRUCache.OptionsBase.noUpdateTTL}
	*/
	noUpdateTTL;
	/**
	* {@link LRUCache.OptionsBase.maxEntrySize}
	*/
	maxEntrySize;
	/**
	* {@link LRUCache.OptionsBase.sizeCalculation}
	*/
	sizeCalculation;
	/**
	* {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
	*/
	noDeleteOnFetchRejection;
	/**
	* {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
	*/
	noDeleteOnStaleGet;
	/**
	* {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
	*/
	allowStaleOnFetchAbort;
	/**
	* {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
	*/
	allowStaleOnFetchRejection;
	/**
	* {@link LRUCache.OptionsBase.ignoreFetchAbort}
	*/
	ignoreFetchAbort;
	#size;
	#calculatedSize;
	#keyMap;
	#keyList;
	#valList;
	#next;
	#prev;
	#head;
	#tail;
	#free;
	#disposed;
	#sizes;
	#starts;
	#ttls;
	#autopurgeTimers;
	#hasDispose;
	#hasFetchMethod;
	#hasDisposeAfter;
	#hasOnInsert;
	/**
	* Do not call this method unless you need to inspect the
	* inner workings of the cache.  If anything returned by this
	* object is modified in any way, strange breakage may occur.
	*
	* These fields are private for a reason!
	*
	* @internal
	*/
	static unsafeExposeInternals(c$2) {
		return {
			starts: c$2.#starts,
			ttls: c$2.#ttls,
			autopurgeTimers: c$2.#autopurgeTimers,
			sizes: c$2.#sizes,
			keyMap: c$2.#keyMap,
			keyList: c$2.#keyList,
			valList: c$2.#valList,
			next: c$2.#next,
			prev: c$2.#prev,
			get head() {
				return c$2.#head;
			},
			get tail() {
				return c$2.#tail;
			},
			free: c$2.#free,
			isBackgroundFetch: (p$3) => c$2.#isBackgroundFetch(p$3),
			backgroundFetch: (k$2, index, options, context) => c$2.#backgroundFetch(k$2, index, options, context),
			moveToTail: (index) => c$2.#moveToTail(index),
			indexes: (options) => c$2.#indexes(options),
			rindexes: (options) => c$2.#rindexes(options),
			isStale: (index) => c$2.#isStale(index)
		};
	}
	/**
	* {@link LRUCache.OptionsBase.max} (read-only)
	*/
	get max() {
		return this.#max;
	}
	/**
	* {@link LRUCache.OptionsBase.maxSize} (read-only)
	*/
	get maxSize() {
		return this.#maxSize;
	}
	/**
	* The total computed size of items in the cache (read-only)
	*/
	get calculatedSize() {
		return this.#calculatedSize;
	}
	/**
	* The number of items stored in the cache (read-only)
	*/
	get size() {
		return this.#size;
	}
	/**
	* {@link LRUCache.OptionsBase.fetchMethod} (read-only)
	*/
	get fetchMethod() {
		return this.#fetchMethod;
	}
	get memoMethod() {
		return this.#memoMethod;
	}
	/**
	* {@link LRUCache.OptionsBase.dispose} (read-only)
	*/
	get dispose() {
		return this.#dispose;
	}
	/**
	* {@link LRUCache.OptionsBase.onInsert} (read-only)
	*/
	get onInsert() {
		return this.#onInsert;
	}
	/**
	* {@link LRUCache.OptionsBase.disposeAfter} (read-only)
	*/
	get disposeAfter() {
		return this.#disposeAfter;
	}
	constructor(options) {
		const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, onInsert, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, perf } = options;
		if (perf !== void 0) {
			if (typeof perf?.now !== "function") throw new TypeError("perf option must have a now() method if specified");
		}
		this.#perf = perf ?? defaultPerf;
		if (max !== 0 && !isPosInt(max)) throw new TypeError("max option must be a nonnegative integer");
		const UintArray = max ? getUintArray(max) : Array;
		if (!UintArray) throw new Error("invalid max value: " + max);
		this.#max = max;
		this.#maxSize = maxSize;
		this.maxEntrySize = maxEntrySize || this.#maxSize;
		this.sizeCalculation = sizeCalculation;
		if (this.sizeCalculation) {
			if (!this.#maxSize && !this.maxEntrySize) throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
			if (typeof this.sizeCalculation !== "function") throw new TypeError("sizeCalculation set to non-function");
		}
		if (memoMethod !== void 0 && typeof memoMethod !== "function") throw new TypeError("memoMethod must be a function if defined");
		this.#memoMethod = memoMethod;
		if (fetchMethod !== void 0 && typeof fetchMethod !== "function") throw new TypeError("fetchMethod must be a function if specified");
		this.#fetchMethod = fetchMethod;
		this.#hasFetchMethod = !!fetchMethod;
		this.#keyMap = /* @__PURE__ */ new Map();
		this.#keyList = new Array(max).fill(void 0);
		this.#valList = new Array(max).fill(void 0);
		this.#next = new UintArray(max);
		this.#prev = new UintArray(max);
		this.#head = 0;
		this.#tail = 0;
		this.#free = Stack.create(max);
		this.#size = 0;
		this.#calculatedSize = 0;
		if (typeof dispose === "function") this.#dispose = dispose;
		if (typeof onInsert === "function") this.#onInsert = onInsert;
		if (typeof disposeAfter === "function") {
			this.#disposeAfter = disposeAfter;
			this.#disposed = [];
		} else {
			this.#disposeAfter = void 0;
			this.#disposed = void 0;
		}
		this.#hasDispose = !!this.#dispose;
		this.#hasOnInsert = !!this.#onInsert;
		this.#hasDisposeAfter = !!this.#disposeAfter;
		this.noDisposeOnSet = !!noDisposeOnSet;
		this.noUpdateTTL = !!noUpdateTTL;
		this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
		this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
		this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
		this.ignoreFetchAbort = !!ignoreFetchAbort;
		if (this.maxEntrySize !== 0) {
			if (this.#maxSize !== 0) {
				if (!isPosInt(this.#maxSize)) throw new TypeError("maxSize must be a positive integer if specified");
			}
			if (!isPosInt(this.maxEntrySize)) throw new TypeError("maxEntrySize must be a positive integer if specified");
			this.#initializeSizeTracking();
		}
		this.allowStale = !!allowStale;
		this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
		this.updateAgeOnGet = !!updateAgeOnGet;
		this.updateAgeOnHas = !!updateAgeOnHas;
		this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
		this.ttlAutopurge = !!ttlAutopurge;
		this.ttl = ttl || 0;
		if (this.ttl) {
			if (!isPosInt(this.ttl)) throw new TypeError("ttl must be a positive integer if specified");
			this.#initializeTTLTracking();
		}
		if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) throw new TypeError("At least one of max, maxSize, or ttl is required");
		if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
			const code = "LRU_CACHE_UNBOUNDED";
			if (shouldWarn(code)) {
				warned.add(code);
				emitWarning("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.", "UnboundedCacheWarning", code, LRUCache);
			}
		}
	}
	/**
	* Return the number of ms left in the item's TTL. If item is not in cache,
	* returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
	*/
	getRemainingTTL(key) {
		return this.#keyMap.has(key) ? Infinity : 0;
	}
	#initializeTTLTracking() {
		const ttls = new ZeroArray(this.#max);
		const starts = new ZeroArray(this.#max);
		this.#ttls = ttls;
		this.#starts = starts;
		const purgeTimers = this.ttlAutopurge ? new Array(this.#max) : void 0;
		this.#autopurgeTimers = purgeTimers;
		this.#setItemTTL = (index, ttl, start = this.#perf.now()) => {
			starts[index] = ttl !== 0 ? start : 0;
			ttls[index] = ttl;
			if (purgeTimers?.[index]) {
				clearTimeout(purgeTimers[index]);
				purgeTimers[index] = void 0;
			}
			if (ttl !== 0 && purgeTimers) {
				const t$1 = setTimeout(() => {
					if (this.#isStale(index)) this.#delete(this.#keyList[index], "expire");
				}, ttl + 1);
				/* c8 ignore start */
				if (t$1.unref) t$1.unref();
				/* c8 ignore stop */
				purgeTimers[index] = t$1;
			}
		};
		this.#updateItemAge = (index) => {
			starts[index] = ttls[index] !== 0 ? this.#perf.now() : 0;
		};
		this.#statusTTL = (status, index) => {
			if (ttls[index]) {
				const ttl = ttls[index];
				const start = starts[index];
				/* c8 ignore next */
				if (!ttl || !start) return;
				status.ttl = ttl;
				status.start = start;
				status.now = cachedNow || getNow();
				const age = status.now - start;
				status.remainingTTL = ttl - age;
			}
		};
		let cachedNow = 0;
		const getNow = () => {
			const n$3 = this.#perf.now();
			if (this.ttlResolution > 0) {
				cachedNow = n$3;
				const t$1 = setTimeout(() => cachedNow = 0, this.ttlResolution);
				/* c8 ignore start */
				if (t$1.unref) t$1.unref();
			}
			return n$3;
		};
		this.getRemainingTTL = (key) => {
			const index = this.#keyMap.get(key);
			if (index === void 0) return 0;
			const ttl = ttls[index];
			const start = starts[index];
			if (!ttl || !start) return Infinity;
			const age = (cachedNow || getNow()) - start;
			return ttl - age;
		};
		this.#isStale = (index) => {
			const s$2 = starts[index];
			const t$1 = ttls[index];
			return !!t$1 && !!s$2 && (cachedNow || getNow()) - s$2 > t$1;
		};
	}
	#updateItemAge = () => {};
	#statusTTL = () => {};
	#setItemTTL = () => {};
	/* c8 ignore stop */
	#isStale = () => false;
	#initializeSizeTracking() {
		const sizes = new ZeroArray(this.#max);
		this.#calculatedSize = 0;
		this.#sizes = sizes;
		this.#removeItemSize = (index) => {
			this.#calculatedSize -= sizes[index];
			sizes[index] = 0;
		};
		this.#requireSize = (k$2, v$2, size, sizeCalculation) => {
			if (this.#isBackgroundFetch(v$2)) return 0;
			if (!isPosInt(size)) if (sizeCalculation) {
				if (typeof sizeCalculation !== "function") throw new TypeError("sizeCalculation must be a function");
				size = sizeCalculation(v$2, k$2);
				if (!isPosInt(size)) throw new TypeError("sizeCalculation return invalid (expect positive integer)");
			} else throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
			return size;
		};
		this.#addItemSize = (index, size, status) => {
			sizes[index] = size;
			if (this.#maxSize) {
				const maxSize = this.#maxSize - sizes[index];
				while (this.#calculatedSize > maxSize) this.#evict(true);
			}
			this.#calculatedSize += sizes[index];
			if (status) {
				status.entrySize = size;
				status.totalCalculatedSize = this.#calculatedSize;
			}
		};
	}
	#removeItemSize = (_i) => {};
	#addItemSize = (_i, _s, _st) => {};
	#requireSize = (_k, _v, size, sizeCalculation) => {
		if (size || sizeCalculation) throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
		return 0;
	};
	*#indexes({ allowStale = this.allowStale } = {}) {
		if (this.#size) for (let i$3 = this.#tail;;) {
			if (!this.#isValidIndex(i$3)) break;
			if (allowStale || !this.#isStale(i$3)) yield i$3;
			if (i$3 === this.#head) break;
			else i$3 = this.#prev[i$3];
		}
	}
	*#rindexes({ allowStale = this.allowStale } = {}) {
		if (this.#size) for (let i$3 = this.#head;;) {
			if (!this.#isValidIndex(i$3)) break;
			if (allowStale || !this.#isStale(i$3)) yield i$3;
			if (i$3 === this.#tail) break;
			else i$3 = this.#next[i$3];
		}
	}
	#isValidIndex(index) {
		return index !== void 0 && this.#keyMap.get(this.#keyList[index]) === index;
	}
	/**
	* Return a generator yielding `[key, value]` pairs,
	* in order from most recently used to least recently used.
	*/
	*entries() {
		for (const i$3 of this.#indexes()) if (this.#valList[i$3] !== void 0 && this.#keyList[i$3] !== void 0 && !this.#isBackgroundFetch(this.#valList[i$3])) yield [this.#keyList[i$3], this.#valList[i$3]];
	}
	/**
	* Inverse order version of {@link LRUCache.entries}
	*
	* Return a generator yielding `[key, value]` pairs,
	* in order from least recently used to most recently used.
	*/
	*rentries() {
		for (const i$3 of this.#rindexes()) if (this.#valList[i$3] !== void 0 && this.#keyList[i$3] !== void 0 && !this.#isBackgroundFetch(this.#valList[i$3])) yield [this.#keyList[i$3], this.#valList[i$3]];
	}
	/**
	* Return a generator yielding the keys in the cache,
	* in order from most recently used to least recently used.
	*/
	*keys() {
		for (const i$3 of this.#indexes()) {
			const k$2 = this.#keyList[i$3];
			if (k$2 !== void 0 && !this.#isBackgroundFetch(this.#valList[i$3])) yield k$2;
		}
	}
	/**
	* Inverse order version of {@link LRUCache.keys}
	*
	* Return a generator yielding the keys in the cache,
	* in order from least recently used to most recently used.
	*/
	*rkeys() {
		for (const i$3 of this.#rindexes()) {
			const k$2 = this.#keyList[i$3];
			if (k$2 !== void 0 && !this.#isBackgroundFetch(this.#valList[i$3])) yield k$2;
		}
	}
	/**
	* Return a generator yielding the values in the cache,
	* in order from most recently used to least recently used.
	*/
	*values() {
		for (const i$3 of this.#indexes()) if (this.#valList[i$3] !== void 0 && !this.#isBackgroundFetch(this.#valList[i$3])) yield this.#valList[i$3];
	}
	/**
	* Inverse order version of {@link LRUCache.values}
	*
	* Return a generator yielding the values in the cache,
	* in order from least recently used to most recently used.
	*/
	*rvalues() {
		for (const i$3 of this.#rindexes()) if (this.#valList[i$3] !== void 0 && !this.#isBackgroundFetch(this.#valList[i$3])) yield this.#valList[i$3];
	}
	/**
	* Iterating over the cache itself yields the same results as
	* {@link LRUCache.entries}
	*/
	[Symbol.iterator]() {
		return this.entries();
	}
	/**
	* A String value that is used in the creation of the default string
	* description of an object. Called by the built-in method
	* `Object.prototype.toString`.
	*/
	[Symbol.toStringTag] = "LRUCache";
	/**
	* Find a value for which the supplied fn method returns a truthy value,
	* similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
	*/
	find(fn, getOptions = {}) {
		for (const i$3 of this.#indexes()) {
			const v$2 = this.#valList[i$3];
			const value = this.#isBackgroundFetch(v$2) ? v$2.__staleWhileFetching : v$2;
			if (value === void 0) continue;
			if (fn(value, this.#keyList[i$3], this)) return this.get(this.#keyList[i$3], getOptions);
		}
	}
	/**
	* Call the supplied function on each item in the cache, in order from most
	* recently used to least recently used.
	*
	* `fn` is called as `fn(value, key, cache)`.
	*
	* If `thisp` is provided, function will be called in the `this`-context of
	* the provided object, or the cache if no `thisp` object is provided.
	*
	* Does not update age or recenty of use, or iterate over stale values.
	*/
	forEach(fn, thisp = this) {
		for (const i$3 of this.#indexes()) {
			const v$2 = this.#valList[i$3];
			const value = this.#isBackgroundFetch(v$2) ? v$2.__staleWhileFetching : v$2;
			if (value === void 0) continue;
			fn.call(thisp, value, this.#keyList[i$3], this);
		}
	}
	/**
	* The same as {@link LRUCache.forEach} but items are iterated over in
	* reverse order.  (ie, less recently used items are iterated over first.)
	*/
	rforEach(fn, thisp = this) {
		for (const i$3 of this.#rindexes()) {
			const v$2 = this.#valList[i$3];
			const value = this.#isBackgroundFetch(v$2) ? v$2.__staleWhileFetching : v$2;
			if (value === void 0) continue;
			fn.call(thisp, value, this.#keyList[i$3], this);
		}
	}
	/**
	* Delete any stale entries. Returns true if anything was removed,
	* false otherwise.
	*/
	purgeStale() {
		let deleted = false;
		for (const i$3 of this.#rindexes({ allowStale: true })) if (this.#isStale(i$3)) {
			this.#delete(this.#keyList[i$3], "expire");
			deleted = true;
		}
		return deleted;
	}
	/**
	* Get the extended info about a given entry, to get its value, size, and
	* TTL info simultaneously. Returns `undefined` if the key is not present.
	*
	* Unlike {@link LRUCache#dump}, which is designed to be portable and survive
	* serialization, the `start` value is always the current timestamp, and the
	* `ttl` is a calculated remaining time to live (negative if expired).
	*
	* Always returns stale values, if their info is found in the cache, so be
	* sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
	* if relevant.
	*/
	info(key) {
		const i$3 = this.#keyMap.get(key);
		if (i$3 === void 0) return void 0;
		const v$2 = this.#valList[i$3];
		/* c8 ignore start - this isn't tested for the info function,
		* but it's the same logic as found in other places. */
		const value = this.#isBackgroundFetch(v$2) ? v$2.__staleWhileFetching : v$2;
		if (value === void 0) return void 0;
		/* c8 ignore end */
		const entry = { value };
		if (this.#ttls && this.#starts) {
			const ttl = this.#ttls[i$3];
			const start = this.#starts[i$3];
			if (ttl && start) {
				entry.ttl = ttl - (this.#perf.now() - start);
				entry.start = Date.now();
			}
		}
		if (this.#sizes) entry.size = this.#sizes[i$3];
		return entry;
	}
	/**
	* Return an array of [key, {@link LRUCache.Entry}] tuples which can be
	* passed to {@link LRUCache#load}.
	*
	* The `start` fields are calculated relative to a portable `Date.now()`
	* timestamp, even if `performance.now()` is available.
	*
	* Stale entries are always included in the `dump`, even if
	* {@link LRUCache.OptionsBase.allowStale} is false.
	*
	* Note: this returns an actual array, not a generator, so it can be more
	* easily passed around.
	*/
	dump() {
		const arr = [];
		for (const i$3 of this.#indexes({ allowStale: true })) {
			const key = this.#keyList[i$3];
			const v$2 = this.#valList[i$3];
			const value = this.#isBackgroundFetch(v$2) ? v$2.__staleWhileFetching : v$2;
			if (value === void 0 || key === void 0) continue;
			const entry = { value };
			if (this.#ttls && this.#starts) {
				entry.ttl = this.#ttls[i$3];
				const age = this.#perf.now() - this.#starts[i$3];
				entry.start = Math.floor(Date.now() - age);
			}
			if (this.#sizes) entry.size = this.#sizes[i$3];
			arr.unshift([key, entry]);
		}
		return arr;
	}
	/**
	* Reset the cache and load in the items in entries in the order listed.
	*
	* The shape of the resulting cache may be different if the same options are
	* not used in both caches.
	*
	* The `start` fields are assumed to be calculated relative to a portable
	* `Date.now()` timestamp, even if `performance.now()` is available.
	*/
	load(arr) {
		this.clear();
		for (const [key, entry] of arr) {
			if (entry.start) {
				const age = Date.now() - entry.start;
				entry.start = this.#perf.now() - age;
			}
			this.set(key, entry.value, entry);
		}
	}
	/**
	* Add a value to the cache.
	*
	* Note: if `undefined` is specified as a value, this is an alias for
	* {@link LRUCache#delete}
	*
	* Fields on the {@link LRUCache.SetOptions} options param will override
	* their corresponding values in the constructor options for the scope
	* of this single `set()` operation.
	*
	* If `start` is provided, then that will set the effective start
	* time for the TTL calculation. Note that this must be a previous
	* value of `performance.now()` if supported, or a previous value of
	* `Date.now()` if not.
	*
	* Options object may also include `size`, which will prevent
	* calling the `sizeCalculation` function and just use the specified
	* number if it is a positive integer, and `noDisposeOnSet` which
	* will prevent calling a `dispose` function in the case of
	* overwrites.
	*
	* If the `size` (or return value of `sizeCalculation`) for a given
	* entry is greater than `maxEntrySize`, then the item will not be
	* added to the cache.
	*
	* Will update the recency of the entry.
	*
	* If the value is `undefined`, then this is an alias for
	* `cache.delete(key)`. `undefined` is never stored in the cache.
	*/
	set(k$2, v$2, setOptions = {}) {
		if (v$2 === void 0) {
			this.delete(k$2);
			return this;
		}
		const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
		let { noUpdateTTL = this.noUpdateTTL } = setOptions;
		const size = this.#requireSize(k$2, v$2, setOptions.size || 0, sizeCalculation);
		if (this.maxEntrySize && size > this.maxEntrySize) {
			if (status) {
				status.set = "miss";
				status.maxEntrySizeExceeded = true;
			}
			this.#delete(k$2, "set");
			return this;
		}
		let index = this.#size === 0 ? void 0 : this.#keyMap.get(k$2);
		if (index === void 0) {
			index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
			this.#keyList[index] = k$2;
			this.#valList[index] = v$2;
			this.#keyMap.set(k$2, index);
			this.#next[this.#tail] = index;
			this.#prev[index] = this.#tail;
			this.#tail = index;
			this.#size++;
			this.#addItemSize(index, size, status);
			if (status) status.set = "add";
			noUpdateTTL = false;
			if (this.#hasOnInsert) this.#onInsert?.(v$2, k$2, "add");
		} else {
			this.#moveToTail(index);
			const oldVal = this.#valList[index];
			if (v$2 !== oldVal) {
				if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
					oldVal.__abortController.abort(/* @__PURE__ */ new Error("replaced"));
					const { __staleWhileFetching: s$2 } = oldVal;
					if (s$2 !== void 0 && !noDisposeOnSet) {
						if (this.#hasDispose) this.#dispose?.(s$2, k$2, "set");
						if (this.#hasDisposeAfter) this.#disposed?.push([
							s$2,
							k$2,
							"set"
						]);
					}
				} else if (!noDisposeOnSet) {
					if (this.#hasDispose) this.#dispose?.(oldVal, k$2, "set");
					if (this.#hasDisposeAfter) this.#disposed?.push([
						oldVal,
						k$2,
						"set"
					]);
				}
				this.#removeItemSize(index);
				this.#addItemSize(index, size, status);
				this.#valList[index] = v$2;
				if (status) {
					status.set = "replace";
					const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
					if (oldValue !== void 0) status.oldValue = oldValue;
				}
			} else if (status) status.set = "update";
			if (this.#hasOnInsert) this.onInsert?.(v$2, k$2, v$2 === oldVal ? "update" : "replace");
		}
		if (ttl !== 0 && !this.#ttls) this.#initializeTTLTracking();
		if (this.#ttls) {
			if (!noUpdateTTL) this.#setItemTTL(index, ttl, start);
			if (status) this.#statusTTL(status, index);
		}
		if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
			const dt$1 = this.#disposed;
			let task;
			while (task = dt$1?.shift()) this.#disposeAfter?.(...task);
		}
		return this;
	}
	/**
	* Evict the least recently used item, returning its value or
	* `undefined` if cache is empty.
	*/
	pop() {
		try {
			while (this.#size) {
				const val = this.#valList[this.#head];
				this.#evict(true);
				if (this.#isBackgroundFetch(val)) {
					if (val.__staleWhileFetching) return val.__staleWhileFetching;
				} else if (val !== void 0) return val;
			}
		} finally {
			if (this.#hasDisposeAfter && this.#disposed) {
				const dt$1 = this.#disposed;
				let task;
				while (task = dt$1?.shift()) this.#disposeAfter?.(...task);
			}
		}
	}
	#evict(free) {
		const head = this.#head;
		const k$2 = this.#keyList[head];
		const v$2 = this.#valList[head];
		if (this.#hasFetchMethod && this.#isBackgroundFetch(v$2)) v$2.__abortController.abort(/* @__PURE__ */ new Error("evicted"));
		else if (this.#hasDispose || this.#hasDisposeAfter) {
			if (this.#hasDispose) this.#dispose?.(v$2, k$2, "evict");
			if (this.#hasDisposeAfter) this.#disposed?.push([
				v$2,
				k$2,
				"evict"
			]);
		}
		this.#removeItemSize(head);
		if (this.#autopurgeTimers?.[head]) {
			clearTimeout(this.#autopurgeTimers[head]);
			this.#autopurgeTimers[head] = void 0;
		}
		if (free) {
			this.#keyList[head] = void 0;
			this.#valList[head] = void 0;
			this.#free.push(head);
		}
		if (this.#size === 1) {
			this.#head = this.#tail = 0;
			this.#free.length = 0;
		} else this.#head = this.#next[head];
		this.#keyMap.delete(k$2);
		this.#size--;
		return head;
	}
	/**
	* Check if a key is in the cache, without updating the recency of use.
	* Will return false if the item is stale, even though it is technically
	* in the cache.
	*
	* Check if a key is in the cache, without updating the recency of
	* use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
	* to `true` in either the options or the constructor.
	*
	* Will return `false` if the item is stale, even though it is technically in
	* the cache. The difference can be determined (if it matters) by using a
	* `status` argument, and inspecting the `has` field.
	*
	* Will not update item age unless
	* {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
	*/
	has(k$2, hasOptions = {}) {
		const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
		const index = this.#keyMap.get(k$2);
		if (index !== void 0) {
			const v$2 = this.#valList[index];
			if (this.#isBackgroundFetch(v$2) && v$2.__staleWhileFetching === void 0) return false;
			if (!this.#isStale(index)) {
				if (updateAgeOnHas) this.#updateItemAge(index);
				if (status) {
					status.has = "hit";
					this.#statusTTL(status, index);
				}
				return true;
			} else if (status) {
				status.has = "stale";
				this.#statusTTL(status, index);
			}
		} else if (status) status.has = "miss";
		return false;
	}
	/**
	* Like {@link LRUCache#get} but doesn't update recency or delete stale
	* items.
	*
	* Returns `undefined` if the item is stale, unless
	* {@link LRUCache.OptionsBase.allowStale} is set.
	*/
	peek(k$2, peekOptions = {}) {
		const { allowStale = this.allowStale } = peekOptions;
		const index = this.#keyMap.get(k$2);
		if (index === void 0 || !allowStale && this.#isStale(index)) return;
		const v$2 = this.#valList[index];
		return this.#isBackgroundFetch(v$2) ? v$2.__staleWhileFetching : v$2;
	}
	#backgroundFetch(k$2, index, options, context) {
		const v$2 = index === void 0 ? void 0 : this.#valList[index];
		if (this.#isBackgroundFetch(v$2)) return v$2;
		const ac = new AC();
		const { signal } = options;
		signal?.addEventListener("abort", () => ac.abort(signal.reason), { signal: ac.signal });
		const fetchOpts = {
			signal: ac.signal,
			options,
			context
		};
		const cb = (v$3, updateCache = false) => {
			const { aborted } = ac.signal;
			const ignoreAbort = options.ignoreFetchAbort && v$3 !== void 0;
			if (options.status) if (aborted && !updateCache) {
				options.status.fetchAborted = true;
				options.status.fetchError = ac.signal.reason;
				if (ignoreAbort) options.status.fetchAbortIgnored = true;
			} else options.status.fetchResolved = true;
			if (aborted && !ignoreAbort && !updateCache) return fetchFail(ac.signal.reason);
			const bf$1 = p$3;
			const vl$1 = this.#valList[index];
			if (vl$1 === p$3 || ignoreAbort && updateCache && vl$1 === void 0) if (v$3 === void 0) if (bf$1.__staleWhileFetching !== void 0) this.#valList[index] = bf$1.__staleWhileFetching;
			else this.#delete(k$2, "fetch");
			else {
				if (options.status) options.status.fetchUpdated = true;
				this.set(k$2, v$3, fetchOpts.options);
			}
			return v$3;
		};
		const eb = (er) => {
			if (options.status) {
				options.status.fetchRejected = true;
				options.status.fetchError = er;
			}
			return fetchFail(er);
		};
		const fetchFail = (er) => {
			const { aborted } = ac.signal;
			const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
			const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
			const noDelete = allowStale || options.noDeleteOnFetchRejection;
			const bf$1 = p$3;
			if (this.#valList[index] === p$3) {
				if (!noDelete || bf$1.__staleWhileFetching === void 0) this.#delete(k$2, "fetch");
				else if (!allowStaleAborted) this.#valList[index] = bf$1.__staleWhileFetching;
			}
			if (allowStale) {
				if (options.status && bf$1.__staleWhileFetching !== void 0) options.status.returnedStale = true;
				return bf$1.__staleWhileFetching;
			} else if (bf$1.__returned === bf$1) throw er;
		};
		const pcall = (res, rej) => {
			const fmp = this.#fetchMethod?.(k$2, v$2, fetchOpts);
			if (fmp && fmp instanceof Promise) fmp.then((v$3) => res(v$3 === void 0 ? void 0 : v$3), rej);
			ac.signal.addEventListener("abort", () => {
				if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
					res(void 0);
					if (options.allowStaleOnFetchAbort) res = (v$3) => cb(v$3, true);
				}
			});
		};
		if (options.status) options.status.fetchDispatched = true;
		const p$3 = new Promise(pcall).then(cb, eb);
		const bf = Object.assign(p$3, {
			__abortController: ac,
			__staleWhileFetching: v$2,
			__returned: void 0
		});
		if (index === void 0) {
			this.set(k$2, bf, {
				...fetchOpts.options,
				status: void 0
			});
			index = this.#keyMap.get(k$2);
		} else this.#valList[index] = bf;
		return bf;
	}
	#isBackgroundFetch(p$3) {
		if (!this.#hasFetchMethod) return false;
		const b$2 = p$3;
		return !!b$2 && b$2 instanceof Promise && b$2.hasOwnProperty("__staleWhileFetching") && b$2.__abortController instanceof AC;
	}
	async fetch(k$2, fetchOptions = {}) {
		const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal } = fetchOptions;
		if (!this.#hasFetchMethod) {
			if (status) status.fetch = "get";
			return this.get(k$2, {
				allowStale,
				updateAgeOnGet,
				noDeleteOnStaleGet,
				status
			});
		}
		const options = {
			allowStale,
			updateAgeOnGet,
			noDeleteOnStaleGet,
			ttl,
			noDisposeOnSet,
			size,
			sizeCalculation,
			noUpdateTTL,
			noDeleteOnFetchRejection,
			allowStaleOnFetchRejection,
			allowStaleOnFetchAbort,
			ignoreFetchAbort,
			status,
			signal
		};
		let index = this.#keyMap.get(k$2);
		if (index === void 0) {
			if (status) status.fetch = "miss";
			const p$3 = this.#backgroundFetch(k$2, index, options, context);
			return p$3.__returned = p$3;
		} else {
			const v$2 = this.#valList[index];
			if (this.#isBackgroundFetch(v$2)) {
				const stale = allowStale && v$2.__staleWhileFetching !== void 0;
				if (status) {
					status.fetch = "inflight";
					if (stale) status.returnedStale = true;
				}
				return stale ? v$2.__staleWhileFetching : v$2.__returned = v$2;
			}
			const isStale = this.#isStale(index);
			if (!forceRefresh && !isStale) {
				if (status) status.fetch = "hit";
				this.#moveToTail(index);
				if (updateAgeOnGet) this.#updateItemAge(index);
				if (status) this.#statusTTL(status, index);
				return v$2;
			}
			const p$3 = this.#backgroundFetch(k$2, index, options, context);
			const staleVal = p$3.__staleWhileFetching !== void 0 && allowStale;
			if (status) {
				status.fetch = isStale ? "stale" : "refresh";
				if (staleVal && isStale) status.returnedStale = true;
			}
			return staleVal ? p$3.__staleWhileFetching : p$3.__returned = p$3;
		}
	}
	async forceFetch(k$2, fetchOptions = {}) {
		const v$2 = await this.fetch(k$2, fetchOptions);
		if (v$2 === void 0) throw new Error("fetch() returned undefined");
		return v$2;
	}
	memo(k$2, memoOptions = {}) {
		const memoMethod = this.#memoMethod;
		if (!memoMethod) throw new Error("no memoMethod provided to constructor");
		const { context, forceRefresh,...options } = memoOptions;
		const v$2 = this.get(k$2, options);
		if (!forceRefresh && v$2 !== void 0) return v$2;
		const vv = memoMethod(k$2, v$2, {
			options,
			context
		});
		this.set(k$2, vv, options);
		return vv;
	}
	/**
	* Return a value from the cache. Will update the recency of the cache
	* entry found.
	*
	* If the key is not found, get() will return `undefined`.
	*/
	get(k$2, getOptions = {}) {
		const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
		const index = this.#keyMap.get(k$2);
		if (index !== void 0) {
			const value = this.#valList[index];
			const fetching = this.#isBackgroundFetch(value);
			if (status) this.#statusTTL(status, index);
			if (this.#isStale(index)) {
				if (status) status.get = "stale";
				if (!fetching) {
					if (!noDeleteOnStaleGet) this.#delete(k$2, "expire");
					if (status && allowStale) status.returnedStale = true;
					return allowStale ? value : void 0;
				} else {
					if (status && allowStale && value.__staleWhileFetching !== void 0) status.returnedStale = true;
					return allowStale ? value.__staleWhileFetching : void 0;
				}
			} else {
				if (status) status.get = "hit";
				if (fetching) return value.__staleWhileFetching;
				this.#moveToTail(index);
				if (updateAgeOnGet) this.#updateItemAge(index);
				return value;
			}
		} else if (status) status.get = "miss";
	}
	#connect(p$3, n$3) {
		this.#prev[n$3] = p$3;
		this.#next[p$3] = n$3;
	}
	#moveToTail(index) {
		if (index !== this.#tail) {
			if (index === this.#head) this.#head = this.#next[index];
			else this.#connect(this.#prev[index], this.#next[index]);
			this.#connect(this.#tail, index);
			this.#tail = index;
		}
	}
	/**
	* Deletes a key out of the cache.
	*
	* Returns true if the key was deleted, false otherwise.
	*/
	delete(k$2) {
		return this.#delete(k$2, "delete");
	}
	#delete(k$2, reason) {
		let deleted = false;
		if (this.#size !== 0) {
			const index = this.#keyMap.get(k$2);
			if (index !== void 0) {
				if (this.#autopurgeTimers?.[index]) {
					clearTimeout(this.#autopurgeTimers?.[index]);
					this.#autopurgeTimers[index] = void 0;
				}
				deleted = true;
				if (this.#size === 1) this.#clear(reason);
				else {
					this.#removeItemSize(index);
					const v$2 = this.#valList[index];
					if (this.#isBackgroundFetch(v$2)) v$2.__abortController.abort(/* @__PURE__ */ new Error("deleted"));
					else if (this.#hasDispose || this.#hasDisposeAfter) {
						if (this.#hasDispose) this.#dispose?.(v$2, k$2, reason);
						if (this.#hasDisposeAfter) this.#disposed?.push([
							v$2,
							k$2,
							reason
						]);
					}
					this.#keyMap.delete(k$2);
					this.#keyList[index] = void 0;
					this.#valList[index] = void 0;
					if (index === this.#tail) this.#tail = this.#prev[index];
					else if (index === this.#head) this.#head = this.#next[index];
					else {
						const pi = this.#prev[index];
						this.#next[pi] = this.#next[index];
						const ni = this.#next[index];
						this.#prev[ni] = this.#prev[index];
					}
					this.#size--;
					this.#free.push(index);
				}
			}
		}
		if (this.#hasDisposeAfter && this.#disposed?.length) {
			const dt$1 = this.#disposed;
			let task;
			while (task = dt$1?.shift()) this.#disposeAfter?.(...task);
		}
		return deleted;
	}
	/**
	* Clear the cache entirely, throwing away all values.
	*/
	clear() {
		return this.#clear("delete");
	}
	#clear(reason) {
		for (const index of this.#rindexes({ allowStale: true })) {
			const v$2 = this.#valList[index];
			if (this.#isBackgroundFetch(v$2)) v$2.__abortController.abort(/* @__PURE__ */ new Error("deleted"));
			else {
				const k$2 = this.#keyList[index];
				if (this.#hasDispose) this.#dispose?.(v$2, k$2, reason);
				if (this.#hasDisposeAfter) this.#disposed?.push([
					v$2,
					k$2,
					reason
				]);
			}
		}
		this.#keyMap.clear();
		this.#valList.fill(void 0);
		this.#keyList.fill(void 0);
		if (this.#ttls && this.#starts) {
			this.#ttls.fill(0);
			this.#starts.fill(0);
			for (const t$1 of this.#autopurgeTimers ?? []) if (t$1 !== void 0) clearTimeout(t$1);
			this.#autopurgeTimers?.fill(void 0);
		}
		if (this.#sizes) this.#sizes.fill(0);
		this.#head = 0;
		this.#tail = 0;
		this.#free.length = 0;
		this.#calculatedSize = 0;
		this.#size = 0;
		if (this.#hasDisposeAfter && this.#disposed) {
			const dt$1 = this.#disposed;
			let task;
			while (task = dt$1?.shift()) this.#disposeAfter?.(...task);
		}
	}
};

//#endregion
//#region node_modules/medium-zoom/dist/medium-zoom.esm.js
/*! medium-zoom 1.1.0 | MIT License | https://github.com/francoischalifour/medium-zoom */
var _extends = Object.assign || function(target) {
	for (var i$3 = 1; i$3 < arguments.length; i$3++) {
		var source = arguments[i$3];
		for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
	}
	return target;
};
var isSupported = function isSupported$1(node) {
	return node.tagName === "IMG";
};
var isNodeList = function isNodeList$1(selector) {
	return NodeList.prototype.isPrototypeOf(selector);
};
var isNode = function isNode$1(selector) {
	return selector && selector.nodeType === 1;
};
var isSvg = function isSvg$1(image) {
	return (image.currentSrc || image.src).substr(-4).toLowerCase() === ".svg";
};
var getImagesFromSelector = function getImagesFromSelector$1(selector) {
	try {
		if (Array.isArray(selector)) return selector.filter(isSupported);
		if (isNodeList(selector)) return [].slice.call(selector).filter(isSupported);
		if (isNode(selector)) return [selector].filter(isSupported);
		if (typeof selector === "string") return [].slice.call(document.querySelectorAll(selector)).filter(isSupported);
		return [];
	} catch (err) {
		throw new TypeError("The provided selector is invalid.\nExpects a CSS selector, a Node element, a NodeList or an array.\nSee: https://github.com/francoischalifour/medium-zoom");
	}
};
var createOverlay = function createOverlay$1(background) {
	var overlay = document.createElement("div");
	overlay.classList.add("medium-zoom-overlay");
	overlay.style.background = background;
	return overlay;
};
var cloneTarget = function cloneTarget$1(template) {
	var _template$getBounding = template.getBoundingClientRect(), top = _template$getBounding.top, left = _template$getBounding.left, width = _template$getBounding.width, height = _template$getBounding.height;
	var clone = template.cloneNode();
	var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
	var scrollLeft = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;
	clone.removeAttribute("id");
	clone.style.position = "absolute";
	clone.style.top = top + scrollTop + "px";
	clone.style.left = left + scrollLeft + "px";
	clone.style.width = width + "px";
	clone.style.height = height + "px";
	clone.style.transform = "";
	return clone;
};
var createCustomEvent = function createCustomEvent$1(type, params) {
	var eventParams = _extends({
		bubbles: false,
		cancelable: false,
		detail: void 0
	}, params);
	if (typeof window.CustomEvent === "function") return new CustomEvent(type, eventParams);
	var customEvent = document.createEvent("CustomEvent");
	customEvent.initCustomEvent(type, eventParams.bubbles, eventParams.cancelable, eventParams.detail);
	return customEvent;
};
var mediumZoom = function mediumZoom$1(selector) {
	var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
	/**
	* Ensure the compatibility with IE11 if no Promise polyfill are used.
	*/
	var Promise$1 = window.Promise || function Promise$2(fn) {
		function noop() {}
		fn(noop, noop);
	};
	var _handleClick = function _handleClick$1(event) {
		var target = event.target;
		if (target === overlay) {
			close();
			return;
		}
		if (images.indexOf(target) === -1) return;
		toggle({ target });
	};
	var _handleScroll = function _handleScroll$1() {
		if (isAnimating || !active.original) return;
		var currentScroll = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
		if (Math.abs(scrollTop - currentScroll) > zoomOptions.scrollOffset) setTimeout(close, 150);
	};
	var _handleKeyUp = function _handleKeyUp$1(event) {
		var key = event.key || event.keyCode;
		if (key === "Escape" || key === "Esc" || key === 27) close();
	};
	var update = function update$1() {
		var options$1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
		var newOptions = options$1;
		if (options$1.background) overlay.style.background = options$1.background;
		if (options$1.container && options$1.container instanceof Object) newOptions.container = _extends({}, zoomOptions.container, options$1.container);
		if (options$1.template) newOptions.template = isNode(options$1.template) ? options$1.template : document.querySelector(options$1.template);
		zoomOptions = _extends({}, zoomOptions, newOptions);
		images.forEach(function(image) {
			image.dispatchEvent(createCustomEvent("medium-zoom:update", { detail: { zoom } }));
		});
		return zoom;
	};
	var clone = function clone$1() {
		var options$1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
		return mediumZoom$1(_extends({}, zoomOptions, options$1));
	};
	var attach = function attach$1() {
		for (var _len = arguments.length, selectors = Array(_len), _key = 0; _key < _len; _key++) selectors[_key] = arguments[_key];
		var newImages = selectors.reduce(function(imagesAccumulator, currentSelector) {
			return [].concat(imagesAccumulator, getImagesFromSelector(currentSelector));
		}, []);
		newImages.filter(function(newImage) {
			return images.indexOf(newImage) === -1;
		}).forEach(function(newImage) {
			images.push(newImage);
			newImage.classList.add("medium-zoom-image");
		});
		eventListeners.forEach(function(_ref) {
			var type = _ref.type, listener = _ref.listener, options$1 = _ref.options;
			newImages.forEach(function(image) {
				image.addEventListener(type, listener, options$1);
			});
		});
		return zoom;
	};
	var detach = function detach$1() {
		for (var _len2 = arguments.length, selectors = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) selectors[_key2] = arguments[_key2];
		if (active.zoomed) close();
		var imagesToDetach = selectors.length > 0 ? selectors.reduce(function(imagesAccumulator, currentSelector) {
			return [].concat(imagesAccumulator, getImagesFromSelector(currentSelector));
		}, []) : images;
		imagesToDetach.forEach(function(image) {
			image.classList.remove("medium-zoom-image");
			image.dispatchEvent(createCustomEvent("medium-zoom:detach", { detail: { zoom } }));
		});
		images = images.filter(function(image) {
			return imagesToDetach.indexOf(image) === -1;
		});
		return zoom;
	};
	var on$1 = function on$2(type, listener) {
		var options$1 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
		images.forEach(function(image) {
			image.addEventListener("medium-zoom:" + type, listener, options$1);
		});
		eventListeners.push({
			type: "medium-zoom:" + type,
			listener,
			options: options$1
		});
		return zoom;
	};
	var off = function off$1(type, listener) {
		var options$1 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
		images.forEach(function(image) {
			image.removeEventListener("medium-zoom:" + type, listener, options$1);
		});
		eventListeners = eventListeners.filter(function(eventListener) {
			return !(eventListener.type === "medium-zoom:" + type && eventListener.listener.toString() === listener.toString());
		});
		return zoom;
	};
	var open = function open$1() {
		var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, target = _ref2.target;
		var _animate = function _animate$1() {
			var container = {
				width: document.documentElement.clientWidth,
				height: document.documentElement.clientHeight,
				left: 0,
				top: 0,
				right: 0,
				bottom: 0
			};
			var viewportWidth = void 0;
			var viewportHeight = void 0;
			if (zoomOptions.container) if (zoomOptions.container instanceof Object) {
				container = _extends({}, container, zoomOptions.container);
				viewportWidth = container.width - container.left - container.right - zoomOptions.margin * 2;
				viewportHeight = container.height - container.top - container.bottom - zoomOptions.margin * 2;
			} else {
				var _zoomContainer$getBou = (isNode(zoomOptions.container) ? zoomOptions.container : document.querySelector(zoomOptions.container)).getBoundingClientRect(), _width = _zoomContainer$getBou.width, _height = _zoomContainer$getBou.height, _left = _zoomContainer$getBou.left, _top = _zoomContainer$getBou.top;
				container = _extends({}, container, {
					width: _width,
					height: _height,
					left: _left,
					top: _top
				});
			}
			viewportWidth = viewportWidth || container.width - zoomOptions.margin * 2;
			viewportHeight = viewportHeight || container.height - zoomOptions.margin * 2;
			var zoomTarget = active.zoomedHd || active.original;
			var naturalWidth = isSvg(zoomTarget) ? viewportWidth : zoomTarget.naturalWidth || viewportWidth;
			var naturalHeight = isSvg(zoomTarget) ? viewportHeight : zoomTarget.naturalHeight || viewportHeight;
			var _zoomTarget$getBoundi = zoomTarget.getBoundingClientRect(), top = _zoomTarget$getBoundi.top, left = _zoomTarget$getBoundi.left, width = _zoomTarget$getBoundi.width, height = _zoomTarget$getBoundi.height;
			var scaleX = Math.min(Math.max(width, naturalWidth), viewportWidth) / width;
			var scaleY = Math.min(Math.max(height, naturalHeight), viewportHeight) / height;
			var scale = Math.min(scaleX, scaleY);
			var translateX = (-left + (viewportWidth - width) / 2 + zoomOptions.margin + container.left) / scale;
			var translateY = (-top + (viewportHeight - height) / 2 + zoomOptions.margin + container.top) / scale;
			var transform = "scale(" + scale + ") translate3d(" + translateX + "px, " + translateY + "px, 0)";
			active.zoomed.style.transform = transform;
			if (active.zoomedHd) active.zoomedHd.style.transform = transform;
		};
		return new Promise$1(function(resolve) {
			if (target && images.indexOf(target) === -1) {
				resolve(zoom);
				return;
			}
			var _handleOpenEnd = function _handleOpenEnd$1() {
				isAnimating = false;
				active.zoomed.removeEventListener("transitionend", _handleOpenEnd$1);
				active.original.dispatchEvent(createCustomEvent("medium-zoom:opened", { detail: { zoom } }));
				resolve(zoom);
			};
			if (active.zoomed) {
				resolve(zoom);
				return;
			}
			if (target) active.original = target;
			else if (images.length > 0) active.original = images[0];
			else {
				resolve(zoom);
				return;
			}
			active.original.dispatchEvent(createCustomEvent("medium-zoom:open", { detail: { zoom } }));
			scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
			isAnimating = true;
			active.zoomed = cloneTarget(active.original);
			document.body.appendChild(overlay);
			if (zoomOptions.template) {
				var template = isNode(zoomOptions.template) ? zoomOptions.template : document.querySelector(zoomOptions.template);
				active.template = document.createElement("div");
				active.template.appendChild(template.content.cloneNode(true));
				document.body.appendChild(active.template);
			}
			if (active.original.parentElement && active.original.parentElement.tagName === "PICTURE" && active.original.currentSrc) active.zoomed.src = active.original.currentSrc;
			document.body.appendChild(active.zoomed);
			window.requestAnimationFrame(function() {
				document.body.classList.add("medium-zoom--opened");
			});
			active.original.classList.add("medium-zoom-image--hidden");
			active.zoomed.classList.add("medium-zoom-image--opened");
			active.zoomed.addEventListener("click", close);
			active.zoomed.addEventListener("transitionend", _handleOpenEnd);
			if (active.original.getAttribute("data-zoom-src")) {
				active.zoomedHd = active.zoomed.cloneNode();
				active.zoomedHd.removeAttribute("srcset");
				active.zoomedHd.removeAttribute("sizes");
				active.zoomedHd.removeAttribute("loading");
				active.zoomedHd.src = active.zoomed.getAttribute("data-zoom-src");
				active.zoomedHd.onerror = function() {
					clearInterval(getZoomTargetSize);
					console.warn("Unable to reach the zoom image target " + active.zoomedHd.src);
					active.zoomedHd = null;
					_animate();
				};
				var getZoomTargetSize = setInterval(function() {
					if (active.zoomedHd.complete) {
						clearInterval(getZoomTargetSize);
						active.zoomedHd.classList.add("medium-zoom-image--opened");
						active.zoomedHd.addEventListener("click", close);
						document.body.appendChild(active.zoomedHd);
						_animate();
					}
				}, 10);
			} else if (active.original.hasAttribute("srcset")) {
				active.zoomedHd = active.zoomed.cloneNode();
				active.zoomedHd.removeAttribute("sizes");
				active.zoomedHd.removeAttribute("loading");
				var loadEventListener = active.zoomedHd.addEventListener("load", function() {
					active.zoomedHd.removeEventListener("load", loadEventListener);
					active.zoomedHd.classList.add("medium-zoom-image--opened");
					active.zoomedHd.addEventListener("click", close);
					document.body.appendChild(active.zoomedHd);
					_animate();
				});
			} else _animate();
		});
	};
	var close = function close$1() {
		return new Promise$1(function(resolve) {
			if (isAnimating || !active.original) {
				resolve(zoom);
				return;
			}
			var _handleCloseEnd = function _handleCloseEnd$1() {
				active.original.classList.remove("medium-zoom-image--hidden");
				document.body.removeChild(active.zoomed);
				if (active.zoomedHd) document.body.removeChild(active.zoomedHd);
				document.body.removeChild(overlay);
				active.zoomed.classList.remove("medium-zoom-image--opened");
				if (active.template) document.body.removeChild(active.template);
				isAnimating = false;
				active.zoomed.removeEventListener("transitionend", _handleCloseEnd$1);
				active.original.dispatchEvent(createCustomEvent("medium-zoom:closed", { detail: { zoom } }));
				active.original = null;
				active.zoomed = null;
				active.zoomedHd = null;
				active.template = null;
				resolve(zoom);
			};
			isAnimating = true;
			document.body.classList.remove("medium-zoom--opened");
			active.zoomed.style.transform = "";
			if (active.zoomedHd) active.zoomedHd.style.transform = "";
			if (active.template) {
				active.template.style.transition = "opacity 150ms";
				active.template.style.opacity = 0;
			}
			active.original.dispatchEvent(createCustomEvent("medium-zoom:close", { detail: { zoom } }));
			active.zoomed.addEventListener("transitionend", _handleCloseEnd);
		});
	};
	var toggle = function toggle$1() {
		var _ref3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, target = _ref3.target;
		if (active.original) return close();
		return open({ target });
	};
	var getOptions = function getOptions$1() {
		return zoomOptions;
	};
	var getImages = function getImages$1() {
		return images;
	};
	var getZoomedImage = function getZoomedImage$1() {
		return active.original;
	};
	var images = [];
	var eventListeners = [];
	var isAnimating = false;
	var scrollTop = 0;
	var zoomOptions = options;
	var active = {
		original: null,
		zoomed: null,
		zoomedHd: null,
		template: null
	};
	if (Object.prototype.toString.call(selector) === "[object Object]") zoomOptions = selector;
	else if (selector || typeof selector === "string") attach(selector);
	zoomOptions = _extends({
		margin: 0,
		background: "#fff",
		scrollOffset: 40,
		container: null,
		template: null
	}, zoomOptions);
	var overlay = createOverlay(zoomOptions.background);
	document.addEventListener("click", _handleClick);
	document.addEventListener("keyup", _handleKeyUp);
	document.addEventListener("scroll", _handleScroll);
	window.addEventListener("resize", close);
	var zoom = {
		open,
		close,
		toggle,
		update,
		clone,
		attach,
		detach,
		on: on$1,
		off,
		getOptions,
		getImages,
		getZoomedImage
	};
	return zoom;
};
function styleInject(css, ref$1) {
	if (ref$1 === void 0) ref$1 = {};
	var insertAt = ref$1.insertAt;
	if (!css || typeof document === "undefined") return;
	var head = document.head || document.getElementsByTagName("head")[0];
	var style = document.createElement("style");
	style.type = "text/css";
	if (insertAt === "top") if (head.firstChild) head.insertBefore(style, head.firstChild);
	else head.appendChild(style);
	else head.appendChild(style);
	if (style.styleSheet) style.styleSheet.cssText = css;
	else style.appendChild(document.createTextNode(css));
}
styleInject(".medium-zoom-overlay{position:fixed;top:0;right:0;bottom:0;left:0;opacity:0;transition:opacity .3s;will-change:opacity}.medium-zoom--opened .medium-zoom-overlay{cursor:pointer;cursor:zoom-out;opacity:1}.medium-zoom-image{cursor:pointer;cursor:zoom-in;transition:transform .3s cubic-bezier(.2,0,.2,1)!important}.medium-zoom-image--hidden{visibility:hidden}.medium-zoom-image--opened{position:relative;cursor:pointer;cursor:zoom-out;will-change:transform}");
var medium_zoom_esm_default = mediumZoom;

//#endregion
//#region node_modules/md-editor-v3/lib/es/chunks/index3.mjs
var M = {
	hljs: `${p$1}-hljs`,
	hlcss: `${p$1}-hlCss`,
	prettier: `${p$1}-prettier`,
	prettierMD: `${p$1}-prettierMD`,
	cropperjs: `${p$1}-cropper`,
	croppercss: `${p$1}-cropperCss`,
	screenfull: `${p$1}-screenfull`,
	mermaidM: `${p$1}-mermaid-m`,
	mermaid: `${p$1}-mermaid`,
	katexjs: `${p$1}-katex`,
	katexcss: `${p$1}-katexCss`,
	echarts: `${p$1}-echarts`
}, Jt = (e$1, t$1, r$2) => {
	const { editorId: n$3 } = r$2, o$2 = reactive({
		buildFinished: !1,
		html: ""
	});
	watch(() => e$1.modelValue, () => {
		o$2.buildFinished = !1;
	}), onMounted(() => {
		F$1.on(n$3, {
			name: L$1,
			callback(u$4) {
				o$2.buildFinished = !0, o$2.html = u$4;
			}
		}), F$1.on(n$3, {
			name: i,
			callback() {
				const u$4 = new Promise((c$2) => {
					if (o$2.buildFinished) c$2(o$2.html);
					else {
						const m$2 = (s$2) => {
							c$2(s$2), F$1.remove(n$3, L$1, m$2);
						};
						F$1.on(n$3, {
							name: L$1,
							callback: m$2
						});
					}
				});
				e$1.onSave ? e$1.onSave(e$1.modelValue, u$4) : t$1.emit("onSave", e$1.modelValue, u$4);
			}
		});
	});
}, Te = (e$1, { editorId: t$1, rootRef: r$2, setting: n$3 }) => {
	const o$2 = h$1.editorExtensions.highlight, u$4 = h$1.editorExtensionsAttrs.highlight;
	provide("editorId", t$1), provide("rootRef", r$2), provide("theme", computed(() => e$1.theme)), provide("language", computed(() => e$1.language)), provide("highlight", computed(() => {
		const { js: m$2 } = o$2, s$2 = {
			...g$1,
			...o$2.css
		}, { js: l$2, css: i$3 = {} } = u$4 || {}, a$2 = e$1.codeStyleReverse && e$1.codeStyleReverseList.includes(e$1.previewTheme) ? "dark" : e$1.theme, d$2 = s$2[e$1.codeTheme] ? s$2[e$1.codeTheme][a$2] : g$1.atom[a$2], $$1 = s$2[e$1.codeTheme] && i$3[e$1.codeTheme] ? i$3[e$1.codeTheme][a$2] : i$3.atom ? i$3.atom[a$2] : {};
		return {
			js: {
				src: m$2,
				...l$2
			},
			css: {
				href: d$2,
				...$$1
			}
		};
	})), provide("showCodeRowNumber", e$1.showCodeRowNumber);
	const c$2 = computed(() => {
		const m$2 = {
			...v,
			...h$1.editorConfig.languageUserDefined
		};
		return h$5(u$3(v["en-US"]), m$2[e$1.language] || {});
	});
	return provide("usedLanguageText", c$2), provide("previewTheme", computed(() => e$1.previewTheme)), provide("customIcon", computed(() => e$1.customIcon)), provide("setting", computed(() => n$3 ? { ...n$3 } : {
		preview: !0,
		htmlPreview: !1,
		previewOnly: !1,
		pageFullscreen: !1,
		fullscreen: !1
	})), { editorId: t$1 };
}, Xt = (e$1, t$1) => (provide("tabWidth", e$1.tabWidth), provide("disabled", computed(() => e$1.disabled)), provide("showToolbarName", computed(() => e$1.showToolbarName)), provide("noUploadImg", e$1.noUploadImg), provide("tableShape", computed(() => e$1.tableShape)), provide("noPrettier", e$1.noPrettier), provide("codeTheme", computed(() => e$1.codeTheme)), provide("updateSetting", t$1.updateSetting), provide("catalogVisible", computed(() => t$1.catalogVisible.value)), provide("defToolbars", t$1.defToolbars), provide("floatingToolbars", computed(() => e$1.floatingToolbars)), Te(e$1, t$1)), Yt = (e$1) => {
	const { noPrettier: t$1, noUploadImg: r$2 } = e$1, { editorExtensions: n$3, editorExtensionsAttrs: o$2 } = h$1, u$4 = t$1 || n$3.prettier.prettierInstance, c$2 = t$1 || n$3.prettier.parserMarkdownInstance, m$2 = r$2 || n$3.cropper.instance;
	onMounted(() => {
		if (!m$2) {
			const { js: s$2 = {}, css: l$2 = {} } = o$2.cropper || {};
			A("link", {
				...l$2,
				rel: "stylesheet",
				href: n$3.cropper.css,
				id: M.croppercss
			}), A("script", {
				...s$2,
				src: n$3.cropper.js,
				id: M.cropperjs
			});
		}
		if (!u$4) {
			const { standaloneJs: s$2 = {} } = o$2.prettier || {};
			A("script", {
				...s$2,
				src: n$3.prettier.standaloneJs,
				id: M.prettier
			});
		}
		if (!c$2) {
			const { parserMarkdownJs: s$2 = {} } = o$2.prettier || {};
			A("script", {
				...s$2,
				src: n$3.prettier.parserMarkdownJs,
				id: M.prettierMD
			});
		}
	});
}, Qt = (e$1, t$1, r$2) => {
	const { editorId: n$3 } = r$2;
	onMounted(() => {
		F$1.on(n$3, {
			name: N$1,
			callback: (o$2) => {
				e$1.onError?.(o$2), t$1.emit("onError", o$2);
			}
		});
	});
}, en = (e$1, t$1, r$2) => {
	const { editorId: n$3 } = r$2, o$2 = reactive({
		pageFullscreen: e$1.pageFullscreen,
		fullscreen: !1,
		preview: e$1.preview,
		htmlPreview: e$1.preview ? !1 : e$1.htmlPreview,
		previewOnly: !1
	}), u$4 = reactive({ ...o$2 }), c$2 = (l$2, i$3) => {
		const a$2 = i$3 === void 0 ? !o$2[l$2] : i$3;
		switch (l$2) {
			case "preview":
				o$2.htmlPreview = !1, o$2.previewOnly = !1;
				break;
			case "htmlPreview":
				o$2.preview = !1, o$2.previewOnly = !1;
				break;
			case "previewOnly":
				a$2 ? !o$2.preview && !o$2.htmlPreview && (o$2.preview = !0) : (u$4.preview || (o$2.preview = !1), u$4.htmlPreview || (o$2.htmlPreview = !1));
				break;
		}
		u$4[l$2] = a$2, o$2[l$2] = a$2;
	};
	let m$2 = "";
	const s$2 = () => {
		o$2.pageFullscreen || o$2.fullscreen ? document.body.style.overflow = "hidden" : document.body.style.overflow = m$2;
	};
	return watch(() => [o$2.pageFullscreen, o$2.fullscreen], s$2), onMounted(() => {
		F$1.on(n$3, {
			name: I,
			callback(l$2, i$3) {
				const a$2 = (d$2) => {
					F$1.emit(n$3, G, "image", {
						desc: "",
						urls: d$2
					}), i$3?.();
				};
				e$1.onUploadImg ? e$1.onUploadImg(l$2, a$2) : t$1.emit("onUploadImg", l$2, a$2);
			}
		}), m$2 = document.body.style.overflow, s$2();
	}), [o$2, c$2];
}, tn = (e$1, t$1) => {
	const { editorId: r$2 } = t$1, n$3 = ref(!1);
	return onMounted(() => {
		F$1.on(r$2, {
			name: C$1,
			callback: (o$2) => {
				o$2 === void 0 ? n$3.value = !n$3.value : n$3.value = o$2;
			}
		});
	}), n$3;
}, nn = (e$1, t$1, r$2) => {
	const { editorId: n$3, catalogVisible: o$2, setting: u$4, updateSetting: c$2, codeRef: m$2 } = r$2;
	watch(() => u$4.pageFullscreen, (l$2) => {
		F$1.emit(n$3, _, l$2);
	}), watch(() => u$4.fullscreen, (l$2) => {
		F$1.emit(n$3, r, l$2);
	}), watch(() => u$4.preview, (l$2) => {
		F$1.emit(n$3, A$1, l$2);
	}), watch(() => u$4.previewOnly, (l$2) => {
		F$1.emit(n$3, R, l$2);
	}), watch(() => u$4.htmlPreview, (l$2) => {
		F$1.emit(n$3, p$2, l$2);
	}), watch(o$2, (l$2) => {
		F$1.emit(n$3, g$2, l$2);
	});
	t$1.expose({
		on(l$2, i$3) {
			switch (l$2) {
				case "pageFullscreen":
					F$1.on(n$3, {
						name: _,
						callback(a$2) {
							i$3(a$2);
						}
					});
					break;
				case "fullscreen":
					F$1.on(n$3, {
						name: r,
						callback(a$2) {
							i$3(a$2);
						}
					});
					break;
				case "preview":
					F$1.on(n$3, {
						name: A$1,
						callback(a$2) {
							i$3(a$2);
						}
					});
					break;
				case "previewOnly":
					F$1.on(n$3, {
						name: R,
						callback(a$2) {
							i$3(a$2);
						}
					});
					break;
				case "htmlPreview":
					F$1.on(n$3, {
						name: p$2,
						callback(a$2) {
							i$3(a$2);
						}
					});
					break;
				case "catalog":
					F$1.on(n$3, {
						name: g$2,
						callback(a$2) {
							i$3(a$2);
						}
					});
					break;
			}
		},
		togglePageFullscreen(l$2) {
			c$2("pageFullscreen", l$2);
		},
		toggleFullscreen(l$2) {
			F$1.emit(n$3, h$2, l$2);
		},
		togglePreview(l$2) {
			c$2("preview", l$2);
		},
		togglePreviewOnly(l$2) {
			c$2("previewOnly", l$2);
		},
		toggleHtmlPreview(l$2) {
			c$2("htmlPreview", l$2);
		},
		toggleCatalog(l$2) {
			F$1.emit(n$3, C$1, l$2);
		},
		triggerSave() {
			F$1.emit(n$3, i);
		},
		insert(l$2) {
			F$1.emit(n$3, G, "universal", { generate: l$2 });
		},
		focus(l$2) {
			m$2.value?.focus(l$2);
		},
		rerender() {
			F$1.emit(n$3, D);
		},
		getSelectedText() {
			return m$2.value?.getSelectedText();
		},
		resetHistory() {
			m$2.value?.resetHistory();
		},
		domEventHandlers(l$2) {
			F$1.emit(n$3, V, l$2);
		},
		execCommand(l$2) {
			F$1.emit(n$3, G, l$2);
		},
		getEditorView() {
			return m$2.value?.getEditorView();
		}
	});
}, tt = (e$1) => {
	const t$1 = useId();
	return e$1.id || e$1.editorId || `${p$1}-${t$1}`;
}, nt = (e$1, t$1, r$2) => {
	const n$3 = inject("editorId"), o$2 = inject("rootRef"), u$4 = inject("usedLanguageText"), c$2 = inject("setting"), m$2 = () => {
		o$2.value.querySelectorAll(`#${n$3} .${p$1}-preview .${p$1}-code`).forEach((i$3) => {
			let a$2 = -1;
			const d$2 = i$3.querySelector(`.${p$1}-copy-button:not([data-processed])`);
			d$2 && (d$2.onclick = ($$1) => {
				$$1.preventDefault(), clearTimeout(a$2);
				const p$3 = (i$3.querySelector("input:checked + pre code") || i$3.querySelector("pre code")).textContent, { text: g$4, successTips: I$1, failTips: v$2 } = u$4.value.copyCode;
				let C$2 = I$1;
				copy2clipboard_default(e$1.formatCopiedText(p$3 || "")).catch(() => {
					C$2 = v$2;
				}).finally(() => {
					d$2.dataset.isIcon ? d$2.dataset.tips = C$2 : d$2.innerHTML = C$2, a$2 = window.setTimeout(() => {
						d$2.dataset.isIcon ? d$2.dataset.tips = g$4 : d$2.innerHTML = g$4;
					}, 1500);
				});
			}, d$2.setAttribute("data-processed", "true"));
		});
	}, s$2 = () => {
		nextTick(m$2);
	}, l$2 = (i$3) => {
		i$3 && nextTick(m$2);
	};
	watch([t$1, r$2], s$2), watch(() => c$2.value.preview, l$2), watch(() => c$2.value.htmlPreview, l$2), onMounted(m$2);
}, ot = (e$1) => {
	const t$1 = inject("editorId"), r$2 = inject("theme"), n$3 = inject("rootRef"), { editorExtensions: o$2, editorExtensionsAttrs: u$4 } = h$1;
	let c$2 = o$2.echarts.instance;
	const m$2 = shallowRef(-1), s$2 = () => {
		!e$1.noEcharts && c$2 && (m$2.value = m$2.value + 1);
	};
	watch(() => r$2.value, () => {
		s$2();
	}), onMounted(() => {
		if (e$1.noEcharts || c$2) return;
		const h$6 = o$2.echarts.js;
		A("script", {
			...u$4.echarts?.js,
			src: h$6,
			id: M.echarts,
			onload() {
				c$2 = window.echarts, s$2();
			}
		}, "echarts");
	});
	let l$2 = [], i$3 = [], a$2 = [];
	const d$2 = (h$6 = !1) => {
		if (!l$2.length) {
			h$6 && (i$3.forEach((v$2) => {
				v$2.dispose?.();
			}), a$2.forEach((v$2) => {
				v$2.disconnect?.();
			}), i$3 = [], a$2 = []);
			return;
		}
		const p$3 = [], g$4 = [], I$1 = [];
		l$2.forEach((v$2, C$2) => {
			const x$1 = i$3[C$2], b$2 = a$2[C$2];
			if (h$6 || !v$2 || !v$2.isConnected || (n$3?.value ? !n$3.value.contains(v$2) : !1)) {
				x$1?.dispose?.(), b$2?.disconnect?.();
				return;
			}
			p$3.push(v$2), x$1 && g$4.push(x$1), b$2 && I$1.push(b$2);
		}), l$2 = p$3, i$3 = g$4, a$2 = I$1;
	}, $$1 = () => {
		d$2(), !e$1.noEcharts && c$2 && Array.from(n$3.value.querySelectorAll(`#${t$1} div.${p$1}-echarts:not([data-processed])`)).forEach((p$3) => {
			if (p$3.dataset.closed === "false") return !1;
			try {
				const g$4 = new Function(`return ${p$3.innerText}`)(), I$1 = c$2.init(p$3, r$2.value);
				I$1.setOption(g$4), p$3.setAttribute("data-processed", ""), l$2.push(p$3), i$3.push(I$1);
				const v$2 = new ResizeObserver(() => {
					I$1.resize();
				});
				v$2.observe(p$3), a$2.push(v$2);
			} catch (g$4) {
				F$1.emit(t$1, N$1, {
					name: "echarts",
					message: g$4?.message,
					error: g$4
				});
			}
		});
	};
	return onBeforeUnmount(() => {
		d$2(!0);
	}), {
		reRenderEcharts: m$2,
		replaceEcharts: $$1
	};
}, at = (e$1) => {
	const t$1 = inject("highlight"), r$2 = shallowRef(h$1.editorExtensions.highlight.instance);
	return onMounted(() => {
		e$1.noHighlight || r$2.value || (A("link", {
			...t$1.value.css,
			rel: "stylesheet",
			id: M.hlcss
		}), A("script", {
			...t$1.value.js,
			id: M.hljs,
			onload() {
				r$2.value = window.hljs;
			}
		}, "hljs"));
	}), watch(() => t$1.value.css, () => {
		e$1.noHighlight || h$1.editorExtensions.highlight.instance || b$1("link", {
			...t$1.value.css,
			rel: "stylesheet",
			id: M.hlcss
		});
	}), r$2;
}, rt = (e$1) => {
	const t$1 = shallowRef(h$1.editorExtensions.katex.instance);
	return onMounted(() => {
		if (e$1.noKatex || t$1.value) return;
		const { editorExtensions: r$2, editorExtensionsAttrs: n$3 } = h$1;
		A("script", {
			...n$3.katex?.js,
			src: r$2.katex.js,
			id: M.katexjs,
			onload() {
				t$1.value = window.katex;
			}
		}, "katex"), A("link", {
			...n$3.katex?.css,
			rel: "stylesheet",
			href: r$2.katex.css,
			id: M.katexcss
		});
	}), t$1;
}, Y$1 = new LRUCache({
	max: 1e3,
	ttl: 6e5
}), lt = (e$1) => {
	const t$1 = inject("editorId"), r$2 = inject("theme"), n$3 = inject("rootRef"), { editorExtensions: o$2, editorExtensionsAttrs: u$4, mermaidConfig: c$2 } = h$1;
	let m$2 = o$2.mermaid.instance;
	const s$2 = shallowRef(-1), l$2 = () => {
		!e$1.noMermaid && m$2 && (m$2.initialize(c$2({
			startOnLoad: !1,
			theme: r$2.value === "dark" ? "dark" : "default"
		})), s$2.value = s$2.value + 1);
	};
	return watch(() => r$2.value, () => {
		Y$1.clear(), l$2();
	}), onMounted(() => {
		if (e$1.noMermaid || m$2) return;
		const a$2 = o$2.mermaid.js;
		/\.mjs/.test(a$2) ? (A("link", {
			...u$4.mermaid?.js,
			rel: "modulepreload",
			href: a$2,
			id: M.mermaidM
		}), import(
			/* @vite-ignore */
			/* webpackIgnore: true */
			a$2
).then((d$2) => {
			m$2 = d$2.default, l$2();
		}).catch((d$2) => {
			F$1.emit(t$1, N$1, {
				name: "mermaid",
				message: `Failed to load mermaid module: ${d$2.message}`,
				error: d$2
			});
		})) : A("script", {
			...u$4.mermaid?.js,
			src: a$2,
			id: M.mermaid,
			onload() {
				m$2 = window.mermaid, l$2();
			}
		}, "mermaid");
	}), {
		reRenderRef: s$2,
		replaceMermaid: async () => {
			if (!e$1.noMermaid && m$2) {
				const a$2 = n$3.value.querySelectorAll(`div.${p$1}-mermaid`), d$2 = document.createElement("div"), $$1 = document.body.offsetWidth > 1366 ? document.body.offsetWidth : 1366, h$6 = document.body.offsetHeight > 768 ? document.body.offsetHeight : 768;
				d$2.style.width = $$1 + "px", d$2.style.height = h$6 + "px", d$2.style.position = "fixed", d$2.style.zIndex = "-10000", d$2.style.top = "-10000";
				let p$3 = a$2.length;
				p$3 > 0 && document.body.appendChild(d$2), await Promise.allSettled(Array.from(a$2).map((g$4) => (async (v$2) => {
					if (v$2.dataset.closed === "false") return !1;
					const C$2 = v$2.innerText;
					let x$1 = Y$1.get(C$2);
					if (!x$1) {
						const b$2 = W$1();
						let F$2 = { svg: "" };
						try {
							F$2 = await m$2.render(b$2, C$2, d$2), x$1 = await e$1.sanitizeMermaid(F$2.svg);
							const S$2 = document.createElement("p");
							S$2.className = `${p$1}-mermaid`, S$2.setAttribute("data-processed", ""), S$2.setAttribute("data-content", C$2), S$2.innerHTML = x$1, S$2.children[0]?.removeAttribute("height"), Y$1.set(C$2, S$2.innerHTML), v$2.dataset.line !== void 0 && (S$2.dataset.line = v$2.dataset.line), v$2.replaceWith(S$2);
						} catch (S$2) {
							F$1.emit(t$1, N$1, {
								name: "mermaid",
								message: S$2.message,
								error: S$2
							});
						}
						--p$3 === 0 && d$2.remove();
					}
				})(g$4)));
			}
		}
	};
}, it = (e$1, t$1) => {
	t$1 = t$1 || {};
	const r$2 = 3, n$3 = t$1.marker || "!", o$2 = n$3.charCodeAt(0), u$4 = n$3.length;
	let c$2 = "", m$2 = "";
	const s$2 = (i$3, a$2, d$2, $$1, h$6) => {
		const p$3 = i$3[a$2];
		return p$3.type === "admonition_open" ? i$3[a$2].attrPush(["class", `${p$1}-admonition ${p$1}-admonition-${p$3.info}`]) : p$3.type === "admonition_title_open" && i$3[a$2].attrPush(["class", `${p$1}-admonition-title`]), h$6.renderToken(i$3, a$2, d$2);
	}, l$2 = (i$3) => {
		const a$2 = i$3.trim().split(" ", 2);
		m$2 = "", c$2 = a$2[0], a$2.length > 1 && (m$2 = i$3.substring(c$2.length + 2));
	};
	e$1.block.ruler.before("code", "admonition", (i$3, a$2, d$2, $$1) => {
		let h$6, p$3, g$4, I$1 = !1, v$2 = i$3.bMarks[a$2] + i$3.tShift[a$2], C$2 = i$3.eMarks[a$2];
		if (o$2 !== i$3.src.charCodeAt(v$2)) return !1;
		for (h$6 = v$2 + 1; h$6 <= C$2 && n$3[(h$6 - v$2) % u$4] === i$3.src[h$6]; h$6++);
		const x$1 = Math.floor((h$6 - v$2) / u$4);
		if (x$1 !== r$2) return !1;
		h$6 -= (h$6 - v$2) % u$4;
		const b$2 = i$3.src.slice(v$2, h$6), F$2 = i$3.src.slice(h$6, C$2);
		if (l$2(F$2), $$1) return !0;
		for (p$3 = a$2; p$3++, !(p$3 >= d$2 || (v$2 = i$3.bMarks[p$3] + i$3.tShift[p$3], C$2 = i$3.eMarks[p$3], v$2 < C$2 && i$3.sCount[p$3] < i$3.blkIndent));) if (o$2 === i$3.src.charCodeAt(v$2) && !(i$3.sCount[p$3] - i$3.blkIndent >= 4)) {
			for (h$6 = v$2 + 1; h$6 <= C$2 && n$3[(h$6 - v$2) % u$4] === i$3.src[h$6]; h$6++);
			if (!(Math.floor((h$6 - v$2) / u$4) < x$1) && (h$6 -= (h$6 - v$2) % u$4, h$6 = i$3.skipSpaces(h$6), !(h$6 < C$2))) {
				I$1 = !0;
				break;
			}
		}
		const S$2 = i$3.parentType, L$2 = i$3.lineMax;
		return i$3.parentType = "root", i$3.lineMax = p$3, g$4 = i$3.push("admonition_open", "div", 1), g$4.markup = b$2, g$4.block = !0, g$4.info = c$2, g$4.map = [a$2, p$3], m$2 && (g$4 = i$3.push("admonition_title_open", "p", 1), g$4.markup = b$2 + " " + c$2, g$4.map = [a$2, p$3], g$4 = i$3.push("inline", "", 0), g$4.content = m$2, g$4.map = [a$2, i$3.line - 1], g$4.children = [], g$4 = i$3.push("admonition_title_close", "p", -1), g$4.markup = b$2 + " " + c$2), i$3.md.block.tokenize(i$3, a$2 + 1, p$3), g$4 = i$3.push("admonition_close", "div", -1), g$4.markup = i$3.src.slice(v$2, h$6), g$4.block = !0, i$3.parentType = S$2, i$3.lineMax = L$2, i$3.line = p$3 + (I$1 ? 1 : 0), !0;
	}, { alt: [
		"paragraph",
		"reference",
		"blockquote",
		"list"
	] }), e$1.renderer.rules.admonition_open = s$2, e$1.renderer.rules.admonition_title_open = s$2, e$1.renderer.rules.admonition_title_close = s$2, e$1.renderer.rules.admonition_close = s$2;
}, se$2 = (e$1, t$1) => {
	const r$2 = e$1.attrs ? e$1.attrs.slice() : [];
	return t$1.forEach((n$3) => {
		const o$2 = e$1.attrIndex(n$3[0]);
		o$2 < 0 ? r$2.push(n$3) : (r$2[o$2] = r$2[o$2].slice(), r$2[o$2][1] += ` ${n$3[1]}`);
	}), r$2;
}, st = (e$1, t$1) => {
	const r$2 = e$1.renderer.rules.fence, n$3 = e$1.utils.unescapeAll, o$2 = /\[(\w*)(?::([\w ]*))?\]/, u$4 = /::(open|close)/, c$2 = (a$2) => a$2.info ? n$3(a$2.info).trim() : "", m$2 = (a$2) => {
		const d$2 = c$2(a$2), [$$1 = null, h$6 = ""] = (o$2.exec(d$2) || []).slice(1);
		return [$$1, h$6];
	}, s$2 = (a$2) => {
		const d$2 = c$2(a$2);
		return d$2 ? d$2.split(/(\s+)/g)[0] : "";
	}, l$2 = (a$2) => {
		const d$2 = a$2.info.match(u$4) || [], $$1 = d$2[1] === "open" || d$2[1] !== "close" && t$1.codeFoldable && a$2.content.trim().split(`
`).length < t$1.autoFoldThreshold, h$6 = d$2[1] || t$1.codeFoldable ? "details" : "div", p$3 = d$2[1] || t$1.codeFoldable ? "summary" : "div";
		return {
			open: $$1,
			tagContainer: h$6,
			tagHeader: p$3
		};
	}, i$3 = (a$2, d$2, $$1, h$6, p$3) => {
		if (a$2[d$2].hidden) return "";
		const g$4 = t$1.usedLanguageTextRef.value?.copyCode.text, I$1 = t$1.customIconRef.value.copy || g$4, v$2 = !!t$1.customIconRef.value.copy, C$2 = `<span class="${p$1}-collapse-tips">${p("collapse-tips", t$1.customIconRef.value)}</span>`, [x$1] = m$2(a$2[d$2]);
		if (x$1 === null) {
			const { open: k$2, tagContainer: A$2, tagHeader: J$1 } = l$2(a$2[d$2]), j$4 = [["class", `${p$1}-code`]];
			k$2 && j$4.push(["open", ""]);
			const ne$1 = { attrs: se$2(a$2[d$2], j$4) };
			a$2[d$2].info = a$2[d$2].info.replace(u$4, "");
			const W$2 = r$2(a$2, d$2, $$1, h$6, p$3);
			return `
        <${A$2} ${p$3.renderAttrs(ne$1)}>
          <${J$1} class="${p$1}-code-head">
            <div class="${p$1}-code-flag"><span></span><span></span><span></span></div>
            <div class="${p$1}-code-action">
              <span class="${p$1}-code-lang">${e$1.utils.escapeHtml(a$2[d$2].info.trim())}</span>
              <span class="${p$1}-copy-button" data-tips="${g$4}"${v$2 ? " data-is-icon=true" : ""}>${I$1}</span>
              ${t$1.extraTools instanceof Function ? t$1.extraTools({ lang: a$2[d$2].info.trim() }) : t$1.extraTools || ""}
              ${A$2 === "details" ? C$2 : ""}
            </div>
          </${J$1}>
          ${W$2}
        </${A$2}>
      `;
		}
		let b$2, F$2, S$2, L$2, _$2 = "", B$1 = "", D$2 = "";
		const { open: q, tagContainer: V$2, tagHeader: z$2 } = l$2(a$2[d$2]), K$1 = [["class", `${p$1}-code`]];
		q && K$1.push(["open", ""]);
		const Z$1 = { attrs: se$2(a$2[d$2], K$1) };
		for (let k$2 = d$2; k$2 < a$2.length && (b$2 = a$2[k$2], [F$2, S$2] = m$2(b$2), F$2 === x$1); k$2++) {
			b$2.info = b$2.info.replace(o$2, "").replace(u$4, ""), b$2.hidden = !0;
			const A$2 = `${p$1}-codetab-${t$1.editorId}-${d$2}-${k$2 - d$2}`;
			L$2 = k$2 - d$2 > 0 ? "" : "checked", _$2 += `
        <li>
          <input
            type="radio"
            id="label-${p$1}-codetab-label-1-${t$1.editorId}-${d$2}-${k$2 - d$2}"
            name="${p$1}-codetab-label-${t$1.editorId}-${d$2}"
            class="${A$2}"
            ${L$2}
          >
          <label
            for="label-${p$1}-codetab-label-1-${t$1.editorId}-${d$2}-${k$2 - d$2}"
            onclick="this.getRootNode().querySelectorAll('.${A$2}').forEach(e => e.click())"
          >
            ${e$1.utils.escapeHtml(S$2 || s$2(b$2))}
          </label>
        </li>`, B$1 += `
        <div role="tabpanel">
          <input
            type="radio"
            name="${p$1}-codetab-pre-${t$1.editorId}-${d$2}"
            class="${A$2}"
            ${L$2}
            role="presentation">
          ${r$2(a$2, k$2, $$1, h$6, p$3)}
        </div>`, D$2 += `
        <input
          type="radio"
          name="${p$1}-codetab-lang-${t$1.editorId}-${d$2}"
          class="${A$2}"
          ${L$2}
          role="presentation">
        <span class=${p$1}-code-lang role="note">${e$1.utils.escapeHtml(s$2(b$2))}</span>`;
		}
		return `
      <${V$2} ${p$3.renderAttrs(Z$1)}>
        <${z$2} class="${p$1}-code-head">
          <div class="${p$1}-code-flag">
            <ul class="${p$1}-codetab-label" role="tablist">${_$2}</ul>
          </div>
          <div class="${p$1}-code-action">
            <span class="${p$1}-codetab-lang">${D$2}</span>
            <span class="${p$1}-copy-button" data-tips="${g$4}"${v$2 ? " data-is-icon=true" : ""}>${I$1}</span>
            ${t$1.extraTools instanceof Function ? t$1.extraTools({ lang: a$2[d$2].info.trim() }) : t$1.extraTools || ""}
            ${V$2 === "details" ? C$2 : ""}
          </div>
        </${z$2}>
        ${B$1}
      </${V$2}>
    `;
	};
	e$1.renderer.rules.fence = i$3, e$1.renderer.rules.code_block = i$3;
}, ct = (e$1, t$1) => {
	const r$2 = e$1.renderer.rules.fence.bind(e$1.renderer.rules);
	e$1.renderer.rules.fence = (n$3, o$2, u$4, c$2, m$2) => {
		const s$2 = n$3[o$2], l$2 = s$2.content.trim();
		if (s$2.info === "echarts") {
			if (s$2.attrSet("class", `${p$1}-echarts`), s$2.attrSet("data-echarts-theme", t$1.themeRef.value), s$2.map && s$2.level === 0) {
				const i$3 = s$2.map[1] - 1, d$2 = !!c$2.srcLines[i$3]?.trim()?.startsWith("```");
				s$2.attrSet("data-closed", `${d$2}`), s$2.attrSet("data-line", String(s$2.map[0]));
			}
			return `<div ${m$2.renderAttrs(s$2)} style="width: 100%; aspect-ratio: 4 / 3;">${e$1.utils.escapeHtml(l$2)}</div>`;
		}
		return r$2(n$3, o$2, u$4, c$2, m$2);
	};
}, dt = (e$1, t$1) => {
	e$1.renderer.rules.heading_open = (r$2, n$3) => {
		const o$2 = r$2[n$3], u$4 = r$2[n$3 + 1].children?.reduce((m$2, s$2) => m$2 + ([
			"text",
			"code_inline",
			"math_inline"
		].includes(s$2.type) && s$2.content || ""), "") || "", c$2 = o$2.markup.length;
		return t$1.headsRef.value.push({
			text: u$4,
			level: c$2,
			line: o$2.map[0],
			currentToken: o$2,
			nextToken: r$2[n$3 + 1]
		}), o$2.map && o$2.level === 0 && o$2.attrSet("id", t$1.mdHeadingId({
			text: u$4,
			level: c$2,
			index: t$1.headsRef.value.length,
			currentToken: o$2,
			nextToken: r$2[n$3 + 1]
		})), e$1.renderer.renderToken(r$2, n$3, t$1);
	}, e$1.renderer.rules.heading_close = (r$2, n$3, o$2, u$4, c$2) => c$2.renderToken(r$2, n$3, o$2);
}, be$3 = {
	block: [{
		open: "$$",
		close: "$$"
	}, {
		open: "\\[",
		close: "\\]"
	}],
	inline: [
		{
			open: "$$",
			close: "$$"
		},
		{
			open: "$",
			close: "$"
		},
		{
			open: "\\[",
			close: "\\]"
		},
		{
			open: "\\(",
			close: "\\)"
		}
	]
}, ut = (e$1) => (t$1, r$2) => {
	const n$3 = e$1.delimiters;
	for (const o$2 of n$3) {
		if (!t$1.src.startsWith(o$2.open, t$1.pos)) continue;
		const u$4 = t$1.pos + o$2.open.length;
		let c$2 = u$4;
		for (; (c$2 = t$1.src.indexOf(o$2.close, c$2)) !== -1;) {
			let m$2 = 0, s$2 = c$2 - 1;
			for (; s$2 >= 0 && t$1.src[s$2] === "\\";) m$2++, s$2--;
			if (m$2 % 2 === 0) break;
			c$2 += o$2.close.length;
		}
		if (c$2 !== -1) {
			if (c$2 - u$4 === 0) return r$2 || (t$1.pending += o$2.open + o$2.close), t$1.pos = c$2 + o$2.close.length, !0;
			if (!r$2) {
				const m$2 = t$1.push("math_inline", "math", 0);
				m$2.markup = o$2.open, m$2.content = t$1.src.slice(u$4, c$2);
			}
			return t$1.pos = c$2 + o$2.close.length, !0;
		}
	}
	return !1;
}, mt = (e$1) => (t$1, r$2, n$3, o$2) => {
	const u$4 = e$1.delimiters, c$2 = t$1.bMarks[r$2] + t$1.tShift[r$2], m$2 = t$1.eMarks[r$2], s$2 = (l$2, i$3, a$2) => {
		t$1.line = i$3;
		const d$2 = t$1.push("math_block", "math", 0);
		return d$2.block = !0, d$2.content = l$2, d$2.map = [r$2, t$1.line], d$2.markup = a$2, !0;
	};
	for (const l$2 of u$4) {
		const i$3 = c$2;
		if (t$1.src.slice(i$3, i$3 + l$2.open.length) !== l$2.open) continue;
		const a$2 = i$3 + l$2.open.length, d$2 = t$1.src.slice(a$2, m$2).trim(), $$1 = d$2 === "", h$6 = d$2 === l$2.close, p$3 = d$2.endsWith(l$2.close);
		if (!$$1 && !h$6 && !p$3) continue;
		if (o$2) return !0;
		if (h$6) return s$2("", r$2 + 1, l$2.open);
		if (!$$1 && p$3) {
			const b$2 = d$2.slice(0, -l$2.close.length);
			return s$2(b$2, r$2 + 1, l$2.open);
		}
		let g$4 = r$2 + 1, I$1 = !1, v$2 = "";
		for (; g$4 < n$3; g$4++) {
			const b$2 = t$1.bMarks[g$4] + t$1.tShift[g$4], F$2 = t$1.eMarks[g$4];
			if (b$2 < F$2 && t$1.tShift[g$4] < t$1.blkIndent) break;
			if (t$1.src.slice(b$2, F$2).trim().endsWith(l$2.close)) {
				const L$2 = t$1.src.slice(0, F$2).lastIndexOf(l$2.close);
				v$2 = t$1.src.slice(b$2, L$2), I$1 = !0;
				break;
			}
		}
		if (!I$1) continue;
		const x$1 = t$1.getLines(r$2 + 1, g$4, t$1.tShift[r$2], !0) + (v$2.trim() ? v$2 : "");
		return s$2(x$1, g$4 + 1, l$2.open);
	}
	return !1;
}, ft = (e$1, { katexRef: t$1, inlineDelimiters: r$2, blockDelimiters: n$3 }) => {
	const o$2 = (m$2, s$2, l$2, i$3, a$2 = !1) => {
		const d$2 = { attrs: se$2(m$2, [["class", s$2]]) }, $$1 = i$3.renderAttrs(d$2);
		if (!t$1.value) return `<${l$2} ${$$1}>${m$2.content}</${l$2}>`;
		const h$6 = t$1.value.renderToString(m$2.content, h$1.katexConfig({
			throwOnError: !1,
			displayMode: a$2
		}));
		return `<${l$2} ${$$1} data-processed>${h$6}</${l$2}>`;
	}, u$4 = (m$2, s$2, l$2, i$3, a$2) => o$2(m$2[s$2], `${p$1}-katex-inline`, "span", a$2), c$2 = (m$2, s$2, l$2, i$3, a$2) => o$2(m$2[s$2], `${p$1}-katex-block`, "p", a$2, !0);
	e$1.inline.ruler.before("escape", "math_inline", ut({ delimiters: r$2 || be$3.inline })), e$1.block.ruler.after("blockquote", "math_block", mt({ delimiters: n$3 || be$3.block }), { alt: [
		"paragraph",
		"reference",
		"blockquote",
		"list"
	] }), e$1.renderer.rules.math_inline = u$4, e$1.renderer.rules.math_block = c$2;
}, ht = (e$1, t$1) => {
	const r$2 = e$1.renderer.rules.fence.bind(e$1.renderer.rules);
	e$1.renderer.rules.fence = (n$3, o$2, u$4, c$2, m$2) => {
		const s$2 = n$3[o$2], l$2 = s$2.content.trim();
		if (s$2.info === "mermaid") {
			if (s$2.attrSet("class", `${p$1}-mermaid`), s$2.attrSet("data-mermaid-theme", t$1.themeRef.value), s$2.map && s$2.level === 0) {
				const a$2 = s$2.map[1] - 1, $$1 = !!c$2.srcLines[a$2]?.trim()?.startsWith("```");
				s$2.attrSet("data-closed", `${$$1}`), s$2.attrSet("data-line", String(s$2.map[0]));
			}
			const i$3 = Y$1.get(l$2);
			return i$3 ? (s$2.attrSet("data-processed", ""), s$2.attrSet("data-content", l$2), `<p ${m$2.renderAttrs(s$2)}>${i$3}</p>`) : `<div ${m$2.renderAttrs(s$2)}>${e$1.utils.escapeHtml(l$2)}</div>`;
		}
		return r$2(n$3, o$2, u$4, c$2, m$2);
	};
}, $e = (e$1, t$1, r$2) => {
	const n$3 = e$1.attrIndex(t$1), o$2 = [t$1, r$2];
	n$3 < 0 ? e$1.attrPush(o$2) : (e$1.attrs = e$1.attrs || [], e$1.attrs[n$3] = o$2);
}, pt = (e$1) => e$1.type === "inline", gt = (e$1) => e$1.type === "paragraph_open", vt = (e$1) => e$1.type === "list_item_open", yt = (e$1) => e$1.content.indexOf("[ ] ") === 0 || e$1.content.indexOf("[x] ") === 0 || e$1.content.indexOf("[X] ") === 0, bt = (e$1, t$1) => pt(e$1[t$1]) && gt(e$1[t$1 - 1]) && vt(e$1[t$1 - 2]) && yt(e$1[t$1]), $t = (e$1, t$1) => {
	const r$2 = e$1[t$1].level - 1;
	for (let n$3 = t$1 - 1; n$3 >= 0; n$3--) if (e$1[n$3].level === r$2) return n$3;
	return -1;
}, wt = (e$1) => {
	const t$1 = new e$1("html_inline", "", 0);
	return t$1.content = "<label>", t$1;
}, Ct = (e$1) => {
	const t$1 = new e$1("html_inline", "", 0);
	return t$1.content = "</label>", t$1;
}, Et = (e$1, t$1, r$2) => {
	const n$3 = new r$2("html_inline", "", 0);
	return n$3.content = "<label class=\"task-list-item-label\" for=\"" + t$1 + "\">" + e$1 + "</label>", n$3.attrs = [["for", t$1]], n$3;
}, kt = (e$1, t$1, r$2) => {
	const n$3 = new t$1("html_inline", "", 0), o$2 = r$2.enabled ? " " : " disabled=\"\" ";
	return e$1.content.indexOf("[ ] ") === 0 ? n$3.content = "<input class=\"task-list-item-checkbox\"" + o$2 + "type=\"checkbox\">" : (e$1.content.indexOf("[x] ") === 0 || e$1.content.indexOf("[X] ") === 0) && (n$3.content = "<input class=\"task-list-item-checkbox\" checked=\"\"" + o$2 + "type=\"checkbox\">"), n$3;
}, Tt = (e$1, t$1, r$2) => {
	if (e$1.children = e$1.children || [], e$1.children.unshift(kt(e$1, t$1, r$2)), e$1.children[1].content = e$1.children[1].content.slice(3), e$1.content = e$1.content.slice(3), r$2.label) if (r$2.labelAfter) {
		e$1.children.pop();
		const n$3 = "task-item-" + Math.ceil(Math.random() * (1e4 * 1e3) - 1e3);
		e$1.children[0].content = e$1.children[0].content.slice(0, -1) + " id=\"" + n$3 + "\">", e$1.children.push(Et(e$1.content, n$3, t$1));
	} else e$1.children.unshift(wt(t$1)), e$1.children.push(Ct(t$1));
}, It = (e$1, t$1 = {}) => {
	e$1.core.ruler.after("inline", "github-task-lists", (r$2) => {
		const n$3 = r$2.tokens;
		for (let o$2 = 2; o$2 < n$3.length; o$2++) bt(n$3, o$2) && (Tt(n$3[o$2], r$2.Token, t$1), $e(n$3[o$2 - 2], "class", "task-list-item" + (t$1.enabled ? " enabled" : " ")), $e(n$3[$t(n$3, o$2 - 2)], "class", "contains-task-list"));
	});
}, St = (e$1) => {
	e$1.core.ruler.push("init-line-number", (t$1) => (t$1.tokens.forEach((r$2) => {
		r$2.map && (r$2.attrs || (r$2.attrs = []), r$2.attrs.push(["data-line", r$2.map[0].toString()]));
	}), !0));
}, xt = (e$1, t$1) => {
	const { editorConfig: r$2, markdownItConfig: n$3, markdownItPlugins: o$2, editorExtensions: u$4 } = h$1, c$2 = inject("editorId"), m$2 = inject("language"), s$2 = inject("usedLanguageText"), l$2 = inject("showCodeRowNumber"), i$3 = inject("theme"), a$2 = inject("customIcon"), d$2 = inject("rootRef"), $$1 = inject("setting"), h$6 = ref([]), p$3 = at(e$1), g$4 = rt(e$1), { reRenderRef: I$1, replaceMermaid: v$2 } = lt(e$1), { reRenderEcharts: C$2, replaceEcharts: x$1 } = ot(e$1), b$2 = lib_default({
		html: !0,
		breaks: !0,
		linkify: !0
	});
	n$3(b$2, { editorId: c$2 });
	const F$2 = [
		{
			type: "image",
			plugin: r$1,
			options: {
				figcaption: !0,
				classes: "md-zoom"
			}
		},
		{
			type: "admonition",
			plugin: it,
			options: {}
		},
		{
			type: "taskList",
			plugin: It,
			options: {}
		},
		{
			type: "heading",
			plugin: dt,
			options: {
				mdHeadingId: e$1.mdHeadingId,
				headsRef: h$6
			}
		},
		{
			type: "code",
			plugin: st,
			options: {
				editorId: c$2,
				usedLanguageTextRef: s$2,
				codeFoldable: e$1.codeFoldable,
				autoFoldThreshold: e$1.autoFoldThreshold,
				customIconRef: a$2
			}
		},
		{
			type: "sub",
			plugin: sub_plugin,
			options: {}
		},
		{
			type: "sup",
			plugin: sup_plugin,
			options: {}
		}
	];
	e$1.noKatex || F$2.push({
		type: "katex",
		plugin: ft,
		options: { katexRef: g$4 }
	}), e$1.noMermaid || F$2.push({
		type: "mermaid",
		plugin: ht,
		options: { themeRef: i$3 }
	}), e$1.noEcharts || F$2.push({
		type: "echarts",
		plugin: ct,
		options: { themeRef: i$3 }
	}), o$2(F$2, { editorId: c$2 }).forEach((k$2) => {
		b$2.use(k$2.plugin, k$2.options);
	});
	const S$2 = b$2.options.highlight;
	b$2.set({ highlight: (k$2, A$2, J$1) => {
		if (S$2) {
			const W$2 = S$2(k$2, A$2, J$1);
			if (W$2) return W$2;
		}
		let j$4;
		!e$1.noHighlight && p$3.value ? p$3.value.getLanguage(A$2) ? j$4 = p$3.value.highlight(k$2, {
			language: A$2,
			ignoreIllegals: !0
		}).value : j$4 = p$3.value.highlightAuto(k$2).value : j$4 = b$2.utils.escapeHtml(k$2);
		const ne$1 = l$2 ? l(j$4.replace(/^\n+|\n+$/g, ""), k$2.replace(/^\n+|\n+$/g, "")) : `<span class="${p$1}-code-block">${j$4.replace(/^\n+|\n+$/g, "")}</span>`;
		return `<pre><code class="language-${A$2}" language=${A$2}>${ne$1}</code></pre>`;
	} }), St(b$2);
	const L$2 = ref(`_article-key_${W$1()}`), _$2 = ref(e$1.sanitize(b$2.render(e$1.modelValue, { srcLines: e$1.modelValue.split(`
`) })));
	let B$1 = () => {}, D$2 = () => {};
	const q = () => {
		const k$2 = d$2.value?.querySelectorAll(`#${c$2} p.${p$1}-mermaid:not([data-closed=false])`);
		D$2(), D$2 = V$1(k$2, { customIcon: a$2.value }), u$4.mermaid?.enableZoom && (B$1(), B$1 = R$1(k$2, { customIcon: a$2.value }));
	}, V$2 = () => {
		F$1.emit(c$2, L$1, _$2.value), e$1.onHtmlChanged(_$2.value), e$1.onGetCatalog(h$6.value), F$1.emit(c$2, S$1, h$6.value), nextTick(() => {
			v$2().then(q), x$1();
		});
	}, z$2 = () => {
		h$6.value = [], _$2.value = e$1.sanitize(b$2.render(e$1.modelValue, { srcLines: e$1.modelValue.split(`
`) }));
	}, K$1 = computed(() => (e$1.noKatex || !!g$4.value) && (e$1.noHighlight || !!p$3.value));
	let Z$1 = -1;
	return watch([
		toRef(e$1, "modelValue"),
		K$1,
		I$1,
		m$2
	], () => {
		Z$1 = window.setTimeout(() => {
			z$2();
		}, t$1 ? 0 : r$2.renderDelay);
	}), watch(() => $$1.value.preview, () => {
		$$1.value.preview && nextTick(() => {
			v$2().then(q), x$1(), F$1.emit(c$2, S$1, h$6.value);
		});
	}), watch([_$2, C$2], () => {
		V$2();
	}), onMounted(V$2), onMounted(() => {
		F$1.on(c$2, {
			name: H,
			callback() {
				F$1.emit(c$2, S$1, h$6.value);
			}
		}), F$1.on(c$2, {
			name: D,
			callback: () => {
				L$2.value = `_article-key_${W$1()}`, z$2();
			}
		});
	}), onBeforeUnmount(() => {
		B$1(), D$2(), clearTimeout(Z$1);
	}), {
		html: _$2,
		key: L$2
	};
}, Ft = (e$1, t$1) => {
	const r$2 = inject("editorId"), n$3 = inject("setting"), { noImgZoomIn: o$2 } = e$1, u$4 = x(() => {
		const c$2 = document.querySelectorAll(`#${r$2}-preview img:not(.not-zoom):not(.medium-zoom-image)`);
		c$2.length !== 0 && medium_zoom_esm_default(c$2, { background: "#00000073" });
	});
	onMounted(async () => {
		!o$2 && n$3.value.preview && await u$4();
	}), watch([t$1, () => n$3.value.preview], async () => {
		!o$2 && n$3.value.preview && await u$4();
	});
}, we = {
	checked: {
		regexp: /- \[x\]/,
		value: "- [ ]"
	},
	unChecked: {
		regexp: /- \[\s\]/,
		value: "- [x]"
	}
}, Rt = (e$1, t$1) => {
	const r$2 = inject("editorId"), n$3 = inject("rootRef");
	let o$2 = () => {};
	const u$4 = () => {
		if (!n$3.value) return !1;
		const c$2 = n$3.value.querySelectorAll(".task-list-item.enabled"), m$2 = (s$2) => {
			s$2.preventDefault();
			const l$2 = s$2.target.checked ? "unChecked" : "checked", i$3 = s$2.target.parentElement?.dataset.line;
			if (!i$3) return;
			const a$2 = Number(i$3), d$2 = e$1.modelValue.split(`
`), $$1 = d$2[Number(a$2)].replace(we[l$2].regexp, we[l$2].value);
			e$1.previewOnly ? (d$2[Number(a$2)] = $$1, e$1.onChange(d$2.join(`
`))) : F$1.emit(r$2, O, a$2 + 1, $$1);
		};
		c$2.forEach((s$2) => {
			s$2.addEventListener("click", m$2);
		}), o$2 = () => {
			c$2.forEach((s$2) => {
				s$2.removeEventListener("click", m$2);
			});
		};
	};
	onBeforeUnmount(() => {
		o$2();
	}), watch([t$1], () => {
		o$2(), nextTick(u$4);
	}, { immediate: !0 });
}, At = (e$1, t$1, r$2) => {
	const n$3 = inject("setting"), o$2 = () => {
		nextTick(() => {
			e$1.onRemount?.();
		});
	}, u$4 = (c$2) => {
		c$2 && o$2();
	};
	watch([t$1, r$2], o$2), watch(() => n$3.value.preview, u$4), watch(() => n$3.value.htmlPreview, u$4), onMounted(o$2);
}, Ie$2 = {
	modelValue: {
		type: String,
		default: ""
	},
	onChange: {
		type: Function,
		default: () => {}
	},
	onHtmlChanged: {
		type: Function,
		default: () => {}
	},
	onGetCatalog: {
		type: Function,
		default: () => {}
	},
	mdHeadingId: {
		type: Function,
		default: () => ""
	},
	noMermaid: {
		type: Boolean,
		default: !1
	},
	sanitize: {
		type: Function,
		default: (e$1) => e$1
	},
	noKatex: {
		type: Boolean,
		default: !1
	},
	formatCopiedText: {
		type: Function,
		default: (e$1) => e$1
	},
	noHighlight: {
		type: Boolean,
		default: !1
	},
	previewOnly: {
		type: Boolean,
		default: !1
	},
	noImgZoomIn: { type: Boolean },
	sanitizeMermaid: { type: Function },
	codeFoldable: { type: Boolean },
	autoFoldThreshold: { type: Number },
	onRemount: { type: Function },
	noEcharts: { type: Boolean },
	previewComponent: {
		type: [Object, Function],
		default: void 0
	}
}, on = {
	...Ie$2,
	updateModelValue: {
		type: Function,
		default: () => {}
	},
	placeholder: {
		type: String,
		default: ""
	},
	scrollAuto: { type: Boolean },
	autofocus: { type: Boolean },
	readonly: { type: Boolean },
	maxlength: { type: Number },
	autoDetectCode: { type: Boolean },
	onBlur: {
		type: Function,
		default: () => {}
	},
	onFocus: {
		type: Function,
		default: () => {}
	},
	completions: { type: Array },
	onInput: { type: Function },
	onDrop: {
		type: Function,
		default: () => {}
	},
	inputBoxWidth: { type: String },
	oninputBoxWidthChange: { type: Function },
	transformImgUrl: {
		type: Function,
		default: (e$1) => e$1
	},
	catalogLayout: { type: String },
	catalogMaxDepth: { type: Number }
}, Ce$1 = (e$1) => {
	const r$2 = new DOMParser().parseFromString(e$1, "text/html");
	return Array.from(r$2.body.childNodes);
}, Ht = (e$1, t$1) => e$1.nodeType !== t$1.nodeType ? !1 : e$1.nodeType === Node.TEXT_NODE || e$1.nodeType === Node.COMMENT_NODE ? e$1.textContent === t$1.textContent : e$1.nodeType === Node.ELEMENT_NODE ? e$1.outerHTML === t$1.outerHTML : e$1.isEqualNode ? e$1.isEqualNode(t$1) : !1, Mt = /* @__PURE__ */ defineComponent({
	name: "UpdateOnDemand",
	props: {
		id: {
			type: String,
			required: !0
		},
		class: {
			type: [
				String,
				Array,
				Object
			],
			required: !0
		},
		html: {
			type: String,
			required: !0
		}
	},
	setup(e$1) {
		const t$1 = ref(), r$2 = e$1.html, n$3 = (o$2, u$4) => {
			if (!t$1.value) return;
			const c$2 = t$1.value, m$2 = Array.from(c$2.childNodes), s$2 = Math.min(o$2.length, u$4.length);
			let l$2 = -1;
			for (let a$2 = 0; a$2 < s$2; a$2++) if (!Ht(o$2[a$2], u$4[a$2])) {
				l$2 = a$2;
				break;
			}
			if (l$2 === -1) if (u$4.length > o$2.length) l$2 = o$2.length;
			else if (o$2.length > u$4.length) l$2 = u$4.length;
			else return;
			const i$3 = Math.min(l$2, m$2.length);
			for (let a$2 = m$2.length - 1; a$2 >= i$3; a$2--) m$2[a$2].remove();
			for (let a$2 = l$2; a$2 < o$2.length; a$2++) c$2.appendChild(o$2[a$2].cloneNode(!0));
		};
		return watch(() => e$1.html, (o$2, u$4) => {
			const c$2 = Ce$1(o$2), m$2 = Ce$1(u$4 || "");
			n$3(c$2, m$2);
		}), () => createVNode("div", {
			id: e$1.id,
			class: e$1.class,
			innerHTML: r$2,
			ref: t$1
		}, null);
	}
}), Pt = /* @__PURE__ */ defineComponent({
	name: "ContentPreview",
	props: Ie$2,
	setup(e$1) {
		const t$1 = inject("editorId"), r$2 = inject("setting"), n$3 = inject("previewTheme"), o$2 = inject("showCodeRowNumber"), { html: u$4, key: c$2 } = xt(e$1, e$1.previewOnly);
		nt(e$1, u$4, c$2), Ft(e$1, u$4), Rt(e$1, u$4), At(e$1, u$4, c$2);
		const m$2 = computed(() => [
			`${p$1}-preview`,
			`${n$3?.value}-theme`,
			o$2 && `${p$1}-scrn`
		].filter(Boolean)), s$2 = () => {
			const l$2 = `${t$1}-preview`;
			return e$1.previewComponent ? h$4(e$1.previewComponent, {
				key: c$2.value,
				html: u$4.value,
				id: l$2,
				class: m$2.value
			}) : createVNode(Mt, {
				key: c$2.value,
				html: u$4.value,
				id: l$2,
				class: m$2.value
			}, null);
		};
		return () => createVNode(Fragment, null, [r$2.value.preview && (e$1.previewOnly ? s$2() : createVNode("div", {
			id: `${t$1}-preview-wrapper`,
			class: `${p$1}-preview-wrapper`,
			key: "content-preview-wrapper"
		}, [s$2()])), r$2.value.htmlPreview && createVNode("div", {
			id: `${t$1}-html-wrapper`,
			class: `${p$1}-preview-wrapper`,
			key: "html-preview-wrapper"
		}, [createVNode("div", { class: `${p$1}-html` }, [u$4.value])])]);
	}
}), Lt = ({ text: e$1 }) => e$1, Se$1 = {
	modelValue: {
		type: String,
		default: ""
	},
	onChange: {
		type: Function,
		default: void 0
	},
	theme: {
		type: String,
		default: "light"
	},
	class: {
		type: String,
		default: ""
	},
	language: {
		type: String,
		default: "zh-CN"
	},
	onHtmlChanged: {
		type: Function,
		default: void 0
	},
	onGetCatalog: {
		type: Function,
		default: void 0
	},
	editorId: {
		type: String,
		default: void 0
	},
	id: {
		type: String,
		default: void 0
	},
	showCodeRowNumber: {
		type: Boolean,
		default: !0
	},
	previewTheme: {
		type: String,
		default: "default"
	},
	style: {
		type: Object,
		default: () => ({})
	},
	mdHeadingId: {
		type: Function,
		default: Lt
	},
	sanitize: {
		type: Function,
		default: (e$1) => e$1
	},
	noMermaid: {
		type: Boolean,
		default: !1
	},
	noKatex: {
		type: Boolean,
		default: !1
	},
	codeTheme: {
		type: String,
		default: "atom"
	},
	formatCopiedText: {
		type: Function,
		default: (e$1) => e$1
	},
	codeStyleReverse: {
		type: Boolean,
		default: !0
	},
	codeStyleReverseList: {
		type: Array,
		default: ["default", "mk-cute"]
	},
	noHighlight: {
		type: Boolean,
		default: !1
	},
	noImgZoomIn: {
		type: Boolean,
		default: !1
	},
	customIcon: {
		type: Object,
		default: {}
	},
	sanitizeMermaid: {
		type: Function,
		default: (e$1) => Promise.resolve(e$1)
	},
	codeFoldable: {
		type: Boolean,
		default: !0
	},
	autoFoldThreshold: {
		type: Number,
		default: 30
	},
	onRemount: {
		type: Function,
		default: void 0
	},
	noEcharts: {
		type: Boolean,
		default: !1
	},
	previewComponent: {
		type: [Object, Function],
		default: void 0
	}
}, an = {
	...Se$1,
	onSave: {
		type: Function,
		default: void 0
	},
	onUploadImg: {
		type: Function,
		default: void 0
	},
	pageFullscreen: {
		type: Boolean,
		default: !1
	},
	preview: {
		type: Boolean,
		default: !0
	},
	htmlPreview: {
		type: Boolean,
		default: !1
	},
	toolbars: {
		type: Array,
		default: k
	},
	floatingToolbars: {
		type: Array,
		default: []
	},
	toolbarsExclude: {
		type: Array,
		default: []
	},
	noPrettier: {
		type: Boolean,
		default: !1
	},
	tabWidth: {
		type: Number,
		default: 2
	},
	tableShape: {
		type: Array,
		default: [6, 4]
	},
	placeholder: {
		type: String,
		default: ""
	},
	defToolbars: {
		type: [String, Object],
		default: void 0
	},
	onError: {
		type: Function,
		default: void 0
	},
	footers: {
		type: Array,
		default: b
	},
	scrollAuto: {
		type: Boolean,
		default: !0
	},
	defFooters: {
		type: [String, Object],
		default: void 0
	},
	noUploadImg: {
		type: Boolean,
		default: !1
	},
	autoFocus: {
		type: Boolean,
		default: !1
	},
	disabled: {
		type: Boolean,
		default: !1
	},
	readOnly: {
		type: Boolean,
		default: !1
	},
	maxLength: {
		type: Number,
		default: void 0
	},
	autoDetectCode: {
		type: Boolean,
		default: !1
	},
	onBlur: {
		type: Function,
		default: void 0
	},
	onFocus: {
		type: Function,
		default: void 0
	},
	completions: {
		type: Array,
		default: void 0
	},
	showToolbarName: {
		type: Boolean,
		default: !1
	},
	onInput: {
		type: Function,
		default: void 0
	},
	onDrop: {
		type: Function,
		default: void 0
	},
	inputBoxWidth: {
		type: String,
		default: "50%"
	},
	oninputBoxWidthChange: {
		type: Function,
		default: void 0
	},
	transformImgUrl: {
		type: Function,
		default: (e$1) => e$1
	},
	catalogLayout: {
		type: String,
		default: "fixed"
	},
	catalogMaxDepth: {
		type: Number,
		default: void 0
	}
}, xe$2 = [
	"onHtmlChanged",
	"onGetCatalog",
	"onChange",
	"onRemount",
	"update:modelValue"
], rn = [
	...xe$2,
	"onSave",
	"onUploadImg",
	"onError",
	"onBlur",
	"onFocus",
	"onInput",
	"onDrop",
	"oninputBoxWidthChange"
], Ot = (e$1, t$1, r$2) => {
	const { editorId: n$3 } = r$2;
	t$1.expose({ rerender() {
		F$1.emit(n$3, D);
	} });
}, ae = /* @__PURE__ */ defineComponent({
	name: "MdPreview",
	props: Se$1,
	emits: xe$2,
	setup(e$1, t$1) {
		const { noKatex: r$2, noMermaid: n$3, noHighlight: o$2 } = e$1, u$4 = ref(), c$2 = tt(e$1);
		Te(e$1, {
			rootRef: u$4,
			editorId: c$2
		}), Ot(e$1, t$1, { editorId: c$2 }), onBeforeUnmount(() => {
			F$1.clear(c$2);
		});
		const m$2 = (a$2) => {
			e$1.onChange?.(a$2), t$1.emit("onChange", a$2), t$1.emit("update:modelValue", a$2);
		}, s$2 = (a$2) => {
			e$1.onHtmlChanged?.(a$2), t$1.emit("onHtmlChanged", a$2);
		}, l$2 = (a$2) => {
			e$1.onGetCatalog?.(a$2), t$1.emit("onGetCatalog", a$2);
		}, i$3 = () => {
			e$1.onRemount?.(), t$1.emit("onRemount");
		};
		return () => createVNode("div", {
			id: c$2,
			class: [
				p$1,
				e$1.class,
				e$1.theme === "dark" && `${p$1}-dark`,
				`${p$1}-previewOnly`
			],
			style: e$1.style,
			ref: u$4
		}, [createVNode(Pt, {
			modelValue: e$1.modelValue,
			onChange: m$2,
			onHtmlChanged: s$2,
			onGetCatalog: l$2,
			mdHeadingId: e$1.mdHeadingId,
			noMermaid: n$3,
			sanitize: e$1.sanitize,
			noKatex: r$2,
			formatCopiedText: e$1.formatCopiedText,
			noHighlight: o$2,
			noImgZoomIn: e$1.noImgZoomIn,
			previewOnly: !0,
			sanitizeMermaid: e$1.sanitizeMermaid,
			codeFoldable: e$1.codeFoldable,
			autoFoldThreshold: e$1.autoFoldThreshold,
			onRemount: i$3,
			noEcharts: e$1.noEcharts,
			previewComponent: e$1.previewComponent
		}, null)]);
	}
});
ae.install = (e$1) => (e$1.component(ae.name, ae), e$1);

//#endregion
//#region node_modules/lucide-vue-next/dist/esm/shared/src/utils.js
/**
* @license lucide-vue-next v0.543.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
var toKebabCase = (string) => string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
var toCamelCase = (string) => string.replace(/^([A-Z])|[\s-_]+(\w)/g, (match, p1, p2) => p2 ? p2.toUpperCase() : p1.toLowerCase());
var toPascalCase = (string) => {
	const camelCase = toCamelCase(string);
	return camelCase.charAt(0).toUpperCase() + camelCase.slice(1);
};
var mergeClasses = (...classes) => classes.filter((className, index, array) => {
	return Boolean(className) && className.trim() !== "" && array.indexOf(className) === index;
}).join(" ").trim();
var isEmptyString = (value) => value === "";

//#endregion
//#region node_modules/lucide-vue-next/dist/esm/defaultAttributes.js
/**
* @license lucide-vue-next v0.543.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
var defaultAttributes = {
	xmlns: "http://www.w3.org/2000/svg",
	width: 24,
	height: 24,
	viewBox: "0 0 24 24",
	fill: "none",
	stroke: "currentColor",
	"stroke-width": 2,
	"stroke-linecap": "round",
	"stroke-linejoin": "round"
};

//#endregion
//#region node_modules/lucide-vue-next/dist/esm/Icon.js
var Icon = ({ name, iconNode, absoluteStrokeWidth, "absolute-stroke-width": absoluteStrokeWidthKebabCase, strokeWidth, "stroke-width": strokeWidthKebabCase, size = defaultAttributes.width, color = defaultAttributes.stroke,...props }, { slots }) => {
	return h$4("svg", {
		...defaultAttributes,
		...props,
		width: size,
		height: size,
		stroke: color,
		"stroke-width": isEmptyString(absoluteStrokeWidth) || isEmptyString(absoluteStrokeWidthKebabCase) || absoluteStrokeWidth === true || absoluteStrokeWidthKebabCase === true ? Number(strokeWidth || strokeWidthKebabCase || defaultAttributes["stroke-width"]) * 24 / Number(size) : strokeWidth || strokeWidthKebabCase || defaultAttributes["stroke-width"],
		class: mergeClasses("lucide", props.class, ...name ? [`lucide-${toKebabCase(toPascalCase(name))}-icon`, `lucide-${toKebabCase(name)}`] : ["lucide-icon"])
	}, [...iconNode.map((child) => h$4(...child)), ...slots.default ? [slots.default()] : []]);
};

//#endregion
//#region node_modules/lucide-vue-next/dist/esm/createLucideIcon.js
var createLucideIcon = (iconName, iconNode) => (props, { slots, attrs }) => h$4(Icon, {
	...attrs,
	...props,
	iconNode,
	name: iconName
}, slots);

//#endregion
//#region node_modules/lucide-vue-next/dist/esm/icons/bold.js
var Bold = createLucideIcon("bold", [["path", {
	d: "M6 12h9a4 4 0 0 1 0 8H7a1 1 0 0 1-1-1V5a1 1 0 0 1 1-1h7a4 4 0 0 1 0 8",
	key: "mg9rjx"
}]]);

//#endregion
//#region node_modules/lucide-vue-next/dist/esm/icons/chart-area.js
var ChartArea = createLucideIcon("chart-area", [["path", {
	d: "M3 3v16a2 2 0 0 0 2 2h16",
	key: "c24i48"
}], ["path", {
	d: "M7 11.207a.5.5 0 0 1 .146-.353l2-2a.5.5 0 0 1 .708 0l3.292 3.292a.5.5 0 0 0 .708 0l4.292-4.292a.5.5 0 0 1 .854.353V16a1 1 0 0 1-1 1H8a1 1 0 0 1-1-1z",
	key: "q0gr47"
}]]);

//#endregion
//#region node_modules/lucide-vue-next/dist/esm/icons/code-xml.js
var CodeXml = createLucideIcon("code-xml", [
	["path", {
		d: "m18 16 4-4-4-4",
		key: "1inbqp"
	}],
	["path", {
		d: "m6 8-4 4 4 4",
		key: "15zrgr"
	}],
	["path", {
		d: "m14.5 4-5 16",
		key: "e7oirm"
	}]
]);

//#endregion
//#region node_modules/lucide-vue-next/dist/esm/icons/code.js
var Code = createLucideIcon("code", [["path", {
	d: "m16 18 6-6-6-6",
	key: "eg8j8"
}], ["path", {
	d: "m8 6-6 6 6 6",
	key: "ppft3o"
}]]);

//#endregion
//#region node_modules/lucide-vue-next/dist/esm/icons/expand.js
var Expand = createLucideIcon("expand", [
	["path", {
		d: "m15 15 6 6",
		key: "1s409w"
	}],
	["path", {
		d: "m15 9 6-6",
		key: "ko1vev"
	}],
	["path", {
		d: "M21 16v5h-5",
		key: "1ck2sf"
	}],
	["path", {
		d: "M21 8V3h-5",
		key: "1qoq8a"
	}],
	["path", {
		d: "M3 16v5h5",
		key: "1t08am"
	}],
	["path", {
		d: "m3 21 6-6",
		key: "wwnumi"
	}],
	["path", {
		d: "M3 8V3h5",
		key: "1ln10m"
	}],
	["path", {
		d: "M9 9 3 3",
		key: "v551iv"
	}]
]);

//#endregion
//#region node_modules/lucide-vue-next/dist/esm/icons/eye.js
var Eye = createLucideIcon("eye", [["path", {
	d: "M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0",
	key: "1nclc0"
}], ["circle", {
	cx: "12",
	cy: "12",
	r: "3",
	key: "1v7zrd"
}]]);

//#endregion
//#region node_modules/lucide-vue-next/dist/esm/icons/forward.js
var Forward = createLucideIcon("forward", [["path", {
	d: "m15 17 5-5-5-5",
	key: "nf172w"
}], ["path", {
	d: "M4 18v-2a4 4 0 0 1 4-4h12",
	key: "jmiej9"
}]]);

//#endregion
//#region node_modules/lucide-vue-next/dist/esm/icons/heading.js
var Heading = createLucideIcon("heading", [
	["path", {
		d: "M6 12h12",
		key: "8npq4p"
	}],
	["path", {
		d: "M6 20V4",
		key: "1w1bmo"
	}],
	["path", {
		d: "M18 20V4",
		key: "o2hl4u"
	}]
]);

//#endregion
//#region node_modules/lucide-vue-next/dist/esm/icons/image.js
var Image = createLucideIcon("image", [
	["rect", {
		width: "18",
		height: "18",
		x: "3",
		y: "3",
		rx: "2",
		ry: "2",
		key: "1m3agn"
	}],
	["circle", {
		cx: "9",
		cy: "9",
		r: "2",
		key: "af1f0g"
	}],
	["path", {
		d: "m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21",
		key: "1xmnt7"
	}]
]);

//#endregion
//#region node_modules/lucide-vue-next/dist/esm/icons/italic.js
var Italic = createLucideIcon("italic", [
	["line", {
		x1: "19",
		x2: "10",
		y1: "4",
		y2: "4",
		key: "15jd3p"
	}],
	["line", {
		x1: "14",
		x2: "5",
		y1: "20",
		y2: "20",
		key: "bu0au3"
	}],
	["line", {
		x1: "15",
		x2: "9",
		y1: "4",
		y2: "20",
		key: "uljnxc"
	}]
]);

//#endregion
//#region node_modules/lucide-vue-next/dist/esm/icons/link.js
var Link = createLucideIcon("link", [["path", {
	d: "M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71",
	key: "1cjeqo"
}], ["path", {
	d: "M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71",
	key: "19qd67"
}]]);

//#endregion
//#region node_modules/lucide-vue-next/dist/esm/icons/list-ordered.js
var ListOrdered = createLucideIcon("list-ordered", [
	["path", {
		d: "M11 5h10",
		key: "1cz7ny"
	}],
	["path", {
		d: "M11 12h10",
		key: "1438ji"
	}],
	["path", {
		d: "M11 19h10",
		key: "11t30w"
	}],
	["path", {
		d: "M4 4h1v5",
		key: "10yrso"
	}],
	["path", {
		d: "M4 9h2",
		key: "r1h2o0"
	}],
	["path", {
		d: "M6.5 20H3.4c0-1 2.6-1.925 2.6-3.5a1.5 1.5 0 0 0-2.6-1.02",
		key: "xtkcd5"
	}]
]);

//#endregion
//#region node_modules/lucide-vue-next/dist/esm/icons/list-todo.js
var ListTodo = createLucideIcon("list-todo", [
	["path", {
		d: "M13 5h8",
		key: "a7qcls"
	}],
	["path", {
		d: "M13 12h8",
		key: "h98zly"
	}],
	["path", {
		d: "M13 19h8",
		key: "c3s6r1"
	}],
	["path", {
		d: "m3 17 2 2 4-4",
		key: "1jhpwq"
	}],
	["rect", {
		x: "3",
		y: "4",
		width: "6",
		height: "6",
		rx: "1",
		key: "cif1o7"
	}]
]);

//#endregion
//#region node_modules/lucide-vue-next/dist/esm/icons/list-tree.js
var ListTree = createLucideIcon("list-tree", [
	["path", {
		d: "M8 5h13",
		key: "1pao27"
	}],
	["path", {
		d: "M13 12h8",
		key: "h98zly"
	}],
	["path", {
		d: "M13 19h8",
		key: "c3s6r1"
	}],
	["path", {
		d: "M3 10a2 2 0 0 0 2 2h3",
		key: "1npucw"
	}],
	["path", {
		d: "M3 5v12a2 2 0 0 0 2 2h3",
		key: "x1gjn2"
	}]
]);

//#endregion
//#region node_modules/lucide-vue-next/dist/esm/icons/list.js
var List = createLucideIcon("list", [
	["path", {
		d: "M3 5h.01",
		key: "18ugdj"
	}],
	["path", {
		d: "M3 12h.01",
		key: "nlz23k"
	}],
	["path", {
		d: "M3 19h.01",
		key: "noohij"
	}],
	["path", {
		d: "M8 5h13",
		key: "1pao27"
	}],
	["path", {
		d: "M8 12h13",
		key: "1za7za"
	}],
	["path", {
		d: "M8 19h13",
		key: "m83p4d"
	}]
]);

//#endregion
//#region node_modules/lucide-vue-next/dist/esm/icons/maximize-2.js
var Maximize2 = createLucideIcon("maximize-2", [
	["path", {
		d: "M15 3h6v6",
		key: "1q9fwt"
	}],
	["path", {
		d: "m21 3-7 7",
		key: "1l2asr"
	}],
	["path", {
		d: "m3 21 7-7",
		key: "tjx5ai"
	}],
	["path", {
		d: "M9 21H3v-6",
		key: "wtvkvv"
	}]
]);

//#endregion
//#region node_modules/lucide-vue-next/dist/esm/icons/minimize-2.js
var Minimize2 = createLucideIcon("minimize-2", [
	["path", {
		d: "m14 10 7-7",
		key: "oa77jy"
	}],
	["path", {
		d: "M20 10h-6V4",
		key: "mjg0md"
	}],
	["path", {
		d: "m3 21 7-7",
		key: "tjx5ai"
	}],
	["path", {
		d: "M4 14h6v6",
		key: "rmj7iw"
	}]
]);

//#endregion
//#region node_modules/lucide-vue-next/dist/esm/icons/quote.js
var Quote = createLucideIcon("quote", [["path", {
	d: "M16 3a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2 1 1 0 0 1 1 1v1a2 2 0 0 1-2 2 1 1 0 0 0-1 1v2a1 1 0 0 0 1 1 6 6 0 0 0 6-6V5a2 2 0 0 0-2-2z",
	key: "rib7q0"
}], ["path", {
	d: "M5 3a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2 1 1 0 0 1 1 1v1a2 2 0 0 1-2 2 1 1 0 0 0-1 1v2a1 1 0 0 0 1 1 6 6 0 0 0 6-6V5a2 2 0 0 0-2-2z",
	key: "1ymkrd"
}]]);

//#endregion
//#region node_modules/lucide-vue-next/dist/esm/icons/reply.js
var Reply = createLucideIcon("reply", [["path", {
	d: "M20 18v-2a4 4 0 0 0-4-4H4",
	key: "5vmcpk"
}], ["path", {
	d: "m9 17-5-5 5-5",
	key: "nvlc11"
}]]);

//#endregion
//#region node_modules/lucide-vue-next/dist/esm/icons/save.js
var Save = createLucideIcon("save", [
	["path", {
		d: "M15.2 3a2 2 0 0 1 1.4.6l3.8 3.8a2 2 0 0 1 .6 1.4V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2z",
		key: "1c8476"
	}],
	["path", {
		d: "M17 21v-7a1 1 0 0 0-1-1H8a1 1 0 0 0-1 1v7",
		key: "1ydtos"
	}],
	["path", {
		d: "M7 3v4a1 1 0 0 0 1 1h7",
		key: "t51u73"
	}]
]);

//#endregion
//#region node_modules/lucide-vue-next/dist/esm/icons/shrink.js
var Shrink = createLucideIcon("shrink", [
	["path", {
		d: "m15 15 6 6m-6-6v4.8m0-4.8h4.8",
		key: "17vawe"
	}],
	["path", {
		d: "M9 19.8V15m0 0H4.2M9 15l-6 6",
		key: "chjx8e"
	}],
	["path", {
		d: "M15 4.2V9m0 0h4.8M15 9l6-6",
		key: "lav6yq"
	}],
	["path", {
		d: "M9 4.2V9m0 0H4.2M9 9 3 3",
		key: "1pxi2q"
	}]
]);

//#endregion
//#region node_modules/lucide-vue-next/dist/esm/icons/square-code.js
var SquareCode = createLucideIcon("square-code", [
	["path", {
		d: "m10 9-3 3 3 3",
		key: "1oro0q"
	}],
	["path", {
		d: "m14 15 3-3-3-3",
		key: "bz13h7"
	}],
	["rect", {
		x: "3",
		y: "3",
		width: "18",
		height: "18",
		rx: "2",
		key: "h1oib"
	}]
]);

//#endregion
//#region node_modules/lucide-vue-next/dist/esm/icons/square-sigma.js
var SquareSigma = createLucideIcon("square-sigma", [["rect", {
	width: "18",
	height: "18",
	x: "3",
	y: "3",
	rx: "2",
	key: "afitv7"
}], ["path", {
	d: "M16 8.9V7H8l4 5-4 5h8v-1.9",
	key: "9nih0i"
}]]);

//#endregion
//#region node_modules/lucide-vue-next/dist/esm/icons/strikethrough.js
var Strikethrough = createLucideIcon("strikethrough", [
	["path", {
		d: "M16 4H9a3 3 0 0 0-2.83 4",
		key: "43sutm"
	}],
	["path", {
		d: "M14 12a4 4 0 0 1 0 8H6",
		key: "nlfj13"
	}],
	["line", {
		x1: "4",
		x2: "20",
		y1: "12",
		y2: "12",
		key: "1e0a9i"
	}]
]);

//#endregion
//#region node_modules/lucide-vue-next/dist/esm/icons/subscript.js
var Subscript = createLucideIcon("subscript", [
	["path", {
		d: "m4 5 8 8",
		key: "1eunvl"
	}],
	["path", {
		d: "m12 5-8 8",
		key: "1ah0jp"
	}],
	["path", {
		d: "M20 19h-4c0-1.5.44-2 1.5-2.5S20 15.33 20 14c0-.47-.17-.93-.48-1.29a2.11 2.11 0 0 0-2.62-.44c-.42.24-.74.62-.9 1.07",
		key: "e8ta8j"
	}]
]);

//#endregion
//#region node_modules/lucide-vue-next/dist/esm/icons/superscript.js
var Superscript = createLucideIcon("superscript", [
	["path", {
		d: "m4 19 8-8",
		key: "hr47gm"
	}],
	["path", {
		d: "m12 19-8-8",
		key: "1dhhmo"
	}],
	["path", {
		d: "M20 12h-4c0-1.5.442-2 1.5-2.5S20 8.334 20 7.002c0-.472-.17-.93-.484-1.29a2.105 2.105 0 0 0-2.617-.436c-.42.239-.738.614-.899 1.06",
		key: "1dfcux"
	}]
]);

//#endregion
//#region node_modules/lucide-vue-next/dist/esm/icons/table.js
var Table = createLucideIcon("table", [
	["path", {
		d: "M12 3v18",
		key: "108xh3"
	}],
	["rect", {
		width: "18",
		height: "18",
		x: "3",
		y: "3",
		rx: "2",
		key: "afitv7"
	}],
	["path", {
		d: "M3 9h18",
		key: "1pudct"
	}],
	["path", {
		d: "M3 15h18",
		key: "5xshup"
	}]
]);

//#endregion
//#region node_modules/lucide-vue-next/dist/esm/icons/trash-2.js
var Trash2 = createLucideIcon("trash-2", [
	["path", {
		d: "M10 11v6",
		key: "nco0om"
	}],
	["path", {
		d: "M14 11v6",
		key: "outv1u"
	}],
	["path", {
		d: "M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6",
		key: "miytrc"
	}],
	["path", {
		d: "M3 6h18",
		key: "d0wm0j"
	}],
	["path", {
		d: "M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2",
		key: "e791ji"
	}]
]);

//#endregion
//#region node_modules/lucide-vue-next/dist/esm/icons/underline.js
var Underline = createLucideIcon("underline", [["path", {
	d: "M6 4v6a6 6 0 0 0 12 0V4",
	key: "9kb039"
}], ["line", {
	x1: "4",
	x2: "20",
	y1: "20",
	y2: "20",
	key: "nun2al"
}]]);

//#endregion
//#region node_modules/lucide-vue-next/dist/esm/icons/upload.js
var Upload = createLucideIcon("upload", [
	["path", {
		d: "M12 3v12",
		key: "1x0j5s"
	}],
	["path", {
		d: "m17 8-5-5-5 5",
		key: "7q97r8"
	}],
	["path", {
		d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4",
		key: "ih7n3h"
	}]
]);

//#endregion
//#region node_modules/lucide-vue-next/dist/esm/icons/view.js
var View = createLucideIcon("view", [
	["path", {
		d: "M21 17v2a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-2",
		key: "mrq65r"
	}],
	["path", {
		d: "M21 7V5a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v2",
		key: "be3xqs"
	}],
	["circle", {
		cx: "12",
		cy: "12",
		r: "1",
		key: "41hilf"
	}],
	["path", {
		d: "M18.944 12.33a1 1 0 0 0 0-.66 7.5 7.5 0 0 0-13.888 0 1 1 0 0 0 0 .66 7.5 7.5 0 0 0 13.888 0",
		key: "11ak4c"
	}]
]);

//#endregion
//#region node_modules/lucide-vue-next/dist/esm/icons/x.js
var X = createLucideIcon("x", [["path", {
	d: "M18 6 6 18",
	key: "1bl5f8"
}], ["path", {
	d: "m6 6 12 12",
	key: "d8bk6v"
}]]);

//#endregion
//#region node_modules/md-editor-v3/lib/es/chunks/index2.mjs
var pe$2 = () => createVNode("svg", {
	xmlns: "http://www.w3.org/2000/svg",
	viewBox: "0 0 24 24",
	fill: "none",
	stroke: "currentColor",
	"stroke-width": "2",
	"stroke-linecap": "round",
	"stroke-linejoin": "round",
	class: "lucide lucide-github-icon"
}, [createVNode("path", { d: "M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4" }, null), createVNode("path", { d: "M9 18c-4.51 2-5-2-7-2" }, null)]), ke$1 = {
	bold: Bold,
	underline: Underline,
	italic: Italic,
	"strike-through": Strikethrough,
	title: Heading,
	sub: Subscript,
	sup: Superscript,
	quote: Quote,
	"unordered-list": List,
	"ordered-list": ListOrdered,
	task: ListTodo,
	"code-row": Code,
	code: SquareCode,
	link: Link,
	image: Image,
	table: Table,
	revoke: Reply,
	next: Forward,
	save: Save,
	prettier: SquareCode,
	minimize: Minimize2,
	maximize: Maximize2,
	"fullscreen-exit": Shrink,
	fullscreen: Expand,
	"preview-only": View,
	preview: Eye,
	"preview-html": CodeXml,
	catalog: ListTree,
	github: pe$2,
	mermaid: ChartArea,
	formula: SquareSigma,
	close: X,
	delete: Trash2,
	upload: Upload
}, xe$1 = /* @__PURE__ */ defineComponent({
	name: `${p$1}-icon-set`,
	props: { name: {
		type: String,
		default: ""
	} },
	setup(e$1) {
		return () => h$4(ke$1[e$1.name], { class: `${p$1}-icon` });
	}
}), P = /* @__PURE__ */ defineComponent({
	name: `${p$1}-icon`,
	props: { name: {
		type: String,
		default: ""
	} },
	setup(e$1) {
		const u$4 = inject("customIcon");
		return () => {
			const a$2 = u$4.value[e$1.name];
			return typeof a$2 == "object" ? typeof a$2.component == "object" ? h$4(a$2.component, a$2.props) : createVNode("span", { innerHTML: a$2.component }, null) : createVNode(xe$1, { name: e$1.name }, null);
		};
	}
}), be$2 = {
	title: {
		type: [String, Object],
		default: ""
	},
	visible: {
		type: Boolean,
		default: !1
	},
	width: {
		type: String,
		default: "auto"
	},
	height: {
		type: String,
		default: "auto"
	},
	onClose: { type: Function },
	showAdjust: {
		type: Boolean,
		default: !1
	},
	isFullscreen: {
		type: Boolean,
		default: !1
	},
	onAdjust: {
		type: Function,
		default: () => {}
	},
	class: {
		type: String,
		default: void 0
	},
	style: {
		type: [Object, String],
		default: () => ({})
	},
	showMask: {
		type: Boolean,
		default: !0
	}
}, S = /* @__PURE__ */ defineComponent({
	name: "MdModal",
	props: be$2,
	emits: ["onClose"],
	setup(e$1, u$4) {
		const a$2 = inject("theme"), $$1 = inject("rootRef"), m$2 = ref(e$1.visible), r$2 = ref([`${p$1}-modal`]), f$3 = ref(), h$6 = ref(), v$2 = ref(), B$1 = shallowRef();
		let d$2 = () => {};
		const n$3 = reactive({
			maskStyle: { zIndex: -1 },
			modalStyle: { zIndex: -1 },
			initPos: {
				insetInlineStart: "0px",
				insetBlockStart: "0px"
			},
			historyPos: {
				insetInlineStart: "0px",
				insetBlockStart: "0px"
			}
		}), F$2 = computed(() => e$1.isFullscreen ? {
			width: "100%",
			height: "100%"
		} : {
			width: e$1.width,
			height: e$1.height
		});
		watch(() => e$1.isFullscreen, (o$2) => {
			o$2 ? d$2() : nextTick(() => {
				d$2 = z$1(h$6.value, (i$3, s$2) => {
					n$3.initPos.insetInlineStart = i$3 + "px", n$3.initPos.insetBlockStart = s$2 + "px";
				});
			});
		}), watch(() => e$1.visible, (o$2) => {
			o$2 ? (n$3.maskStyle.zIndex = h$1.editorConfig.zIndex + m$1(), n$3.modalStyle.zIndex = h$1.editorConfig.zIndex + m$1(), r$2.value.push("zoom-in"), m$2.value = o$2, nextTick(() => {
				const i$3 = f$3.value.offsetWidth / 2, s$2 = f$3.value.offsetHeight / 2, T$1 = document.documentElement.clientWidth / 2, H$2 = document.documentElement.clientHeight / 2;
				n$3.initPos.insetInlineStart = T$1 - i$3 + "px", n$3.initPos.insetBlockStart = H$2 - s$2 + "px", e$1.isFullscreen || (d$2 = z$1(h$6.value, (A$2, L$2) => {
					n$3.initPos.insetInlineStart = A$2 + "px", n$3.initPos.insetBlockStart = L$2 + "px";
				}));
			}), setTimeout(() => {
				r$2.value = r$2.value.filter((i$3) => i$3 !== "zoom-in");
			}, 140)) : (r$2.value.push("zoom-out"), d$2(), setTimeout(() => {
				r$2.value = r$2.value.filter((i$3) => i$3 !== "zoom-out"), m$2.value = o$2;
			}, 130));
		});
		const y$2 = computed(() => ({ display: m$2.value ? "block" : "none" })), R$4 = computed(() => {
			if (typeof e$1.style == "string") {
				const o$2 = Object.entries(y$2.value).map(([i$3, s$2]) => `${i$3}: ${s$2}`).join("; ");
				return [e$1.style, o$2].join("; ");
			} else return e$1.style instanceof Object ? {
				...y$2.value,
				...e$1.style
			} : y$2.value;
		});
		return onMounted(() => {
			const o$2 = $$1.value?.getRootNode();
			v$2.value = o$2 instanceof Document ? document.body : o$2;
		}), () => {
			const o$2 = g({ ctx: u$4 }), i$3 = g({
				props: e$1,
				ctx: u$4
			}, "title");
			return v$2.value ? createVNode(Teleport, { to: v$2.value }, { default: () => [createVNode("div", {
				ref: B$1,
				class: `${p$1}-modal-container`,
				"data-theme": a$2.value
			}, [createVNode("div", {
				class: e$1.class,
				style: R$4.value
			}, [e$1.showMask && createVNode("div", {
				class: `${p$1}-modal-mask`,
				style: n$3.maskStyle,
				onClick: () => {
					e$1.onClose?.(), u$4.emit("onClose");
				}
			}, null), createVNode("div", {
				class: r$2.value,
				style: {
					...n$3.modalStyle,
					...n$3.initPos,
					...F$2.value
				},
				ref: f$3
			}, [
				createVNode("div", {
					class: `${p$1}-modal-header`,
					ref: h$6
				}, [i$3 || ""]),
				createVNode("div", { class: `${p$1}-modal-body` }, [o$2]),
				createVNode("div", { class: `${p$1}-modal-func` }, [e$1.showAdjust && createVNode("div", {
					class: `${p$1}-modal-adjust`,
					onClick: (s$2) => {
						s$2.stopPropagation(), e$1.isFullscreen ? n$3.initPos = n$3.historyPos : (n$3.historyPos = n$3.initPos, n$3.initPos = {
							insetInlineStart: "0",
							insetBlockStart: "0"
						}), e$1.onAdjust(!e$1.isFullscreen);
					}
				}, [createVNode(P, { name: e$1.isFullscreen ? "minimize" : "maximize" }, null)]), createVNode("div", {
					class: `${p$1}-modal-close`,
					onClick: (s$2) => {
						s$2.stopPropagation(), e$1.onClose?.(), u$4.emit("onClose");
					}
				}, [createVNode(P, { name: "close" }, null)])])
			])])])] }) : "";
		};
	}
});
S.install = (e$1) => (e$1.component(S.name, S), e$1);

//#endregion
//#region node_modules/md-editor-v3/lib/es/ModalToolbar.mjs
function m(e$1) {
	return typeof e$1 == "function" || Object.prototype.toString.call(e$1) === "[object Object]" && !isVNode(e$1);
}
var h$3 = {
	title: {
		type: String,
		default: ""
	},
	modalTitle: {
		type: [String, Object],
		default: ""
	},
	visible: {
		type: Boolean,
		default: void 0
	},
	width: {
		type: String,
		default: "auto"
	},
	height: {
		type: String,
		default: "auto"
	},
	trigger: {
		type: [String, Object],
		default: void 0
	},
	onClick: {
		type: Function,
		default: void 0
	},
	onClose: {
		type: Function,
		default: void 0
	},
	showAdjust: {
		type: Boolean,
		default: !1
	},
	isFullscreen: {
		type: Boolean,
		default: !1
	},
	onAdjust: {
		type: Function,
		default: void 0
	},
	class: {
		type: String,
		default: void 0
	},
	style: {
		type: [Object, String],
		default: void 0
	},
	showMask: {
		type: Boolean,
		default: !0
	},
	insert: {
		type: Function,
		default: void 0
	},
	language: {
		type: String,
		default: void 0
	},
	theme: {
		type: String,
		default: void 0
	},
	previewTheme: {
		type: String,
		default: void 0
	},
	codeTheme: {
		type: String,
		default: void 0
	},
	disabled: {
		type: Boolean,
		default: void 0
	},
	showToolbarName: {
		type: Boolean,
		default: void 0
	}
}, o = /* @__PURE__ */ defineComponent({
	name: "ModalToolbar",
	props: h$3,
	emits: [
		"onClick",
		"onClose",
		"onAdjust"
	],
	setup(e$1, t$1) {
		const u$4 = () => {
			e$1.onClose?.(), t$1.emit("onClose");
		}, s$2 = (n$3) => {
			e$1.onAdjust?.(n$3), t$1.emit("onAdjust", n$3);
		};
		return () => {
			const n$3 = g({
				props: e$1,
				ctx: t$1
			}, "trigger"), f$3 = g({
				props: e$1,
				ctx: t$1
			}, "modalTitle"), l$2 = g({
				props: e$1,
				ctx: t$1
			});
			return createVNode(Fragment, null, [createVNode("button", {
				class: [`${p$1}-toolbar-item`, e$1.disabled && `${p$1}-disabled`],
				title: e$1.title,
				disabled: e$1.disabled,
				onClick: () => {
					e$1.onClick?.(), t$1.emit("onClick");
				},
				type: "button"
			}, [n$3]), createVNode(S, {
				style: e$1.style,
				class: e$1.class,
				width: e$1.width,
				height: e$1.height,
				title: f$3,
				visible: e$1.visible,
				showMask: e$1.showMask,
				onClose: u$4,
				showAdjust: e$1.showAdjust,
				isFullscreen: e$1.isFullscreen,
				onAdjust: s$2
			}, m(l$2) ? l$2 : { default: () => [l$2] })]);
		};
	}
});
o.install = (e$1) => (e$1.component(o.name, o), e$1);

//#endregion
//#region node_modules/md-editor-v3/lib/es/NormalToolbar.mjs
var f$1 = {
	title: {
		type: String,
		default: ""
	},
	trigger: {
		type: [String, Object],
		default: void 0
	},
	onClick: {
		type: Function,
		default: void 0
	},
	insert: {
		type: Function,
		default: void 0
	},
	language: {
		type: String,
		default: void 0
	},
	theme: {
		type: String,
		default: void 0
	},
	previewTheme: {
		type: String,
		default: void 0
	},
	codeTheme: {
		type: String,
		default: void 0
	},
	disabled: {
		type: Boolean,
		default: void 0
	},
	showToolbarName: {
		type: Boolean,
		default: void 0
	}
}, n = /* @__PURE__ */ defineComponent({
	name: "NormalToolbar",
	props: f$1,
	emits: ["onClick"],
	setup(e$1, t$1) {
		return () => {
			const o$2 = g({
				props: e$1,
				ctx: t$1
			}, "trigger"), a$2 = g({
				props: e$1,
				ctx: t$1
			});
			return createVNode("button", {
				class: [`${p$1}-toolbar-item`, e$1.disabled && `${p$1}-disabled`],
				title: e$1.title,
				disabled: e$1.disabled,
				onClick: (i$3) => {
					e$1.onClick?.(i$3), t$1.emit("onClick", i$3);
				},
				type: "button"
			}, [a$2 || o$2]);
		};
	}
});
n.install = (e$1) => (e$1.component(n.name, n), e$1);

//#endregion
//#region node_modules/@codemirror/commands/dist/index.js
/**
Comment or uncomment the current selection. Will use line comments
if available, otherwise falling back to block comments.
*/
var toggleComment = (target) => {
	let { state } = target, line = state.doc.lineAt(state.selection.main.from), config = getConfig(target.state, line.from);
	return config.line ? toggleLineComment(target) : config.block ? toggleBlockCommentByLine(target) : false;
};
function command(f$3, option) {
	return ({ state, dispatch }) => {
		if (state.readOnly) return false;
		let tr = f$3(option, state);
		if (!tr) return false;
		dispatch(state.update(tr));
		return true;
	};
}
/**
Comment or uncomment the current selection using line comments.
The line comment syntax is taken from the
[`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language
data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).
*/
var toggleLineComment = /* @__PURE__ */ command(changeLineComment, 0);
/**
Comment or uncomment the current selection using block comments.
The block comment syntax is taken from the
[`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language
data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).
*/
var toggleBlockComment = /* @__PURE__ */ command(changeBlockComment, 0);
/**
Comment or uncomment the lines around the current selection using
block comments.
*/
var toggleBlockCommentByLine = /* @__PURE__ */ command((o$2, s$2) => changeBlockComment(o$2, s$2, selectedLineRanges(s$2)), 0);
function getConfig(state, pos) {
	let data = state.languageDataAt("commentTokens", pos, 1);
	return data.length ? data[0] : {};
}
var SearchMargin = 50;
/**
Determines if the given range is block-commented in the given
state.
*/
function findBlockComment(state, { open, close }, from, to) {
	let textBefore = state.sliceDoc(from - SearchMargin, from);
	let textAfter = state.sliceDoc(to, to + SearchMargin);
	let spaceBefore = /\s*$/.exec(textBefore)[0].length, spaceAfter = /^\s*/.exec(textAfter)[0].length;
	let beforeOff = textBefore.length - spaceBefore;
	if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) return {
		open: {
			pos: from - spaceBefore,
			margin: spaceBefore && 1
		},
		close: {
			pos: to + spaceAfter,
			margin: spaceAfter && 1
		}
	};
	let startText, endText;
	if (to - from <= 2 * SearchMargin) startText = endText = state.sliceDoc(from, to);
	else {
		startText = state.sliceDoc(from, from + SearchMargin);
		endText = state.sliceDoc(to - SearchMargin, to);
	}
	let startSpace = /^\s*/.exec(startText)[0].length, endSpace = /\s*$/.exec(endText)[0].length;
	let endOff = endText.length - endSpace - close.length;
	if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) return {
		open: {
			pos: from + startSpace + open.length,
			margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0
		},
		close: {
			pos: to - endSpace - close.length,
			margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0
		}
	};
	return null;
}
function selectedLineRanges(state) {
	let ranges = [];
	for (let r$2 of state.selection.ranges) {
		let fromLine = state.doc.lineAt(r$2.from);
		let toLine = r$2.to <= fromLine.to ? fromLine : state.doc.lineAt(r$2.to);
		if (toLine.from > fromLine.from && toLine.from == r$2.to) toLine = r$2.to == fromLine.to + 1 ? fromLine : state.doc.lineAt(r$2.to - 1);
		let last = ranges.length - 1;
		if (last >= 0 && ranges[last].to > fromLine.from) ranges[last].to = toLine.to;
		else ranges.push({
			from: fromLine.from + /^\s*/.exec(fromLine.text)[0].length,
			to: toLine.to
		});
	}
	return ranges;
}
function changeBlockComment(option, state, ranges = state.selection.ranges) {
	let tokens = ranges.map((r$2) => getConfig(state, r$2.from).block);
	if (!tokens.every((c$2) => c$2)) return null;
	let comments = ranges.map((r$2, i$3) => findBlockComment(state, tokens[i$3], r$2.from, r$2.to));
	if (option != 2 && !comments.every((c$2) => c$2)) return { changes: state.changes(ranges.map((range, i$3) => {
		if (comments[i$3]) return [];
		return [{
			from: range.from,
			insert: tokens[i$3].open + " "
		}, {
			from: range.to,
			insert: " " + tokens[i$3].close
		}];
	})) };
	else if (option != 1 && comments.some((c$2) => c$2)) {
		let changes = [];
		for (let i$3 = 0, comment; i$3 < comments.length; i$3++) if (comment = comments[i$3]) {
			let token = tokens[i$3], { open, close } = comment;
			changes.push({
				from: open.pos - token.open.length,
				to: open.pos + open.margin
			}, {
				from: close.pos - close.margin,
				to: close.pos + token.close.length
			});
		}
		return { changes };
	}
	return null;
}
function changeLineComment(option, state, ranges = state.selection.ranges) {
	let lines = [];
	let prevLine = -1;
	for (let { from, to } of ranges) {
		let startI = lines.length, minIndent = 1e9;
		let token = getConfig(state, from).line;
		if (!token) continue;
		for (let pos = from; pos <= to;) {
			let line = state.doc.lineAt(pos);
			if (line.from > prevLine && (from == to || to > line.from)) {
				prevLine = line.from;
				let indent = /^\s*/.exec(line.text)[0].length;
				let empty$1 = indent == line.length;
				let comment = line.text.slice(indent, indent + token.length) == token ? indent : -1;
				if (indent < line.text.length && indent < minIndent) minIndent = indent;
				lines.push({
					line,
					comment,
					token,
					indent,
					empty: empty$1,
					single: false
				});
			}
			pos = line.to + 1;
		}
		if (minIndent < 1e9) {
			for (let i$3 = startI; i$3 < lines.length; i$3++) if (lines[i$3].indent < lines[i$3].line.text.length) lines[i$3].indent = minIndent;
		}
		if (lines.length == startI + 1) lines[startI].single = true;
	}
	if (option != 2 && lines.some((l$2) => l$2.comment < 0 && (!l$2.empty || l$2.single))) {
		let changes = [];
		for (let { line, token, indent, empty: empty$1, single } of lines) if (single || !empty$1) changes.push({
			from: line.from + indent,
			insert: token + " "
		});
		let changeSet = state.changes(changes);
		return {
			changes: changeSet,
			selection: state.selection.map(changeSet, 1)
		};
	} else if (option != 1 && lines.some((l$2) => l$2.comment >= 0)) {
		let changes = [];
		for (let { line, comment, token } of lines) if (comment >= 0) {
			let from = line.from + comment, to = from + token.length;
			if (line.text[to - line.from] == " ") to++;
			changes.push({
				from,
				to
			});
		}
		return { changes };
	}
	return null;
}
var fromHistory = /* @__PURE__ */ Annotation.define();
/**
Transaction annotation that will prevent that transaction from
being combined with other transactions in the undo history. Given
`"before"`, it'll prevent merging with previous transactions. With
`"after"`, subsequent transactions won't be combined with this
one. With `"full"`, the transaction is isolated on both sides.
*/
var isolateHistory = /* @__PURE__ */ Annotation.define();
/**
This facet provides a way to register functions that, given a
transaction, provide a set of effects that the history should
store when inverting the transaction. This can be used to
integrate some kinds of effects in the history, so that they can
be undone (and redone again).
*/
var invertedEffects = /* @__PURE__ */ Facet.define();
var historyConfig = /* @__PURE__ */ Facet.define({ combine(configs) {
	return combineConfig(configs, {
		minDepth: 100,
		newGroupDelay: 500,
		joinToEvent: (_t, isAdjacent$1) => isAdjacent$1
	}, {
		minDepth: Math.max,
		newGroupDelay: Math.min,
		joinToEvent: (a$2, b$2) => (tr, adj) => a$2(tr, adj) || b$2(tr, adj)
	});
} });
var historyField_ = /* @__PURE__ */ StateField.define({
	create() {
		return HistoryState.empty;
	},
	update(state, tr) {
		let config = tr.state.facet(historyConfig);
		let fromHist = tr.annotation(fromHistory);
		if (fromHist) {
			let item = HistEvent.fromTransaction(tr, fromHist.selection), from = fromHist.side;
			let other = from == 0 ? state.undone : state.done;
			if (item) other = updateBranch(other, other.length, config.minDepth, item);
			else other = addSelection(other, tr.startState.selection);
			return new HistoryState(from == 0 ? fromHist.rest : other, from == 0 ? other : fromHist.rest);
		}
		let isolate = tr.annotation(isolateHistory);
		if (isolate == "full" || isolate == "before") state = state.isolate();
		if (tr.annotation(Transaction.addToHistory) === false) return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;
		let event = HistEvent.fromTransaction(tr);
		let time = tr.annotation(Transaction.time), userEvent = tr.annotation(Transaction.userEvent);
		if (event) state = state.addChanges(event, time, userEvent, config, tr);
		else if (tr.selection) state = state.addSelection(tr.startState.selection, time, userEvent, config.newGroupDelay);
		if (isolate == "full" || isolate == "after") state = state.isolate();
		return state;
	},
	toJSON(value) {
		return {
			done: value.done.map((e$1) => e$1.toJSON()),
			undone: value.undone.map((e$1) => e$1.toJSON())
		};
	},
	fromJSON(json) {
		return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));
	}
});
/**
Create a history extension with the given configuration.
*/
function history(config = {}) {
	return [
		historyField_,
		historyConfig.of(config),
		EditorView.domEventHandlers({ beforeinput(e$1, view) {
			let command$1 = e$1.inputType == "historyUndo" ? undo : e$1.inputType == "historyRedo" ? redo : null;
			if (!command$1) return false;
			e$1.preventDefault();
			return command$1(view);
		} })
	];
}
function cmd(side, selection) {
	return function({ state, dispatch }) {
		if (!selection && state.readOnly) return false;
		let historyState = state.field(historyField_, false);
		if (!historyState) return false;
		let tr = historyState.pop(side, state, selection);
		if (!tr) return false;
		dispatch(tr);
		return true;
	};
}
/**
Undo a single group of history events. Returns false if no group
was available.
*/
var undo = /* @__PURE__ */ cmd(0, false);
/**
Redo a group of history events. Returns false if no group was
available.
*/
var redo = /* @__PURE__ */ cmd(1, false);
/**
Undo a change or selection change.
*/
var undoSelection = /* @__PURE__ */ cmd(0, true);
/**
Redo a change or selection change.
*/
var redoSelection = /* @__PURE__ */ cmd(1, true);
var HistEvent = class HistEvent {
	constructor(changes, effects, mapped, startSelection, selectionsAfter) {
		this.changes = changes;
		this.effects = effects;
		this.mapped = mapped;
		this.startSelection = startSelection;
		this.selectionsAfter = selectionsAfter;
	}
	setSelAfter(after) {
		return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);
	}
	toJSON() {
		var _a, _b, _c;
		return {
			changes: (_a = this.changes) === null || _a === void 0 ? void 0 : _a.toJSON(),
			mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),
			startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),
			selectionsAfter: this.selectionsAfter.map((s$2) => s$2.toJSON())
		};
	}
	static fromJSON(json) {
		return new HistEvent(json.changes && ChangeSet.fromJSON(json.changes), [], json.mapped && ChangeDesc.fromJSON(json.mapped), json.startSelection && EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(EditorSelection.fromJSON));
	}
	static fromTransaction(tr, selection) {
		let effects = none;
		for (let invert of tr.startState.facet(invertedEffects)) {
			let result = invert(tr);
			if (result.length) effects = effects.concat(result);
		}
		if (!effects.length && tr.changes.empty) return null;
		return new HistEvent(tr.changes.invert(tr.startState.doc), effects, void 0, selection || tr.startState.selection, none);
	}
	static selection(selections) {
		return new HistEvent(void 0, none, void 0, void 0, selections);
	}
};
function updateBranch(branch, to, maxLen, newEvent) {
	let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;
	let newBranch = branch.slice(start, to);
	newBranch.push(newEvent);
	return newBranch;
}
function isAdjacent(a$2, b$2) {
	let ranges = [], isAdjacent$1 = false;
	a$2.iterChangedRanges((f$3, t$1) => ranges.push(f$3, t$1));
	b$2.iterChangedRanges((_f, _t, f$3, t$1) => {
		for (let i$3 = 0; i$3 < ranges.length;) {
			let from = ranges[i$3++], to = ranges[i$3++];
			if (t$1 >= from && f$3 <= to) isAdjacent$1 = true;
		}
	});
	return isAdjacent$1;
}
function eqSelectionShape(a$2, b$2) {
	return a$2.ranges.length == b$2.ranges.length && a$2.ranges.filter((r$2, i$3) => r$2.empty != b$2.ranges[i$3].empty).length === 0;
}
function conc(a$2, b$2) {
	return !a$2.length ? b$2 : !b$2.length ? a$2 : a$2.concat(b$2);
}
var none = [];
var MaxSelectionsPerEvent = 200;
function addSelection(branch, selection) {
	if (!branch.length) return [HistEvent.selection([selection])];
	else {
		let lastEvent = branch[branch.length - 1];
		let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));
		if (sels.length && sels[sels.length - 1].eq(selection)) return branch;
		sels.push(selection);
		return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));
	}
}
function popSelection(branch) {
	let last = branch[branch.length - 1];
	let newBranch = branch.slice();
	newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));
	return newBranch;
}
function addMappingToBranch(branch, mapping) {
	if (!branch.length) return branch;
	let length = branch.length, selections = none;
	while (length) {
		let event = mapEvent(branch[length - 1], mapping, selections);
		if (event.changes && !event.changes.empty || event.effects.length) {
			let result = branch.slice(0, length);
			result[length - 1] = event;
			return result;
		} else {
			mapping = event.mapped;
			length--;
			selections = event.selectionsAfter;
		}
	}
	return selections.length ? [HistEvent.selection(selections)] : none;
}
function mapEvent(event, mapping, extraSelections) {
	let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map((s$2) => s$2.map(mapping)) : none, extraSelections);
	if (!event.changes) return HistEvent.selection(selections);
	let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);
	let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;
	return new HistEvent(mappedChanges, StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);
}
var joinableUserEvent = /^(input\.type|delete)($|\.)/;
var HistoryState = class HistoryState {
	constructor(done, undone, prevTime = 0, prevUserEvent = void 0) {
		this.done = done;
		this.undone = undone;
		this.prevTime = prevTime;
		this.prevUserEvent = prevUserEvent;
	}
	isolate() {
		return this.prevTime ? new HistoryState(this.done, this.undone) : this;
	}
	addChanges(event, time, userEvent, config, tr) {
		let done = this.done, lastEvent = done[done.length - 1];
		if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time - this.prevTime < config.newGroupDelay && config.joinToEvent(tr, isAdjacent(lastEvent.changes, event.changes)) || userEvent == "input.type.compose")) done = updateBranch(done, done.length - 1, config.minDepth, new HistEvent(event.changes.compose(lastEvent.changes), conc(StateEffect.mapEffects(event.effects, lastEvent.changes), lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none));
		else done = updateBranch(done, done.length, config.minDepth, event);
		return new HistoryState(done, none, time, userEvent);
	}
	addSelection(selection, time, userEvent, newGroupDelay) {
		let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none;
		if (last.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\.)/.test(userEvent) && eqSelectionShape(last[last.length - 1], selection)) return this;
		return new HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);
	}
	addMapping(mapping) {
		return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
	}
	pop(side, state, onlySelection) {
		let branch = side == 0 ? this.done : this.undone;
		if (branch.length == 0) return null;
		let event = branch[branch.length - 1], selection = event.selectionsAfter[0] || state.selection;
		if (onlySelection && event.selectionsAfter.length) return state.update({
			selection: event.selectionsAfter[event.selectionsAfter.length - 1],
			annotations: fromHistory.of({
				side,
				rest: popSelection(branch),
				selection
			}),
			userEvent: side == 0 ? "select.undo" : "select.redo",
			scrollIntoView: true
		});
		else if (!event.changes) return null;
		else {
			let rest = branch.length == 1 ? none : branch.slice(0, branch.length - 1);
			if (event.mapped) rest = addMappingToBranch(rest, event.mapped);
			return state.update({
				changes: event.changes,
				selection: event.startSelection,
				effects: event.effects,
				annotations: fromHistory.of({
					side,
					rest,
					selection
				}),
				filter: false,
				userEvent: side == 0 ? "undo" : "redo",
				scrollIntoView: true
			});
		}
	}
};
HistoryState.empty = /* @__PURE__ */ new HistoryState(none, none);
/**
Default key bindings for the undo history.

- Mod-z: [`undo`](https://codemirror.net/6/docs/ref/#commands.undo).
- Mod-y (Mod-Shift-z on macOS) + Ctrl-Shift-z on Linux: [`redo`](https://codemirror.net/6/docs/ref/#commands.redo).
- Mod-u: [`undoSelection`](https://codemirror.net/6/docs/ref/#commands.undoSelection).
- Alt-u (Mod-Shift-u on macOS): [`redoSelection`](https://codemirror.net/6/docs/ref/#commands.redoSelection).
*/
var historyKeymap = [
	{
		key: "Mod-z",
		run: undo,
		preventDefault: true
	},
	{
		key: "Mod-y",
		mac: "Mod-Shift-z",
		run: redo,
		preventDefault: true
	},
	{
		linux: "Ctrl-Shift-z",
		run: redo,
		preventDefault: true
	},
	{
		key: "Mod-u",
		run: undoSelection,
		preventDefault: true
	},
	{
		key: "Alt-u",
		mac: "Mod-Shift-u",
		run: redoSelection,
		preventDefault: true
	}
];
function updateSel(sel, by) {
	return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);
}
function setSel(state, selection) {
	return state.update({
		selection,
		scrollIntoView: true,
		userEvent: "select"
	});
}
function moveSel({ state, dispatch }, how) {
	let selection = updateSel(state.selection, how);
	if (selection.eq(state.selection, true)) return false;
	dispatch(setSel(state, selection));
	return true;
}
function rangeEnd(range, forward) {
	return EditorSelection.cursor(forward ? range.to : range.from);
}
function cursorByChar(view, forward) {
	return moveSel(view, (range) => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));
}
function ltrAtCursor(view) {
	return view.textDirectionAt(view.state.selection.main.head) == Direction.LTR;
}
/**
Move the selection one character to the left (which is backward in
left-to-right text, forward in right-to-left text).
*/
var cursorCharLeft = (view) => cursorByChar(view, !ltrAtCursor(view));
/**
Move the selection one character to the right.
*/
var cursorCharRight = (view) => cursorByChar(view, ltrAtCursor(view));
function cursorByGroup(view, forward) {
	return moveSel(view, (range) => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));
}
/**
Move the selection to the left across one group of word or
non-word (but also non-space) characters.
*/
var cursorGroupLeft = (view) => cursorByGroup(view, !ltrAtCursor(view));
/**
Move the selection one group to the right.
*/
var cursorGroupRight = (view) => cursorByGroup(view, ltrAtCursor(view));
var segmenter = typeof Intl != "undefined" && Intl.Segmenter ? /* @__PURE__ */ new Intl.Segmenter(void 0, { granularity: "word" }) : null;
function interestingNode(state, node, bracketProp) {
	if (node.type.prop(bracketProp)) return true;
	let len = node.to - node.from;
	return len && (len > 2 || /[^\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;
}
function moveBySyntax(state, start, forward) {
	let pos = syntaxTree(state).resolveInner(start.head);
	let bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy;
	for (let at$1 = start.head;;) {
		let next = forward ? pos.childAfter(at$1) : pos.childBefore(at$1);
		if (!next) break;
		if (interestingNode(state, next, bracketProp)) pos = next;
		else at$1 = forward ? next.to : next.from;
	}
	let bracket = pos.type.prop(bracketProp), match, newPos;
	if (bracket && (match = forward ? matchBrackets(state, pos.from, 1) : matchBrackets(state, pos.to, -1)) && match.matched) newPos = forward ? match.end.to : match.end.from;
	else newPos = forward ? pos.to : pos.from;
	return EditorSelection.cursor(newPos, forward ? -1 : 1);
}
/**
Move the cursor over the next syntactic element to the left.
*/
var cursorSyntaxLeft = (view) => moveSel(view, (range) => moveBySyntax(view.state, range, !ltrAtCursor(view)));
/**
Move the cursor over the next syntactic element to the right.
*/
var cursorSyntaxRight = (view) => moveSel(view, (range) => moveBySyntax(view.state, range, ltrAtCursor(view)));
function cursorByLine(view, forward) {
	return moveSel(view, (range) => {
		if (!range.empty) return rangeEnd(range, forward);
		let moved = view.moveVertically(range, forward);
		return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);
	});
}
/**
Move the selection one line up.
*/
var cursorLineUp = (view) => cursorByLine(view, false);
/**
Move the selection one line down.
*/
var cursorLineDown = (view) => cursorByLine(view, true);
function pageInfo(view) {
	let selfScroll = view.scrollDOM.clientHeight < view.scrollDOM.scrollHeight - 2;
	let marginTop = 0, marginBottom = 0, height;
	if (selfScroll) {
		for (let source of view.state.facet(EditorView.scrollMargins)) {
			let margins = source(view);
			if (margins === null || margins === void 0 ? void 0 : margins.top) marginTop = Math.max(margins === null || margins === void 0 ? void 0 : margins.top, marginTop);
			if (margins === null || margins === void 0 ? void 0 : margins.bottom) marginBottom = Math.max(margins === null || margins === void 0 ? void 0 : margins.bottom, marginBottom);
		}
		height = view.scrollDOM.clientHeight - marginTop - marginBottom;
	} else height = (view.dom.ownerDocument.defaultView || window).innerHeight;
	return {
		marginTop,
		marginBottom,
		selfScroll,
		height: Math.max(view.defaultLineHeight, height - 5)
	};
}
function cursorByPage(view, forward) {
	let page = pageInfo(view);
	let { state } = view, selection = updateSel(state.selection, (range) => {
		return range.empty ? view.moveVertically(range, forward, page.height) : rangeEnd(range, forward);
	});
	if (selection.eq(state.selection)) return false;
	let effect;
	if (page.selfScroll) {
		let startPos = view.coordsAtPos(state.selection.main.head);
		let scrollRect = view.scrollDOM.getBoundingClientRect();
		let scrollTop = scrollRect.top + page.marginTop, scrollBottom = scrollRect.bottom - page.marginBottom;
		if (startPos && startPos.top > scrollTop && startPos.bottom < scrollBottom) effect = EditorView.scrollIntoView(selection.main.head, {
			y: "start",
			yMargin: startPos.top - scrollTop
		});
	}
	view.dispatch(setSel(state, selection), { effects: effect });
	return true;
}
/**
Move the selection one page up.
*/
var cursorPageUp = (view) => cursorByPage(view, false);
/**
Move the selection one page down.
*/
var cursorPageDown = (view) => cursorByPage(view, true);
function moveByLineBoundary(view, start, forward) {
	let line = view.lineBlockAt(start.head), moved = view.moveToLineBoundary(start, forward);
	if (moved.head == start.head && moved.head != (forward ? line.to : line.from)) moved = view.moveToLineBoundary(start, forward, false);
	if (!forward && moved.head == line.from && line.length) {
		let space = /^\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;
		if (space && start.head != line.from + space) moved = EditorSelection.cursor(line.from + space);
	}
	return moved;
}
/**
Move the selection to the next line wrap point, or to the end of
the line if there isn't one left on this line.
*/
var cursorLineBoundaryForward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, true));
/**
Move the selection to previous line wrap point, or failing that to
the start of the line. If the line is indented, and the cursor
isn't already at the end of the indentation, this will move to the
end of the indentation instead of the start of the line.
*/
var cursorLineBoundaryBackward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, false));
/**
Move the selection one line wrap point to the left.
*/
var cursorLineBoundaryLeft = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, !ltrAtCursor(view)));
/**
Move the selection one line wrap point to the right.
*/
var cursorLineBoundaryRight = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, ltrAtCursor(view)));
/**
Move the selection to the start of the line.
*/
var cursorLineStart = (view) => moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from, 1));
/**
Move the selection to the end of the line.
*/
var cursorLineEnd = (view) => moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to, -1));
function toMatchingBracket(state, dispatch, extend) {
	let found = false, selection = updateSel(state.selection, (range) => {
		let matching = matchBrackets(state, range.head, -1) || matchBrackets(state, range.head, 1) || range.head > 0 && matchBrackets(state, range.head - 1, 1) || range.head < state.doc.length && matchBrackets(state, range.head + 1, -1);
		if (!matching || !matching.end) return range;
		found = true;
		let head = matching.start.from == range.head ? matching.end.to : matching.end.from;
		return extend ? EditorSelection.range(range.anchor, head) : EditorSelection.cursor(head);
	});
	if (!found) return false;
	dispatch(setSel(state, selection));
	return true;
}
/**
Move the selection to the bracket matching the one it is currently
on, if any.
*/
var cursorMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, false);
function extendSel(target, how) {
	let selection = updateSel(target.state.selection, (range) => {
		let head = how(range);
		return EditorSelection.range(range.anchor, head.head, head.goalColumn, head.bidiLevel || void 0);
	});
	if (selection.eq(target.state.selection)) return false;
	target.dispatch(setSel(target.state, selection));
	return true;
}
function selectByChar(view, forward) {
	return extendSel(view, (range) => view.moveByChar(range, forward));
}
/**
Move the selection head one character to the left, while leaving
the anchor in place.
*/
var selectCharLeft = (view) => selectByChar(view, !ltrAtCursor(view));
/**
Move the selection head one character to the right.
*/
var selectCharRight = (view) => selectByChar(view, ltrAtCursor(view));
function selectByGroup(view, forward) {
	return extendSel(view, (range) => view.moveByGroup(range, forward));
}
/**
Move the selection head one [group](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) to
the left.
*/
var selectGroupLeft = (view) => selectByGroup(view, !ltrAtCursor(view));
/**
Move the selection head one group to the right.
*/
var selectGroupRight = (view) => selectByGroup(view, ltrAtCursor(view));
/**
Move the selection head over the next syntactic element to the left.
*/
var selectSyntaxLeft = (view) => extendSel(view, (range) => moveBySyntax(view.state, range, !ltrAtCursor(view)));
/**
Move the selection head over the next syntactic element to the right.
*/
var selectSyntaxRight = (view) => extendSel(view, (range) => moveBySyntax(view.state, range, ltrAtCursor(view)));
function selectByLine(view, forward) {
	return extendSel(view, (range) => view.moveVertically(range, forward));
}
/**
Move the selection head one line up.
*/
var selectLineUp = (view) => selectByLine(view, false);
/**
Move the selection head one line down.
*/
var selectLineDown = (view) => selectByLine(view, true);
function selectByPage(view, forward) {
	return extendSel(view, (range) => view.moveVertically(range, forward, pageInfo(view).height));
}
/**
Move the selection head one page up.
*/
var selectPageUp = (view) => selectByPage(view, false);
/**
Move the selection head one page down.
*/
var selectPageDown = (view) => selectByPage(view, true);
/**
Move the selection head to the next line boundary.
*/
var selectLineBoundaryForward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, true));
/**
Move the selection head to the previous line boundary.
*/
var selectLineBoundaryBackward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, false));
/**
Move the selection head one line boundary to the left.
*/
var selectLineBoundaryLeft = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, !ltrAtCursor(view)));
/**
Move the selection head one line boundary to the right.
*/
var selectLineBoundaryRight = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, ltrAtCursor(view)));
/**
Move the selection head to the start of the line.
*/
var selectLineStart = (view) => extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from));
/**
Move the selection head to the end of the line.
*/
var selectLineEnd = (view) => extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to));
/**
Move the selection to the start of the document.
*/
var cursorDocStart = ({ state, dispatch }) => {
	dispatch(setSel(state, { anchor: 0 }));
	return true;
};
/**
Move the selection to the end of the document.
*/
var cursorDocEnd = ({ state, dispatch }) => {
	dispatch(setSel(state, { anchor: state.doc.length }));
	return true;
};
/**
Move the selection head to the start of the document.
*/
var selectDocStart = ({ state, dispatch }) => {
	dispatch(setSel(state, {
		anchor: state.selection.main.anchor,
		head: 0
	}));
	return true;
};
/**
Move the selection head to the end of the document.
*/
var selectDocEnd = ({ state, dispatch }) => {
	dispatch(setSel(state, {
		anchor: state.selection.main.anchor,
		head: state.doc.length
	}));
	return true;
};
/**
Select the entire document.
*/
var selectAll = ({ state, dispatch }) => {
	dispatch(state.update({
		selection: {
			anchor: 0,
			head: state.doc.length
		},
		userEvent: "select"
	}));
	return true;
};
/**
Expand the selection to cover entire lines.
*/
var selectLine = ({ state, dispatch }) => {
	let ranges = selectedLineBlocks(state).map(({ from, to }) => EditorSelection.range(from, Math.min(to + 1, state.doc.length)));
	dispatch(state.update({
		selection: EditorSelection.create(ranges),
		userEvent: "select"
	}));
	return true;
};
/**
Select the next syntactic construct that is larger than the
selection. Note that this will only work insofar as the language
[provider](https://codemirror.net/6/docs/ref/#language.language) you use builds up a full
syntax tree.
*/
var selectParentSyntax = ({ state, dispatch }) => {
	let selection = updateSel(state.selection, (range) => {
		let tree = syntaxTree(state), stack = tree.resolveStack(range.from, 1);
		if (range.empty) {
			let stackBefore = tree.resolveStack(range.from, -1);
			if (stackBefore.node.from >= stack.node.from && stackBefore.node.to <= stack.node.to) stack = stackBefore;
		}
		for (let cur = stack; cur; cur = cur.next) {
			let { node } = cur;
			if ((node.from < range.from && node.to >= range.to || node.to > range.to && node.from <= range.from) && cur.next) return EditorSelection.range(node.to, node.from);
		}
		return range;
	});
	if (selection.eq(state.selection)) return false;
	dispatch(setSel(state, selection));
	return true;
};
function addCursorVertically(view, forward) {
	let { state } = view, sel = state.selection, ranges = state.selection.ranges.slice();
	for (let range of state.selection.ranges) {
		let line = state.doc.lineAt(range.head);
		if (forward ? line.to < view.state.doc.length : line.from > 0) for (let cur = range;;) {
			let next = view.moveVertically(cur, forward);
			if (next.head < line.from || next.head > line.to) {
				if (!ranges.some((r$2) => r$2.head == next.head)) ranges.push(next);
				break;
			} else if (next.head == cur.head) break;
			else cur = next;
		}
	}
	if (ranges.length == sel.ranges.length) return false;
	view.dispatch(setSel(state, EditorSelection.create(ranges, ranges.length - 1)));
	return true;
}
/**
Expand the selection by adding a cursor above the heads of
currently selected ranges.
*/
var addCursorAbove = (view) => addCursorVertically(view, false);
/**
Expand the selection by adding a cursor below the heads of
currently selected ranges.
*/
var addCursorBelow = (view) => addCursorVertically(view, true);
/**
Simplify the current selection. When multiple ranges are selected,
reduce it to its main range. Otherwise, if the selection is
non-empty, convert it to a cursor selection.
*/
var simplifySelection = ({ state, dispatch }) => {
	let cur = state.selection, selection = null;
	if (cur.ranges.length > 1) selection = EditorSelection.create([cur.main]);
	else if (!cur.main.empty) selection = EditorSelection.create([EditorSelection.cursor(cur.main.head)]);
	if (!selection) return false;
	dispatch(setSel(state, selection));
	return true;
};
function deleteBy(target, by) {
	if (target.state.readOnly) return false;
	let event = "delete.selection", { state } = target;
	let changes = state.changeByRange((range) => {
		let { from, to } = range;
		if (from == to) {
			let towards = by(range);
			if (towards < from) {
				event = "delete.backward";
				towards = skipAtomic(target, towards, false);
			} else if (towards > from) {
				event = "delete.forward";
				towards = skipAtomic(target, towards, true);
			}
			from = Math.min(from, towards);
			to = Math.max(to, towards);
		} else {
			from = skipAtomic(target, from, false);
			to = skipAtomic(target, to, true);
		}
		return from == to ? { range } : {
			changes: {
				from,
				to
			},
			range: EditorSelection.cursor(from, from < range.head ? -1 : 1)
		};
	});
	if (changes.changes.empty) return false;
	target.dispatch(state.update(changes, {
		scrollIntoView: true,
		userEvent: event,
		effects: event == "delete.selection" ? EditorView.announce.of(state.phrase("Selection deleted")) : void 0
	}));
	return true;
}
function skipAtomic(target, pos, forward) {
	if (target instanceof EditorView) for (let ranges of target.state.facet(EditorView.atomicRanges).map((f$3) => f$3(target))) ranges.between(pos, pos, (from, to) => {
		if (from < pos && to > pos) pos = forward ? to : from;
	});
	return pos;
}
var deleteByChar = (target, forward, byIndentUnit) => deleteBy(target, (range) => {
	let pos = range.from, { state } = target, line = state.doc.lineAt(pos), before, targetPos;
	if (byIndentUnit && !forward && pos > line.from && pos < line.from + 200 && !/[^ \t]/.test(before = line.text.slice(0, pos - line.from))) {
		if (before[before.length - 1] == "	") return pos - 1;
		let col = countColumn(before, state.tabSize), drop = col % getIndentUnit(state) || getIndentUnit(state);
		for (let i$3 = 0; i$3 < drop && before[before.length - 1 - i$3] == " "; i$3++) pos--;
		targetPos = pos;
	} else {
		targetPos = findClusterBreak(line.text, pos - line.from, forward, forward) + line.from;
		if (targetPos == pos && line.number != (forward ? state.doc.lines : 1)) targetPos += forward ? 1 : -1;
		else if (!forward && /[\ufe00-\ufe0f]/.test(line.text.slice(targetPos - line.from, pos - line.from))) targetPos = findClusterBreak(line.text, targetPos - line.from, false, false) + line.from;
	}
	return targetPos;
});
/**
Delete the selection, or, for cursor selections, the character or
indentation unit before the cursor.
*/
var deleteCharBackward = (view) => deleteByChar(view, false, true);
/**
Delete the selection or the character after the cursor.
*/
var deleteCharForward = (view) => deleteByChar(view, true, false);
var deleteByGroup = (target, forward) => deleteBy(target, (range) => {
	let pos = range.head, { state } = target, line = state.doc.lineAt(pos);
	let categorize = state.charCategorizer(pos);
	for (let cat = null;;) {
		if (pos == (forward ? line.to : line.from)) {
			if (pos == range.head && line.number != (forward ? state.doc.lines : 1)) pos += forward ? 1 : -1;
			break;
		}
		let next = findClusterBreak(line.text, pos - line.from, forward) + line.from;
		let nextChar = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);
		let nextCat = categorize(nextChar);
		if (cat != null && nextCat != cat) break;
		if (nextChar != " " || pos != range.head) cat = nextCat;
		pos = next;
	}
	return pos;
});
/**
Delete the selection or backward until the end of the next
[group](https://codemirror.net/6/docs/ref/#view.EditorView.moveByGroup), only skipping groups of
whitespace when they consist of a single space.
*/
var deleteGroupBackward = (target) => deleteByGroup(target, false);
/**
Delete the selection or forward until the end of the next group.
*/
var deleteGroupForward = (target) => deleteByGroup(target, true);
/**
Delete the selection, or, if it is a cursor selection, delete to
the end of the line. If the cursor is directly at the end of the
line, delete the line break after it.
*/
var deleteToLineEnd = (view) => deleteBy(view, (range) => {
	let lineEnd = view.lineBlockAt(range.head).to;
	return range.head < lineEnd ? lineEnd : Math.min(view.state.doc.length, range.head + 1);
});
/**
Delete the selection, or, if it is a cursor selection, delete to
the start of the line or the next line wrap before the cursor.
*/
var deleteLineBoundaryBackward = (view) => deleteBy(view, (range) => {
	let lineStart = view.moveToLineBoundary(range, false).head;
	return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);
});
/**
Delete the selection, or, if it is a cursor selection, delete to
the end of the line or the next line wrap after the cursor.
*/
var deleteLineBoundaryForward = (view) => deleteBy(view, (range) => {
	let lineStart = view.moveToLineBoundary(range, true).head;
	return range.head < lineStart ? lineStart : Math.min(view.state.doc.length, range.head + 1);
});
/**
Replace each selection range with a line break, leaving the cursor
on the line before the break.
*/
var splitLine = ({ state, dispatch }) => {
	if (state.readOnly) return false;
	let changes = state.changeByRange((range) => {
		return {
			changes: {
				from: range.from,
				to: range.to,
				insert: Text.of(["", ""])
			},
			range: EditorSelection.cursor(range.from)
		};
	});
	dispatch(state.update(changes, {
		scrollIntoView: true,
		userEvent: "input"
	}));
	return true;
};
/**
Flip the characters before and after the cursor(s).
*/
var transposeChars = ({ state, dispatch }) => {
	if (state.readOnly) return false;
	let changes = state.changeByRange((range) => {
		if (!range.empty || range.from == 0 || range.from == state.doc.length) return { range };
		let pos = range.from, line = state.doc.lineAt(pos);
		let from = pos == line.from ? pos - 1 : findClusterBreak(line.text, pos - line.from, false) + line.from;
		let to = pos == line.to ? pos + 1 : findClusterBreak(line.text, pos - line.from, true) + line.from;
		return {
			changes: {
				from,
				to,
				insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos))
			},
			range: EditorSelection.cursor(to)
		};
	});
	if (changes.changes.empty) return false;
	dispatch(state.update(changes, {
		scrollIntoView: true,
		userEvent: "move.character"
	}));
	return true;
};
function selectedLineBlocks(state) {
	let blocks = [], upto = -1;
	for (let range of state.selection.ranges) {
		let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);
		if (!range.empty && range.to == endLine.from) endLine = state.doc.lineAt(range.to - 1);
		if (upto >= startLine.number) {
			let prev = blocks[blocks.length - 1];
			prev.to = endLine.to;
			prev.ranges.push(range);
		} else blocks.push({
			from: startLine.from,
			to: endLine.to,
			ranges: [range]
		});
		upto = endLine.number + 1;
	}
	return blocks;
}
function moveLine(state, dispatch, forward) {
	if (state.readOnly) return false;
	let changes = [], ranges = [];
	for (let block of selectedLineBlocks(state)) {
		if (forward ? block.to == state.doc.length : block.from == 0) continue;
		let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);
		let size = nextLine.length + 1;
		if (forward) {
			changes.push({
				from: block.to,
				to: nextLine.to
			}, {
				from: block.from,
				insert: nextLine.text + state.lineBreak
			});
			for (let r$2 of block.ranges) ranges.push(EditorSelection.range(Math.min(state.doc.length, r$2.anchor + size), Math.min(state.doc.length, r$2.head + size)));
		} else {
			changes.push({
				from: nextLine.from,
				to: block.from
			}, {
				from: block.to,
				insert: state.lineBreak + nextLine.text
			});
			for (let r$2 of block.ranges) ranges.push(EditorSelection.range(r$2.anchor - size, r$2.head - size));
		}
	}
	if (!changes.length) return false;
	dispatch(state.update({
		changes,
		scrollIntoView: true,
		selection: EditorSelection.create(ranges, state.selection.mainIndex),
		userEvent: "move.line"
	}));
	return true;
}
/**
Move the selected lines up one line.
*/
var moveLineUp = ({ state, dispatch }) => moveLine(state, dispatch, false);
/**
Move the selected lines down one line.
*/
var moveLineDown = ({ state, dispatch }) => moveLine(state, dispatch, true);
function copyLine(state, dispatch, forward) {
	if (state.readOnly) return false;
	let changes = [];
	for (let block of selectedLineBlocks(state)) if (forward) changes.push({
		from: block.from,
		insert: state.doc.slice(block.from, block.to) + state.lineBreak
	});
	else changes.push({
		from: block.to,
		insert: state.lineBreak + state.doc.slice(block.from, block.to)
	});
	let changeSet = state.changes(changes);
	dispatch(state.update({
		changes: changeSet,
		selection: state.selection.map(changeSet, forward ? 1 : -1),
		scrollIntoView: true,
		userEvent: "input.copyline"
	}));
	return true;
}
/**
Create a copy of the selected lines. Keep the selection in the top copy.
*/
var copyLineUp = ({ state, dispatch }) => copyLine(state, dispatch, false);
/**
Create a copy of the selected lines. Keep the selection in the bottom copy.
*/
var copyLineDown = ({ state, dispatch }) => copyLine(state, dispatch, true);
/**
Delete selected lines.
*/
var deleteLine = (view) => {
	if (view.state.readOnly) return false;
	let { state } = view, changes = state.changes(selectedLineBlocks(state).map(({ from, to }) => {
		if (from > 0) from--;
		else if (to < state.doc.length) to++;
		return {
			from,
			to
		};
	}));
	let selection = updateSel(state.selection, (range) => {
		let dist = void 0;
		if (view.lineWrapping) {
			let block = view.lineBlockAt(range.head), pos = view.coordsAtPos(range.head, range.assoc || 1);
			if (pos) dist = block.bottom + view.documentTop - pos.bottom + view.defaultLineHeight / 2;
		}
		return view.moveVertically(range, true, dist);
	}).map(changes);
	view.dispatch({
		changes,
		selection,
		scrollIntoView: true,
		userEvent: "delete.line"
	});
	return true;
};
function isBetweenBrackets(state, pos) {
	if (/\(\)|\[\]|\{\}/.test(state.sliceDoc(pos - 1, pos + 1))) return {
		from: pos,
		to: pos
	};
	let context = syntaxTree(state).resolveInner(pos);
	let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;
	if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from && !/\S/.test(state.sliceDoc(before.to, after.from))) return {
		from: before.to,
		to: after.from
	};
	return null;
}
/**
Replace the selection with a newline and indent the newly created
line(s). If the current line consists only of whitespace, this
will also delete that whitespace. When the cursor is between
matching brackets, an additional newline will be inserted after
the cursor.
*/
var insertNewlineAndIndent = /* @__PURE__ */ newlineAndIndent(false);
/**
Create a blank, indented line below the current line.
*/
var insertBlankLine = /* @__PURE__ */ newlineAndIndent(true);
function newlineAndIndent(atEof) {
	return ({ state, dispatch }) => {
		if (state.readOnly) return false;
		let changes = state.changeByRange((range) => {
			let { from, to } = range, line = state.doc.lineAt(from);
			let explode = !atEof && from == to && isBetweenBrackets(state, from);
			if (atEof) from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;
			let cx = new IndentContext(state, {
				simulateBreak: from,
				simulateDoubleBreak: !!explode
			});
			let indent = getIndentation(cx, from);
			if (indent == null) indent = countColumn(/^\s*/.exec(state.doc.lineAt(from).text)[0], state.tabSize);
			while (to < line.to && /\s/.test(line.text[to - line.from])) to++;
			if (explode) ({from, to} = explode);
			else if (from > line.from && from < line.from + 100 && !/\S/.test(line.text.slice(0, from))) from = line.from;
			let insert = ["", indentString(state, indent)];
			if (explode) insert.push(indentString(state, cx.lineIndent(line.from, -1)));
			return {
				changes: {
					from,
					to,
					insert: Text.of(insert)
				},
				range: EditorSelection.cursor(from + 1 + insert[1].length)
			};
		});
		dispatch(state.update(changes, {
			scrollIntoView: true,
			userEvent: "input"
		}));
		return true;
	};
}
function changeBySelectedLine(state, f$3) {
	let atLine = -1;
	return state.changeByRange((range) => {
		let changes = [];
		for (let pos = range.from; pos <= range.to;) {
			let line = state.doc.lineAt(pos);
			if (line.number > atLine && (range.empty || range.to > line.from)) {
				f$3(line, changes, range);
				atLine = line.number;
			}
			pos = line.to + 1;
		}
		let changeSet = state.changes(changes);
		return {
			changes,
			range: EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1))
		};
	});
}
/**
Auto-indent the selected lines. This uses the [indentation service
facet](https://codemirror.net/6/docs/ref/#language.indentService) as source for auto-indent
information.
*/
var indentSelection = ({ state, dispatch }) => {
	if (state.readOnly) return false;
	let updated = Object.create(null);
	let context = new IndentContext(state, { overrideIndentation: (start) => {
		let found = updated[start];
		return found == null ? -1 : found;
	} });
	let changes = changeBySelectedLine(state, (line, changes$1, range) => {
		let indent = getIndentation(context, line.from);
		if (indent == null) return;
		if (!/\S/.test(line.text)) indent = 0;
		let cur = /^\s*/.exec(line.text)[0];
		let norm = indentString(state, indent);
		if (cur != norm || range.from < line.from + cur.length) {
			updated[line.from] = indent;
			changes$1.push({
				from: line.from,
				to: line.from + cur.length,
				insert: norm
			});
		}
	});
	if (!changes.changes.empty) dispatch(state.update(changes, { userEvent: "indent" }));
	return true;
};
/**
Add a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation to all selected
lines.
*/
var indentMore = ({ state, dispatch }) => {
	if (state.readOnly) return false;
	dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
		changes.push({
			from: line.from,
			insert: state.facet(indentUnit)
		});
	}), { userEvent: "input.indent" }));
	return true;
};
/**
Remove a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation from all
selected lines.
*/
var indentLess = ({ state, dispatch }) => {
	if (state.readOnly) return false;
	dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
		let space = /^\s*/.exec(line.text)[0];
		if (!space) return;
		let col = countColumn(space, state.tabSize), keep = 0;
		let insert = indentString(state, Math.max(0, col - getIndentUnit(state)));
		while (keep < space.length && keep < insert.length && space.charCodeAt(keep) == insert.charCodeAt(keep)) keep++;
		changes.push({
			from: line.from + keep,
			to: line.from + space.length,
			insert: insert.slice(keep)
		});
	}), { userEvent: "delete.dedent" }));
	return true;
};
/**
Enables or disables
[tab-focus mode](https://codemirror.net/6/docs/ref/#view.EditorView.setTabFocusMode). While on, this
prevents the editor's key bindings from capturing Tab or
Shift-Tab, making it possible for the user to move focus out of
the editor with the keyboard.
*/
var toggleTabFocusMode = (view) => {
	view.setTabFocusMode();
	return true;
};
/**
Array of key bindings containing the Emacs-style bindings that are
available on macOS by default.

- Ctrl-b: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)
- Ctrl-f: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)
- Ctrl-p: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)
- Ctrl-n: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)
- Ctrl-a: [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)
- Ctrl-e: [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)
- Ctrl-d: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)
- Ctrl-h: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)
- Ctrl-k: [`deleteToLineEnd`](https://codemirror.net/6/docs/ref/#commands.deleteToLineEnd)
- Ctrl-Alt-h: [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)
- Ctrl-o: [`splitLine`](https://codemirror.net/6/docs/ref/#commands.splitLine)
- Ctrl-t: [`transposeChars`](https://codemirror.net/6/docs/ref/#commands.transposeChars)
- Ctrl-v: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown)
- Alt-v: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp)
*/
var emacsStyleKeymap = [
	{
		key: "Ctrl-b",
		run: cursorCharLeft,
		shift: selectCharLeft,
		preventDefault: true
	},
	{
		key: "Ctrl-f",
		run: cursorCharRight,
		shift: selectCharRight
	},
	{
		key: "Ctrl-p",
		run: cursorLineUp,
		shift: selectLineUp
	},
	{
		key: "Ctrl-n",
		run: cursorLineDown,
		shift: selectLineDown
	},
	{
		key: "Ctrl-a",
		run: cursorLineStart,
		shift: selectLineStart
	},
	{
		key: "Ctrl-e",
		run: cursorLineEnd,
		shift: selectLineEnd
	},
	{
		key: "Ctrl-d",
		run: deleteCharForward
	},
	{
		key: "Ctrl-h",
		run: deleteCharBackward
	},
	{
		key: "Ctrl-k",
		run: deleteToLineEnd
	},
	{
		key: "Ctrl-Alt-h",
		run: deleteGroupBackward
	},
	{
		key: "Ctrl-o",
		run: splitLine
	},
	{
		key: "Ctrl-t",
		run: transposeChars
	},
	{
		key: "Ctrl-v",
		run: cursorPageDown
	}
];
/**
An array of key bindings closely sticking to platform-standard or
widely used bindings. (This includes the bindings from
[`emacsStyleKeymap`](https://codemirror.net/6/docs/ref/#commands.emacsStyleKeymap), with their `key`
property changed to `mac`.)

- ArrowLeft: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)
- ArrowRight: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)
- Ctrl-ArrowLeft (Alt-ArrowLeft on macOS): [`cursorGroupLeft`](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) ([`selectGroupLeft`](https://codemirror.net/6/docs/ref/#commands.selectGroupLeft) with Shift)
- Ctrl-ArrowRight (Alt-ArrowRight on macOS): [`cursorGroupRight`](https://codemirror.net/6/docs/ref/#commands.cursorGroupRight) ([`selectGroupRight`](https://codemirror.net/6/docs/ref/#commands.selectGroupRight) with Shift)
- Cmd-ArrowLeft (on macOS): [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)
- Cmd-ArrowRight (on macOS): [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)
- ArrowUp: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)
- ArrowDown: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)
- Cmd-ArrowUp (on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)
- Cmd-ArrowDown (on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)
- Ctrl-ArrowUp (on macOS): [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)
- Ctrl-ArrowDown (on macOS): [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)
- PageUp: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)
- PageDown: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)
- Home: [`cursorLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryBackward) ([`selectLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryBackward) with Shift)
- End: [`cursorLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryForward) ([`selectLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryForward) with Shift)
- Ctrl-Home (Cmd-Home on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)
- Ctrl-End (Cmd-Home on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)
- Enter and Shift-Enter: [`insertNewlineAndIndent`](https://codemirror.net/6/docs/ref/#commands.insertNewlineAndIndent)
- Ctrl-a (Cmd-a on macOS): [`selectAll`](https://codemirror.net/6/docs/ref/#commands.selectAll)
- Backspace: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)
- Delete: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)
- Ctrl-Backspace (Alt-Backspace on macOS): [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)
- Ctrl-Delete (Alt-Delete on macOS): [`deleteGroupForward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupForward)
- Cmd-Backspace (macOS): [`deleteLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.deleteLineBoundaryBackward).
- Cmd-Delete (macOS): [`deleteLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.deleteLineBoundaryForward).
*/
var standardKeymap = /* @__PURE__ */ [
	{
		key: "ArrowLeft",
		run: cursorCharLeft,
		shift: selectCharLeft,
		preventDefault: true
	},
	{
		key: "Mod-ArrowLeft",
		mac: "Alt-ArrowLeft",
		run: cursorGroupLeft,
		shift: selectGroupLeft,
		preventDefault: true
	},
	{
		mac: "Cmd-ArrowLeft",
		run: cursorLineBoundaryLeft,
		shift: selectLineBoundaryLeft,
		preventDefault: true
	},
	{
		key: "ArrowRight",
		run: cursorCharRight,
		shift: selectCharRight,
		preventDefault: true
	},
	{
		key: "Mod-ArrowRight",
		mac: "Alt-ArrowRight",
		run: cursorGroupRight,
		shift: selectGroupRight,
		preventDefault: true
	},
	{
		mac: "Cmd-ArrowRight",
		run: cursorLineBoundaryRight,
		shift: selectLineBoundaryRight,
		preventDefault: true
	},
	{
		key: "ArrowUp",
		run: cursorLineUp,
		shift: selectLineUp,
		preventDefault: true
	},
	{
		mac: "Cmd-ArrowUp",
		run: cursorDocStart,
		shift: selectDocStart
	},
	{
		mac: "Ctrl-ArrowUp",
		run: cursorPageUp,
		shift: selectPageUp
	},
	{
		key: "ArrowDown",
		run: cursorLineDown,
		shift: selectLineDown,
		preventDefault: true
	},
	{
		mac: "Cmd-ArrowDown",
		run: cursorDocEnd,
		shift: selectDocEnd
	},
	{
		mac: "Ctrl-ArrowDown",
		run: cursorPageDown,
		shift: selectPageDown
	},
	{
		key: "PageUp",
		run: cursorPageUp,
		shift: selectPageUp
	},
	{
		key: "PageDown",
		run: cursorPageDown,
		shift: selectPageDown
	},
	{
		key: "Home",
		run: cursorLineBoundaryBackward,
		shift: selectLineBoundaryBackward,
		preventDefault: true
	},
	{
		key: "Mod-Home",
		run: cursorDocStart,
		shift: selectDocStart
	},
	{
		key: "End",
		run: cursorLineBoundaryForward,
		shift: selectLineBoundaryForward,
		preventDefault: true
	},
	{
		key: "Mod-End",
		run: cursorDocEnd,
		shift: selectDocEnd
	},
	{
		key: "Enter",
		run: insertNewlineAndIndent,
		shift: insertNewlineAndIndent
	},
	{
		key: "Mod-a",
		run: selectAll
	},
	{
		key: "Backspace",
		run: deleteCharBackward,
		shift: deleteCharBackward,
		preventDefault: true
	},
	{
		key: "Delete",
		run: deleteCharForward,
		preventDefault: true
	},
	{
		key: "Mod-Backspace",
		mac: "Alt-Backspace",
		run: deleteGroupBackward,
		preventDefault: true
	},
	{
		key: "Mod-Delete",
		mac: "Alt-Delete",
		run: deleteGroupForward,
		preventDefault: true
	},
	{
		mac: "Mod-Backspace",
		run: deleteLineBoundaryBackward,
		preventDefault: true
	},
	{
		mac: "Mod-Delete",
		run: deleteLineBoundaryForward,
		preventDefault: true
	}
].concat(/* @__PURE__ */ emacsStyleKeymap.map((b$2) => ({
	mac: b$2.key,
	run: b$2.run,
	shift: b$2.shift
})));
/**
The default keymap. Includes all bindings from
[`standardKeymap`](https://codemirror.net/6/docs/ref/#commands.standardKeymap) plus the following:

- Alt-ArrowLeft (Ctrl-ArrowLeft on macOS): [`cursorSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxLeft) ([`selectSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxLeft) with Shift)
- Alt-ArrowRight (Ctrl-ArrowRight on macOS): [`cursorSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxRight) ([`selectSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxRight) with Shift)
- Alt-ArrowUp: [`moveLineUp`](https://codemirror.net/6/docs/ref/#commands.moveLineUp)
- Alt-ArrowDown: [`moveLineDown`](https://codemirror.net/6/docs/ref/#commands.moveLineDown)
- Shift-Alt-ArrowUp: [`copyLineUp`](https://codemirror.net/6/docs/ref/#commands.copyLineUp)
- Shift-Alt-ArrowDown: [`copyLineDown`](https://codemirror.net/6/docs/ref/#commands.copyLineDown)
- Ctrl-Alt-ArrowUp (Cmd-Alt-ArrowUp on macOS): [`addCursorAbove`](https://codemirror.net/6/docs/ref/#commands.addCursorAbove).
- Ctrl-Alt-ArrowDown (Cmd-Alt-ArrowDown on macOS): [`addCursorBelow`](https://codemirror.net/6/docs/ref/#commands.addCursorBelow).
- Escape: [`simplifySelection`](https://codemirror.net/6/docs/ref/#commands.simplifySelection)
- Ctrl-Enter (Cmd-Enter on macOS): [`insertBlankLine`](https://codemirror.net/6/docs/ref/#commands.insertBlankLine)
- Alt-l (Ctrl-l on macOS): [`selectLine`](https://codemirror.net/6/docs/ref/#commands.selectLine)
- Ctrl-i (Cmd-i on macOS): [`selectParentSyntax`](https://codemirror.net/6/docs/ref/#commands.selectParentSyntax)
- Ctrl-[ (Cmd-[ on macOS): [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess)
- Ctrl-] (Cmd-] on macOS): [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore)
- Ctrl-Alt-\\ (Cmd-Alt-\\ on macOS): [`indentSelection`](https://codemirror.net/6/docs/ref/#commands.indentSelection)
- Shift-Ctrl-k (Shift-Cmd-k on macOS): [`deleteLine`](https://codemirror.net/6/docs/ref/#commands.deleteLine)
- Shift-Ctrl-\\ (Shift-Cmd-\\ on macOS): [`cursorMatchingBracket`](https://codemirror.net/6/docs/ref/#commands.cursorMatchingBracket)
- Ctrl-/ (Cmd-/ on macOS): [`toggleComment`](https://codemirror.net/6/docs/ref/#commands.toggleComment).
- Shift-Alt-a: [`toggleBlockComment`](https://codemirror.net/6/docs/ref/#commands.toggleBlockComment).
- Ctrl-m (Alt-Shift-m on macOS): [`toggleTabFocusMode`](https://codemirror.net/6/docs/ref/#commands.toggleTabFocusMode).
*/
var defaultKeymap = /* @__PURE__ */ [
	{
		key: "Alt-ArrowLeft",
		mac: "Ctrl-ArrowLeft",
		run: cursorSyntaxLeft,
		shift: selectSyntaxLeft
	},
	{
		key: "Alt-ArrowRight",
		mac: "Ctrl-ArrowRight",
		run: cursorSyntaxRight,
		shift: selectSyntaxRight
	},
	{
		key: "Alt-ArrowUp",
		run: moveLineUp
	},
	{
		key: "Shift-Alt-ArrowUp",
		run: copyLineUp
	},
	{
		key: "Alt-ArrowDown",
		run: moveLineDown
	},
	{
		key: "Shift-Alt-ArrowDown",
		run: copyLineDown
	},
	{
		key: "Mod-Alt-ArrowUp",
		run: addCursorAbove
	},
	{
		key: "Mod-Alt-ArrowDown",
		run: addCursorBelow
	},
	{
		key: "Escape",
		run: simplifySelection
	},
	{
		key: "Mod-Enter",
		run: insertBlankLine
	},
	{
		key: "Alt-l",
		mac: "Ctrl-l",
		run: selectLine
	},
	{
		key: "Mod-i",
		run: selectParentSyntax,
		preventDefault: true
	},
	{
		key: "Mod-[",
		run: indentLess
	},
	{
		key: "Mod-]",
		run: indentMore
	},
	{
		key: "Mod-Alt-\\",
		run: indentSelection
	},
	{
		key: "Shift-Mod-k",
		run: deleteLine
	},
	{
		key: "Shift-Mod-\\",
		run: cursorMatchingBracket
	},
	{
		key: "Mod-/",
		run: toggleComment
	},
	{
		key: "Alt-A",
		run: toggleBlockComment
	},
	{
		key: "Ctrl-m",
		mac: "Shift-Alt-m",
		run: toggleTabFocusMode
	}
].concat(standardKeymap);
/**
A binding that binds Tab to [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) and
Shift-Tab to [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess).
Please see the [Tab example](../../examples/tab/) before using
this.
*/
var indentWithTab = {
	key: "Tab",
	run: indentMore,
	shift: indentLess
};

//#endregion
//#region node_modules/@codemirror/language-data/dist/index.js
function legacy(parser) {
	return new LanguageSupport(StreamLanguage.define(parser));
}
function sql(dialectName) {
	return import("./dist-MwhmfbNZ.js").then((m$2) => m$2.sql({ dialect: m$2[dialectName] }));
}
/**
An array of language descriptions for known language packages.
*/
var languages = [
	/* @__PURE__ */ LanguageDescription.of({
		name: "C",
		extensions: [
			"c",
			"h",
			"ino"
		],
		load() {
			return import("./dist-wvS3Y3-3.js").then((m$2) => m$2.cpp());
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "C++",
		alias: ["cpp"],
		extensions: [
			"cpp",
			"c++",
			"cc",
			"cxx",
			"hpp",
			"h++",
			"hh",
			"hxx"
		],
		load() {
			return import("./dist-wvS3Y3-3.js").then((m$2) => m$2.cpp());
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "CQL",
		alias: ["cassandra"],
		extensions: ["cql"],
		load() {
			return sql("Cassandra");
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "CSS",
		extensions: ["css"],
		load() {
			return import("./dist-BebeYi8C.js").then((m$2) => m$2.css());
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Go",
		extensions: ["go"],
		load() {
			return import("./dist-DyjNhPPi.js").then((m$2) => m$2.go());
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "HTML",
		alias: ["xhtml"],
		extensions: [
			"html",
			"htm",
			"handlebars",
			"hbs"
		],
		load() {
			return import("./dist-DzQnt3cd.js").then((m$2) => m$2.html());
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Java",
		extensions: ["java"],
		load() {
			return import("./dist-C1B7hXyD.js").then((m$2) => m$2.java());
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "JavaScript",
		alias: [
			"ecmascript",
			"js",
			"node"
		],
		extensions: [
			"js",
			"mjs",
			"cjs"
		],
		load() {
			return import("./dist-MYyqRbp2.js").then((m$2) => m$2.javascript());
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Jinja",
		extensions: [
			"j2",
			"jinja",
			"jinja2"
		],
		load() {
			return import("./dist-Dn5T70gM.js").then((m$2) => m$2.jinja());
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "JSON",
		alias: ["json5"],
		extensions: ["json", "map"],
		load() {
			return import("./dist-QYuewqxQ.js").then((m$2) => m$2.json());
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "JSX",
		extensions: ["jsx"],
		load() {
			return import("./dist-MYyqRbp2.js").then((m$2) => m$2.javascript({ jsx: true }));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "LESS",
		extensions: ["less"],
		load() {
			return import("./dist-C602wNxZ.js").then((m$2) => m$2.less());
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Liquid",
		extensions: ["liquid"],
		load() {
			return import("./dist-DTcQ_Dgl.js").then((m$2) => m$2.liquid());
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "MariaDB SQL",
		load() {
			return sql("MariaSQL");
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Markdown",
		extensions: [
			"md",
			"markdown",
			"mkd"
		],
		load() {
			return import("./dist-BHar7zeX.js").then((m$2) => m$2.markdown());
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "MS SQL",
		load() {
			return sql("MSSQL");
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "MySQL",
		load() {
			return sql("MySQL");
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "PHP",
		extensions: [
			"php",
			"php3",
			"php4",
			"php5",
			"php7",
			"phtml"
		],
		load() {
			return import("./dist-BamzyFxv.js").then((m$2) => m$2.php());
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "PLSQL",
		extensions: ["pls"],
		load() {
			return sql("PLSQL");
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "PostgreSQL",
		load() {
			return sql("PostgreSQL");
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Python",
		extensions: [
			"BUILD",
			"bzl",
			"py",
			"pyw"
		],
		filename: /^(BUCK|BUILD)$/,
		load() {
			return import("./dist-CsHH634p.js").then((m$2) => m$2.python());
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Rust",
		extensions: ["rs"],
		load() {
			return import("./dist-B0oyZoeE.js").then((m$2) => m$2.rust());
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Sass",
		extensions: ["sass"],
		load() {
			return import("./dist-DI8xJvpi.js").then((m$2) => m$2.sass({ indented: true }));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "SCSS",
		extensions: ["scss"],
		load() {
			return import("./dist-DI8xJvpi.js").then((m$2) => m$2.sass());
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "SQL",
		extensions: ["sql"],
		load() {
			return sql("StandardSQL");
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "SQLite",
		load() {
			return sql("SQLite");
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "TSX",
		extensions: ["tsx"],
		load() {
			return import("./dist-MYyqRbp2.js").then((m$2) => m$2.javascript({
				jsx: true,
				typescript: true
			}));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "TypeScript",
		alias: ["ts"],
		extensions: [
			"ts",
			"mts",
			"cts"
		],
		load() {
			return import("./dist-MYyqRbp2.js").then((m$2) => m$2.javascript({ typescript: true }));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "WebAssembly",
		extensions: ["wat", "wast"],
		load() {
			return import("./dist-Da3nw9au.js").then((m$2) => m$2.wast());
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "XML",
		alias: [
			"rss",
			"wsdl",
			"xsd"
		],
		extensions: [
			"xml",
			"xsl",
			"xsd",
			"svg"
		],
		load() {
			return import("./dist-BFCD0awR.js").then((m$2) => m$2.xml());
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "YAML",
		alias: ["yml"],
		extensions: ["yaml", "yml"],
		load() {
			return import("./dist-Cebk3ztM.js").then((m$2) => m$2.yaml());
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "APL",
		extensions: ["dyalog", "apl"],
		load() {
			return import("./apl-BgQTqvH5.js").then((m$2) => legacy(m$2.apl));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "PGP",
		alias: ["asciiarmor"],
		extensions: [
			"asc",
			"pgp",
			"sig"
		],
		load() {
			return import("./asciiarmor-r1v-T_6I.js").then((m$2) => legacy(m$2.asciiArmor));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "ASN.1",
		extensions: ["asn", "asn1"],
		load() {
			return import("./asn1-D7kQs9xK.js").then((m$2) => legacy(m$2.asn1({})));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Asterisk",
		filename: /^extensions\.conf$/i,
		load() {
			return import("./asterisk-DUZtS4DD.js").then((m$2) => legacy(m$2.asterisk));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Brainfuck",
		extensions: ["b", "bf"],
		load() {
			return import("./brainfuck-2uOLTC2Y.js").then((m$2) => legacy(m$2.brainfuck));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Cobol",
		extensions: ["cob", "cpy"],
		load() {
			return import("./cobol-DNCTY9Tj.js").then((m$2) => legacy(m$2.cobol));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "C#",
		alias: ["csharp", "cs"],
		extensions: ["cs"],
		load() {
			return import("./clike-CnLgDCdA.js").then((m$2) => legacy(m$2.csharp));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Clojure",
		extensions: [
			"clj",
			"cljc",
			"cljx"
		],
		load() {
			return import("./clojure-BL_OP7PS.js").then((m$2) => legacy(m$2.clojure));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "ClojureScript",
		extensions: ["cljs"],
		load() {
			return import("./clojure-BL_OP7PS.js").then((m$2) => legacy(m$2.clojure));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Closure Stylesheets (GSS)",
		extensions: ["gss"],
		load() {
			return import("./css-DTC4bEd6.js").then((m$2) => legacy(m$2.gss));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "CMake",
		extensions: ["cmake", "cmake.in"],
		filename: /^CMakeLists\.txt$/,
		load() {
			return import("./cmake-CJFT9agD.js").then((m$2) => legacy(m$2.cmake));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "CoffeeScript",
		alias: ["coffee", "coffee-script"],
		extensions: ["coffee"],
		load() {
			return import("./coffeescript-CuWSjmAN.js").then((m$2) => legacy(m$2.coffeeScript));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Common Lisp",
		alias: ["lisp"],
		extensions: [
			"cl",
			"lisp",
			"el"
		],
		load() {
			return import("./commonlisp-DvN_RSje.js").then((m$2) => legacy(m$2.commonLisp));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Cypher",
		extensions: ["cyp", "cypher"],
		load() {
			return import("./cypher-BMYJatEC.js").then((m$2) => legacy(m$2.cypher));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Cython",
		extensions: [
			"pyx",
			"pxd",
			"pxi"
		],
		load() {
			return import("./python-CZQHoEEd.js").then((m$2) => legacy(m$2.cython));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Crystal",
		extensions: ["cr"],
		load() {
			return import("./crystal-jOORj916.js").then((m$2) => legacy(m$2.crystal));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "D",
		extensions: ["d"],
		load() {
			return import("./d-DCsYVBWa.js").then((m$2) => legacy(m$2.d));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Dart",
		extensions: ["dart"],
		load() {
			return import("./clike-CnLgDCdA.js").then((m$2) => legacy(m$2.dart));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "diff",
		extensions: ["diff", "patch"],
		load() {
			return import("./diff-cImU_sCF.js").then((m$2) => legacy(m$2.diff));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Dockerfile",
		filename: /^Dockerfile$/,
		load() {
			return import("./dockerfile-DXladsfZ.js").then((m$2) => legacy(m$2.dockerFile));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "DTD",
		extensions: ["dtd"],
		load() {
			return import("./dtd-CdlaLCkB.js").then((m$2) => legacy(m$2.dtd));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Dylan",
		extensions: [
			"dylan",
			"dyl",
			"intr"
		],
		load() {
			return import("./dylan-Ch2OUiIW.js").then((m$2) => legacy(m$2.dylan));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "EBNF",
		load() {
			return import("./ebnf-CY5Higli.js").then((m$2) => legacy(m$2.ebnf));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "ECL",
		extensions: ["ecl"],
		load() {
			return import("./ecl-A-l70iGy.js").then((m$2) => legacy(m$2.ecl));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "edn",
		extensions: ["edn"],
		load() {
			return import("./clojure-BL_OP7PS.js").then((m$2) => legacy(m$2.clojure));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Eiffel",
		extensions: ["e"],
		load() {
			return import("./eiffel-DCXvZpwQ.js").then((m$2) => legacy(m$2.eiffel));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Elm",
		extensions: ["elm"],
		load() {
			return import("./elm-DA6ud1Oa.js").then((m$2) => legacy(m$2.elm));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Erlang",
		extensions: ["erl"],
		load() {
			return import("./erlang-DpYioWfk.js").then((m$2) => legacy(m$2.erlang));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Esper",
		load() {
			return import("./sql-CM9c9SsD.js").then((m$2) => legacy(m$2.esper));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Factor",
		extensions: ["factor"],
		load() {
			return import("./factor-CyEGxRsJ.js").then((m$2) => legacy(m$2.factor));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "FCL",
		load() {
			return import("./fcl-6TIinfSb.js").then((m$2) => legacy(m$2.fcl));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Forth",
		extensions: [
			"forth",
			"fth",
			"4th"
		],
		load() {
			return import("./forth-Crqd03KQ.js").then((m$2) => legacy(m$2.forth));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Fortran",
		extensions: [
			"f",
			"for",
			"f77",
			"f90",
			"f95"
		],
		load() {
			return import("./fortran-DxArstiT.js").then((m$2) => legacy(m$2.fortran));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "F#",
		alias: ["fsharp"],
		extensions: ["fs"],
		load() {
			return import("./mllike-BUZXn7dS.js").then((m$2) => legacy(m$2.fSharp));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Gas",
		extensions: ["s"],
		load() {
			return import("./gas-BE7gEtRh.js").then((m$2) => legacy(m$2.gas));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Gherkin",
		extensions: ["feature"],
		load() {
			return import("./gherkin-DTY5kole.js").then((m$2) => legacy(m$2.gherkin));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Groovy",
		extensions: ["groovy", "gradle"],
		filename: /^Jenkinsfile$/,
		load() {
			return import("./groovy-BZh6ACNO.js").then((m$2) => legacy(m$2.groovy));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Haskell",
		extensions: ["hs"],
		load() {
			return import("./haskell-BGhHj9HP.js").then((m$2) => legacy(m$2.haskell));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Haxe",
		extensions: ["hx"],
		load() {
			return import("./haxe-DJICfd3P.js").then((m$2) => legacy(m$2.haxe));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "HXML",
		extensions: ["hxml"],
		load() {
			return import("./haxe-DJICfd3P.js").then((m$2) => legacy(m$2.hxml));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "HTTP",
		load() {
			return import("./http-DSCIGkz8.js").then((m$2) => legacy(m$2.http));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "IDL",
		extensions: ["pro"],
		load() {
			return import("./idl-DryAWtJf.js").then((m$2) => legacy(m$2.idl));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "JSON-LD",
		alias: ["jsonld"],
		extensions: ["jsonld"],
		load() {
			return import("./javascript-dJm-4kGr.js").then((m$2) => legacy(m$2.jsonld));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Julia",
		extensions: ["jl"],
		load() {
			return import("./julia-P-73l8Xv.js").then((m$2) => legacy(m$2.julia));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Kotlin",
		extensions: ["kt", "kts"],
		load() {
			return import("./clike-CnLgDCdA.js").then((m$2) => legacy(m$2.kotlin));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "LiveScript",
		alias: ["ls"],
		extensions: ["ls"],
		load() {
			return import("./livescript-XQl6ClvB.js").then((m$2) => legacy(m$2.liveScript));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Lua",
		extensions: ["lua"],
		load() {
			return import("./lua-KiAcqTPu.js").then((m$2) => legacy(m$2.lua));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "mIRC",
		extensions: ["mrc"],
		load() {
			return import("./mirc-G-n1waPQ.js").then((m$2) => legacy(m$2.mirc));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Mathematica",
		extensions: [
			"m",
			"nb",
			"wl",
			"wls"
		],
		load() {
			return import("./mathematica-CM5RKOMc.js").then((m$2) => legacy(m$2.mathematica));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Modelica",
		extensions: ["mo"],
		load() {
			return import("./modelica-CTMs4ubE.js").then((m$2) => legacy(m$2.modelica));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "MUMPS",
		extensions: ["mps"],
		load() {
			return import("./mumps-cFw8Gd73.js").then((m$2) => legacy(m$2.mumps));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Mbox",
		extensions: ["mbox"],
		load() {
			return import("./mbox-D-h-2fuj.js").then((m$2) => legacy(m$2.mbox));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Nginx",
		filename: /nginx.*\.conf$/i,
		load() {
			return import("./nginx-CqEqFgMD.js").then((m$2) => legacy(m$2.nginx));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "NSIS",
		extensions: ["nsh", "nsi"],
		load() {
			return import("./nsis-mxcK5-9o.js").then((m$2) => legacy(m$2.nsis));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "NTriples",
		extensions: ["nt", "nq"],
		load() {
			return import("./ntriples-DvkOQSC-.js").then((m$2) => legacy(m$2.ntriples));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Objective-C",
		alias: ["objective-c", "objc"],
		extensions: ["m"],
		load() {
			return import("./clike-CnLgDCdA.js").then((m$2) => legacy(m$2.objectiveC));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Objective-C++",
		alias: ["objective-c++", "objc++"],
		extensions: ["mm"],
		load() {
			return import("./clike-CnLgDCdA.js").then((m$2) => legacy(m$2.objectiveCpp));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "OCaml",
		extensions: [
			"ml",
			"mli",
			"mll",
			"mly"
		],
		load() {
			return import("./mllike-BUZXn7dS.js").then((m$2) => legacy(m$2.oCaml));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Octave",
		extensions: ["m"],
		load() {
			return import("./octave-BVQox9TZ.js").then((m$2) => legacy(m$2.octave));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Oz",
		extensions: ["oz"],
		load() {
			return import("./oz-5ugXdKO6.js").then((m$2) => legacy(m$2.oz));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Pascal",
		extensions: ["p", "pas"],
		load() {
			return import("./pascal-CMLrJnRg.js").then((m$2) => legacy(m$2.pascal));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Perl",
		extensions: ["pl", "pm"],
		load() {
			return import("./perl-DmhZgjhW.js").then((m$2) => legacy(m$2.perl));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Pig",
		extensions: ["pig"],
		load() {
			return import("./pig-BFW-bNPG.js").then((m$2) => legacy(m$2.pig));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "PowerShell",
		extensions: [
			"ps1",
			"psd1",
			"psm1"
		],
		load() {
			return import("./powershell-CNl2l3bh.js").then((m$2) => legacy(m$2.powerShell));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Properties files",
		alias: ["ini", "properties"],
		extensions: [
			"properties",
			"ini",
			"in"
		],
		load() {
			return import("./properties-Dy6CajZ3.js").then((m$2) => legacy(m$2.properties));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "ProtoBuf",
		extensions: ["proto"],
		load() {
			return import("./protobuf-BOCSmfE9.js").then((m$2) => legacy(m$2.protobuf));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Pug",
		alias: ["jade"],
		extensions: ["pug", "jade"],
		load() {
			return import("./pug-CoGYJyaN.js").then((m$2) => legacy(m$2.pug));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Puppet",
		extensions: ["pp"],
		load() {
			return import("./puppet-Dh_BGWNK.js").then((m$2) => legacy(m$2.puppet));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Q",
		extensions: ["q"],
		load() {
			return import("./q-DmOEBbmj.js").then((m$2) => legacy(m$2.q));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "R",
		alias: ["rscript"],
		extensions: ["r", "R"],
		load() {
			return import("./r-KAOgpAcg.js").then((m$2) => legacy(m$2.r));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "RPM Changes",
		load() {
			return import("./rpm-CpcXD6KM.js").then((m$2) => legacy(m$2.rpmChanges));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "RPM Spec",
		extensions: ["spec"],
		load() {
			return import("./rpm-CpcXD6KM.js").then((m$2) => legacy(m$2.rpmSpec));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Ruby",
		alias: [
			"jruby",
			"macruby",
			"rake",
			"rb",
			"rbx"
		],
		extensions: ["rb"],
		filename: /^(Gemfile|Rakefile)$/,
		load() {
			return import("./ruby-CnJRfDVO.js").then((m$2) => legacy(m$2.ruby));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "SAS",
		extensions: ["sas"],
		load() {
			return import("./sas-CIsa3YPf.js").then((m$2) => legacy(m$2.sas));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Scala",
		extensions: ["scala"],
		load() {
			return import("./clike-CnLgDCdA.js").then((m$2) => legacy(m$2.scala));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Scheme",
		extensions: ["scm", "ss"],
		load() {
			return import("./scheme-ciDJqpU7.js").then((m$2) => legacy(m$2.scheme));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Shell",
		alias: [
			"bash",
			"sh",
			"zsh"
		],
		extensions: [
			"sh",
			"ksh",
			"bash"
		],
		filename: /^PKGBUILD$/,
		load() {
			return import("./shell-DmDDcZpP.js").then((m$2) => legacy(m$2.shell));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Sieve",
		extensions: ["siv", "sieve"],
		load() {
			return import("./sieve-CZmLOlFh.js").then((m$2) => legacy(m$2.sieve));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Smalltalk",
		extensions: ["st"],
		load() {
			return import("./smalltalk-DbW9VNFB.js").then((m$2) => legacy(m$2.smalltalk));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Solr",
		load() {
			return import("./solr-C2djISkc.js").then((m$2) => legacy(m$2.solr));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "SML",
		extensions: [
			"sml",
			"sig",
			"fun",
			"smackspec"
		],
		load() {
			return import("./mllike-BUZXn7dS.js").then((m$2) => legacy(m$2.sml));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "SPARQL",
		alias: ["sparul"],
		extensions: ["rq", "sparql"],
		load() {
			return import("./sparql-DxUDIfb8.js").then((m$2) => legacy(m$2.sparql));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Spreadsheet",
		alias: ["excel", "formula"],
		load() {
			return import("./spreadsheet-CBmZfCrk.js").then((m$2) => legacy(m$2.spreadsheet));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Squirrel",
		extensions: ["nut"],
		load() {
			return import("./clike-CnLgDCdA.js").then((m$2) => legacy(m$2.squirrel));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Stylus",
		extensions: ["styl"],
		load() {
			return import("./stylus-_zuKyqeX.js").then((m$2) => legacy(m$2.stylus));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Swift",
		extensions: ["swift"],
		load() {
			return import("./swift-B3uYq2MD.js").then((m$2) => legacy(m$2.swift));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "sTeX",
		load() {
			return import("./stex-Bfbhyw1s.js").then((m$2) => legacy(m$2.stex));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "LaTeX",
		alias: ["tex"],
		extensions: [
			"text",
			"ltx",
			"tex"
		],
		load() {
			return import("./stex-Bfbhyw1s.js").then((m$2) => legacy(m$2.stex));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "SystemVerilog",
		extensions: [
			"v",
			"sv",
			"svh"
		],
		load() {
			return import("./verilog-ZWi3g-au.js").then((m$2) => legacy(m$2.verilog));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Tcl",
		extensions: ["tcl"],
		load() {
			return import("./tcl-BzvJ97iB.js").then((m$2) => legacy(m$2.tcl));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Textile",
		extensions: ["textile"],
		load() {
			return import("./textile-B_WQgjg9.js").then((m$2) => legacy(m$2.textile));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "TiddlyWiki",
		load() {
			return import("./tiddlywiki-CgSqzZCf.js").then((m$2) => legacy(m$2.tiddlyWiki));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Tiki wiki",
		load() {
			return import("./tiki-D9NB9SiM.js").then((m$2) => legacy(m$2.tiki));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "TOML",
		extensions: ["toml"],
		load() {
			return import("./toml-CsK9Qheq.js").then((m$2) => legacy(m$2.toml));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Troff",
		extensions: [
			"1",
			"2",
			"3",
			"4",
			"5",
			"6",
			"7",
			"8",
			"9"
		],
		load() {
			return import("./troff-CCrACkv4.js").then((m$2) => legacy(m$2.troff));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "TTCN",
		extensions: [
			"ttcn",
			"ttcn3",
			"ttcnpp"
		],
		load() {
			return import("./ttcn-DONAa995.js").then((m$2) => legacy(m$2.ttcn));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "TTCN_CFG",
		extensions: ["cfg"],
		load() {
			return import("./ttcn-cfg-CLdUJG8m.js").then((m$2) => legacy(m$2.ttcnCfg));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Turtle",
		extensions: ["ttl"],
		load() {
			return import("./turtle-BOjmTzKM.js").then((m$2) => legacy(m$2.turtle));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Web IDL",
		extensions: ["webidl"],
		load() {
			return import("./webidl-5BCY4w0h.js").then((m$2) => legacy(m$2.webIDL));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "VB.NET",
		extensions: ["vb"],
		load() {
			return import("./vb-CJUHDmdq.js").then((m$2) => legacy(m$2.vb));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "VBScript",
		extensions: ["vbs"],
		load() {
			return import("./vbscript-CEh1JSbI.js").then((m$2) => legacy(m$2.vbScript));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Velocity",
		extensions: ["vtl"],
		load() {
			return import("./velocity-CI1qY8Ft.js").then((m$2) => legacy(m$2.velocity));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Verilog",
		extensions: ["v"],
		load() {
			return import("./verilog-ZWi3g-au.js").then((m$2) => legacy(m$2.verilog));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "VHDL",
		extensions: ["vhd", "vhdl"],
		load() {
			return import("./vhdl-C3kpx4Xx.js").then((m$2) => legacy(m$2.vhdl));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "XQuery",
		extensions: [
			"xy",
			"xquery",
			"xq",
			"xqm",
			"xqy"
		],
		load() {
			return import("./xquery-Bm4osyBK.js").then((m$2) => legacy(m$2.xQuery));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Yacas",
		extensions: ["ys"],
		load() {
			return import("./yacas-BKAB9Xi_.js").then((m$2) => legacy(m$2.yacas));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Z80",
		extensions: ["z80"],
		load() {
			return import("./z80-DOkap4DZ.js").then((m$2) => legacy(m$2.z80));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "MscGen",
		extensions: [
			"mscgen",
			"mscin",
			"msc"
		],
		load() {
			return import("./mscgen-O42m87Rr.js").then((m$2) => legacy(m$2.mscgen));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Xù",
		extensions: ["xu"],
		load() {
			return import("./mscgen-O42m87Rr.js").then((m$2) => legacy(m$2.xu));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "MsGenny",
		extensions: ["msgenny"],
		load() {
			return import("./mscgen-O42m87Rr.js").then((m$2) => legacy(m$2.msgenny));
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Vue",
		extensions: ["vue"],
		load() {
			return import("./dist-DUl79jNC.js").then((m$2) => m$2.vue());
		}
	}),
	/* @__PURE__ */ LanguageDescription.of({
		name: "Angular Template",
		load() {
			return import("./dist-_2mZ4p8u.js").then((m$2) => m$2.angular());
		}
	})
];

//#endregion
//#region node_modules/@codemirror/search/dist/index.js
var basicNormalize = typeof String.prototype.normalize == "function" ? (x$1) => x$1.normalize("NFKD") : (x$1) => x$1;
/**
A search cursor provides an iterator over text matches in a
document.
*/
var SearchCursor = class {
	/**
	Create a text cursor. The query is the search string, `from` to
	`to` provides the region to search.
	
	When `normalize` is given, it will be called, on both the query
	string and the content it is matched against, before comparing.
	You can, for example, create a case-insensitive search by
	passing `s => s.toLowerCase()`.
	
	Text is always normalized with
	[`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
	(when supported).
	*/
	constructor(text, query, from = 0, to = text.length, normalize, test) {
		this.test = test;
		/**
		The current match (only holds a meaningful value after
		[`next`](https://codemirror.net/6/docs/ref/#search.SearchCursor.next) has been called and when
		`done` is false).
		*/
		this.value = {
			from: 0,
			to: 0
		};
		/**
		Whether the end of the iterated region has been reached.
		*/
		this.done = false;
		this.matches = [];
		this.buffer = "";
		this.bufferPos = 0;
		this.iter = text.iterRange(from, to);
		this.bufferStart = from;
		this.normalize = normalize ? (x$1) => normalize(basicNormalize(x$1)) : basicNormalize;
		this.query = this.normalize(query);
	}
	peek() {
		if (this.bufferPos == this.buffer.length) {
			this.bufferStart += this.buffer.length;
			this.iter.next();
			if (this.iter.done) return -1;
			this.bufferPos = 0;
			this.buffer = this.iter.value;
		}
		return codePointAt(this.buffer, this.bufferPos);
	}
	/**
	Look for the next match. Updates the iterator's
	[`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
	[`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
	at least once before using the cursor.
	*/
	next() {
		while (this.matches.length) this.matches.pop();
		return this.nextOverlapping();
	}
	/**
	The `next` method will ignore matches that partially overlap a
	previous match. This method behaves like `next`, but includes
	such matches.
	*/
	nextOverlapping() {
		for (;;) {
			let next = this.peek();
			if (next < 0) {
				this.done = true;
				return this;
			}
			let str = fromCodePoint(next), start = this.bufferStart + this.bufferPos;
			this.bufferPos += codePointSize(next);
			let norm = this.normalize(str);
			if (norm.length) for (let i$3 = 0, pos = start;; i$3++) {
				let code = norm.charCodeAt(i$3);
				let match = this.match(code, pos, this.bufferPos + this.bufferStart);
				if (i$3 == norm.length - 1) {
					if (match) {
						this.value = match;
						return this;
					}
					break;
				}
				if (pos == start && i$3 < str.length && str.charCodeAt(i$3) == code) pos++;
			}
		}
	}
	match(code, pos, end) {
		let match = null;
		for (let i$3 = 0; i$3 < this.matches.length; i$3 += 2) {
			let index = this.matches[i$3], keep = false;
			if (this.query.charCodeAt(index) == code) if (index == this.query.length - 1) match = {
				from: this.matches[i$3 + 1],
				to: end
			};
			else {
				this.matches[i$3]++;
				keep = true;
			}
			if (!keep) {
				this.matches.splice(i$3, 2);
				i$3 -= 2;
			}
		}
		if (this.query.charCodeAt(0) == code) if (this.query.length == 1) match = {
			from: pos,
			to: end
		};
		else this.matches.push(1, pos);
		if (match && this.test && !this.test(match.from, match.to, this.buffer, this.bufferStart)) match = null;
		return match;
	}
};
if (typeof Symbol != "undefined") SearchCursor.prototype[Symbol.iterator] = function() {
	return this;
};
var empty = {
	from: -1,
	to: -1,
	match: /* @__PURE__ */ /.*/.exec("")
};
var baseFlags = "gm" + (/x/.unicode == null ? "" : "u");
/**
This class is similar to [`SearchCursor`](https://codemirror.net/6/docs/ref/#search.SearchCursor)
but searches for a regular expression pattern instead of a plain
string.
*/
var RegExpCursor = class {
	/**
	Create a cursor that will search the given range in the given
	document. `query` should be the raw pattern (as you'd pass it to
	`new RegExp`).
	*/
	constructor(text, query, options, from = 0, to = text.length) {
		this.text = text;
		this.to = to;
		this.curLine = "";
		/**
		Set to `true` when the cursor has reached the end of the search
		range.
		*/
		this.done = false;
		/**
		Will contain an object with the extent of the match and the
		match object when [`next`](https://codemirror.net/6/docs/ref/#search.RegExpCursor.next)
		sucessfully finds a match.
		*/
		this.value = empty;
		if (/\\[sWDnr]|\n|\r|\[\^/.test(query)) return new MultilineRegExpCursor(text, query, options, from, to);
		this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
		this.test = options === null || options === void 0 ? void 0 : options.test;
		this.iter = text.iter();
		this.curLineStart = text.lineAt(from).from;
		this.matchPos = toCharEnd(text, from);
		this.getLine(this.curLineStart);
	}
	getLine(skip) {
		this.iter.next(skip);
		if (this.iter.lineBreak) this.curLine = "";
		else {
			this.curLine = this.iter.value;
			if (this.curLineStart + this.curLine.length > this.to) this.curLine = this.curLine.slice(0, this.to - this.curLineStart);
			this.iter.next();
		}
	}
	nextLine() {
		this.curLineStart = this.curLineStart + this.curLine.length + 1;
		if (this.curLineStart > this.to) this.curLine = "";
		else this.getLine(0);
	}
	/**
	Move to the next match, if there is one.
	*/
	next() {
		for (let off = this.matchPos - this.curLineStart;;) {
			this.re.lastIndex = off;
			let match = this.matchPos <= this.to && this.re.exec(this.curLine);
			if (match) {
				let from = this.curLineStart + match.index, to = from + match[0].length;
				this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));
				if (from == this.curLineStart + this.curLine.length) this.nextLine();
				if ((from < to || from > this.value.to) && (!this.test || this.test(from, to, match))) {
					this.value = {
						from,
						to,
						match
					};
					return this;
				}
				off = this.matchPos - this.curLineStart;
			} else if (this.curLineStart + this.curLine.length < this.to) {
				this.nextLine();
				off = 0;
			} else {
				this.done = true;
				return this;
			}
		}
	}
};
var flattened = /* @__PURE__ */ new WeakMap();
var FlattenedDoc = class FlattenedDoc {
	constructor(from, text) {
		this.from = from;
		this.text = text;
	}
	get to() {
		return this.from + this.text.length;
	}
	static get(doc, from, to) {
		let cached = flattened.get(doc);
		if (!cached || cached.from >= to || cached.to <= from) {
			let flat = new FlattenedDoc(from, doc.sliceString(from, to));
			flattened.set(doc, flat);
			return flat;
		}
		if (cached.from == from && cached.to == to) return cached;
		let { text, from: cachedFrom } = cached;
		if (cachedFrom > from) {
			text = doc.sliceString(from, cachedFrom) + text;
			cachedFrom = from;
		}
		if (cached.to < to) text += doc.sliceString(cached.to, to);
		flattened.set(doc, new FlattenedDoc(cachedFrom, text));
		return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));
	}
};
var MultilineRegExpCursor = class {
	constructor(text, query, options, from, to) {
		this.text = text;
		this.to = to;
		this.done = false;
		this.value = empty;
		this.matchPos = toCharEnd(text, from);
		this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
		this.test = options === null || options === void 0 ? void 0 : options.test;
		this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5e3));
	}
	chunkEnd(pos) {
		return pos >= this.to ? this.to : this.text.lineAt(pos).to;
	}
	next() {
		for (;;) {
			let off = this.re.lastIndex = this.matchPos - this.flat.from;
			let match = this.re.exec(this.flat.text);
			if (match && !match[0] && match.index == off) {
				this.re.lastIndex = off + 1;
				match = this.re.exec(this.flat.text);
			}
			if (match) {
				let from = this.flat.from + match.index, to = from + match[0].length;
				if ((this.flat.to >= this.to || match.index + match[0].length <= this.flat.text.length - 10) && (!this.test || this.test(from, to, match))) {
					this.value = {
						from,
						to,
						match
					};
					this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));
					return this;
				}
			}
			if (this.flat.to == this.to) {
				this.done = true;
				return this;
			}
			this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
		}
	}
};
if (typeof Symbol != "undefined") RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] = function() {
	return this;
};
function validRegExp(source) {
	try {
		new RegExp(source, baseFlags);
		return true;
	} catch (_a) {
		return false;
	}
}
function toCharEnd(text, pos) {
	if (pos >= text.length) return pos;
	let line = text.lineAt(pos), next;
	while (pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 56320 && next < 57344) pos++;
	return pos;
}
function createLineDialog(view) {
	let line = String(view.state.doc.lineAt(view.state.selection.main.head).number);
	let input = crelt("input", {
		class: "cm-textfield",
		name: "line",
		value: line
	});
	let dom = crelt("form", {
		class: "cm-gotoLine",
		onkeydown: (event) => {
			if (event.keyCode == 27) {
				event.preventDefault();
				view.dispatch({ effects: dialogEffect.of(false) });
				view.focus();
			} else if (event.keyCode == 13) {
				event.preventDefault();
				go$1();
			}
		},
		onsubmit: (event) => {
			event.preventDefault();
			go$1();
		}
	}, crelt("label", view.state.phrase("Go to line"), ": ", input), " ", crelt("button", {
		class: "cm-button",
		type: "submit"
	}, view.state.phrase("go")), crelt("button", {
		name: "close",
		onclick: () => {
			view.dispatch({ effects: dialogEffect.of(false) });
			view.focus();
		},
		"aria-label": view.state.phrase("close"),
		type: "button"
	}, ["×"]));
	function go$1() {
		let match = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(input.value);
		if (!match) return;
		let { state } = view, startLine = state.doc.lineAt(state.selection.main.head);
		let [, sign, ln, cl$1, percent] = match;
		let col = cl$1 ? +cl$1.slice(1) : 0;
		let line$1 = ln ? +ln : startLine.number;
		if (ln && percent) {
			let pc = line$1 / 100;
			if (sign) pc = pc * (sign == "-" ? -1 : 1) + startLine.number / state.doc.lines;
			line$1 = Math.round(state.doc.lines * pc);
		} else if (ln && sign) line$1 = line$1 * (sign == "-" ? -1 : 1) + startLine.number;
		let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line$1)));
		let selection = EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length)));
		view.dispatch({
			effects: [dialogEffect.of(false), EditorView.scrollIntoView(selection.from, { y: "center" })],
			selection
		});
		view.focus();
	}
	return { dom };
}
var dialogEffect = /* @__PURE__ */ StateEffect.define();
var dialogField = /* @__PURE__ */ StateField.define({
	create() {
		return true;
	},
	update(value, tr) {
		for (let e$1 of tr.effects) if (e$1.is(dialogEffect)) value = e$1.value;
		return value;
	},
	provide: (f$3) => showPanel.from(f$3, (val) => val ? createLineDialog : null)
});
/**
Command that shows a dialog asking the user for a line number, and
when a valid position is provided, moves the cursor to that line.

Supports line numbers, relative line offsets prefixed with `+` or
`-`, document percentages suffixed with `%`, and an optional
column position by adding `:` and a second number after the line
number.
*/
var gotoLine = (view) => {
	let panel = getPanel(view, createLineDialog);
	if (!panel) {
		let effects = [dialogEffect.of(true)];
		if (view.state.field(dialogField, false) == null) effects.push(StateEffect.appendConfig.of([dialogField, baseTheme$1]));
		view.dispatch({ effects });
		panel = getPanel(view, createLineDialog);
	}
	if (panel) panel.dom.querySelector("input").select();
	return true;
};
var baseTheme$1 = /* @__PURE__ */ EditorView.baseTheme({ ".cm-panel.cm-gotoLine": {
	padding: "2px 6px 4px",
	position: "relative",
	"& label": { fontSize: "80%" },
	"& [name=close]": {
		position: "absolute",
		top: "0",
		bottom: "0",
		right: "4px",
		backgroundColor: "inherit",
		border: "none",
		font: "inherit",
		padding: "0"
	}
} });
var selectWord = ({ state, dispatch }) => {
	let { selection } = state;
	let newSel = EditorSelection.create(selection.ranges.map((range) => state.wordAt(range.head) || EditorSelection.cursor(range.head)), selection.mainIndex);
	if (newSel.eq(selection)) return false;
	dispatch(state.update({ selection: newSel }));
	return true;
};
function findNextOccurrence(state, query) {
	let { main, ranges } = state.selection;
	let word = state.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;
	for (let cycled = false, cursor = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to);;) {
		cursor.next();
		if (cursor.done) {
			if (cycled) return null;
			cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));
			cycled = true;
		} else {
			if (cycled && ranges.some((r$2) => r$2.from == cursor.value.from)) continue;
			if (fullWord) {
				let word$1 = state.wordAt(cursor.value.from);
				if (!word$1 || word$1.from != cursor.value.from || word$1.to != cursor.value.to) continue;
			}
			return cursor.value;
		}
	}
}
/**
Select next occurrence of the current selection. Expand selection
to the surrounding word when the selection is empty.
*/
var selectNextOccurrence = ({ state, dispatch }) => {
	let { ranges } = state.selection;
	if (ranges.some((sel) => sel.from === sel.to)) return selectWord({
		state,
		dispatch
	});
	let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);
	if (state.selection.ranges.some((r$2) => state.sliceDoc(r$2.from, r$2.to) != searchedText)) return false;
	let range = findNextOccurrence(state, searchedText);
	if (!range) return false;
	dispatch(state.update({
		selection: state.selection.addRange(EditorSelection.range(range.from, range.to), false),
		effects: EditorView.scrollIntoView(range.to)
	}));
	return true;
};
var searchConfigFacet = /* @__PURE__ */ Facet.define({ combine(configs) {
	return combineConfig(configs, {
		top: false,
		caseSensitive: false,
		literal: false,
		regexp: false,
		wholeWord: false,
		createPanel: (view) => new SearchPanel(view),
		scrollToMatch: (range) => EditorView.scrollIntoView(range)
	});
} });
/**
A search query. Part of the editor's search state.
*/
var SearchQuery = class {
	/**
	Create a query object.
	*/
	constructor(config) {
		this.search = config.search;
		this.caseSensitive = !!config.caseSensitive;
		this.literal = !!config.literal;
		this.regexp = !!config.regexp;
		this.replace = config.replace || "";
		this.valid = !!this.search && (!this.regexp || validRegExp(this.search));
		this.unquoted = this.unquote(this.search);
		this.wholeWord = !!config.wholeWord;
	}
	/**
	@internal
	*/
	unquote(text) {
		return this.literal ? text : text.replace(/\\([nrt\\])/g, (_$2, ch) => ch == "n" ? "\n" : ch == "r" ? "\r" : ch == "t" ? "	" : "\\");
	}
	/**
	Compare this query to another query.
	*/
	eq(other) {
		return this.search == other.search && this.replace == other.replace && this.caseSensitive == other.caseSensitive && this.regexp == other.regexp && this.wholeWord == other.wholeWord;
	}
	/**
	@internal
	*/
	create() {
		return this.regexp ? new RegExpQuery(this) : new StringQuery(this);
	}
	/**
	Get a search cursor for this query, searching through the given
	range in the given state.
	*/
	getCursor(state, from = 0, to) {
		let st$1 = state.doc ? state : EditorState.create({ doc: state });
		if (to == null) to = st$1.doc.length;
		return this.regexp ? regexpCursor(this, st$1, from, to) : stringCursor(this, st$1, from, to);
	}
};
var QueryType = class {
	constructor(spec) {
		this.spec = spec;
	}
};
function stringCursor(spec, state, from, to) {
	return new SearchCursor(state.doc, spec.unquoted, from, to, spec.caseSensitive ? void 0 : (x$1) => x$1.toLowerCase(), spec.wholeWord ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head)) : void 0);
}
function stringWordTest(doc, categorizer) {
	return (from, to, buf, bufPos) => {
		if (bufPos > from || bufPos + buf.length < to) {
			bufPos = Math.max(0, from - 2);
			buf = doc.sliceString(bufPos, Math.min(doc.length, to + 2));
		}
		return (categorizer(charBefore(buf, from - bufPos)) != CharCategory.Word || categorizer(charAfter(buf, from - bufPos)) != CharCategory.Word) && (categorizer(charAfter(buf, to - bufPos)) != CharCategory.Word || categorizer(charBefore(buf, to - bufPos)) != CharCategory.Word);
	};
}
var StringQuery = class extends QueryType {
	constructor(spec) {
		super(spec);
	}
	nextMatch(state, curFrom, curTo) {
		let cursor = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();
		if (cursor.done) {
			let end = Math.min(state.doc.length, curFrom + this.spec.unquoted.length);
			cursor = stringCursor(this.spec, state, 0, end).nextOverlapping();
		}
		return cursor.done || cursor.value.from == curFrom && cursor.value.to == curTo ? null : cursor.value;
	}
	prevMatchInRange(state, from, to) {
		for (let pos = to;;) {
			let start = Math.max(from, pos - 1e4 - this.spec.unquoted.length);
			let cursor = stringCursor(this.spec, state, start, pos), range = null;
			while (!cursor.nextOverlapping().done) range = cursor.value;
			if (range) return range;
			if (start == from) return null;
			pos -= 1e4;
		}
	}
	prevMatch(state, curFrom, curTo) {
		let found = this.prevMatchInRange(state, 0, curFrom);
		if (!found) found = this.prevMatchInRange(state, Math.max(0, curTo - this.spec.unquoted.length), state.doc.length);
		return found && (found.from != curFrom || found.to != curTo) ? found : null;
	}
	getReplacement(_result) {
		return this.spec.unquote(this.spec.replace);
	}
	matchAll(state, limit) {
		let cursor = stringCursor(this.spec, state, 0, state.doc.length), ranges = [];
		while (!cursor.next().done) {
			if (ranges.length >= limit) return null;
			ranges.push(cursor.value);
		}
		return ranges;
	}
	highlight(state, from, to, add) {
		let cursor = stringCursor(this.spec, state, Math.max(0, from - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, state.doc.length));
		while (!cursor.next().done) add(cursor.value.from, cursor.value.to);
	}
};
function regexpCursor(spec, state, from, to) {
	return new RegExpCursor(state.doc, spec.search, {
		ignoreCase: !spec.caseSensitive,
		test: spec.wholeWord ? regexpWordTest(state.charCategorizer(state.selection.main.head)) : void 0
	}, from, to);
}
function charBefore(str, index) {
	return str.slice(findClusterBreak(str, index, false), index);
}
function charAfter(str, index) {
	return str.slice(index, findClusterBreak(str, index));
}
function regexpWordTest(categorizer) {
	return (_from, _to, match) => !match[0].length || (categorizer(charBefore(match.input, match.index)) != CharCategory.Word || categorizer(charAfter(match.input, match.index)) != CharCategory.Word) && (categorizer(charAfter(match.input, match.index + match[0].length)) != CharCategory.Word || categorizer(charBefore(match.input, match.index + match[0].length)) != CharCategory.Word);
}
var RegExpQuery = class extends QueryType {
	nextMatch(state, curFrom, curTo) {
		let cursor = regexpCursor(this.spec, state, curTo, state.doc.length).next();
		if (cursor.done) cursor = regexpCursor(this.spec, state, 0, curFrom).next();
		return cursor.done ? null : cursor.value;
	}
	prevMatchInRange(state, from, to) {
		for (let size = 1;; size++) {
			let start = Math.max(from, to - size * 1e4);
			let cursor = regexpCursor(this.spec, state, start, to), range = null;
			while (!cursor.next().done) range = cursor.value;
			if (range && (start == from || range.from > start + 10)) return range;
			if (start == from) return null;
		}
	}
	prevMatch(state, curFrom, curTo) {
		return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);
	}
	getReplacement(result) {
		return this.spec.unquote(this.spec.replace).replace(/\$([$&]|\d+)/g, (m$2, i$3) => {
			if (i$3 == "&") return result.match[0];
			if (i$3 == "$") return "$";
			for (let l$2 = i$3.length; l$2 > 0; l$2--) {
				let n$3 = +i$3.slice(0, l$2);
				if (n$3 > 0 && n$3 < result.match.length) return result.match[n$3] + i$3.slice(l$2);
			}
			return m$2;
		});
	}
	matchAll(state, limit) {
		let cursor = regexpCursor(this.spec, state, 0, state.doc.length), ranges = [];
		while (!cursor.next().done) {
			if (ranges.length >= limit) return null;
			ranges.push(cursor.value);
		}
		return ranges;
	}
	highlight(state, from, to, add) {
		let cursor = regexpCursor(this.spec, state, Math.max(0, from - 250), Math.min(to + 250, state.doc.length));
		while (!cursor.next().done) add(cursor.value.from, cursor.value.to);
	}
};
/**
A state effect that updates the current search query. Note that
this only has an effect if the search state has been initialized
(by including [`search`](https://codemirror.net/6/docs/ref/#search.search) in your configuration or
by running [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) at least
once).
*/
var setSearchQuery = /* @__PURE__ */ StateEffect.define();
var togglePanel = /* @__PURE__ */ StateEffect.define();
var searchState = /* @__PURE__ */ StateField.define({
	create(state) {
		return new SearchState(defaultQuery(state).create(), null);
	},
	update(value, tr) {
		for (let effect of tr.effects) if (effect.is(setSearchQuery)) value = new SearchState(effect.value.create(), value.panel);
		else if (effect.is(togglePanel)) value = new SearchState(value.query, effect.value ? createSearchPanel : null);
		return value;
	},
	provide: (f$3) => showPanel.from(f$3, (val) => val.panel)
});
var SearchState = class {
	constructor(query, panel) {
		this.query = query;
		this.panel = panel;
	}
};
var matchMark = /* @__PURE__ */ Decoration.mark({ class: "cm-searchMatch" }), selectedMatchMark = /* @__PURE__ */ Decoration.mark({ class: "cm-searchMatch cm-searchMatch-selected" });
var searchHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
	constructor(view) {
		this.view = view;
		this.decorations = this.highlight(view.state.field(searchState));
	}
	update(update) {
		let state = update.state.field(searchState);
		if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged) this.decorations = this.highlight(state);
	}
	highlight({ query, panel }) {
		if (!panel || !query.spec.valid) return Decoration.none;
		let { view } = this;
		let builder = new RangeSetBuilder();
		for (let i$3 = 0, ranges = view.visibleRanges, l$2 = ranges.length; i$3 < l$2; i$3++) {
			let { from, to } = ranges[i$3];
			while (i$3 < l$2 - 1 && to > ranges[i$3 + 1].from - 500) to = ranges[++i$3].to;
			query.highlight(view.state, from, to, (from$1, to$1) => {
				let selected = view.state.selection.ranges.some((r$2) => r$2.from == from$1 && r$2.to == to$1);
				builder.add(from$1, to$1, selected ? selectedMatchMark : matchMark);
			});
		}
		return builder.finish();
	}
}, { decorations: (v$2) => v$2.decorations });
function searchCommand(f$3) {
	return (view) => {
		let state = view.state.field(searchState, false);
		return state && state.query.spec.valid ? f$3(view, state) : openSearchPanel(view);
	};
}
/**
Open the search panel if it isn't already open, and move the
selection to the first match after the current main selection.
Will wrap around to the start of the document when it reaches the
end.
*/
var findNext = /* @__PURE__ */ searchCommand((view, { query }) => {
	let { to } = view.state.selection.main;
	let next = query.nextMatch(view.state, to, to);
	if (!next) return false;
	let selection = EditorSelection.single(next.from, next.to);
	let config = view.state.facet(searchConfigFacet);
	view.dispatch({
		selection,
		effects: [announceMatch(view, next), config.scrollToMatch(selection.main, view)],
		userEvent: "select.search"
	});
	selectSearchInput(view);
	return true;
});
/**
Move the selection to the previous instance of the search query,
before the current main selection. Will wrap past the start
of the document to start searching at the end again.
*/
var findPrevious = /* @__PURE__ */ searchCommand((view, { query }) => {
	let { state } = view, { from } = state.selection.main;
	let prev = query.prevMatch(state, from, from);
	if (!prev) return false;
	let selection = EditorSelection.single(prev.from, prev.to);
	let config = view.state.facet(searchConfigFacet);
	view.dispatch({
		selection,
		effects: [announceMatch(view, prev), config.scrollToMatch(selection.main, view)],
		userEvent: "select.search"
	});
	selectSearchInput(view);
	return true;
});
/**
Select all instances of the search query.
*/
var selectMatches = /* @__PURE__ */ searchCommand((view, { query }) => {
	let ranges = query.matchAll(view.state, 1e3);
	if (!ranges || !ranges.length) return false;
	view.dispatch({
		selection: EditorSelection.create(ranges.map((r$2) => EditorSelection.range(r$2.from, r$2.to))),
		userEvent: "select.search.matches"
	});
	return true;
});
/**
Select all instances of the currently selected text.
*/
var selectSelectionMatches = ({ state, dispatch }) => {
	let sel = state.selection;
	if (sel.ranges.length > 1 || sel.main.empty) return false;
	let { from, to } = sel.main;
	let ranges = [], main = 0;
	for (let cur = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur.next().done;) {
		if (ranges.length > 1e3) return false;
		if (cur.value.from == from) main = ranges.length;
		ranges.push(EditorSelection.range(cur.value.from, cur.value.to));
	}
	dispatch(state.update({
		selection: EditorSelection.create(ranges, main),
		userEvent: "select.search.matches"
	}));
	return true;
};
/**
Replace the current match of the search query.
*/
var replaceNext = /* @__PURE__ */ searchCommand((view, { query }) => {
	let { state } = view, { from, to } = state.selection.main;
	if (state.readOnly) return false;
	let match = query.nextMatch(state, from, from);
	if (!match) return false;
	let next = match;
	let changes = [], selection, replacement;
	let effects = [];
	if (next.from == from && next.to == to) {
		replacement = state.toText(query.getReplacement(next));
		changes.push({
			from: next.from,
			to: next.to,
			insert: replacement
		});
		next = query.nextMatch(state, next.from, next.to);
		effects.push(EditorView.announce.of(state.phrase("replaced match on line $", state.doc.lineAt(from).number) + "."));
	}
	let changeSet = view.state.changes(changes);
	if (next) {
		selection = EditorSelection.single(next.from, next.to).map(changeSet);
		effects.push(announceMatch(view, next));
		effects.push(state.facet(searchConfigFacet).scrollToMatch(selection.main, view));
	}
	view.dispatch({
		changes: changeSet,
		selection,
		effects,
		userEvent: "input.replace"
	});
	return true;
});
/**
Replace all instances of the search query with the given
replacement.
*/
var replaceAll = /* @__PURE__ */ searchCommand((view, { query }) => {
	if (view.state.readOnly) return false;
	let changes = query.matchAll(view.state, 1e9).map((match) => {
		let { from, to } = match;
		return {
			from,
			to,
			insert: query.getReplacement(match)
		};
	});
	if (!changes.length) return false;
	let announceText = view.state.phrase("replaced $ matches", changes.length) + ".";
	view.dispatch({
		changes,
		effects: EditorView.announce.of(announceText),
		userEvent: "input.replace.all"
	});
	return true;
});
function createSearchPanel(view) {
	return view.state.facet(searchConfigFacet).createPanel(view);
}
function defaultQuery(state, fallback) {
	var _a, _b, _c, _d, _e$1;
	let sel = state.selection.main;
	let selText = sel.empty || sel.to > sel.from + 100 ? "" : state.sliceDoc(sel.from, sel.to);
	if (fallback && !selText) return fallback;
	let config = state.facet(searchConfigFacet);
	return new SearchQuery({
		search: ((_a = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a !== void 0 ? _a : config.literal) ? selText : selText.replace(/\n/g, "\\n"),
		caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config.caseSensitive,
		literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config.literal,
		regexp: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.regexp) !== null && _d !== void 0 ? _d : config.regexp,
		wholeWord: (_e$1 = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _e$1 !== void 0 ? _e$1 : config.wholeWord
	});
}
function getSearchInput(view) {
	let panel = getPanel(view, createSearchPanel);
	return panel && panel.dom.querySelector("[main-field]");
}
function selectSearchInput(view) {
	let input = getSearchInput(view);
	if (input && input == view.root.activeElement) input.select();
}
/**
Make sure the search panel is open and focused.
*/
var openSearchPanel = (view) => {
	let state = view.state.field(searchState, false);
	if (state && state.panel) {
		let searchInput = getSearchInput(view);
		if (searchInput && searchInput != view.root.activeElement) {
			let query = defaultQuery(view.state, state.query.spec);
			if (query.valid) view.dispatch({ effects: setSearchQuery.of(query) });
			searchInput.focus();
			searchInput.select();
		}
	} else view.dispatch({ effects: [togglePanel.of(true), state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : StateEffect.appendConfig.of(searchExtensions)] });
	return true;
};
/**
Close the search panel.
*/
var closeSearchPanel = (view) => {
	let state = view.state.field(searchState, false);
	if (!state || !state.panel) return false;
	let panel = getPanel(view, createSearchPanel);
	if (panel && panel.dom.contains(view.root.activeElement)) view.focus();
	view.dispatch({ effects: togglePanel.of(false) });
	return true;
};
/**
Default search-related key bindings.

- Mod-f: [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel)
- F3, Mod-g: [`findNext`](https://codemirror.net/6/docs/ref/#search.findNext)
- Shift-F3, Shift-Mod-g: [`findPrevious`](https://codemirror.net/6/docs/ref/#search.findPrevious)
- Mod-Alt-g: [`gotoLine`](https://codemirror.net/6/docs/ref/#search.gotoLine)
- Mod-d: [`selectNextOccurrence`](https://codemirror.net/6/docs/ref/#search.selectNextOccurrence)
*/
var searchKeymap = [
	{
		key: "Mod-f",
		run: openSearchPanel,
		scope: "editor search-panel"
	},
	{
		key: "F3",
		run: findNext,
		shift: findPrevious,
		scope: "editor search-panel",
		preventDefault: true
	},
	{
		key: "Mod-g",
		run: findNext,
		shift: findPrevious,
		scope: "editor search-panel",
		preventDefault: true
	},
	{
		key: "Escape",
		run: closeSearchPanel,
		scope: "editor search-panel"
	},
	{
		key: "Mod-Shift-l",
		run: selectSelectionMatches
	},
	{
		key: "Mod-Alt-g",
		run: gotoLine
	},
	{
		key: "Mod-d",
		run: selectNextOccurrence,
		preventDefault: true
	}
];
var SearchPanel = class {
	constructor(view) {
		this.view = view;
		let query = this.query = view.state.field(searchState).query.spec;
		this.commit = this.commit.bind(this);
		this.searchField = crelt("input", {
			value: query.search,
			placeholder: phrase(view, "Find"),
			"aria-label": phrase(view, "Find"),
			class: "cm-textfield",
			name: "search",
			form: "",
			"main-field": "true",
			onchange: this.commit,
			onkeyup: this.commit
		});
		this.replaceField = crelt("input", {
			value: query.replace,
			placeholder: phrase(view, "Replace"),
			"aria-label": phrase(view, "Replace"),
			class: "cm-textfield",
			name: "replace",
			form: "",
			onchange: this.commit,
			onkeyup: this.commit
		});
		this.caseField = crelt("input", {
			type: "checkbox",
			name: "case",
			form: "",
			checked: query.caseSensitive,
			onchange: this.commit
		});
		this.reField = crelt("input", {
			type: "checkbox",
			name: "re",
			form: "",
			checked: query.regexp,
			onchange: this.commit
		});
		this.wordField = crelt("input", {
			type: "checkbox",
			name: "word",
			form: "",
			checked: query.wholeWord,
			onchange: this.commit
		});
		function button(name, onclick, content) {
			return crelt("button", {
				class: "cm-button",
				name,
				onclick,
				type: "button"
			}, content);
		}
		this.dom = crelt("div", {
			onkeydown: (e$1) => this.keydown(e$1),
			class: "cm-search"
		}, [
			this.searchField,
			button("next", () => findNext(view), [phrase(view, "next")]),
			button("prev", () => findPrevious(view), [phrase(view, "previous")]),
			button("select", () => selectMatches(view), [phrase(view, "all")]),
			crelt("label", null, [this.caseField, phrase(view, "match case")]),
			crelt("label", null, [this.reField, phrase(view, "regexp")]),
			crelt("label", null, [this.wordField, phrase(view, "by word")]),
			...view.state.readOnly ? [] : [
				crelt("br"),
				this.replaceField,
				button("replace", () => replaceNext(view), [phrase(view, "replace")]),
				button("replaceAll", () => replaceAll(view), [phrase(view, "replace all")])
			],
			crelt("button", {
				name: "close",
				onclick: () => closeSearchPanel(view),
				"aria-label": phrase(view, "close"),
				type: "button"
			}, ["×"])
		]);
	}
	commit() {
		let query = new SearchQuery({
			search: this.searchField.value,
			caseSensitive: this.caseField.checked,
			regexp: this.reField.checked,
			wholeWord: this.wordField.checked,
			replace: this.replaceField.value
		});
		if (!query.eq(this.query)) {
			this.query = query;
			this.view.dispatch({ effects: setSearchQuery.of(query) });
		}
	}
	keydown(e$1) {
		if (runScopeHandlers(this.view, e$1, "search-panel")) e$1.preventDefault();
		else if (e$1.keyCode == 13 && e$1.target == this.searchField) {
			e$1.preventDefault();
			(e$1.shiftKey ? findPrevious : findNext)(this.view);
		} else if (e$1.keyCode == 13 && e$1.target == this.replaceField) {
			e$1.preventDefault();
			replaceNext(this.view);
		}
	}
	update(update) {
		for (let tr of update.transactions) for (let effect of tr.effects) if (effect.is(setSearchQuery) && !effect.value.eq(this.query)) this.setQuery(effect.value);
	}
	setQuery(query) {
		this.query = query;
		this.searchField.value = query.search;
		this.replaceField.value = query.replace;
		this.caseField.checked = query.caseSensitive;
		this.reField.checked = query.regexp;
		this.wordField.checked = query.wholeWord;
	}
	mount() {
		this.searchField.select();
	}
	get pos() {
		return 80;
	}
	get top() {
		return this.view.state.facet(searchConfigFacet).top;
	}
};
function phrase(view, phrase$1) {
	return view.state.phrase(phrase$1);
}
var AnnounceMargin = 30;
var Break = /[\s\.,:;?!]/;
function announceMatch(view, { from, to }) {
	let line = view.state.doc.lineAt(from), lineEnd = view.state.doc.lineAt(to).to;
	let start = Math.max(line.from, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);
	let text = view.state.sliceDoc(start, end);
	if (start != line.from) {
		for (let i$3 = 0; i$3 < AnnounceMargin; i$3++) if (!Break.test(text[i$3 + 1]) && Break.test(text[i$3])) {
			text = text.slice(i$3);
			break;
		}
	}
	if (end != lineEnd) {
		for (let i$3 = text.length - 1; i$3 > text.length - AnnounceMargin; i$3--) if (!Break.test(text[i$3 - 1]) && Break.test(text[i$3])) {
			text = text.slice(0, i$3);
			break;
		}
	}
	return EditorView.announce.of(`${view.state.phrase("current match")}. ${text} ${view.state.phrase("on line")} ${line.number}.`);
}
var baseTheme = /* @__PURE__ */ EditorView.baseTheme({
	".cm-panel.cm-search": {
		padding: "2px 6px 4px",
		position: "relative",
		"& [name=close]": {
			position: "absolute",
			top: "0",
			right: "4px",
			backgroundColor: "inherit",
			border: "none",
			font: "inherit",
			padding: 0,
			margin: 0
		},
		"& input, & button, & label": { margin: ".2em .6em .2em 0" },
		"& input[type=checkbox]": { marginRight: ".2em" },
		"& label": {
			fontSize: "80%",
			whiteSpace: "pre"
		}
	},
	"&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
	"&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
	"&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
	"&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
});
var searchExtensions = [
	searchState,
	/* @__PURE__ */ Prec.low(searchHighlighter),
	baseTheme
];

//#endregion
//#region node_modules/md-editor-v3/lib/es/MdEditor.mjs
var oo = (e$1, t$1, o$2) => {
	const n$3 = inject("editorId"), i$3 = inject("setting");
	let s$2 = () => {}, c$2 = () => {};
	const d$2 = () => {
		s$2();
		const u$4 = o$2.value?.view.contentDOM.getRootNode(), v$2 = u$4?.querySelector(`#${n$3} .cm-scroller`), m$2 = u$4?.querySelector(`[id="${n$3}-preview-wrapper"]`), f$3 = u$4?.querySelector(`[id="${n$3}-html-wrapper"]`);
		(m$2 || f$3) && ([c$2, s$2] = (m$2 ? he$1 : ve$2)(v$2, m$2 || f$3, o$2.value), e$1.scrollAuto && c$2());
	};
	watch([t$1, i$3], () => {
		nextTick(d$2);
	}), watch(() => e$1.scrollAuto, (u$4) => {
		u$4 ? c$2() : s$2();
	}), watch(() => i$3.value.previewOnly, (u$4) => {
		u$4 ? s$2() : c$2();
	}), onMounted(d$2);
}, ue$1 = async (e$1, t$1, o$2) => {
	if (/^h[1-6]$/.test(e$1)) return lo(e$1, t$1);
	if (e$1 === "prettier") return await ao(t$1, o$2);
	switch (e$1) {
		case "bold":
		case "underline":
		case "italic":
		case "strikeThrough":
		case "sub":
		case "sup":
		case "codeRow":
		case "katexInline":
		case "katexBlock": return ro(e$1, t$1);
		case "quote":
		case "orderedList":
		case "unorderedList":
		case "task": return io(e$1, t$1);
		case "code": return co(o$2, t$1);
		case "table": return bo(o$2);
		case "link": {
			const n$3 = t$1.getSelectedText(), { desc: i$3 = n$3, url: s$2 = "" } = o$2, c$2 = `[${i$3}](${s$2})`;
			return {
				text: c$2,
				options: {
					select: s$2 === "",
					deviationStart: c$2.length - s$2.length - 1,
					deviationEnd: -1
				}
			};
		}
		case "image": return mo(o$2, t$1);
		case "flow":
		case "sequence":
		case "gantt":
		case "class":
		case "state":
		case "pie":
		case "relationship":
		case "journey": return uo(e$1);
		case "universal": return vo(t$1.getSelectedText(), o$2);
		default: return {
			text: "",
			options: {}
		};
	}
}, lo = (e$1, t$1) => {
	const o$2 = e$1.slice(1), n$3 = "#".repeat(Number(o$2)), [i$3, s$2, c$2] = pe$1(t$1, { wholeLine: !0 });
	return {
		text: `${n$3} ${i$3}`,
		options: {
			deviationStart: n$3.length + 1,
			replaceStart: s$2,
			replaceEnd: c$2
		}
	};
}, ao = async (e$1, t$1) => {
	const o$2 = window.prettier || h$1.editorExtensions.prettier?.prettierInstance, n$3 = [window.prettierPlugins?.markdown || h$1.editorExtensions.prettier?.parserMarkdownInstance];
	return !o$2 || !n$3[0] ? (F$1.emit(t$1.editorId, N$1, {
		name: "prettier",
		message: "prettier is undefined"
	}), {
		text: e$1.getValue(),
		options: {
			select: !1,
			replaceAll: !0
		}
	}) : {
		text: await o$2.format(e$1.getValue(), {
			parser: "markdown",
			plugins: n$3
		}),
		options: {
			select: !1,
			replaceAll: !0
		}
	};
}, no = {
	bold: [
		"**",
		"**",
		2,
		-2
	],
	underline: [
		"<u>",
		"</u>",
		3,
		-4
	],
	italic: [
		"*",
		"*",
		1,
		-1
	],
	strikeThrough: [
		"~~",
		"~~",
		2,
		-2
	],
	sub: [
		"~",
		"~",
		1,
		-1
	],
	sup: [
		"^",
		"^",
		1,
		-1
	],
	codeRow: [
		"`",
		"`",
		1,
		-1
	],
	katexInline: [
		"$",
		"$",
		1,
		-1
	],
	katexBlock: [
		`
$$
`,
		`
$$
`,
		4,
		-4
	]
}, ro = (e$1, t$1) => {
	const o$2 = t$1.getSelectedText(), [n$3, i$3, s$2, c$2] = no[e$1];
	return {
		text: `${n$3}${o$2}${i$3}`,
		options: {
			deviationStart: s$2,
			deviationEnd: c$2
		}
	};
}, so = {
	quote: "> ",
	unorderedList: "- ",
	orderedList: 1,
	task: "- [ ] "
}, io = (e$1, t$1) => {
	const [o$2, n$3, i$3] = pe$1(t$1, { wholeLine: !0 }), s$2 = o$2.split(`
`), c$2 = so[e$1], d$2 = e$1 === "orderedList" ? s$2.map((m$2, f$3) => `${c$2 + f$3}. ${m$2}`) : s$2.map((m$2) => `${c$2}${m$2}`), u$4 = e$1 === "orderedList" ? "1. " : c$2.toString(), v$2 = s$2.length === 1 ? u$4.length : 0;
	return {
		text: d$2.join(`
`),
		options: {
			deviationStart: v$2,
			replaceStart: n$3,
			replaceEnd: i$3
		}
	};
}, co = (e$1, t$1) => {
	const [o$2, n$3, i$3] = pe$1(t$1), s$2 = e$1.mode || "language", c$2 = `
\`\`\`${s$2}
${e$1.text || o$2 || ""}
\`\`\`
`;
	return {
		text: c$2,
		options: {
			deviationStart: 4,
			deviationEnd: 4 + s$2.length - c$2.length,
			replaceStart: n$3,
			replaceEnd: i$3
		}
	};
}, uo = (e$1) => ({
	text: `
\`\`\`mermaid
${{
		flow: `flowchart TD 
  Start --> Stop`,
		sequence: `sequenceDiagram
  A->>B: hello!
  B-->>A: hi!`,
		gantt: `gantt
title Gantt Chart
dateFormat  YYYY-MM-DD`,
		class: `classDiagram
  class Animal`,
		state: `stateDiagram-v2
  s1 --> s2`,
		pie: `pie
  "Dogs" : 386
  "Cats" : 85
  "Rats" : 15`,
		relationship: `erDiagram
  CAR ||--o{ NAMED-DRIVER : allows`,
		journey: `journey
  title My Journey`,
		...h$1.editorConfig.mermaidTemplate
	}[e$1]}
\`\`\`
`,
	options: {
		deviationStart: 12,
		deviationEnd: -5
	}
}), mo = (e$1, t$1) => {
	const o$2 = t$1.getSelectedText(), { desc: n$3 = o$2, url: i$3 = "", urls: s$2 } = e$1;
	let c$2 = "";
	const d$2 = i$3 === "" && (!s$2 || s$2 instanceof Array && s$2.length === 0);
	return s$2 instanceof Array ? c$2 = s$2.reduce((u$4, v$2) => {
		const { url: m$2 = "", alt: f$3 = "", title: g$4 = "" } = typeof v$2 == "object" ? v$2 : { url: v$2 };
		return u$4 + `![${f$3}](${m$2}${g$4 ? " '" + g$4 + "'" : ""})
`;
	}, "") : c$2 = `![${n$3}](${i$3})
`, {
		text: c$2,
		options: {
			select: i$3 === "",
			deviationStart: d$2 ? c$2.length - i$3.length - 2 : c$2.length,
			deviationEnd: d$2 ? -2 : 0
		}
	};
}, bo = (e$1) => {
	const { selectedShape: t$1 = {
		x: 1,
		y: 1
	} } = e$1, { x: o$2, y: n$3 } = t$1;
	let i$3 = `
| Column`;
	for (let s$2 = 0; s$2 <= n$3; s$2++) i$3 += " |";
	i$3 += `
|`;
	for (let s$2 = 0; s$2 <= n$3; s$2++) i$3 += " - |";
	for (let s$2 = 0; s$2 <= o$2; s$2++) {
		i$3 += `
|`;
		for (let c$2 = 0; c$2 <= n$3; c$2++) i$3 += " |";
	}
	return i$3 += `
`, {
		text: i$3,
		options: {
			deviationStart: 3,
			deviationEnd: 10 - i$3.length
		}
	};
}, vo = (e$1, t$1) => {
	const { generate: o$2 } = t$1, n$3 = o$2(e$1);
	return {
		text: n$3.targetValue,
		options: {
			select: n$3.select ?? !0,
			deviationStart: n$3.deviationStart || 0,
			deviationEnd: n$3.deviationEnd || 0
		}
	};
}, pe$1 = (e$1, t$1 = { wholeLine: !1 }) => {
	const o$2 = e$1.view.state, n$3 = o$2.selection.main;
	if (n$3.empty) {
		const i$3 = o$2.doc.lineAt(n$3.from);
		return [
			o$2.doc.lineAt(n$3.from).text,
			i$3.from,
			i$3.to
		];
	} else if (t$1.wholeLine) {
		const i$3 = o$2.doc.lineAt(n$3.from), s$2 = o$2.doc.lineAt(n$3.to);
		return [
			o$2.doc.sliceString(i$3.from, s$2.to),
			i$3.from,
			s$2.to
		];
	}
	return [
		o$2.doc.sliceString(n$3.from, n$3.to),
		n$3.from,
		n$3.to
	];
}, G$1 = (e$1) => {
	const t$1 = new Compartment();
	return (n$3) => (t$1.get(e$1.state) ? e$1.dispatch({ effects: t$1.reconfigure(n$3) }) : e$1.dispatch({ effects: StateEffect.appendConfig.of(t$1.of(n$3)) }), !0);
};
var go = class {
	view;
	maxLength = Number.MAX_SAFE_INTEGER;
	toggleTabSize;
	togglePlaceholder;
	/**
	* 设置全部的扩展
	*/
	setExtensions;
	toggleDisabled;
	toggleReadOnly;
	toggleMaxlength;
	getValue() {
		return this.view.state.doc.toString();
	}
	/**
	* 设置内容
	*
	* @param insert 待插入内容
	* @param from 插入开始位置
	* @param to 插入结束位置
	*/
	setValue(t$1, o$2 = 0, n$3 = this.view.state.doc.length) {
		this.view.dispatch({ changes: {
			from: o$2,
			to: n$3,
			insert: t$1
		} });
	}
	/**
	* 获取选中的文本
	*/
	getSelectedText() {
		const { from: t$1, to: o$2 } = this.view.state.selection.main;
		return this.view.state.sliceDoc(t$1, o$2);
	}
	/**
	* 使用新的内容替换选中的内容
	*
	* @param text 待替换内容
	* @param options 替换后是否选中
	*/
	replaceSelectedText(t$1, o$2, n$3) {
		const i$3 = {
			select: !0,
			deviationStart: 0,
			deviationEnd: 0,
			replaceAll: !1,
			replaceStart: -1,
			replaceEnd: -1,
			...o$2
		};
		try {
			if (i$3.replaceAll) {
				if (this.setValue(t$1), t$1.length > this.maxLength) throw new Error("The input text is too long");
				return;
			}
			if (this.view.state.doc.length - this.getSelectedText().length + t$1.length > this.maxLength) throw new Error("The input text is too long");
			const { from: s$2 } = this.view.state.selection.main;
			i$3.replaceStart !== -1 ? this.view.dispatch({ changes: {
				from: i$3.replaceStart,
				to: i$3.replaceEnd,
				insert: t$1
			} }) : this.view.dispatch(this.view.state.replaceSelection(t$1)), i$3.select && this.view.dispatch({ selection: {
				anchor: i$3.replaceStart === -1 ? s$2 + i$3.deviationStart : i$3.replaceStart + i$3.deviationStart,
				head: i$3.replaceStart === -1 ? s$2 + t$1.length + i$3.deviationEnd : i$3.replaceStart + t$1.length + i$3.deviationEnd
			} }), this.view.focus();
		} catch (s$2) {
			if (s$2.message === "The input text is too long") F$1.emit(n$3, N$1, {
				name: "overlength",
				message: s$2.message,
				data: t$1
			});
			else throw s$2;
		}
	}
	constructor(t$1) {
		this.view = t$1, this.toggleTabSize = G$1(this.view), this.togglePlaceholder = G$1(this.view), this.setExtensions = G$1(this.view), this.toggleDisabled = G$1(this.view), this.toggleReadOnly = G$1(this.view), this.toggleMaxlength = G$1(this.view);
	}
	/**
	* 设置tabSize
	*
	* @param tabSize 需要切换的大小
	*/
	setTabSize(t$1) {
		this.toggleTabSize([EditorState.tabSize.of(t$1), indentUnit.of(" ".repeat(t$1))]);
	}
	/**
	* 设置placeholder
	*
	* @param t 目标内容
	*/
	setPlaceholder(t$1) {
		this.togglePlaceholder(placeholder(t$1));
	}
	focus(t$1) {
		if (this.view.focus(), !t$1) return;
		let o$2 = 0, n$3 = 0, i$3 = 0;
		switch (t$1) {
			case "start": break;
			case "end":
				o$2 = n$3 = i$3 = this.getValue().length;
				break;
			default: o$2 = t$1.rangeAnchor || t$1.cursorPos, n$3 = t$1.rangeHead || t$1.cursorPos, i$3 = t$1.cursorPos;
		}
		this.view.dispatch({
			scrollIntoView: !0,
			selection: EditorSelection.create([EditorSelection.range(o$2, n$3), EditorSelection.cursor(i$3)], 1)
		});
	}
	setDisabled(t$1) {
		this.toggleDisabled([EditorView.editable.of(!t$1)]);
	}
	setReadOnly(t$1) {
		this.toggleReadOnly([EditorState.readOnly.of(t$1)]);
	}
	setMaxLength(t$1) {
		this.maxLength = t$1, this.toggleMaxlength([EditorState.changeFilter.of((o$2) => o$2.newDoc.length <= t$1)]);
	}
};
var ho = (e$1, t$1) => {
	if (e$1 === t$1) return !0;
	if (e$1.length !== t$1.length) return !1;
	for (let o$2 = 0; o$2 < e$1.length; o$2++) if (e$1[o$2] !== t$1[o$2]) return !1;
	return !0;
}, fo = (e$1, t$1) => {
	const o$2 = ref(t$1.value);
	watch([t$1], () => {
		(!o$2.value || !ho(o$2.value, t$1.value)) && (o$2.value = t$1.value, e$1());
	});
}, ae$1 = (e$1, t$1, o$2, n$3, i$3) => (s$2, c$2, d$2, u$4) => {
	const v$2 = `${e$1}${t$1}${o$2}${n$3}`, m$2 = d$2 + c$2.label.length + (i$3 === "title" ? o$2.length : 0);
	s$2.dispatch({
		changes: {
			from: d$2,
			to: u$4,
			insert: v$2
		},
		selection: EditorSelection.create([EditorSelection.range(d$2 + c$2.label.length + (i$3 === "title" ? 1 : -t$1.length), m$2), EditorSelection.cursor(m$2)], 1)
	}), s$2.focus();
}, Ie$1 = (e$1) => (t$1, o$2, n$3, i$3) => {
	const s$2 = e$1.slice(i$3 - n$3);
	t$1.dispatch(t$1.state.replaceSelection(`${s$2} `));
}, Ee$1 = (e$1) => {
	const t$1 = (o$2) => {
		const n$3 = o$2.matchBefore(/^#+|^-\s*\[*\s*\]*|`+|\[|!\[*|^\|\s?\|?|\$\$?|!+\s*\w*/);
		return n$3 === null || n$3.from == n$3.to && o$2.explicit ? null : {
			from: n$3.from,
			options: [
				...[
					"h2",
					"h3",
					"h4",
					"h5",
					"h6"
				].map((i$3, s$2) => {
					const c$2 = new Array(s$2 + 2).fill("#").join("");
					return {
						label: c$2,
						type: "text",
						apply: Ie$1(c$2)
					};
				}),
				...["unchecked", "checked"].map((i$3) => {
					const s$2 = i$3 === "checked" ? "- [x]" : "- [ ]";
					return {
						label: s$2,
						type: "text",
						apply: Ie$1(s$2)
					};
				}),
				...[
					["`", ""],
					["```", "language"],
					["```mermaid\n", ""],
					["```echarts\n", ""]
				].map((i$3) => ({
					label: `${i$3[0]}${i$3[1]}`,
					type: "text",
					apply: ae$1(i$3[0], i$3[1], "", i$3[0] === "`" ? "`" : "\n```", "type")
				})),
				{
					label: "[]()",
					type: "text"
				},
				{
					label: "![]()",
					type: "text"
				},
				{
					label: "| |",
					type: "text",
					detail: "table",
					apply: `| col | col | col |
| - | - | - |
| content | content | content |
| content | content | content |`
				},
				{
					label: "$",
					type: "text",
					apply: ae$1("$", "", "", "$", "type")
				},
				{
					label: "$$",
					type: "text",
					apply: ae$1("$$", "", `
`, `
$$`, "title")
				},
				...[
					"note",
					"abstract",
					"info",
					"tip",
					"success",
					"question",
					"warning",
					"failure",
					"danger",
					"bug",
					"example",
					"quote",
					"hint",
					"caution",
					"error",
					"attention"
				].map((i$3) => ({
					label: `!!! ${i$3}`,
					type: "text",
					apply: ae$1("!!!", ` ${i$3}`, " Title", `

!!!`, "title")
				}))
			]
		};
	};
	return autocompletion({ override: e$1 ? [t$1, ...e$1] : [t$1] });
}, po = /* @__PURE__ */ defineComponent({
	name: `${p$1}-divider`,
	setup() {
		return () => createVNode("div", { class: `${p$1}-divider` }, null);
	}
}), To = /* @__PURE__ */ defineComponent({
	name: "ToolbarBold",
	setup() {
		const e$1 = inject("editorId"), t$1 = inject("usedLanguageText"), o$2 = inject("disabled"), n$3 = inject("showToolbarName");
		return () => createVNode("button", {
			class: [`${p$1}-toolbar-item`, o$2?.value && `${p$1}-disabled`],
			title: t$1.value.toolbarTips?.bold,
			disabled: o$2?.value,
			onClick: () => {
				F$1.emit(e$1, G, "bold");
			},
			type: "button"
		}, [createVNode(P, { name: "bold" }, null), n$3?.value && createVNode("div", { class: `${p$1}-toolbar-item-name` }, [t$1.value.toolbarTips?.bold])]);
	}
}), wo = /* @__PURE__ */ defineComponent({
	name: "ToolbarCatalog",
	setup() {
		const e$1 = inject("editorId"), t$1 = inject("usedLanguageText"), o$2 = inject("disabled"), n$3 = inject("showToolbarName"), i$3 = inject("catalogVisible");
		return () => createVNode("button", {
			class: [
				`${p$1}-toolbar-item`,
				i$3.value && `${p$1}-toolbar-active`,
				o$2?.value && `${p$1}-disabled`
			],
			title: t$1.value.toolbarTips?.catalog,
			disabled: o$2?.value,
			onClick: () => {
				F$1.emit(e$1, C$1);
			},
			key: "bar-catalog",
			type: "button"
		}, [createVNode(P, { name: "catalog" }, null), n$3?.value && createVNode("div", { class: `${p$1}-toolbar-item-name` }, [t$1.value.toolbarTips?.catalog])]);
	}
}), yo = /* @__PURE__ */ defineComponent({
	name: "ToolbarCode",
	setup() {
		const e$1 = inject("editorId"), t$1 = inject("usedLanguageText"), o$2 = inject("disabled"), n$3 = inject("showToolbarName");
		return () => createVNode("button", {
			class: [`${p$1}-toolbar-item`, o$2?.value && `${p$1}-disabled`],
			title: t$1.value.toolbarTips?.code,
			disabled: o$2?.value,
			onClick: () => {
				F$1.emit(e$1, G, "code");
			},
			type: "button"
		}, [createVNode(P, { name: "code" }, null), n$3?.value && createVNode("div", { class: `${p$1}-toolbar-item-name` }, [t$1.value.toolbarTips?.code])]);
	}
}), Co = /* @__PURE__ */ defineComponent({
	name: "ToolbarCodeRow",
	setup() {
		const e$1 = inject("editorId"), t$1 = inject("usedLanguageText"), o$2 = inject("disabled"), n$3 = inject("showToolbarName");
		return () => createVNode("button", {
			class: [`${p$1}-toolbar-item`, o$2?.value && `${p$1}-disabled`],
			title: t$1.value.toolbarTips?.codeRow,
			disabled: o$2?.value,
			onClick: () => {
				F$1.emit(e$1, G, "codeRow");
			},
			type: "button"
		}, [createVNode(P, { name: "code-row" }, null), n$3?.value && createVNode("div", { class: `${p$1}-toolbar-item-name` }, [t$1.value.toolbarTips?.codeRow])]);
	}
}), ko = /* @__PURE__ */ defineComponent({
	name: "ToolbarFullscreen",
	setup() {
		const e$1 = inject("usedLanguageText"), t$1 = inject("disabled"), o$2 = inject("showToolbarName"), n$3 = inject("setting"), { fullscreenHandler: i$3 } = tl();
		return () => createVNode("button", {
			class: [
				`${p$1}-toolbar-item`,
				n$3.value.fullscreen && `${p$1}-toolbar-active`,
				t$1?.value && `${p$1}-disabled`
			],
			title: e$1.value.toolbarTips?.fullscreen,
			disabled: t$1?.value,
			onClick: () => {
				i$3();
			},
			type: "button"
		}, [createVNode(P, { name: n$3.value.fullscreen ? "fullscreen-exit" : "fullscreen" }, null), o$2?.value && createVNode("div", { class: `${p$1}-toolbar-item-name` }, [e$1.value.toolbarTips?.fullscreen])]);
	}
}), $o = /* @__PURE__ */ defineComponent({
	name: "ToolbarGithub",
	setup() {
		const e$1 = inject("usedLanguageText"), t$1 = inject("disabled"), o$2 = inject("showToolbarName");
		return () => createVNode("button", {
			class: [`${p$1}-toolbar-item`, t$1?.value && `${p$1}-disabled`],
			title: e$1.value.toolbarTips?.github,
			disabled: t$1?.value,
			onClick: () => {
				L("https://github.com/imzbf/md-editor-v3");
			},
			type: "button"
		}, [createVNode(P, { name: "github" }, null), o$2?.value && createVNode("div", { class: `${p$1}-toolbar-item-name` }, [e$1.value.toolbarTips?.github])]);
	}
}), xo = /* @__PURE__ */ defineComponent({
	name: "ToolbarHtmlPreview",
	setup() {
		const e$1 = inject("usedLanguageText"), t$1 = inject("disabled"), o$2 = inject("showToolbarName"), n$3 = inject("setting"), i$3 = inject("updateSetting");
		return () => createVNode("button", {
			class: [
				`${p$1}-toolbar-item`,
				n$3.value.htmlPreview && `${p$1}-toolbar-active`,
				t$1?.value && `${p$1}-disabled`
			],
			title: e$1.value.toolbarTips?.htmlPreview,
			disabled: t$1?.value,
			onClick: () => {
				i$3("htmlPreview");
			},
			type: "button"
		}, [createVNode(P, { name: "preview-html" }, null), o$2?.value && createVNode("div", { class: `${p$1}-toolbar-item-name` }, [e$1.value.toolbarTips?.htmlPreview])]);
	}
}), So = /* @__PURE__ */ defineComponent({
	name: "ToolbarImage",
	setup() {
		const e$1 = inject("editorId"), t$1 = inject("usedLanguageText"), o$2 = inject("disabled"), n$3 = inject("showToolbarName");
		return () => createVNode("button", {
			class: [`${p$1}-toolbar-item`, o$2?.value && `${p$1}-disabled`],
			title: t$1.value.toolbarTips?.image,
			disabled: o$2?.value,
			onClick: () => {
				F$1.emit(e$1, G, "image");
			},
			type: "button"
		}, [createVNode(P, { name: "image" }, null), n$3?.value && createVNode("div", { class: `${p$1}-toolbar-item-name` }, [t$1.value.toolbarTips?.image])]);
	}
}), Io = {
	visible: {
		type: Boolean,
		default: !1
	},
	onCancel: {
		type: Function,
		default: () => {}
	},
	onOk: {
		type: Function,
		default: () => {}
	}
}, Eo = /* @__PURE__ */ defineComponent({
	name: `${p$1}-modal-clip`,
	props: Io,
	setup(e$1) {
		const t$1 = inject("usedLanguageText"), o$2 = inject("editorId"), n$3 = inject("rootRef");
		let i$3 = h$1.editorExtensions.cropper.instance;
		const s$2 = ref(), c$2 = ref(), d$2 = ref(), u$4 = reactive({
			cropperInited: !1,
			imgSelected: !1,
			imgSrc: "",
			isFullscreen: !1
		});
		let v$2 = null;
		watch(() => e$1.visible, () => {
			e$1.visible && !u$4.cropperInited && (i$3 = i$3 || window.Cropper, s$2.value.onchange = () => {
				if (!i$3) {
					F$1.emit(o$2, N$1, {
						name: "Cropper",
						message: "Cropper is undefined"
					});
					return;
				}
				const g$4 = s$2.value.files || [];
				if (u$4.imgSelected = !0, g$4?.length > 0) {
					const p$3 = new FileReader();
					p$3.onload = (k$2) => {
						u$4.imgSrc = k$2.target.result;
					}, p$3.readAsDataURL(g$4[0]);
				}
			});
		}), watch(() => [u$4.imgSelected], () => {
			d$2.value.style = "";
		}), watch([toRef(() => u$4.isFullscreen), toRef(() => u$4.imgSrc)], () => {
			u$4.imgSrc && nextTick(() => {
				v$2?.destroy(), d$2.value.style = "", c$2.value && (v$2 = new i$3(c$2.value, {
					viewMode: 2,
					preview: n$3.value.getRootNode().querySelector(`.${p$1}-clip-preview-target`)
				}));
			});
		});
		const m$2 = () => {
			v$2.clear(), v$2.destroy(), v$2 = null, s$2.value.value = "", u$4.imgSelected = !1, u$4.imgSrc = "";
		}, f$3 = (g$4) => {
			u$4.isFullscreen = g$4;
		};
		return () => createVNode(S, {
			class: `${p$1}-modal-clip`,
			title: t$1.value.clipModalTips?.title,
			visible: e$1.visible,
			onClose: e$1.onCancel,
			showAdjust: !0,
			isFullscreen: u$4.isFullscreen,
			onAdjust: f$3,
			width: "668px",
			height: "421px"
		}, { default: () => [
			createVNode("div", { class: `${p$1}-form-item ${p$1}-clip` }, [createVNode("div", { class: `${p$1}-clip-main` }, [u$4.imgSelected ? createVNode("div", { class: `${p$1}-clip-cropper` }, [createVNode("img", {
				src: u$4.imgSrc,
				ref: c$2,
				style: { display: "none" },
				alt: ""
			}, null), createVNode("div", {
				class: `${p$1}-clip-delete`,
				onClick: m$2
			}, [createVNode(P, { name: "delete" }, null)])]) : createVNode("div", {
				class: `${p$1}-clip-upload`,
				onClick: () => {
					s$2.value.click();
				},
				role: "button",
				tabindex: "0",
				"aria-label": t$1.value.imgTitleItem?.upload
			}, [createVNode(P, { name: "upload" }, null)])]), createVNode("div", { class: `${p$1}-clip-preview` }, [createVNode("div", {
				class: `${p$1}-clip-preview-target`,
				ref: d$2
			}, null)])]),
			createVNode("div", { class: `${p$1}-form-item` }, [createVNode("button", {
				class: `${p$1}-btn`,
				type: "button",
				onClick: () => {
					if (v$2) {
						const g$4 = v$2.getCroppedCanvas();
						F$1.emit(o$2, I, [u$2(g$4.toDataURL("image/png"))], e$1.onOk), m$2();
					}
				}
			}, [t$1.value.clipModalTips?.buttonUpload || t$1.value.linkModalTips?.buttonOK])]),
			createVNode("input", {
				ref: s$2,
				accept: "image/*",
				type: "file",
				multiple: !1,
				style: { display: "none" },
				"aria-hidden": "true"
			}, null)
		] });
	}
}), Lo = {
	clipVisible: {
		type: Boolean,
		default: !1
	},
	onCancel: {
		type: Function,
		default: () => {}
	},
	onOk: {
		type: Function,
		default: () => {}
	}
}, No = /* @__PURE__ */ defineComponent({
	name: `${p$1}-modals`,
	props: Lo,
	setup(e$1) {
		return () => createVNode(Eo, {
			visible: e$1.clipVisible,
			onOk: e$1.onOk,
			onCancel: e$1.onCancel
		}, null);
	}
}), Ao = /* @__PURE__ */ defineComponent({
	name: "ToolbarImageDropdown",
	setup() {
		const e$1 = inject("editorId"), t$1 = inject("usedLanguageText"), o$2 = inject("disabled"), n$3 = inject("showToolbarName"), i$3 = `${e$1}-toolbar-wrapper`, s$2 = ref(!1), c$2 = ref(!1), d$2 = ref(), u$4 = () => {
			F$1.emit(e$1, I, Array.from(d$2.value.files || [])), d$2.value.value = "";
		}, v$2 = (k$2, E) => {
			o$2?.value || F$1.emit(e$1, G, k$2, E);
		};
		onMounted(() => {
			d$2.value.addEventListener("change", u$4);
		});
		const m$2 = (k$2) => {
			s$2.value = k$2;
		}, f$3 = () => {
			c$2.value = !1;
		}, g$4 = (k$2) => {
			k$2 && v$2("image", {
				desc: k$2.desc,
				url: k$2.url,
				transform: !0
			}), c$2.value = !1;
		}, p$3 = computed(() => createVNode("ul", {
			class: `${p$1}-menu`,
			onClick: () => {
				s$2.value = !1;
			},
			role: "menu"
		}, [
			createVNode("li", {
				class: `${p$1}-menu-item ${p$1}-menu-item-image`,
				onClick: () => {
					v$2("image");
				},
				role: "menuitem",
				tabindex: "0"
			}, [t$1.value.imgTitleItem?.link]),
			createVNode("li", {
				class: `${p$1}-menu-item ${p$1}-menu-item-image`,
				onClick: () => {
					d$2.value.click();
				},
				role: "menuitem",
				tabindex: "0"
			}, [t$1.value.imgTitleItem?.upload]),
			createVNode("li", {
				class: `${p$1}-menu-item ${p$1}-menu-item-image`,
				onClick: () => {
					c$2.value = !0;
				},
				role: "menuitem",
				tabindex: "0"
			}, [t$1.value.imgTitleItem?.clip2upload])
		]));
		return () => createVNode(Fragment, null, [
			createVNode("label", {
				for: `${i$3}_label`,
				style: { display: "none" },
				"aria-label": t$1.value.imgTitleItem?.upload
			}, null),
			createVNode("input", {
				id: `${i$3}_label`,
				ref: d$2,
				accept: "image/*",
				type: "file",
				multiple: !0,
				style: { display: "none" }
			}, null),
			createVNode(j$2, {
				relative: `#${i$3}`,
				visible: s$2.value,
				onChange: m$2,
				disabled: o$2?.value,
				overlay: p$3.value
			}, { default: () => [createVNode("button", {
				class: [`${p$1}-toolbar-item`, o$2?.value && `${p$1}-disabled`],
				title: t$1.value.toolbarTips?.image,
				disabled: o$2?.value,
				type: "button"
			}, [createVNode(P, { name: "image" }, null), n$3?.value && createVNode("div", { class: `${p$1}-toolbar-item-name` }, [t$1.value.toolbarTips?.image])])] }),
			createVNode(No, {
				clipVisible: c$2.value,
				onCancel: f$3,
				onOk: g$4
			}, null)
		]);
	}
}), Do = /* @__PURE__ */ defineComponent({
	name: "ToolbarItalic",
	setup() {
		const e$1 = inject("editorId"), t$1 = inject("usedLanguageText"), o$2 = inject("disabled"), n$3 = inject("showToolbarName");
		return () => createVNode("button", {
			class: [`${p$1}-toolbar-item`, o$2?.value && `${p$1}-disabled`],
			title: t$1.value.toolbarTips?.italic,
			disabled: o$2?.value,
			onClick: () => {
				F$1.emit(e$1, G, "italic");
			},
			type: "button"
		}, [createVNode(P, { name: "italic" }, null), n$3?.value && createVNode("div", { class: `${p$1}-toolbar-item-name` }, [t$1.value.toolbarTips?.italic])]);
	}
}), Ro = /* @__PURE__ */ defineComponent({
	name: "ToolbarKatex",
	setup() {
		const e$1 = inject("editorId"), t$1 = inject("usedLanguageText"), o$2 = inject("disabled"), n$3 = inject("showToolbarName"), i$3 = `${e$1}-toolbar-wrapper`, s$2 = ref(!1), c$2 = (v$2) => {
			o$2?.value || F$1.emit(e$1, G, v$2);
		}, d$2 = (v$2) => {
			s$2.value = v$2;
		}, u$4 = computed(() => createVNode("ul", {
			class: `${p$1}-menu`,
			onClick: () => {
				s$2.value = !1;
			},
			role: "menu"
		}, [createVNode("li", {
			class: `${p$1}-menu-item ${p$1}-menu-item-katex`,
			onClick: () => {
				c$2("katexInline");
			},
			role: "menuitem",
			tabindex: "0"
		}, [t$1.value.katex?.inline]), createVNode("li", {
			class: `${p$1}-menu-item ${p$1}-menu-item-katex`,
			onClick: () => {
				c$2("katexBlock");
			},
			role: "menuitem",
			tabindex: "0"
		}, [t$1.value.katex?.block])]));
		return () => createVNode(j$2, {
			relative: `#${i$3}`,
			visible: s$2.value,
			onChange: d$2,
			disabled: o$2?.value,
			overlay: u$4.value,
			key: "bar-katex"
		}, { default: () => [createVNode("button", {
			class: [`${p$1}-toolbar-item`, o$2?.value && `${p$1}-disabled`],
			title: t$1.value.toolbarTips?.katex,
			disabled: o$2?.value,
			type: "button"
		}, [createVNode(P, { name: "formula" }, null), n$3?.value && createVNode("div", { class: `${p$1}-toolbar-item-name` }, [t$1.value.toolbarTips?.katex])])] });
	}
}), Mo = /* @__PURE__ */ defineComponent({
	name: "ToolbarLink",
	setup() {
		const e$1 = inject("editorId"), t$1 = inject("usedLanguageText"), o$2 = inject("disabled"), n$3 = inject("showToolbarName");
		return () => createVNode("button", {
			class: [`${p$1}-toolbar-item`, o$2?.value && `${p$1}-disabled`],
			title: t$1.value.toolbarTips?.link,
			disabled: o$2?.value,
			onClick: () => {
				F$1.emit(e$1, G, "link");
			},
			type: "button"
		}, [createVNode(P, { name: "link" }, null), n$3?.value && createVNode("div", { class: `${p$1}-toolbar-item-name` }, [t$1.value.toolbarTips?.link])]);
	}
}), Fo = /* @__PURE__ */ defineComponent({
	name: "ToolbarMermaid",
	setup() {
		const e$1 = inject("editorId"), t$1 = inject("usedLanguageText"), o$2 = inject("disabled"), n$3 = inject("showToolbarName"), i$3 = `${e$1}-toolbar-wrapper`, s$2 = ref(!1), c$2 = (v$2) => {
			o$2?.value || F$1.emit(e$1, G, v$2);
		}, d$2 = (v$2) => {
			s$2.value = v$2;
		}, u$4 = computed(() => createVNode("ul", {
			class: `${p$1}-menu`,
			onClick: () => {
				s$2.value = !1;
			},
			role: "menu"
		}, [
			createVNode("li", {
				class: `${p$1}-menu-item ${p$1}-menu-item-mermaid`,
				onClick: () => {
					c$2("flow");
				},
				role: "menuitem",
				tabindex: "0"
			}, [t$1.value.mermaid?.flow]),
			createVNode("li", {
				class: `${p$1}-menu-item ${p$1}-menu-item-mermaid`,
				onClick: () => {
					c$2("sequence");
				},
				role: "menuitem",
				tabindex: "0"
			}, [t$1.value.mermaid?.sequence]),
			createVNode("li", {
				class: `${p$1}-menu-item ${p$1}-menu-item-mermaid`,
				onClick: () => {
					c$2("gantt");
				},
				role: "menuitem",
				tabindex: "0"
			}, [t$1.value.mermaid?.gantt]),
			createVNode("li", {
				class: `${p$1}-menu-item ${p$1}-menu-item-mermaid`,
				onClick: () => {
					c$2("class");
				},
				role: "menuitem",
				tabindex: "0"
			}, [t$1.value.mermaid?.class]),
			createVNode("li", {
				class: `${p$1}-menu-item ${p$1}-menu-item-mermaid`,
				onClick: () => {
					c$2("state");
				},
				role: "menuitem",
				tabindex: "0"
			}, [t$1.value.mermaid?.state]),
			createVNode("li", {
				class: `${p$1}-menu-item ${p$1}-menu-item-mermaid`,
				onClick: () => {
					c$2("pie");
				},
				role: "menuitem",
				tabindex: "0"
			}, [t$1.value.mermaid?.pie]),
			createVNode("li", {
				class: `${p$1}-menu-item ${p$1}-menu-item-mermaid`,
				onClick: () => {
					c$2("relationship");
				},
				role: "menuitem",
				tabindex: "0"
			}, [t$1.value.mermaid?.relationship]),
			createVNode("li", {
				class: `${p$1}-menu-item ${p$1}-menu-item-mermaid`,
				onClick: () => {
					c$2("journey");
				},
				role: "menuitem",
				tabindex: "0"
			}, [t$1.value.mermaid?.journey])
		]));
		return () => createVNode(j$2, {
			relative: `#${i$3}`,
			visible: s$2.value,
			onChange: d$2,
			disabled: o$2?.value,
			overlay: u$4.value,
			key: "bar-mermaid"
		}, { default: () => [createVNode("button", {
			class: [`${p$1}-toolbar-item`, o$2?.value && `${p$1}-disabled`],
			title: t$1.value.toolbarTips?.mermaid,
			disabled: o$2?.value,
			type: "button"
		}, [createVNode(P, { name: "mermaid" }, null), n$3?.value && createVNode("div", { class: `${p$1}-toolbar-item-name` }, [t$1.value.toolbarTips?.mermaid])])] });
	}
}), Bo = /* @__PURE__ */ defineComponent({
	name: "ToolbarNext",
	setup() {
		const e$1 = inject("editorId"), t$1 = inject("usedLanguageText"), o$2 = inject("disabled"), n$3 = inject("showToolbarName");
		return () => createVNode("button", {
			class: [`${p$1}-toolbar-item`, o$2?.value && `${p$1}-disabled`],
			title: t$1.value.toolbarTips?.next,
			disabled: o$2?.value,
			onClick: () => {
				F$1.emit(e$1, d);
			},
			type: "button"
		}, [createVNode(P, { name: "next" }, null), n$3?.value && createVNode("div", { class: `${p$1}-toolbar-item-name` }, [t$1.value.toolbarTips?.next])]);
	}
}), Po = /* @__PURE__ */ defineComponent({
	name: "ToolbarOrderedList",
	setup() {
		const e$1 = inject("editorId"), t$1 = inject("usedLanguageText"), o$2 = inject("disabled"), n$3 = inject("showToolbarName");
		return () => createVNode("button", {
			class: [`${p$1}-toolbar-item`, o$2?.value && `${p$1}-disabled`],
			title: t$1.value.toolbarTips?.orderedList,
			disabled: o$2?.value,
			onClick: () => {
				F$1.emit(e$1, G, "orderedList");
			},
			type: "button"
		}, [createVNode(P, { name: "ordered-list" }, null), n$3?.value && createVNode("div", { class: `${p$1}-toolbar-item-name` }, [t$1.value.toolbarTips?.orderedList])]);
	}
}), Ho = /* @__PURE__ */ defineComponent({
	name: "ToolbarPageFullscreen",
	setup() {
		const e$1 = inject("usedLanguageText"), t$1 = inject("disabled"), o$2 = inject("showToolbarName"), n$3 = inject("setting"), i$3 = inject("updateSetting");
		return () => createVNode("button", {
			class: [
				`${p$1}-toolbar-item`,
				n$3.value.pageFullscreen && `${p$1}-toolbar-active`,
				t$1?.value && `${p$1}-disabled`
			],
			title: e$1.value.toolbarTips?.pageFullscreen,
			disabled: t$1?.value,
			onClick: () => {
				i$3("pageFullscreen");
			},
			type: "button"
		}, [createVNode(P, { name: n$3.value.pageFullscreen ? "minimize" : "maximize" }, null), o$2?.value && createVNode("div", { class: `${p$1}-toolbar-item-name` }, [e$1.value.toolbarTips?.pageFullscreen])]);
	}
}), Oo = /* @__PURE__ */ defineComponent({
	name: "ToolbarPrettier",
	setup() {
		const e$1 = inject("editorId"), t$1 = inject("usedLanguageText"), o$2 = inject("disabled"), n$3 = inject("showToolbarName");
		return () => createVNode("button", {
			class: [`${p$1}-toolbar-item`, o$2?.value && `${p$1}-disabled`],
			title: t$1.value.toolbarTips?.prettier,
			disabled: o$2?.value,
			onClick: () => {
				F$1.emit(e$1, G, "prettier");
			},
			type: "button"
		}, [createVNode(P, { name: "prettier" }, null), n$3?.value && createVNode("div", { class: `${p$1}-toolbar-item-name` }, [t$1.value.toolbarTips?.prettier])]);
	}
}), Vo = /* @__PURE__ */ defineComponent({
	name: "ToolbarPreview",
	setup() {
		const e$1 = inject("usedLanguageText"), t$1 = inject("disabled"), o$2 = inject("showToolbarName"), n$3 = inject("setting"), i$3 = inject("updateSetting");
		return () => createVNode("button", {
			class: [
				`${p$1}-toolbar-item`,
				n$3.value.preview && `${p$1}-toolbar-active`,
				t$1?.value && `${p$1}-disabled`
			],
			title: e$1.value.toolbarTips?.preview,
			disabled: t$1?.value,
			onClick: () => {
				i$3("preview");
			},
			type: "button"
		}, [createVNode(P, { name: "preview" }, null), o$2?.value && createVNode("div", { class: `${p$1}-toolbar-item-name` }, [e$1.value.toolbarTips?.preview])]);
	}
}), Wo = /* @__PURE__ */ defineComponent({
	name: "ToolbarPreviewOnly",
	setup() {
		const e$1 = inject("usedLanguageText"), t$1 = inject("disabled"), o$2 = inject("showToolbarName"), n$3 = inject("setting"), i$3 = inject("updateSetting");
		return () => createVNode("button", {
			class: [
				`${p$1}-toolbar-item`,
				n$3.value.previewOnly && `${p$1}-toolbar-active`,
				t$1?.value && `${p$1}-disabled`
			],
			title: e$1.value.toolbarTips?.previewOnly,
			disabled: t$1?.value,
			onClick: () => {
				i$3("previewOnly");
			},
			type: "button"
		}, [createVNode(P, { name: "preview-only" }, null), o$2?.value && createVNode("div", { class: `${p$1}-toolbar-item-name` }, [e$1.value.toolbarTips?.previewOnly])]);
	}
}), _o = /* @__PURE__ */ defineComponent({
	name: "ToolbarQuote",
	setup() {
		const e$1 = inject("editorId"), t$1 = inject("usedLanguageText"), o$2 = inject("disabled"), n$3 = inject("showToolbarName");
		return () => createVNode("button", {
			class: [`${p$1}-toolbar-item`, o$2?.value && `${p$1}-disabled`],
			title: t$1.value.toolbarTips?.quote,
			disabled: o$2?.value,
			onClick: () => {
				F$1.emit(e$1, G, "quote");
			},
			type: "button"
		}, [createVNode(P, { name: "quote" }, null), n$3?.value && createVNode("div", { class: `${p$1}-toolbar-item-name` }, [t$1.value.toolbarTips?.quote])]);
	}
}), zo = /* @__PURE__ */ defineComponent({
	name: "ToolbarRevoke",
	setup() {
		const e$1 = inject("editorId"), t$1 = inject("usedLanguageText"), o$2 = inject("disabled"), n$3 = inject("showToolbarName");
		return () => createVNode("button", {
			class: [`${p$1}-toolbar-item`, o$2?.value && `${p$1}-disabled`],
			title: t$1.value.toolbarTips?.revoke,
			disabled: o$2?.value,
			onClick: () => {
				F$1.emit(e$1, T);
			},
			type: "button"
		}, [createVNode(P, { name: "revoke" }, null), n$3?.value && createVNode("div", { class: `${p$1}-toolbar-item-name` }, [t$1.value.toolbarTips?.revoke])]);
	}
}), qo = /* @__PURE__ */ defineComponent({
	name: "ToolbarSave",
	setup() {
		const e$1 = inject("editorId"), t$1 = inject("usedLanguageText"), o$2 = inject("disabled"), n$3 = inject("showToolbarName");
		return () => createVNode("button", {
			class: [`${p$1}-toolbar-item`, o$2?.value && `${p$1}-disabled`],
			title: t$1.value.toolbarTips?.save,
			disabled: o$2?.value,
			onClick: () => {
				F$1.emit(e$1, i);
			},
			type: "button"
		}, [createVNode(P, { name: "save" }, null), n$3?.value && createVNode("div", { class: `${p$1}-toolbar-item-name` }, [t$1.value.toolbarTips?.save])]);
	}
}), Uo = /* @__PURE__ */ defineComponent({
	name: "ToolbarStrikeThrough",
	setup() {
		const e$1 = inject("editorId"), t$1 = inject("usedLanguageText"), o$2 = inject("disabled"), n$3 = inject("showToolbarName");
		return () => createVNode("button", {
			class: [`${p$1}-toolbar-item`, o$2?.value && `${p$1}-disabled`],
			title: t$1.value.toolbarTips?.strikeThrough,
			disabled: o$2?.value,
			onClick: () => {
				F$1.emit(e$1, G, "strikeThrough");
			},
			type: "button"
		}, [createVNode(P, { name: "strike-through" }, null), n$3?.value && createVNode("div", { class: `${p$1}-toolbar-item-name` }, [t$1.value.toolbarTips?.strikeThrough])]);
	}
}), Ko = /* @__PURE__ */ defineComponent({
	name: "ToolbarSub",
	setup() {
		const e$1 = inject("editorId"), t$1 = inject("usedLanguageText"), o$2 = inject("disabled"), n$3 = inject("showToolbarName");
		return () => createVNode("button", {
			class: [`${p$1}-toolbar-item`, o$2?.value && `${p$1}-disabled`],
			title: t$1.value.toolbarTips?.sub,
			disabled: o$2?.value,
			onClick: () => {
				F$1.emit(e$1, G, "sub");
			},
			type: "button"
		}, [createVNode(P, { name: "sub" }, null), n$3?.value && createVNode("div", { class: `${p$1}-toolbar-item-name` }, [t$1.value.toolbarTips?.sub])]);
	}
}), Go = /* @__PURE__ */ defineComponent({
	name: "ToolbarSup",
	setup() {
		const e$1 = inject("editorId"), t$1 = inject("usedLanguageText"), o$2 = inject("disabled"), n$3 = inject("showToolbarName");
		return () => createVNode("button", {
			class: [`${p$1}-toolbar-item`, o$2?.value && `${p$1}-disabled`],
			title: t$1.value.toolbarTips?.sup,
			disabled: o$2?.value,
			onClick: () => {
				F$1.emit(e$1, G, "sup");
			},
			type: "button"
		}, [createVNode(P, { name: "sup" }, null), n$3?.value && createVNode("div", { class: `${p$1}-toolbar-item-name` }, [t$1.value.toolbarTips?.sup])]);
	}
}), jo = {
	tableShape: {
		type: Array,
		default: () => [6, 4]
	},
	onSelected: {
		type: Function,
		default: () => {}
	}
}, Yo = /* @__PURE__ */ defineComponent({
	name: "TableShape",
	props: jo,
	setup(e$1) {
		const t$1 = reactive({
			x: -1,
			y: -1
		}), o$2 = computed(() => JSON.stringify(e$1.tableShape)), n$3 = () => {
			const s$2 = [...JSON.parse(o$2.value)];
			return (!s$2[2] || s$2[2] < s$2[0]) && (s$2[2] = s$2[0]), (!s$2[3] || s$2[3] < s$2[3]) && (s$2[3] = s$2[1]), s$2;
		}, i$3 = ref(n$3());
		return watch([o$2], () => {
			i$3.value = n$3();
		}), () => createVNode("div", {
			class: `${p$1}-table-shape`,
			onMouseleave: () => {
				i$3.value = n$3(), t$1.x = -1, t$1.y = -1;
			}
		}, [new Array(i$3.value[1]).fill("").map((s$2, c$2) => createVNode("div", {
			class: `${p$1}-table-shape-row`,
			key: `table-shape-row-${c$2}`
		}, [new Array(i$3.value[0]).fill("").map((d$2, u$4) => createVNode("div", {
			class: `${p$1}-table-shape-col`,
			key: `table-shape-col-${u$4}`,
			onMouseenter: () => {
				t$1.x = c$2, t$1.y = u$4, u$4 + 1 === i$3.value[0] && u$4 + 1 < i$3.value[2] ? i$3.value[0]++ : u$4 + 2 < i$3.value[0] && i$3.value[0] > e$1.tableShape[0] && i$3.value[0]--, c$2 + 1 === i$3.value[1] && c$2 + 1 < i$3.value[3] ? i$3.value[1]++ : c$2 + 2 < i$3.value[1] && i$3.value[1] > e$1.tableShape[1] && i$3.value[1]--;
			},
			onClick: () => {
				e$1.onSelected(t$1);
			}
		}, [createVNode("div", { class: [`${p$1}-table-shape-col-default`, c$2 <= t$1.x && u$4 <= t$1.y && `${p$1}-table-shape-col-include`] }, null)]))]))]);
	}
}), Zo = /* @__PURE__ */ defineComponent({
	name: "ToolbarTable",
	setup() {
		const e$1 = inject("editorId"), t$1 = inject("usedLanguageText"), o$2 = inject("disabled"), n$3 = inject("showToolbarName"), i$3 = inject("tableShape"), s$2 = `${e$1}-toolbar-wrapper`, c$2 = ref(!1), d$2 = (m$2) => {
			c$2.value = m$2;
		}, u$4 = (m$2) => {
			o$2?.value || F$1.emit(e$1, G, "table", { selectedShape: m$2 });
		}, v$2 = computed(() => createVNode(Yo, {
			tableShape: i$3.value,
			onSelected: u$4
		}, null));
		return () => createVNode(j$2, {
			relative: `#${s$2}`,
			visible: c$2.value,
			onChange: d$2,
			disabled: o$2?.value,
			key: "bar-table",
			overlay: v$2.value
		}, { default: () => [createVNode("button", {
			class: [`${p$1}-toolbar-item`, o$2?.value && `${p$1}-disabled`],
			title: t$1.value.toolbarTips?.table,
			disabled: o$2?.value,
			type: "button"
		}, [createVNode(P, { name: "table" }, null), n$3?.value && createVNode("div", { class: `${p$1}-toolbar-item-name` }, [t$1.value.toolbarTips?.table])])] });
	}
}), Xo = /* @__PURE__ */ defineComponent({
	name: "ToolbarTask",
	setup() {
		const e$1 = inject("editorId"), t$1 = inject("usedLanguageText"), o$2 = inject("disabled"), n$3 = inject("showToolbarName");
		return () => createVNode("button", {
			class: [`${p$1}-toolbar-item`, o$2?.value && `${p$1}-disabled`],
			title: t$1.value.toolbarTips?.task,
			disabled: o$2?.value,
			onClick: () => {
				F$1.emit(e$1, G, "task");
			},
			type: "button"
		}, [createVNode(P, { name: "task" }, null), n$3?.value && createVNode("div", { class: `${p$1}-toolbar-item-name` }, [t$1.value.toolbarTips?.task])]);
	}
}), Jo = /* @__PURE__ */ defineComponent({
	name: "ToolbarTitle",
	setup() {
		const e$1 = inject("editorId"), t$1 = inject("usedLanguageText"), o$2 = inject("disabled"), n$3 = inject("showToolbarName"), i$3 = `${e$1}-toolbar-wrapper`, s$2 = ref(!1), c$2 = (v$2) => {
			o$2?.value || F$1.emit(e$1, G, v$2);
		}, d$2 = (v$2) => {
			s$2.value = v$2;
		}, u$4 = computed(() => createVNode("ul", {
			class: `${p$1}-menu`,
			onClick: () => {
				s$2.value = !1;
			},
			role: "menu"
		}, [
			createVNode("li", {
				class: `${p$1}-menu-item ${p$1}-menu-item-title`,
				onClick: () => {
					c$2("h1");
				},
				role: "menuitem",
				tabindex: "0"
			}, [t$1.value.titleItem?.h1]),
			createVNode("li", {
				class: `${p$1}-menu-item ${p$1}-menu-item-title`,
				onClick: () => {
					c$2("h2");
				},
				role: "menuitem",
				tabindex: "0"
			}, [t$1.value.titleItem?.h2]),
			createVNode("li", {
				class: `${p$1}-menu-item ${p$1}-menu-item-title`,
				onClick: () => {
					c$2("h3");
				},
				role: "menuitem",
				tabindex: "0"
			}, [t$1.value.titleItem?.h3]),
			createVNode("li", {
				class: `${p$1}-menu-item ${p$1}-menu-item-title`,
				onClick: () => {
					c$2("h4");
				},
				role: "menuitem",
				tabindex: "0"
			}, [t$1.value.titleItem?.h4]),
			createVNode("li", {
				class: `${p$1}-menu-item ${p$1}-menu-item-title`,
				onClick: () => {
					c$2("h5");
				},
				role: "menuitem",
				tabindex: "0"
			}, [t$1.value.titleItem?.h5]),
			createVNode("li", {
				class: `${p$1}-menu-item ${p$1}-menu-item-title`,
				onClick: () => {
					c$2("h6");
				},
				role: "menuitem",
				tabindex: "0"
			}, [t$1.value.titleItem?.h6])
		]));
		return () => createVNode(j$2, {
			relative: `#${i$3}`,
			visible: s$2.value,
			onChange: d$2,
			disabled: o$2?.value,
			overlay: u$4.value
		}, { default: () => [createVNode("button", {
			class: [`${p$1}-toolbar-item`, o$2?.value && `${p$1}-disabled`],
			disabled: o$2?.value,
			title: t$1.value.toolbarTips?.title,
			type: "button"
		}, [createVNode(P, { name: "title" }, null), n$3?.value && createVNode("div", { class: `${p$1}-toolbar-item-name` }, [t$1.value.toolbarTips?.title])])] });
	}
}), Qo = /* @__PURE__ */ defineComponent({
	name: "ToolbarUnderline",
	setup() {
		const e$1 = inject("editorId"), t$1 = inject("usedLanguageText"), o$2 = inject("disabled"), n$3 = inject("showToolbarName");
		return () => createVNode("button", {
			class: [`${p$1}-toolbar-item`, o$2?.value && `${p$1}-disabled`],
			title: t$1.value.toolbarTips?.underline,
			disabled: o$2?.value,
			onClick: () => {
				F$1.emit(e$1, G, "underline");
			},
			type: "button"
		}, [createVNode(P, { name: "underline" }, null), n$3?.value && createVNode("div", { class: `${p$1}-toolbar-item-name` }, [t$1.value.toolbarTips?.underline])]);
	}
}), el = /* @__PURE__ */ defineComponent({
	name: "ToolbarUnorderedList",
	setup() {
		const e$1 = inject("editorId"), t$1 = inject("usedLanguageText"), o$2 = inject("disabled"), n$3 = inject("showToolbarName");
		return () => createVNode("button", {
			class: [`${p$1}-toolbar-item`, o$2?.value && `${p$1}-disabled`],
			title: t$1.value.toolbarTips?.unorderedList,
			disabled: o$2?.value,
			onClick: () => {
				F$1.emit(e$1, G, "unorderedList");
			},
			type: "button"
		}, [createVNode(P, { name: "unordered-list" }, null), n$3?.value && createVNode("div", { class: `${p$1}-toolbar-item-name` }, [t$1.value.toolbarTips?.unorderedList])]);
	}
}), tl = () => {
	const e$1 = inject("editorId"), t$1 = inject("setting"), o$2 = inject("updateSetting"), { editorExtensions: n$3, editorExtensionsAttrs: i$3 } = h$1;
	let s$2 = n$3.screenfull.instance;
	const c$2 = ref(!1), d$2 = (m$2) => {
		if (!s$2) {
			F$1.emit(e$1, N$1, {
				name: "fullscreen",
				message: "fullscreen is undefined"
			});
			return;
		}
		s$2.isEnabled ? (c$2.value = !0, (m$2 === void 0 ? !s$2.isFullscreen : m$2) ? s$2.request() : s$2.exit()) : console.error("browser does not support screenfull!");
	}, u$4 = () => {
		s$2 && s$2.isEnabled && s$2.on("change", () => {
			(c$2.value || t$1.value.fullscreen) && (c$2.value = !1, o$2("fullscreen"));
		});
	}, v$2 = () => {
		s$2 = window.screenfull, u$4();
	};
	return onMounted(() => {
		u$4(), s$2 || A("script", {
			...i$3.screenfull?.js,
			src: n$3.screenfull.js,
			id: M.screenfull,
			onload: v$2
		}, "screenfull");
	}), onMounted(() => {
		F$1.on(e$1, {
			name: h$2,
			callback: d$2
		});
	}), { fullscreenHandler: d$2 };
};
var ol = 0;
var Ze = () => {
	const e$1 = inject("editorId"), t$1 = inject("theme"), o$2 = inject("previewTheme"), n$3 = inject("language"), i$3 = inject("disabled"), s$2 = inject("noUploadImg"), c$2 = inject("noPrettier"), d$2 = inject("codeTheme"), u$4 = inject("showToolbarName"), v$2 = inject("setting"), m$2 = inject("defToolbars");
	return { barRender: (g$4) => {
		if (k.includes(g$4)) switch (g$4) {
			case "-": return createVNode(po, { key: `bar-${ol++}` }, null);
			case "bold": return createVNode(To, { key: "bar-bold" }, null);
			case "underline": return createVNode(Qo, { key: "bar-unorderline" }, null);
			case "italic": return createVNode(Do, { key: "bar-italic" }, null);
			case "strikeThrough": return createVNode(Uo, { key: "bar-strikeThrough" }, null);
			case "title": return createVNode(Jo, { key: "bar-title" }, null);
			case "sub": return createVNode(Ko, { key: "bar-sub" }, null);
			case "sup": return createVNode(Go, { key: "bar-sup" }, null);
			case "quote": return createVNode(_o, { key: "bar-quote" }, null);
			case "unorderedList": return createVNode(el, { key: "bar-unorderedList" }, null);
			case "orderedList": return createVNode(Po, { key: "bar-orderedList" }, null);
			case "task": return createVNode(Xo, { key: "bar-task" }, null);
			case "codeRow": return createVNode(Co, { key: "bar-codeRow" }, null);
			case "code": return createVNode(yo, { key: "bar-code" }, null);
			case "link": return createVNode(Mo, { key: "bar-link" }, null);
			case "image": return s$2 ? createVNode(So, { key: "bar-image" }, null) : createVNode(Ao, { key: "bar-imageDropdown" }, null);
			case "table": return createVNode(Zo, { key: "bar-table" }, null);
			case "revoke": return createVNode(zo, { key: "bar-revoke" }, null);
			case "next": return createVNode(Bo, { key: "bar-next" }, null);
			case "save": return createVNode(qo, { key: "bar-save" }, null);
			case "prettier": return !c$2 && createVNode(Oo, { key: "bar-prettier" }, null);
			case "pageFullscreen": return !v$2.value.fullscreen && createVNode(Ho, { key: "bar-pageFullscreen" }, null);
			case "fullscreen": return createVNode(ko, { key: "bar-fullscreen" }, null);
			case "catalog": return createVNode(wo, { key: "bar-catalog" }, null);
			case "preview": return createVNode(Vo, { key: "bar-preview" }, null);
			case "previewOnly": return createVNode(Wo, { key: "bar-previewOnly" }, null);
			case "htmlPreview": return createVNode(xo, { key: "bar-htmlPreview" }, null);
			case "github": return createVNode($o, { key: "bar-github" }, null);
			case "mermaid": return createVNode(Fo, { key: "bar-mermaid" }, null);
			case "katex": return createVNode(Ro, { key: "bar-katex" }, null);
		}
		else if (m$2.value instanceof Array) {
			const p$3 = m$2.value[g$4];
			return p$3 ? cloneVNode(p$3, {
				theme: p$3.props?.theme || t$1.value,
				previewTheme: p$3.props?.theme || o$2.value,
				language: p$3.props?.theme || n$3.value,
				codeTheme: p$3.props?.codeTheme || d$2.value,
				disabled: p$3.props?.disabled || i$3.value,
				showToolbarName: p$3.props?.showToolbarName || u$4.value,
				insert(E) {
					F$1.emit(e$1, G, "universal", { generate: E });
				}
			}) : "";
		} else if (m$2.value?.children instanceof Array) {
			const p$3 = m$2.value.children[g$4];
			return p$3 ? cloneVNode(p$3, {
				theme: p$3.props?.theme || t$1.value,
				previewTheme: p$3.props?.theme || o$2.value,
				language: p$3.props?.theme || n$3.value,
				codeTheme: p$3.props?.codeTheme || d$2.value,
				disabled: p$3.props?.disabled || i$3.value,
				showToolbarName: p$3.props?.showToolbarName || u$4.value,
				insert(E) {
					F$1.emit(e$1, G, "universal", { generate: E });
				}
			}) : "";
		} else return "";
	} };
}, ll = /* @__PURE__ */ defineComponent({
	name: "FloatingToolbar",
	setup() {
		const e$1 = inject("floatingToolbars"), { barRender: t$1 } = Ze();
		return () => createVNode("div", { class: `${p$1}-floating-toolbar` }, [e$1.value.map((o$2) => t$1(o$2))]);
	}
}), ge$1 = StateEffect.define(), al = StateField.define({
	create() {
		return null;
	},
	update(e$1, t$1) {
		for (const o$2 of t$1.effects) o$2.is(ge$1) && (e$1 = o$2.value);
		return e$1;
	},
	provide: (e$1) => showTooltip.from(e$1)
}), nl = (e$1) => {
	let t$1 = null;
	const o$2 = (s$2, c$2) => {
		t$1 && t$1.kind === c$2.kind && t$1.pos === c$2.pos || (t$1 = c$2, s$2.dispatch({ effects: ge$1.of({
			pos: c$2.pos,
			above: !0,
			arrow: !0,
			create: () => {
				const d$2 = document.createElement("div"), u$4 = `${p$1}-floating-toolbar-container`;
				d$2.classList.add(u$4), d$2.dataset.state = "hidden", requestAnimationFrame(() => {
					d$2.dataset.state = "visible";
				});
				const v$2 = document.createElement("div");
				d$2.appendChild(v$2);
				const m$2 = createApp(ll);
				return e$1.privide(m$2), m$2.mount(d$2), {
					dom: d$2,
					destroy: () => m$2.unmount()
				};
			}
		}) }));
	}, n$3 = (s$2) => {
		t$1 && (t$1 = null, s$2.dispatch({ effects: ge$1.of(null) }));
	}, i$3 = EditorView.updateListener.of((s$2) => {
		if (s$2.selectionSet || s$2.docChanged) {
			const c$2 = s$2.state, d$2 = c$2.selection.main;
			if (!d$2.empty) o$2(s$2.view, {
				kind: "selection",
				pos: d$2.anchor
			});
			else {
				const u$4 = d$2.head, v$2 = c$2.doc.lineAt(u$4);
				/^\s*$/.test(v$2.text) ? o$2(s$2.view, {
					kind: "emptyLine",
					pos: u$4
				}) : n$3(s$2.view);
			}
		}
	});
	return [al, i$3];
}, rl = "#e5c07b", Le$1 = "var(--md-color)", sl = "#56b6c2", il = "#fff", Q$1 = "#3f4a54", Ne = "#2d8cf0", cl = "#2d8cf0", ul = "#3f4a54", Ae = "#d19a66", dl = "#c678dd", ml = "#f6f6f6", bl = "#ceedfa33", De$1 = "var(--md-bk-color)", de$1 = "var(--md-bk-color)", vl = "#bad5fa", Re$1 = "#3f4a54", gl = EditorView.theme({
	"&": {
		color: Q$1,
		backgroundColor: De$1
	},
	".cm-content": { caretColor: Re$1 },
	".cm-cursor, .cm-dropCursor": { borderLeftColor: Re$1 },
	"&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: vl },
	".cm-panels": {
		backgroundColor: ml,
		color: Q$1
	},
	".cm-panels.cm-panels-top": { borderBottom: "1px solid var(--md-border-color)" },
	".cm-panels.cm-panels-bottom": { borderTop: "1px solid var(--md-border-color)" },
	".cm-searchMatch": {
		backgroundColor: "#72a1ff59",
		outline: "1px solid #457dff"
	},
	".cm-searchMatch.cm-searchMatch-selected": { backgroundColor: "#6199ff2f" },
	".cm-activeLine": { backgroundColor: "#ceedfa33" },
	".cm-selectionMatch": { backgroundColor: "#aafe661a" },
	"&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bad0f847" },
	".cm-gutters": {
		backgroundColor: De$1,
		color: Q$1,
		borderRight: "1px solid",
		borderColor: "var(--md-border-color)"
	},
	".cm-activeLineGutter": { backgroundColor: bl },
	".cm-foldPlaceholder": {
		backgroundColor: "transparent",
		border: "none",
		color: "#ddd"
	},
	".cm-tooltip": {
		border: "1px solid var(--md-border-color)",
		backgroundColor: de$1
	},
	".cm-tooltip .cm-tooltip-arrow:before": {
		borderTopColor: "var(--md-border-color)",
		borderBottomColor: "var(--md-border-color)"
	},
	".cm-tooltip .cm-tooltip-arrow:after": {
		borderTopColor: de$1,
		borderBottomColor: de$1
	},
	".cm-tooltip-autocomplete": { "& > ul > li[aria-selected]": { color: Q$1 } }
}), hl = HighlightStyle.define([
	{
		tag: tags.keyword,
		color: dl
	},
	{
		tag: [
			tags.name,
			tags.deleted,
			tags.character,
			tags.propertyName,
			tags.macroName
		],
		color: Le$1
	},
	{
		tag: [tags.function(tags.variableName), tags.labelName],
		color: cl
	},
	{
		tag: [
			tags.color,
			tags.constant(tags.name),
			tags.standard(tags.name)
		],
		color: Ae
	},
	{
		tag: [tags.definition(tags.name), tags.separator],
		color: Q$1
	},
	{
		tag: [
			tags.typeName,
			tags.className,
			tags.number,
			tags.changed,
			tags.annotation,
			tags.modifier,
			tags.self,
			tags.namespace
		],
		color: rl
	},
	{
		tag: [
			tags.operator,
			tags.operatorKeyword,
			tags.url,
			tags.escape,
			tags.regexp,
			tags.link,
			tags.special(tags.string)
		],
		color: sl
	},
	{
		tag: [tags.meta, tags.comment],
		color: Ne
	},
	{
		tag: tags.strong,
		fontWeight: "bold"
	},
	{
		tag: tags.emphasis,
		fontStyle: "italic"
	},
	{
		tag: tags.strikethrough,
		textDecoration: "line-through"
	},
	{
		tag: tags.link,
		color: Ne,
		textDecoration: "underline"
	},
	{
		tag: tags.heading,
		fontWeight: "bold",
		color: Le$1
	},
	{
		tag: [
			tags.atom,
			tags.bool,
			tags.special(tags.variableName)
		],
		color: Ae
	},
	{
		tag: [
			tags.processingInstruction,
			tags.string,
			tags.inserted
		],
		color: ul
	},
	{
		tag: tags.invalid,
		color: il
	}
]), Me = [gl, syntaxHighlighting(hl)], fl = "#e5c07b", Fe$1 = "var(--md-color)", pl = "#56b6c2", Tl = "#ffffff", ee$1 = "var(--md-color)", Be = "#e5c07b", wl = "#e5c07b", yl = "var(--md-color)", Pe = "#d19a66", Cl = "#c678dd", kl = "#21252b", $l = "#2c313a", He = "var(--md-bk-color)", me$1 = "var(--md-bk-color)", xl = "#ceedfa33", Oe = "#528bff", Sl = EditorView.theme({
	"&": {
		color: ee$1,
		backgroundColor: He
	},
	".cm-content": { caretColor: Oe },
	".cm-cursor, .cm-dropCursor": { borderLeftColor: Oe },
	"&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: xl },
	".cm-panels": {
		backgroundColor: kl,
		color: ee$1
	},
	".cm-panels.cm-panels-top": { borderBottom: "1px solid var(--md-border-color)" },
	".cm-panels.cm-panels-bottom": { borderTop: "1px solid var(--md-border-color)" },
	".cm-searchMatch": {
		backgroundColor: "#72a1ff59",
		outline: "1px solid #457dff"
	},
	".cm-searchMatch.cm-searchMatch-selected": { backgroundColor: "#6199ff2f" },
	".cm-activeLine": { backgroundColor: "#ceedfa33" },
	".cm-selectionMatch": { backgroundColor: "#aafe661a" },
	"&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bad0f847" },
	".cm-gutters": {
		backgroundColor: He,
		color: ee$1,
		borderRight: "1px solid",
		borderColor: "var(--md-border-color)"
	},
	".cm-activeLineGutter": { backgroundColor: $l },
	".cm-foldPlaceholder": {
		backgroundColor: "transparent",
		border: "none",
		color: "#ddd"
	},
	".cm-tooltip": {
		border: "1px solid var(--md-border-color)",
		backgroundColor: me$1
	},
	".cm-tooltip .cm-tooltip-arrow:before": {
		borderTopColor: "var(--md-border-color)",
		borderBottomColor: "var(--md-border-color)"
	},
	".cm-tooltip .cm-tooltip-arrow:after": {
		borderTopColor: me$1,
		borderBottomColor: me$1
	},
	".cm-tooltip-autocomplete": { "& > ul > li[aria-selected]": { color: ee$1 } }
}, { dark: !0 }), Il = HighlightStyle.define([
	{
		tag: tags.keyword,
		color: Cl
	},
	{
		tag: [
			tags.name,
			tags.deleted,
			tags.character,
			tags.propertyName,
			tags.macroName
		],
		color: Fe$1
	},
	{
		tag: [tags.function(tags.variableName), tags.labelName],
		color: wl
	},
	{
		tag: [
			tags.color,
			tags.constant(tags.name),
			tags.standard(tags.name)
		],
		color: Pe
	},
	{
		tag: [tags.definition(tags.name), tags.separator],
		color: ee$1
	},
	{
		tag: [
			tags.typeName,
			tags.className,
			tags.number,
			tags.changed,
			tags.annotation,
			tags.modifier,
			tags.self,
			tags.namespace
		],
		color: fl
	},
	{
		tag: [
			tags.operator,
			tags.operatorKeyword,
			tags.url,
			tags.escape,
			tags.regexp,
			tags.link,
			tags.special(tags.string)
		],
		color: pl
	},
	{
		tag: [tags.meta, tags.comment],
		color: Be
	},
	{
		tag: tags.strong,
		fontWeight: "bold"
	},
	{
		tag: tags.emphasis,
		fontStyle: "italic"
	},
	{
		tag: tags.strikethrough,
		textDecoration: "line-through"
	},
	{
		tag: tags.link,
		color: Be,
		textDecoration: "underline"
	},
	{
		tag: tags.heading,
		fontWeight: "bold",
		color: Fe$1
	},
	{
		tag: [
			tags.atom,
			tags.bool,
			tags.special(tags.variableName)
		],
		color: Pe
	},
	{
		tag: [
			tags.processingInstruction,
			tags.string,
			tags.inserted
		],
		color: yl
	},
	{
		tag: tags.invalid,
		color: Tl
	}
]), Ve = [Sl, syntaxHighlighting(Il)], El = (e$1, t$1) => {
	const o$2 = inject("editorId"), n$3 = (s$2) => {
		s$2 instanceof Promise ? s$2.then((c$2) => {
			F$1.emit(o$2, G, "universal", { generate() {
				return { targetValue: c$2 };
			} });
		}).catch((c$2) => {
			console.error(c$2);
		}) : F$1.emit(o$2, G, "universal", { generate() {
			return { targetValue: s$2 };
		} });
	};
	return (s$2) => {
		if (!s$2.clipboardData) return;
		if (s$2.clipboardData.files.length > 0) {
			const { files: g$4 } = s$2.clipboardData;
			F$1.emit(o$2, I, Array.from(g$4).filter((p$3) => /image\/.*/.test(p$3.type))), s$2.preventDefault();
			return;
		}
		const c$2 = s$2.clipboardData.getData("text/plain"), d$2 = t$1.value?.view.state.selection.main.to || 0, u$4 = t$1.value?.view.state.doc.lineAt(d$2).from || 0, v$2 = t$1.value?.view.state.doc.sliceString(u$4, d$2) || "", m$2 = /!\[.*\]\(\s*$/.test(v$2), f$3 = /!\[.*\]\((.*)\s?.*\)/.test(c$2);
		if (m$2) {
			const g$4 = e$1.transformImgUrl(c$2);
			n$3(g$4), s$2.preventDefault();
			return;
		} else if (f$3) {
			const g$4 = c$2.match(new RegExp(`(?<=!\\[.*\\]\\()([^)\\s]+)(?=\\s?["']?.*["']?\\))`, "g"));
			g$4 ? Promise.all(g$4.map((p$3) => e$1.transformImgUrl(p$3))).then((p$3) => {
				n$3(p$3.reduce((k$2, E, M$3) => k$2.replace(g$4[M$3], E), c$2));
			}).catch((p$3) => {
				console.error(p$3);
			}) : n$3(c$2), s$2.preventDefault();
			return;
		}
		if (e$1.autoDetectCode && s$2.clipboardData.types.includes("vscode-editor-data")) {
			const g$4 = JSON.parse(s$2.clipboardData.getData("vscode-editor-data"));
			F$1.emit(o$2, G, "code", {
				mode: g$4.mode,
				text: s$2.clipboardData.getData("text/plain")
			}), s$2.preventDefault();
			return;
		}
		e$1.maxlength && c$2.length + e$1.modelValue.length > e$1.maxlength && F$1.emit(o$2, N$1, {
			name: "overlength",
			message: "The input text is too long",
			data: c$2
		});
	};
}, Ll = (e$1, t$1) => [
	{
		key: "Ctrl-b",
		mac: "Cmd-b",
		run: () => (F$1.emit(e$1, G, "bold"), !0)
	},
	{
		key: "Ctrl-d",
		mac: "Cmd-d",
		run: deleteLine,
		preventDefault: !0
	},
	{
		key: "Ctrl-s",
		mac: "Cmd-s",
		run: (L$2) => (F$1.emit(e$1, i, L$2.state.doc.toString()), !0),
		shift: () => (F$1.emit(e$1, G, "strikeThrough"), !0)
	},
	{
		key: "Ctrl-u",
		mac: "Cmd-u",
		preventDefault: !0,
		run: () => (F$1.emit(e$1, G, "underline"), !0),
		shift: () => (F$1.emit(e$1, G, "unorderedList"), !0)
	},
	{
		key: "Ctrl-i",
		mac: "Cmd-i",
		preventDefault: !0,
		run: () => (F$1.emit(e$1, G, "italic"), !0),
		shift: () => (F$1.emit(e$1, G, "image"), !0)
	},
	{
		key: "Ctrl-1",
		mac: "Cmd-1",
		run: () => (F$1.emit(e$1, G, "h1"), !0)
	},
	{
		key: "Ctrl-2",
		mac: "Cmd-2",
		run: () => (F$1.emit(e$1, G, "h2"), !0)
	},
	{
		key: "Ctrl-3",
		mac: "Cmd-3",
		run: () => (F$1.emit(e$1, G, "h3"), !0)
	},
	{
		key: "Ctrl-4",
		mac: "Cmd-4",
		run: () => (F$1.emit(e$1, G, "h4"), !0)
	},
	{
		key: "Ctrl-5",
		mac: "Cmd-5",
		run: () => (F$1.emit(e$1, G, "h5"), !0)
	},
	{
		key: "Ctrl-6",
		mac: "Cmd-6",
		run: () => (F$1.emit(e$1, G, "h6"), !0)
	},
	{
		key: "Ctrl-ArrowUp",
		mac: "Cmd-ArrowUp",
		run: () => (F$1.emit(e$1, G, "sup"), !0)
	},
	{
		key: "Ctrl-ArrowDown",
		mac: "Cmd-ArrowDown",
		run: () => (F$1.emit(e$1, G, "sub"), !0)
	},
	{
		key: "Ctrl-o",
		mac: "Cmd-o",
		run: () => (F$1.emit(e$1, G, "orderedList"), !0)
	},
	{
		key: "Ctrl-c",
		mac: "Cmd-c",
		shift: () => (F$1.emit(e$1, G, "code"), !0),
		any(L$2, T$1) {
			return (T$1.ctrlKey || T$1.metaKey) && T$1.altKey && T$1.code === "KeyC" ? (F$1.emit(e$1, G, "codeRow"), !0) : !1;
		}
	},
	{
		key: "Ctrl-l",
		mac: "Cmd-l",
		run: () => (F$1.emit(e$1, G, "link"), !0)
	},
	{
		key: "Ctrl-f",
		mac: "Cmd-f",
		shift: () => t$1.noPrettier ? !1 : (F$1.emit(e$1, G, "prettier"), !0)
	},
	{ any: (L$2, T$1) => (T$1.ctrlKey || T$1.metaKey) && T$1.altKey && T$1.shiftKey && T$1.code === "KeyT" ? (F$1.emit(e$1, G, "table"), !0) : !1 },
	...searchKeymap
], Nl = /[a-z][a-z0-9.+-]*:\/\/[^\s<>"'`()]+(?:\([^\s<>"'`]*\)[^\s<>"'`]*)*/i, Al = /\/\/[^\s<>"'`()]+/i, Dl = /data:[a-z]+\/[a-z0-9.+-]+(?:;base64)?,[a-z0-9+/=%]+/i, Rl = /\/(?!\/)[^\s<>"'`()]+/i, se$1 = new RegExp(`(${Nl.source}|${Al.source}|${Dl.source}|${Rl.source})`, "gi"), Ml = /[a-z0-9.+-]/i, Fl = (e$1) => {
	const t$1 = [];
	se$1.lastIndex = 0;
	let o$2;
	for (; o$2 = se$1.exec(e$1);) {
		const n$3 = o$2.index ?? 0, i$3 = n$3 > 0 ? e$1[n$3 - 1] : "";
		if (i$3 && Ml.test(i$3) || i$3 === "<" && e$1[n$3] === "/") continue;
		const c$2 = n$3 + o$2[0].length;
		t$1.push([n$3, c$2]);
	}
	return t$1;
}, Bl = (e$1, t$1, o$2) => e$1.some((n$3) => n$3.from === t$1 && n$3.to === o$2), Pl = (e$1) => {
	const t$1 = e$1.shortenText || (() => "..."), o$2 = StateEffect.define(), n$3 = StateEffect.define(), i$3 = (u$4, v$2) => {
		const m$2 = new RangeSetBuilder(), f$3 = [];
		for (let g$4 = 1; g$4 <= u$4.doc.lines; g$4++) {
			const p$3 = u$4.doc.line(g$4), k$2 = p$3.text;
			se$1.lastIndex = 0;
			const E = e$1.findTexts?.({
				state: u$4,
				lineText: k$2,
				lineNumber: p$3.number,
				lineFrom: p$3.from,
				lineTo: p$3.to,
				defaultTextRegex: se$1
			}) ?? Fl(k$2);
			for (const M$3 of E) {
				if (!M$3) continue;
				const [A$2, S$2] = M$3;
				if (typeof A$2 != "number" || typeof S$2 != "number" || A$2 < 0 || S$2 <= A$2 || A$2 >= k$2.length || S$2 > k$2.length) continue;
				const D$2 = k$2.slice(A$2, S$2);
				if (!D$2 || D$2.length <= e$1.maxLength) continue;
				const L$2 = p$3.from + A$2, T$1 = p$3.from + S$2;
				if (Bl(v$2, L$2, T$1)) {
					f$3.push({
						from: L$2,
						to: T$1
					});
					continue;
				}
				const R$4 = t$1(D$2);
				m$2.add(L$2, T$1, Decoration.replace({ widget: new s$2(R$4, D$2, L$2, T$1) }));
			}
		}
		return {
			deco: m$2.finish(),
			expanded: f$3
		};
	};
	class s$2 extends WidgetType {
		constructor(v$2, m$2, f$3, g$4) {
			super(), this.short = v$2, this.raw = m$2, this.from = f$3, this.to = g$4;
		}
		toDOM(v$2) {
			const m$2 = document.createElement("span");
			return m$2.textContent = this.short, m$2.className = "cm-short-text", m$2.title = this.raw, m$2.style.display = "inline", m$2.style.textDecoration = "underline", m$2.addEventListener("mousedown", (f$3) => {
				f$3.preventDefault(), f$3.stopPropagation(), v$2.dispatch({
					selection: EditorSelection.cursor(this.from),
					effects: o$2.of({
						from: this.from,
						to: this.to,
						expand: !0
					})
				}), v$2.focus();
			}), m$2.addEventListener("click", (f$3) => {
				f$3.preventDefault();
			}), m$2;
		}
		ignoreEvent() {
			return !1;
		}
		eq(v$2) {
			return this.short === v$2.short && this.raw === v$2.raw && this.from === v$2.from && this.to === v$2.to;
		}
	}
	const c$2 = StateField.define({
		create(u$4) {
			return i$3(u$4, []);
		},
		update(u$4, v$2) {
			let m$2 = u$4.expanded;
			v$2.docChanged && m$2.length && (m$2 = m$2.map(({ from: g$4, to: p$3 }) => ({
				from: v$2.changes.mapPos(g$4, 1),
				to: v$2.changes.mapPos(p$3, -1)
			})).filter(({ from: g$4, to: p$3 }) => g$4 < p$3));
			let f$3 = m$2 !== u$4.expanded;
			for (const g$4 of v$2.effects) g$4.is(o$2) ? g$4.value.expand ? m$2 = [{
				from: g$4.value.from,
				to: g$4.value.to
			}] : m$2 = m$2.filter(({ from: p$3, to: k$2 }) => p$3 !== g$4.value.from || k$2 !== g$4.value.to) : g$4.is(n$3) && m$2.length > 0 && (m$2 = []);
			return !f$3 && m$2 !== u$4.expanded && (f$3 = !0), v$2.docChanged || f$3 ? i$3(v$2.state, m$2) : u$4;
		},
		provide: (u$4) => EditorView.decorations.compute([u$4], (v$2) => v$2.field(u$4).deco)
	}), d$2 = EditorView.domEventHandlers({ mousedown(u$4, v$2) {
		const m$2 = v$2.state.field(c$2, !1);
		if (!m$2 || m$2.expanded.length === 0) return !1;
		const f$3 = u$4.target;
		if (f$3 && v$2.dom.contains(f$3)) {
			const g$4 = v$2.posAtDOM(f$3, 0);
			if (g$4 != null && g$4 !== -1 && m$2.expanded.some(({ from: k$2, to: E }) => g$4 >= k$2 && g$4 <= E)) return !1;
		}
		return v$2.dispatch({ effects: n$3.of(void 0) }), !1;
	} });
	return [c$2, d$2];
};
EditorView.EDIT_CONTEXT = !1;
var Xe = (e$1) => e$1.extension instanceof Function ? e$1.extension(e$1.options) : e$1.extension, Hl = (e$1) => {
	const t$1 = Xe(e$1);
	return e$1.compartment ? e$1.compartment.of(t$1) : t$1;
}, Ol = (e$1) => {
	const t$1 = inject("tabWidth"), o$2 = inject("editorId"), n$3 = inject("theme"), i$3 = inject("previewTheme"), s$2 = inject("language"), c$2 = inject("usedLanguageText"), d$2 = inject("disabled"), u$4 = inject("showToolbarName"), v$2 = inject("customIcon"), m$2 = inject("noUploadImg"), f$3 = inject("tableShape"), g$4 = inject("noPrettier"), p$3 = inject("codeTheme"), k$2 = inject("setting"), E = inject("updateSetting"), M$3 = inject("catalogVisible"), A$2 = inject("defToolbars"), S$2 = inject("floatingToolbars"), D$2 = inject("rootRef"), L$2 = ref(), T$1 = shallowRef(), R$4 = ref(!1), z$2 = new Compartment(), q = new Compartment(), $$1 = new Compartment(), Te$1 = new Compartment(), Je = new Compartment(), Qe = Ll(o$2, { noPrettier: g$4 }), we$1 = () => [
		...Qe,
		...defaultKeymap,
		...historyKeymap,
		indentWithTab
	], oe$1 = {
		paste: El(e$1, T$1),
		blur: e$1.onBlur,
		focus: e$1.onFocus,
		drop: e$1.onDrop,
		compositionstart: () => {
			R$4.value = !0;
		},
		compositionend: (w$3, F$2) => {
			R$4.value = !1, e$1.updateModelValue(F$2.state.doc.toString());
		},
		input: (w$3) => {
			e$1.onInput && e$1.onInput(w$3);
			const { data: F$2 } = w$3;
			e$1.maxlength && e$1.modelValue.length + F$2.length > e$1.maxlength && F$1.emit(o$2, N$1, {
				name: "overlength",
				message: "The input text is too long",
				data: F$2
			});
		}
	}, et = nl({ privide(w$3) {
		w$3.provide("editorId", o$2), w$3.provide("theme", n$3), w$3.provide("previewTheme", i$3), w$3.provide("language", s$2), w$3.provide("disabled", d$2), w$3.provide("noUploadImg", m$2), w$3.provide("tableShape", f$3), w$3.provide("noPrettier", g$4), w$3.provide("codeTheme", p$3), w$3.provide("showToolbarName", u$4), w$3.provide("setting", k$2), w$3.provide("updateSetting", E), w$3.provide("usedLanguageText", c$2), w$3.provide("catalogVisible", M$3), w$3.provide("defToolbars", A$2), w$3.provide("tabWidth", t$1), w$3.provide("customIcon", v$2), w$3.provide("floatingToolbars", S$2), w$3.provide("rootRef", D$2);
	} }), tt$1 = [
		{
			type: "theme",
			extension: ({ theme: w$3 }) => w$3.value === "light" ? Me : Ve,
			compartment: z$2,
			options: { theme: n$3 }
		},
		{
			type: "updateListener",
			extension: EditorView.updateListener.of((w$3) => {
				w$3.docChanged && (e$1.onChange(w$3.state.doc.toString()), R$4.value || e$1.updateModelValue(w$3.state.doc.toString()));
			})
		},
		{
			type: "domEventHandlers",
			extension: EditorView.domEventHandlers(oe$1),
			compartment: Te$1
		},
		{
			type: "completions",
			extension: Ee$1(e$1.completions),
			compartment: q
		},
		{
			type: "history",
			extension: history(),
			compartment: $$1
		}
	], ye = h$1.codeMirrorExtensions([
		{
			type: "lineWrapping",
			extension: EditorView.lineWrapping
		},
		{
			type: "keymap",
			extension: keymap.of(we$1())
		},
		{
			type: "drawSelection",
			extension: drawSelection()
		},
		{
			type: "markdown",
			extension: markdown({ codeLanguages: languages })
		},
		{
			type: "linkShortener",
			extension: (w$3) => Pl(w$3),
			options: { maxLength: 30 }
		},
		{
			type: "floatingToolbar",
			extension: S$2.value.length > 0 ? et : [],
			compartment: Je
		}
	], {
		editorId: o$2,
		theme: n$3.value,
		keyBindings: we$1()
	}), ot$1 = () => [...tt$1, ...ye].map(Hl);
	return onMounted(() => {
		const w$3 = new EditorView({
			doc: e$1.modelValue,
			parent: L$2.value,
			extensions: ot$1()
		}), F$2 = new go(w$3);
		T$1.value = F$2, setTimeout(() => {
			F$2.setTabSize(t$1), F$2.setDisabled(d$2.value), F$2.setReadOnly(e$1.readonly), e$1.placeholder && F$2.setPlaceholder(e$1.placeholder), typeof e$1.maxlength == "number" && F$2.setMaxLength(e$1.maxlength), e$1.autofocus && w$3.focus();
		}, 0), F$1.on(o$2, {
			name: T,
			callback() {
				undo(w$3);
			}
		}), F$1.on(o$2, {
			name: d,
			callback() {
				redo(w$3);
			}
		}), F$1.on(o$2, {
			name: G,
			async callback(O$3, H$2 = {}) {
				if (O$3 === "image" && H$2.transform) {
					const V$2 = e$1.transformImgUrl(H$2.url);
					if (V$2 instanceof Promise) V$2.then(async (_$2) => {
						const { text: W$2, options: J$1 } = await ue$1(O$3, T$1.value, {
							...H$2,
							url: _$2
						});
						T$1.value?.replaceSelectedText(W$2, J$1, o$2);
					}).catch((_$2) => {
						console.error(_$2);
					});
					else {
						const { text: _$2, options: W$2 } = await ue$1(O$3, T$1.value, {
							...H$2,
							url: V$2
						});
						T$1.value?.replaceSelectedText(_$2, W$2, o$2);
					}
				} else {
					const { text: V$2, options: _$2 } = await ue$1(O$3, T$1.value, H$2);
					T$1.value?.replaceSelectedText(V$2, _$2, o$2);
				}
			}
		}), F$1.on(o$2, {
			name: V,
			callback: F((O$3) => {
				const H$2 = { ...oe$1 }, V$2 = Object.keys(oe$1);
				for (const _$2 in O$3) {
					const W$2 = _$2;
					V$2.includes(W$2) ? H$2[W$2] = (J$1, Ce$2) => {
						O$3[W$2](J$1, Ce$2), J$1.defaultPrevented || oe$1[W$2](J$1, Ce$2);
					} : H$2[W$2] = O$3[W$2];
				}
				T$1.value?.view.dispatch({ effects: Te$1.reconfigure(EditorView.domEventHandlers(H$2)) });
			})
		}), F$1.on(o$2, {
			name: O,
			callback: (O$3, H$2) => {
				const V$2 = w$3.state.doc.line(O$3);
				w$3.dispatch(w$3.state.update({ changes: {
					from: V$2.from,
					to: V$2.to,
					insert: H$2
				} }));
			}
		}), F$1.on(o$2, {
			name: u$1,
			callback() {
				F$1.emit(o$2, f, w$3);
			}
		}), F$1.emit(o$2, f, w$3);
	}), watch(n$3, () => {
		T$1.value?.view.dispatch({ effects: z$2.reconfigure(n$3.value === "light" ? Me : Ve) });
	}, { deep: !0 }), watch(() => e$1.completions, () => {
		T$1.value?.view.dispatch({ effects: q.reconfigure(Ee$1(e$1.completions)) });
	}, { deep: !0 }), watch(() => e$1.modelValue, () => {
		T$1.value?.getValue() !== e$1.modelValue && T$1.value?.setValue(e$1.modelValue);
	}), watch(() => e$1.placeholder, () => {
		T$1.value?.setPlaceholder(e$1.placeholder);
	}), watch([d$2], () => {
		T$1.value?.setDisabled(d$2.value);
	}), watch(() => e$1.readonly, () => {
		T$1.value?.setDisabled(e$1.readonly);
	}), watch(() => e$1.maxlength, () => {
		e$1.maxlength && T$1.value?.setMaxLength(e$1.maxlength);
	}), fo(() => {
		const w$3 = ye.find((F$2) => F$2.type === "floatingToolbar");
		w$3?.compartment && (S$2.value.length > 0 ? T$1.value?.view.dispatch({ effects: w$3.compartment.reconfigure(Xe(w$3)) }) : T$1.value?.view.dispatch({ effects: w$3.compartment.reconfigure([]) }));
	}, S$2), {
		inputWrapperRef: L$2,
		codeMirrorUt: T$1,
		resetHistory() {
			T$1.value?.view.dispatch({ effects: $$1.reconfigure([]) }), T$1.value?.view.dispatch({ effects: $$1.reconfigure(history()) });
		}
	};
}, Vl = (e$1, t$1, o$2) => {
	const n$3 = inject("setting"), i$3 = computed(() => /px$/.test(`${e$1.inputBoxWidth}`) ? "50%" : e$1.inputBoxWidth), s$2 = reactive({ resizedWidth: i$3.value }), c$2 = reactive({ width: i$3.value }), d$2 = reactive({
		insetInlineStart: i$3.value,
		display: "initial"
	}), u$4 = (f$3) => {
		const g$4 = t$1.value?.offsetWidth || 0, p$3 = t$1.value?.getBoundingClientRect().x || 0;
		let k$2 = f$3.x - p$3;
		k$2 / g$4 < w$1 ? k$2 = g$4 * w$1 : k$2 > g$4 - g$4 * w$1 && (k$2 = g$4 - g$4 * w$1);
		const E = `${k$2 / g$4 * 100}%`;
		c$2.width = E, d$2.insetInlineStart = E, s$2.resizedWidth = E, e$1.oninputBoxWidthChange?.(E);
	}, v$2 = (f$3) => {
		f$3.target === o$2.value && document.addEventListener("mousemove", u$4);
	}, m$2 = () => {
		document.removeEventListener("mousemove", u$4);
	};
	return watch([o$2], () => {
		document.removeEventListener("mousedown", v$2), document.removeEventListener("mouseup", m$2), document.addEventListener("mousedown", v$2), document.addEventListener("mouseup", m$2);
	}), onMounted(() => {
		document.addEventListener("mousedown", v$2), document.addEventListener("mouseup", m$2);
	}), onBeforeUnmount(() => {
		document.removeEventListener("mousedown", v$2), document.removeEventListener("mouseup", m$2);
	}), watch([i$3], ([f$3]) => {
		s$2.resizedWidth = f$3, c$2.width = f$3, d$2.insetInlineStart = f$3;
	}), watch([
		() => n$3.value.htmlPreview,
		() => n$3.value.preview,
		() => n$3.value.previewOnly
	], () => {
		n$3.value.previewOnly ? (c$2.width = "0%", d$2.display = "none") : !n$3.value.htmlPreview && !n$3.value.preview ? (c$2.width = "100%", d$2.display = "none") : (c$2.width = s$2.resizedWidth, d$2.display = "initial");
	}, { immediate: !0 }), {
		inputWrapperStyle: c$2,
		resizeOperateStyle: d$2
	};
}, Wl = () => {
	const e$1 = inject("editorId"), t$1 = ref(!0), o$2 = C();
	return {
		onCatalogActive: (c$2, d$2) => {
			const u$4 = document.querySelector(`#${e$1} .${p$1}-catalog-editor`);
			if (!d$2 || !t$1.value || !u$4) return;
			const v$2 = d$2.offsetTop - u$4.scrollTop;
			(v$2 > 100 || v$2 < 100) && o$2(u$4, d$2.offsetTop - 100);
		},
		onMouseenter: () => t$1.value = !1,
		onMouseleave: () => t$1.value = !0
	};
}, be$1 = /* @__PURE__ */ defineComponent({
	name: `${u}CustomScrollbar`,
	props: {
		id: {
			type: String,
			default: void 0
		},
		class: {
			type: [String, Array],
			default: void 0
		},
		scrollTarget: {
			type: String,
			default: void 0
		},
		alwaysShowTrack: {
			type: Boolean,
			default: !1
		},
		onMouseenter: {
			type: Function,
			default: () => {}
		},
		onMouseleave: {
			type: Function,
			default: () => {}
		}
	},
	setup(e$1, { slots: t$1 }) {
		const o$2 = ref(null), n$3 = ref(null), i$3 = ref(null), s$2 = ref(null);
		let c$2 = null, d$2 = null, u$4 = !1, v$2 = 0, m$2 = 0;
		const f$3 = () => {
			if (!n$3.value || !o$2.value || !i$3.value || !s$2.value) return;
			const S$2 = o$2.value.clientHeight, D$2 = n$3.value.scrollHeight, L$2 = n$3.value.scrollTop;
			if (D$2 <= S$2) {
				i$3.value.style.display = "none", e$1.alwaysShowTrack || (s$2.value.style.display = "none");
				return;
			} else i$3.value.style.display = "block", s$2.value.style.display = "block";
			const T$1 = S$2 / D$2, R$4 = Math.max(S$2 * T$1, 20), z$2 = S$2 - R$4, q = Math.min(L$2 * T$1, z$2);
			i$3.value.style.height = `${R$4}px`, i$3.value.style.top = `${q}px`;
		}, g$4 = () => f$3(), p$3 = (S$2) => {
			u$4 = !0, v$2 = S$2.clientY, m$2 = n$3.value.scrollTop, document.body.style.userSelect = "none";
		}, k$2 = (S$2) => {
			if (!u$4 || !n$3.value || !o$2.value) return;
			const D$2 = S$2.clientY - v$2, L$2 = n$3.value.scrollHeight / o$2.value.clientHeight;
			n$3.value.scrollTop = m$2 + D$2 * L$2;
		}, E = () => {
			u$4 = !1, document.body.style.userSelect = "";
		}, M$3 = (S$2) => {
			n$3.value && n$3.value.removeEventListener("scroll", g$4), n$3.value = S$2, n$3.value ? (n$3.value.addEventListener("scroll", g$4), f$3()) : s$2.value && !e$1.alwaysShowTrack && (s$2.value.style.display = "none");
		}, A$2 = () => {
			if (!o$2.value) return;
			const S$2 = e$1.scrollTarget ? o$2.value.querySelector(e$1.scrollTarget) : o$2.value.firstElementChild;
			M$3(S$2);
		};
		return onMounted(async () => {
			await nextTick(), A$2(), c$2 = new MutationObserver(() => {
				d$2 && cancelAnimationFrame(d$2), d$2 = requestAnimationFrame(() => {
					A$2();
				});
			}), c$2.observe(o$2.value, {
				childList: !0,
				subtree: !0
			}), window.addEventListener("resize", f$3), i$3.value?.addEventListener("mousedown", p$3), document.addEventListener("mousemove", k$2), document.addEventListener("mouseup", E);
		}), onBeforeUnmount(() => {
			c$2?.disconnect(), n$3.value && n$3.value.removeEventListener("scroll", g$4), window.removeEventListener("resize", f$3), i$3.value?.removeEventListener("mousedown", p$3), document.removeEventListener("mousemove", k$2), document.removeEventListener("mouseup", E);
		}), () => createVNode("div", {
			id: e$1.id,
			class: [`${p$1}-custom-scrollbar`, e$1.class],
			ref: o$2,
			onMouseenter: e$1.onMouseenter,
			onMouseleave: e$1.onMouseleave
		}, [t$1.default?.(), createVNode("div", {
			class: `${p$1}-custom-scrollbar__track`,
			ref: s$2
		}, [createVNode("div", {
			class: `${p$1}-custom-scrollbar__thumb`,
			ref: i$3
		}, null)])]);
	}
}), _l = C(), zl = { flex: 1 }, ql = /* @__PURE__ */ defineComponent({
	name: "MDEditorContent",
	props: on,
	setup(e$1, t$1) {
		const o$2 = inject("editorId"), n$3 = inject("catalogVisible"), i$3 = inject("theme"), s$2 = inject("setting"), c$2 = ref(""), d$2 = ref(), u$4 = ref(), { inputWrapperRef: v$2, codeMirrorUt: m$2, resetHistory: f$3 } = Ol(e$1), { inputWrapperStyle: g$4, resizeOperateStyle: p$3 } = Vl(e$1, d$2, u$4);
		oo(e$1, c$2, m$2);
		const { onCatalogActive: k$2, onMouseenter: E, onMouseleave: M$3 } = Wl(), A$2 = (L$2, T$1) => {
			if (!s$2.value.preview && T$1.line !== void 0) {
				L$2.preventDefault();
				const R$4 = m$2.value?.view;
				if (R$4) {
					const z$2 = R$4.state.doc.line(T$1.line + 1), q = R$4.lineBlockAt(z$2.from)?.top, $$1 = R$4.scrollDOM;
					_l($$1, q);
				}
			}
		}, S$2 = computed(() => s$2.value.preview ? "preview" : "editor"), D$2 = (L$2) => {
			c$2.value = L$2, e$1.onHtmlChanged(L$2);
		};
		return t$1.expose({
			getSelectedText() {
				return m$2.value?.getSelectedText();
			},
			focus(L$2) {
				m$2.value?.focus(L$2);
			},
			resetHistory: f$3,
			getEditorView() {
				return m$2.value?.view;
			}
		}), () => createVNode("div", { class: `${p$1}-content` }, [createVNode("div", {
			class: `${p$1}-content-wrapper`,
			ref: d$2
		}, [
			createVNode(be$1, {
				alwaysShowTrack: !0,
				scrollTarget: `#${o$2} .cm-scroller`,
				style: g$4
			}, { default: () => [createVNode("div", {
				class: `${p$1}-input-wrapper`,
				ref: v$2
			}, null)] }),
			(s$2.value.htmlPreview || s$2.value.preview) && createVNode("div", {
				class: `${p$1}-resize-operate`,
				style: p$3,
				ref: u$4
			}, null),
			createVNode(be$1, { style: zl }, { default: () => [createVNode(Pt, {
				modelValue: e$1.modelValue,
				onChange: e$1.onChange,
				onHtmlChanged: D$2,
				onGetCatalog: e$1.onGetCatalog,
				mdHeadingId: e$1.mdHeadingId,
				noMermaid: e$1.noMermaid,
				sanitize: e$1.sanitize,
				noKatex: e$1.noKatex,
				formatCopiedText: e$1.formatCopiedText,
				noHighlight: e$1.noHighlight,
				noImgZoomIn: e$1.noImgZoomIn,
				sanitizeMermaid: e$1.sanitizeMermaid,
				codeFoldable: e$1.codeFoldable,
				autoFoldThreshold: e$1.autoFoldThreshold,
				onRemount: e$1.onRemount,
				previewComponent: e$1.previewComponent,
				noEcharts: e$1.noEcharts
			}, null)] })
		]), n$3.value && createVNode(be$1, {
			class: `${p$1}-catalog-${e$1.catalogLayout}`,
			onMouseenter: E,
			onMouseleave: M$3
		}, { default: () => [createVNode(W, {
			theme: i$3.value,
			class: `${p$1}-catalog-editor`,
			editorId: o$2,
			mdHeadingId: e$1.mdHeadingId,
			key: "internal-catalog",
			scrollElementOffsetTop: 2,
			syncWith: S$2.value,
			onClick: A$2,
			catalogMaxDepth: e$1.catalogMaxDepth,
			onActive: k$2
		}, null)] })]);
	}
}), Ul = /* @__PURE__ */ defineComponent({
	props: { modelValue: {
		type: String,
		default: ""
	} },
	setup(e$1) {
		const t$1 = inject("usedLanguageText");
		return () => createVNode("div", { class: `${p$1}-footer-item` }, [createVNode("label", { class: `${p$1}-footer-label` }, [`${t$1.value.footer?.markdownTotal}:`]), createVNode("span", null, [e$1.modelValue?.length || 0])]);
	}
}), Kl = {
	checked: {
		type: Boolean,
		default: !1
	},
	onChange: {
		type: Function,
		default: () => {}
	},
	disabled: {
		type: Boolean,
		default: void 0
	}
}, Gl = /* @__PURE__ */ defineComponent({
	name: `${p$1}-checkbox`,
	props: Kl,
	setup(e$1) {
		return () => createVNode("div", {
			class: [
				`${p$1}-checkbox`,
				e$1.checked && `${p$1}-checkbox-checked`,
				e$1.disabled && `${p$1}-disabled`
			],
			onClick: () => {
				e$1.disabled || e$1.onChange(!e$1.checked);
			}
		}, null);
	}
}), jl = {
	scrollAuto: { type: Boolean },
	onScrollAutoChange: {
		type: Function,
		default: () => {}
	}
}, Yl = /* @__PURE__ */ defineComponent({
	props: jl,
	setup(e$1) {
		const t$1 = inject("usedLanguageText"), o$2 = inject("disabled");
		return () => createVNode("div", { class: [`${p$1}-footer-item`, o$2?.value && `${p$1}-disabled`] }, [createVNode("label", {
			class: `${p$1}-footer-label`,
			onClick: () => {
				o$2?.value || e$1.onScrollAutoChange(!e$1.scrollAuto);
			}
		}, [t$1?.value.footer?.scrollAuto]), createVNode(Gl, {
			checked: e$1.scrollAuto,
			onChange: e$1.onScrollAutoChange,
			disabled: o$2?.value
		}, null)]);
	}
}), Zl = {
	modelValue: {
		type: String,
		default: ""
	},
	footers: {
		type: Array,
		default: []
	},
	scrollAuto: { type: Boolean },
	noScrollAuto: { type: Boolean },
	onScrollAutoChange: {
		type: Function,
		default: () => {}
	},
	defFooters: { type: Object }
}, Xl = /* @__PURE__ */ defineComponent({
	name: "MDEditorFooter",
	props: Zl,
	setup(e$1) {
		const t$1 = inject("theme"), o$2 = inject("language"), n$3 = inject("disabled"), i$3 = computed(() => {
			const c$2 = e$1.footers.indexOf("="), d$2 = c$2 === -1 ? e$1.footers : e$1.footers.slice(0, c$2), u$4 = c$2 === -1 ? [] : e$1.footers.slice(c$2, Number.MAX_SAFE_INTEGER);
			return [d$2, u$4];
		}), s$2 = (c$2) => {
			if (b.includes(c$2)) switch (c$2) {
				case "markdownTotal": return createVNode(Ul, { modelValue: e$1.modelValue }, null);
				case "scrollSwitch": return !e$1.noScrollAuto && createVNode(Yl, {
					scrollAuto: e$1.scrollAuto,
					onScrollAutoChange: e$1.onScrollAutoChange
				}, null);
			}
			else if (e$1.defFooters instanceof Array) {
				const d$2 = e$1.defFooters[c$2];
				return d$2 ? cloneVNode(d$2, {
					theme: d$2.props?.theme || t$1.value,
					language: d$2.props?.language || o$2.value,
					disabled: d$2.props?.disabled || n$3?.value
				}) : "";
			} else if (e$1.defFooters && e$1.defFooters.children instanceof Array) {
				const d$2 = e$1.defFooters.children[c$2];
				return d$2 ? cloneVNode(d$2, {
					theme: d$2.props?.theme || t$1.value,
					language: d$2.props?.language || o$2.value,
					disabled: d$2.props?.disabled || n$3?.value
				}) : "";
			} else return "";
		};
		return () => {
			const c$2 = i$3.value[0].map((u$4) => s$2(u$4)), d$2 = i$3.value[1].map((u$4) => s$2(u$4));
			return createVNode("div", { class: `${p$1}-footer` }, [createVNode("div", { class: `${p$1}-footer-left` }, [c$2]), createVNode("div", { class: `${p$1}-footer-right` }, [d$2])]);
		};
	}
}), Jl = {
	toolbars: {
		type: Array,
		default: () => []
	},
	toolbarsExclude: {
		type: Array,
		default: () => []
	}
}, Ql = /* @__PURE__ */ defineComponent({
	name: "MDEditorToolbar",
	props: Jl,
	setup(e$1) {
		const t$1 = inject("editorId"), o$2 = inject("showToolbarName"), n$3 = `${t$1}-toolbar-wrapper`, i$3 = ref(), s$2 = ref(), { barRender: c$2 } = Ze(), d$2 = computed(() => {
			const u$4 = e$1.toolbars.filter((g$4) => !e$1.toolbarsExclude.includes(g$4)), v$2 = u$4.indexOf("="), m$2 = v$2 === -1 ? u$4 : u$4.slice(0, v$2 + 1), f$3 = v$2 === -1 ? [] : u$4.slice(v$2, Number.MAX_SAFE_INTEGER);
			return [m$2, f$3];
		});
		return watch(() => e$1.toolbars, () => {
			nextTick(() => {
				i$3.value && U$1(i$3.value);
			});
		}, { immediate: !0 }), () => {
			const u$4 = d$2.value[0].map((m$2) => c$2(m$2)), v$2 = d$2.value[1].map((m$2) => c$2(m$2));
			return createVNode(Fragment, null, [e$1.toolbars.length > 0 && createVNode("div", {
				class: `${p$1}-toolbar-wrapper`,
				ref: i$3,
				id: n$3
			}, [createVNode("div", { class: [`${p$1}-toolbar`, o$2.value && `${p$1}-stn`] }, [createVNode("div", {
				class: `${p$1}-toolbar-left`,
				ref: s$2
			}, [u$4]), createVNode("div", { class: `${p$1}-toolbar-right` }, [v$2])])])]);
		};
	}
}), ve = /* @__PURE__ */ defineComponent({
	name: "MdEditorV3",
	props: an,
	emits: rn,
	setup(e$1, t$1) {
		const { noKatex: o$2, noMermaid: n$3, noHighlight: i$3 } = e$1, s$2 = reactive({ scrollAuto: e$1.scrollAuto }), c$2 = ref(), d$2 = ref(), u$4 = computed(() => g({
			props: e$1,
			ctx: t$1
		}, "defToolbars")), v$2 = computed(() => g({
			props: e$1,
			ctx: t$1
		}, "defFooters")), m$2 = tt(e$1), [f$3, g$4] = en(e$1, t$1, { editorId: m$2 }), p$3 = tn(e$1, { editorId: m$2 });
		Jt(e$1, t$1, { editorId: m$2 }), Yt(e$1), Qt(e$1, t$1, { editorId: m$2 }), nn(e$1, t$1, {
			editorId: m$2,
			catalogVisible: p$3,
			setting: f$3,
			updateSetting: g$4,
			codeRef: d$2
		}), Xt(e$1, {
			rootRef: c$2,
			editorId: m$2,
			setting: f$3,
			updateSetting: g$4,
			catalogVisible: p$3,
			defToolbars: u$4
		}), onBeforeUnmount(() => {
			F$1.clear(m$2);
		});
		const k$2 = ($$1) => {
			t$1.emit("update:modelValue", $$1);
		}, E = ($$1) => {
			e$1.onChange?.($$1), t$1.emit("onChange", $$1);
		}, M$3 = ($$1) => {
			e$1.onHtmlChanged?.($$1), t$1.emit("onHtmlChanged", $$1);
		}, A$2 = ($$1) => {
			e$1.onGetCatalog?.($$1), t$1.emit("onGetCatalog", $$1);
		}, S$2 = ($$1) => {
			e$1.onBlur?.($$1), t$1.emit("onBlur", $$1);
		}, D$2 = ($$1) => {
			e$1.onFocus?.($$1), t$1.emit("onFocus", $$1);
		}, L$2 = ($$1) => {
			e$1.onInput?.($$1), t$1.emit("onInput", $$1);
		}, T$1 = ($$1) => {
			e$1.onDrop?.($$1), t$1.emit("onDrop", $$1);
		}, R$4 = ($$1) => {
			e$1.oninputBoxWidthChange?.($$1), t$1.emit("oninputBoxWidthChange", $$1);
		}, z$2 = () => {
			e$1.onRemount?.(), t$1.emit("onRemount");
		}, q = ($$1) => {
			s$2.scrollAuto = $$1;
		};
		return () => createVNode("div", {
			id: m$2,
			class: [
				p$1,
				e$1.class,
				e$1.theme === "dark" && `${p$1}-dark`,
				f$3.fullscreen || f$3.pageFullscreen ? `${p$1}-fullscreen` : ""
			],
			style: e$1.style,
			ref: c$2
		}, [
			e$1.toolbars.length > 0 && createVNode(Ql, {
				toolbars: e$1.toolbars,
				toolbarsExclude: e$1.toolbarsExclude
			}, null),
			createVNode(ql, {
				ref: d$2,
				modelValue: e$1.modelValue,
				mdHeadingId: e$1.mdHeadingId,
				noMermaid: n$3,
				sanitize: e$1.sanitize,
				placeholder: e$1.placeholder,
				noKatex: o$2,
				scrollAuto: s$2.scrollAuto,
				formatCopiedText: e$1.formatCopiedText,
				autofocus: e$1.autoFocus,
				readonly: e$1.readOnly,
				maxlength: e$1.maxLength,
				autoDetectCode: e$1.autoDetectCode,
				noHighlight: i$3,
				updateModelValue: k$2,
				onChange: E,
				onHtmlChanged: M$3,
				onGetCatalog: A$2,
				onBlur: S$2,
				onFocus: D$2,
				onInput: L$2,
				completions: e$1.completions,
				noImgZoomIn: e$1.noImgZoomIn,
				onDrop: T$1,
				inputBoxWidth: e$1.inputBoxWidth,
				oninputBoxWidthChange: R$4,
				sanitizeMermaid: e$1.sanitizeMermaid,
				transformImgUrl: e$1.transformImgUrl,
				codeFoldable: e$1.codeFoldable,
				autoFoldThreshold: e$1.autoFoldThreshold,
				onRemount: z$2,
				catalogLayout: e$1.catalogLayout,
				catalogMaxDepth: e$1.catalogMaxDepth,
				noEcharts: e$1.noEcharts,
				previewComponent: e$1.previewComponent
			}, null),
			e$1.footers.length > 0 && createVNode(Xl, {
				modelValue: e$1.modelValue,
				footers: e$1.footers,
				defFooters: v$2.value,
				noScrollAuto: !f$3.preview && !f$3.htmlPreview || f$3.previewOnly,
				scrollAuto: s$2.scrollAuto,
				onScrollAutoChange: q
			}, null)
		]);
	}
});
ve.install = (e$1) => (e$1.component(ve.name, ve), e$1.use(n).use(h).use(o).use(W).use(ae), e$1);

//#endregion
//#region node_modules/md-editor-v3/lib/es/config.mjs
var s = v["zh-CN"], a = v["en-US"];

//#endregion
//#region node_modules/md-editor-v3/lib/es/index.mjs
function xe(t$1, n$3) {
	for (var i$3 = 0; i$3 < n$3.length; i$3++) {
		const s$2 = n$3[i$3];
		if (typeof s$2 != "string" && !Array.isArray(s$2)) {
			for (const g$4 in s$2) if (g$4 !== "default" && !(g$4 in t$1)) {
				const e$1 = Object.getOwnPropertyDescriptor(s$2, g$4);
				e$1 && Object.defineProperty(t$1, g$4, e$1.get ? e$1 : {
					enumerable: !0,
					get: () => s$2[g$4]
				});
			}
		}
	}
	return Object.freeze(Object.defineProperty(t$1, Symbol.toStringTag, { value: "Module" }));
}
var ke = {
	onClick: {
		type: Function,
		default: void 0
	},
	language: {
		type: String,
		default: void 0
	},
	theme: {
		type: String,
		default: void 0
	},
	disabled: {
		type: Boolean,
		default: void 0
	}
}, Q = /* @__PURE__ */ defineComponent({
	name: "NormalFooterToolbar",
	props: ke,
	emits: ["onClick"],
	setup(t$1, n$3) {
		return () => {
			const i$3 = g({
				props: t$1,
				ctx: n$3
			});
			return createVNode("div", {
				class: [`${p$1}-footer-item`, t$1.disabled && `${p$1}-disabled`],
				onClick: (s$2) => {
					t$1.disabled || (t$1.onClick?.(s$2), n$3.emit("onClick", s$2));
				}
			}, [i$3]);
		};
	}
});
Q.install = (t$1) => (t$1.component(Q.name, Q), t$1);
function Se(t$1) {
	return t$1 && t$1.__esModule && Object.prototype.hasOwnProperty.call(t$1, "default") ? t$1.default : t$1;
}
var z = { exports: {} }, w = {}, M$1 = { exports: {} }, N = {}, ie;
function ve$1() {
	if (ie) return N;
	ie = 1;
	function t$1() {
		var e$1 = {};
		return e$1["align-content"] = !1, e$1["align-items"] = !1, e$1["align-self"] = !1, e$1["alignment-adjust"] = !1, e$1["alignment-baseline"] = !1, e$1.all = !1, e$1["anchor-point"] = !1, e$1.animation = !1, e$1["animation-delay"] = !1, e$1["animation-direction"] = !1, e$1["animation-duration"] = !1, e$1["animation-fill-mode"] = !1, e$1["animation-iteration-count"] = !1, e$1["animation-name"] = !1, e$1["animation-play-state"] = !1, e$1["animation-timing-function"] = !1, e$1.azimuth = !1, e$1["backface-visibility"] = !1, e$1.background = !0, e$1["background-attachment"] = !0, e$1["background-clip"] = !0, e$1["background-color"] = !0, e$1["background-image"] = !0, e$1["background-origin"] = !0, e$1["background-position"] = !0, e$1["background-repeat"] = !0, e$1["background-size"] = !0, e$1["baseline-shift"] = !1, e$1.binding = !1, e$1.bleed = !1, e$1["bookmark-label"] = !1, e$1["bookmark-level"] = !1, e$1["bookmark-state"] = !1, e$1.border = !0, e$1["border-bottom"] = !0, e$1["border-bottom-color"] = !0, e$1["border-bottom-left-radius"] = !0, e$1["border-bottom-right-radius"] = !0, e$1["border-bottom-style"] = !0, e$1["border-bottom-width"] = !0, e$1["border-collapse"] = !0, e$1["border-color"] = !0, e$1["border-image"] = !0, e$1["border-image-outset"] = !0, e$1["border-image-repeat"] = !0, e$1["border-image-slice"] = !0, e$1["border-image-source"] = !0, e$1["border-image-width"] = !0, e$1["border-left"] = !0, e$1["border-left-color"] = !0, e$1["border-left-style"] = !0, e$1["border-left-width"] = !0, e$1["border-radius"] = !0, e$1["border-right"] = !0, e$1["border-right-color"] = !0, e$1["border-right-style"] = !0, e$1["border-right-width"] = !0, e$1["border-spacing"] = !0, e$1["border-style"] = !0, e$1["border-top"] = !0, e$1["border-top-color"] = !0, e$1["border-top-left-radius"] = !0, e$1["border-top-right-radius"] = !0, e$1["border-top-style"] = !0, e$1["border-top-width"] = !0, e$1["border-width"] = !0, e$1.bottom = !1, e$1["box-decoration-break"] = !0, e$1["box-shadow"] = !0, e$1["box-sizing"] = !0, e$1["box-snap"] = !0, e$1["box-suppress"] = !0, e$1["break-after"] = !0, e$1["break-before"] = !0, e$1["break-inside"] = !0, e$1["caption-side"] = !1, e$1.chains = !1, e$1.clear = !0, e$1.clip = !1, e$1["clip-path"] = !1, e$1["clip-rule"] = !1, e$1.color = !0, e$1["color-interpolation-filters"] = !0, e$1["column-count"] = !1, e$1["column-fill"] = !1, e$1["column-gap"] = !1, e$1["column-rule"] = !1, e$1["column-rule-color"] = !1, e$1["column-rule-style"] = !1, e$1["column-rule-width"] = !1, e$1["column-span"] = !1, e$1["column-width"] = !1, e$1.columns = !1, e$1.contain = !1, e$1.content = !1, e$1["counter-increment"] = !1, e$1["counter-reset"] = !1, e$1["counter-set"] = !1, e$1.crop = !1, e$1.cue = !1, e$1["cue-after"] = !1, e$1["cue-before"] = !1, e$1.cursor = !1, e$1.direction = !1, e$1.display = !0, e$1["display-inside"] = !0, e$1["display-list"] = !0, e$1["display-outside"] = !0, e$1["dominant-baseline"] = !1, e$1.elevation = !1, e$1["empty-cells"] = !1, e$1.filter = !1, e$1.flex = !1, e$1["flex-basis"] = !1, e$1["flex-direction"] = !1, e$1["flex-flow"] = !1, e$1["flex-grow"] = !1, e$1["flex-shrink"] = !1, e$1["flex-wrap"] = !1, e$1.float = !1, e$1["float-offset"] = !1, e$1["flood-color"] = !1, e$1["flood-opacity"] = !1, e$1["flow-from"] = !1, e$1["flow-into"] = !1, e$1.font = !0, e$1["font-family"] = !0, e$1["font-feature-settings"] = !0, e$1["font-kerning"] = !0, e$1["font-language-override"] = !0, e$1["font-size"] = !0, e$1["font-size-adjust"] = !0, e$1["font-stretch"] = !0, e$1["font-style"] = !0, e$1["font-synthesis"] = !0, e$1["font-variant"] = !0, e$1["font-variant-alternates"] = !0, e$1["font-variant-caps"] = !0, e$1["font-variant-east-asian"] = !0, e$1["font-variant-ligatures"] = !0, e$1["font-variant-numeric"] = !0, e$1["font-variant-position"] = !0, e$1["font-weight"] = !0, e$1.grid = !1, e$1["grid-area"] = !1, e$1["grid-auto-columns"] = !1, e$1["grid-auto-flow"] = !1, e$1["grid-auto-rows"] = !1, e$1["grid-column"] = !1, e$1["grid-column-end"] = !1, e$1["grid-column-start"] = !1, e$1["grid-row"] = !1, e$1["grid-row-end"] = !1, e$1["grid-row-start"] = !1, e$1["grid-template"] = !1, e$1["grid-template-areas"] = !1, e$1["grid-template-columns"] = !1, e$1["grid-template-rows"] = !1, e$1["hanging-punctuation"] = !1, e$1.height = !0, e$1.hyphens = !1, e$1.icon = !1, e$1["image-orientation"] = !1, e$1["image-resolution"] = !1, e$1["ime-mode"] = !1, e$1["initial-letters"] = !1, e$1["inline-box-align"] = !1, e$1["justify-content"] = !1, e$1["justify-items"] = !1, e$1["justify-self"] = !1, e$1.left = !1, e$1["letter-spacing"] = !0, e$1["lighting-color"] = !0, e$1["line-box-contain"] = !1, e$1["line-break"] = !1, e$1["line-grid"] = !1, e$1["line-height"] = !1, e$1["line-snap"] = !1, e$1["line-stacking"] = !1, e$1["line-stacking-ruby"] = !1, e$1["line-stacking-shift"] = !1, e$1["line-stacking-strategy"] = !1, e$1["list-style"] = !0, e$1["list-style-image"] = !0, e$1["list-style-position"] = !0, e$1["list-style-type"] = !0, e$1.margin = !0, e$1["margin-bottom"] = !0, e$1["margin-left"] = !0, e$1["margin-right"] = !0, e$1["margin-top"] = !0, e$1["marker-offset"] = !1, e$1["marker-side"] = !1, e$1.marks = !1, e$1.mask = !1, e$1["mask-box"] = !1, e$1["mask-box-outset"] = !1, e$1["mask-box-repeat"] = !1, e$1["mask-box-slice"] = !1, e$1["mask-box-source"] = !1, e$1["mask-box-width"] = !1, e$1["mask-clip"] = !1, e$1["mask-image"] = !1, e$1["mask-origin"] = !1, e$1["mask-position"] = !1, e$1["mask-repeat"] = !1, e$1["mask-size"] = !1, e$1["mask-source-type"] = !1, e$1["mask-type"] = !1, e$1["max-height"] = !0, e$1["max-lines"] = !1, e$1["max-width"] = !0, e$1["min-height"] = !0, e$1["min-width"] = !0, e$1["move-to"] = !1, e$1["nav-down"] = !1, e$1["nav-index"] = !1, e$1["nav-left"] = !1, e$1["nav-right"] = !1, e$1["nav-up"] = !1, e$1["object-fit"] = !1, e$1["object-position"] = !1, e$1.opacity = !1, e$1.order = !1, e$1.orphans = !1, e$1.outline = !1, e$1["outline-color"] = !1, e$1["outline-offset"] = !1, e$1["outline-style"] = !1, e$1["outline-width"] = !1, e$1.overflow = !1, e$1["overflow-wrap"] = !1, e$1["overflow-x"] = !1, e$1["overflow-y"] = !1, e$1.padding = !0, e$1["padding-bottom"] = !0, e$1["padding-left"] = !0, e$1["padding-right"] = !0, e$1["padding-top"] = !0, e$1.page = !1, e$1["page-break-after"] = !1, e$1["page-break-before"] = !1, e$1["page-break-inside"] = !1, e$1["page-policy"] = !1, e$1.pause = !1, e$1["pause-after"] = !1, e$1["pause-before"] = !1, e$1.perspective = !1, e$1["perspective-origin"] = !1, e$1.pitch = !1, e$1["pitch-range"] = !1, e$1["play-during"] = !1, e$1.position = !1, e$1["presentation-level"] = !1, e$1.quotes = !1, e$1["region-fragment"] = !1, e$1.resize = !1, e$1.rest = !1, e$1["rest-after"] = !1, e$1["rest-before"] = !1, e$1.richness = !1, e$1.right = !1, e$1.rotation = !1, e$1["rotation-point"] = !1, e$1["ruby-align"] = !1, e$1["ruby-merge"] = !1, e$1["ruby-position"] = !1, e$1["shape-image-threshold"] = !1, e$1["shape-outside"] = !1, e$1["shape-margin"] = !1, e$1.size = !1, e$1.speak = !1, e$1["speak-as"] = !1, e$1["speak-header"] = !1, e$1["speak-numeral"] = !1, e$1["speak-punctuation"] = !1, e$1["speech-rate"] = !1, e$1.stress = !1, e$1["string-set"] = !1, e$1["tab-size"] = !1, e$1["table-layout"] = !1, e$1["text-align"] = !0, e$1["text-align-last"] = !0, e$1["text-combine-upright"] = !0, e$1["text-decoration"] = !0, e$1["text-decoration-color"] = !0, e$1["text-decoration-line"] = !0, e$1["text-decoration-skip"] = !0, e$1["text-decoration-style"] = !0, e$1["text-emphasis"] = !0, e$1["text-emphasis-color"] = !0, e$1["text-emphasis-position"] = !0, e$1["text-emphasis-style"] = !0, e$1["text-height"] = !0, e$1["text-indent"] = !0, e$1["text-justify"] = !0, e$1["text-orientation"] = !0, e$1["text-overflow"] = !0, e$1["text-shadow"] = !0, e$1["text-space-collapse"] = !0, e$1["text-transform"] = !0, e$1["text-underline-position"] = !0, e$1["text-wrap"] = !0, e$1.top = !1, e$1.transform = !1, e$1["transform-origin"] = !1, e$1["transform-style"] = !1, e$1.transition = !1, e$1["transition-delay"] = !1, e$1["transition-duration"] = !1, e$1["transition-property"] = !1, e$1["transition-timing-function"] = !1, e$1["unicode-bidi"] = !1, e$1["vertical-align"] = !1, e$1.visibility = !1, e$1["voice-balance"] = !1, e$1["voice-duration"] = !1, e$1["voice-family"] = !1, e$1["voice-pitch"] = !1, e$1["voice-range"] = !1, e$1["voice-rate"] = !1, e$1["voice-stress"] = !1, e$1["voice-volume"] = !1, e$1.volume = !1, e$1["white-space"] = !1, e$1.widows = !1, e$1.width = !0, e$1["will-change"] = !1, e$1["word-break"] = !0, e$1["word-spacing"] = !0, e$1["word-wrap"] = !0, e$1["wrap-flow"] = !1, e$1["wrap-through"] = !1, e$1["writing-mode"] = !1, e$1["z-index"] = !1, e$1;
	}
	function n$3(e$1, v$2, u$4) {}
	function i$3(e$1, v$2, u$4) {}
	var s$2 = /javascript\s*\:/gim;
	function g$4(e$1, v$2) {
		return s$2.test(v$2) ? "" : v$2;
	}
	return N.whiteList = t$1(), N.getDefaultWhiteList = t$1, N.onAttr = n$3, N.onIgnoreAttr = i$3, N.safeAttrValue = g$4, N;
}
var j$1, ne;
function he() {
	return ne || (ne = 1, j$1 = {
		indexOf: function(t$1, n$3) {
			var i$3, s$2;
			if (Array.prototype.indexOf) return t$1.indexOf(n$3);
			for (i$3 = 0, s$2 = t$1.length; i$3 < s$2; i$3++) if (t$1[i$3] === n$3) return i$3;
			return -1;
		},
		forEach: function(t$1, n$3, i$3) {
			var s$2, g$4;
			if (Array.prototype.forEach) return t$1.forEach(n$3, i$3);
			for (s$2 = 0, g$4 = t$1.length; s$2 < g$4; s$2++) n$3.call(i$3, t$1[s$2], s$2, t$1);
		},
		trim: function(t$1) {
			return String.prototype.trim ? t$1.trim() : t$1.replace(/(^\s*)|(\s*$)/g, "");
		},
		trimRight: function(t$1) {
			return String.prototype.trimRight ? t$1.trimRight() : t$1.replace(/(\s*$)/g, "");
		}
	}), j$1;
}
var Z, se;
function Ee() {
	if (se) return Z;
	se = 1;
	var t$1 = he();
	function n$3(i$3, s$2) {
		i$3 = t$1.trimRight(i$3), i$3[i$3.length - 1] !== ";" && (i$3 += ";");
		var g$4 = i$3.length, e$1 = !1, v$2 = 0, u$4 = 0, T$1 = "";
		function k$2() {
			if (!e$1) {
				var f$3 = t$1.trim(i$3.slice(v$2, u$4)), a$2 = f$3.indexOf(":");
				if (a$2 !== -1) {
					var y$2 = t$1.trim(f$3.slice(0, a$2)), x$1 = t$1.trim(f$3.slice(a$2 + 1));
					if (y$2) {
						var c$2 = s$2(v$2, T$1.length, y$2, x$1, f$3);
						c$2 && (T$1 += c$2 + "; ");
					}
				}
			}
			v$2 = u$4 + 1;
		}
		for (; u$4 < g$4; u$4++) {
			var S$2 = i$3[u$4];
			if (S$2 === "/" && i$3[u$4 + 1] === "*") {
				var r$2 = i$3.indexOf("*/", u$4 + 2);
				if (r$2 === -1) break;
				u$4 = r$2 + 1, v$2 = u$4 + 1, e$1 = !1;
			} else S$2 === "(" ? e$1 = !0 : S$2 === ")" ? e$1 = !1 : S$2 === ";" ? e$1 || k$2() : S$2 === `
` && k$2();
		}
		return t$1.trim(T$1);
	}
	return Z = n$3, Z;
}
var J, oe;
function Ce() {
	if (oe) return J;
	oe = 1;
	var t$1 = ve$1(), n$3 = Ee();
	he();
	function i$3(e$1) {
		return e$1 == null;
	}
	function s$2(e$1) {
		var v$2 = {};
		for (var u$4 in e$1) v$2[u$4] = e$1[u$4];
		return v$2;
	}
	function g$4(e$1) {
		e$1 = s$2(e$1 || {}), e$1.whiteList = e$1.whiteList || t$1.whiteList, e$1.onAttr = e$1.onAttr || t$1.onAttr, e$1.onIgnoreAttr = e$1.onIgnoreAttr || t$1.onIgnoreAttr, e$1.safeAttrValue = e$1.safeAttrValue || t$1.safeAttrValue, this.options = e$1;
	}
	return g$4.prototype.process = function(e$1) {
		if (e$1 = e$1 || "", e$1 = e$1.toString(), !e$1) return "";
		var v$2 = this, u$4 = v$2.options, T$1 = u$4.whiteList, k$2 = u$4.onAttr, S$2 = u$4.onIgnoreAttr, r$2 = u$4.safeAttrValue;
		return n$3(e$1, function(a$2, y$2, x$1, c$2, I$1) {
			var p$3 = T$1[x$1], d$2 = !1;
			if (p$3 === !0 ? d$2 = p$3 : typeof p$3 == "function" ? d$2 = p$3(c$2) : p$3 instanceof RegExp && (d$2 = p$3.test(c$2)), d$2 !== !0 && (d$2 = !1), c$2 = r$2(x$1, c$2), !!c$2) {
				var C$2 = {
					position: y$2,
					sourcePosition: a$2,
					source: I$1,
					isWhite: d$2
				};
				if (d$2) {
					var b$2 = k$2(x$1, c$2, C$2);
					return i$3(b$2) ? x$1 + ":" + c$2 : b$2;
				} else {
					var b$2 = S$2(x$1, c$2, C$2);
					if (!i$3(b$2)) return b$2;
				}
			}
		});
	}, J = g$4, J;
}
var le;
function ee() {
	return le || (le = 1, (function(t$1, n$3) {
		var i$3 = ve$1(), s$2 = Ce();
		function g$4(v$2, u$4) {
			return new s$2(u$4).process(v$2);
		}
		n$3 = t$1.exports = g$4, n$3.FilterCSS = s$2;
		for (var e$1 in i$3) n$3[e$1] = i$3[e$1];
		typeof window < "u" && (window.filterCSS = t$1.exports);
	})(M$1, M$1.exports)), M$1.exports;
}
var K, fe;
function re() {
	return fe || (fe = 1, K = {
		indexOf: function(t$1, n$3) {
			var i$3, s$2;
			if (Array.prototype.indexOf) return t$1.indexOf(n$3);
			for (i$3 = 0, s$2 = t$1.length; i$3 < s$2; i$3++) if (t$1[i$3] === n$3) return i$3;
			return -1;
		},
		forEach: function(t$1, n$3, i$3) {
			var s$2, g$4;
			if (Array.prototype.forEach) return t$1.forEach(n$3, i$3);
			for (s$2 = 0, g$4 = t$1.length; s$2 < g$4; s$2++) n$3.call(i$3, t$1[s$2], s$2, t$1);
		},
		trim: function(t$1) {
			return String.prototype.trim ? t$1.trim() : t$1.replace(/(^\s*)|(\s*$)/g, "");
		},
		spaceIndex: function(t$1) {
			var n$3 = /\s|\n|\t/, i$3 = n$3.exec(t$1);
			return i$3 ? i$3.index : -1;
		}
	}), K;
}
var ue;
function me() {
	if (ue) return w;
	ue = 1;
	var t$1 = ee().FilterCSS, n$3 = ee().getDefaultWhiteList, i$3 = re();
	function s$2() {
		return {
			a: [
				"target",
				"href",
				"title"
			],
			abbr: ["title"],
			address: [],
			area: [
				"shape",
				"coords",
				"href",
				"alt"
			],
			article: [],
			aside: [],
			audio: [
				"autoplay",
				"controls",
				"crossorigin",
				"loop",
				"muted",
				"preload",
				"src"
			],
			b: [],
			bdi: ["dir"],
			bdo: ["dir"],
			big: [],
			blockquote: ["cite"],
			br: [],
			caption: [],
			center: [],
			cite: [],
			code: [],
			col: [
				"align",
				"valign",
				"span",
				"width"
			],
			colgroup: [
				"align",
				"valign",
				"span",
				"width"
			],
			dd: [],
			del: ["datetime"],
			details: ["open"],
			div: [],
			dl: [],
			dt: [],
			em: [],
			figcaption: [],
			figure: [],
			font: [
				"color",
				"size",
				"face"
			],
			footer: [],
			h1: [],
			h2: [],
			h3: [],
			h4: [],
			h5: [],
			h6: [],
			header: [],
			hr: [],
			i: [],
			img: [
				"src",
				"alt",
				"title",
				"width",
				"height",
				"loading"
			],
			ins: ["datetime"],
			kbd: [],
			li: [],
			mark: [],
			nav: [],
			ol: [],
			p: [],
			pre: [],
			s: [],
			section: [],
			small: [],
			span: [],
			sub: [],
			summary: [],
			sup: [],
			strong: [],
			strike: [],
			table: [
				"width",
				"border",
				"align",
				"valign"
			],
			tbody: ["align", "valign"],
			td: [
				"width",
				"rowspan",
				"colspan",
				"align",
				"valign"
			],
			tfoot: ["align", "valign"],
			th: [
				"width",
				"rowspan",
				"colspan",
				"align",
				"valign"
			],
			thead: ["align", "valign"],
			tr: [
				"rowspan",
				"align",
				"valign"
			],
			tt: [],
			u: [],
			ul: [],
			video: [
				"autoplay",
				"controls",
				"crossorigin",
				"loop",
				"muted",
				"playsinline",
				"poster",
				"preload",
				"src",
				"height",
				"width"
			]
		};
	}
	var g$4 = new t$1();
	function e$1(o$2, m$2, l$2) {}
	function v$2(o$2, m$2, l$2) {}
	function u$4(o$2, m$2, l$2) {}
	function T$1(o$2, m$2, l$2) {}
	function k$2(o$2) {
		return o$2.replace(r$2, "&lt;").replace(f$3, "&gt;");
	}
	function S$2(o$2, m$2, l$2, h$6) {
		if (l$2 = $$1(l$2), m$2 === "href" || m$2 === "src") {
			if (l$2 = i$3.trim(l$2), l$2 === "#") return "#";
			if (!(l$2.substr(0, 7) === "http://" || l$2.substr(0, 8) === "https://" || l$2.substr(0, 7) === "mailto:" || l$2.substr(0, 4) === "tel:" || l$2.substr(0, 11) === "data:image/" || l$2.substr(0, 6) === "ftp://" || l$2.substr(0, 2) === "./" || l$2.substr(0, 3) === "../" || l$2[0] === "#" || l$2[0] === "/")) return "";
		} else if (m$2 === "background") {
			if (p$3.lastIndex = 0, p$3.test(l$2)) return "";
		} else if (m$2 === "style") {
			if (d$2.lastIndex = 0, d$2.test(l$2) || (C$2.lastIndex = 0, C$2.test(l$2) && (p$3.lastIndex = 0, p$3.test(l$2)))) return "";
			h$6 !== !1 && (h$6 = h$6 || g$4, l$2 = h$6.process(l$2));
		}
		return l$2 = R$4(l$2), l$2;
	}
	var r$2 = /</g, f$3 = />/g, a$2 = /"/g, y$2 = /&quot;/g, x$1 = /&#([a-zA-Z0-9]*);?/gim, c$2 = /&colon;?/gim, I$1 = /&newline;?/gim, p$3 = /((j\s*a\s*v\s*a|v\s*b|l\s*i\s*v\s*e)\s*s\s*c\s*r\s*i\s*p\s*t\s*|m\s*o\s*c\s*h\s*a):/gi, d$2 = /e\s*x\s*p\s*r\s*e\s*s\s*s\s*i\s*o\s*n\s*\(.*/gi, C$2 = /u\s*r\s*l\s*\(.*/gi;
	function b$2(o$2) {
		return o$2.replace(a$2, "&quot;");
	}
	function A$2(o$2) {
		return o$2.replace(y$2, "\"");
	}
	function E(o$2) {
		return o$2.replace(x$1, function(l$2, h$6) {
			return h$6[0] === "x" || h$6[0] === "X" ? String.fromCharCode(parseInt(h$6.substr(1), 16)) : String.fromCharCode(parseInt(h$6, 10));
		});
	}
	function L$2(o$2) {
		return o$2.replace(c$2, ":").replace(I$1, " ");
	}
	function F$2(o$2) {
		for (var m$2 = "", l$2 = 0, h$6 = o$2.length; l$2 < h$6; l$2++) m$2 += o$2.charCodeAt(l$2) < 32 ? " " : o$2.charAt(l$2);
		return i$3.trim(m$2);
	}
	function $$1(o$2) {
		return o$2 = A$2(o$2), o$2 = E(o$2), o$2 = L$2(o$2), o$2 = F$2(o$2), o$2;
	}
	function R$4(o$2) {
		return o$2 = b$2(o$2), o$2 = k$2(o$2), o$2;
	}
	function P$2() {
		return "";
	}
	function H$2(o$2, m$2) {
		typeof m$2 != "function" && (m$2 = function() {});
		var l$2 = !Array.isArray(o$2);
		function h$6(_$2) {
			return l$2 ? !0 : i$3.indexOf(o$2, _$2) !== -1;
		}
		var O$3 = [], W$2 = !1;
		return {
			onIgnoreTag: function(_$2, V$2, q) {
				if (h$6(_$2)) if (q.isClosing) {
					var G$2 = "[/removed]", we$1 = q.position + G$2.length;
					return O$3.push([W$2 !== !1 ? W$2 : q.position, we$1]), W$2 = !1, G$2;
				} else return W$2 || (W$2 = q.position), "[removed]";
				else return m$2(_$2, V$2, q);
			},
			remove: function(_$2) {
				var V$2 = "", q = 0;
				return i$3.forEach(O$3, function(G$2) {
					V$2 += _$2.slice(q, G$2[0]), q = G$2[1];
				}), V$2 += _$2.slice(q), V$2;
			}
		};
	}
	function X$1(o$2) {
		for (var m$2 = "", l$2 = 0; l$2 < o$2.length;) {
			var h$6 = o$2.indexOf("<!--", l$2);
			if (h$6 === -1) {
				m$2 += o$2.slice(l$2);
				break;
			}
			m$2 += o$2.slice(l$2, h$6);
			var O$3 = o$2.indexOf("-->", h$6);
			if (O$3 === -1) break;
			l$2 = O$3 + 3;
		}
		return m$2;
	}
	function D$2(o$2) {
		var m$2 = o$2.split("");
		return m$2 = m$2.filter(function(l$2) {
			var h$6 = l$2.charCodeAt(0);
			return h$6 === 127 ? !1 : h$6 <= 31 ? h$6 === 10 || h$6 === 13 : !0;
		}), m$2.join("");
	}
	return w.whiteList = s$2(), w.getDefaultWhiteList = s$2, w.onTag = e$1, w.onIgnoreTag = v$2, w.onTagAttr = u$4, w.onIgnoreTagAttr = T$1, w.safeAttrValue = S$2, w.escapeHtml = k$2, w.escapeQuote = b$2, w.unescapeQuote = A$2, w.escapeHtmlEntities = E, w.escapeDangerHtml5Entities = L$2, w.clearNonPrintableCharacter = F$2, w.friendlyAttrValue = $$1, w.escapeAttrValue = R$4, w.onIgnoreTagStripAll = P$2, w.StripTagBody = H$2, w.stripCommentTag = X$1, w.stripBlankChar = D$2, w.attributeWrapSign = "\"", w.cssFilter = g$4, w.getDefaultCSSWhiteList = n$3, w;
}
var B = {}, ce;
function be() {
	if (ce) return B;
	ce = 1;
	var t$1 = re();
	function n$3(r$2) {
		var f$3 = t$1.spaceIndex(r$2), a$2;
		return f$3 === -1 ? a$2 = r$2.slice(1, -1) : a$2 = r$2.slice(1, f$3 + 1), a$2 = t$1.trim(a$2).toLowerCase(), a$2.slice(0, 1) === "/" && (a$2 = a$2.slice(1)), a$2.slice(-1) === "/" && (a$2 = a$2.slice(0, -1)), a$2;
	}
	function i$3(r$2) {
		return r$2.slice(0, 2) === "</";
	}
	function s$2(r$2, f$3, a$2) {
		var y$2 = "", x$1 = 0, c$2 = !1, I$1 = !1, p$3 = 0, d$2 = r$2.length, C$2 = "", b$2 = "";
		e: for (p$3 = 0; p$3 < d$2; p$3++) {
			var A$2 = r$2.charAt(p$3);
			if (c$2 === !1) {
				if (A$2 === "<") {
					c$2 = p$3;
					continue;
				}
			} else if (I$1 === !1) {
				if (A$2 === "<") {
					y$2 += a$2(r$2.slice(x$1, p$3)), c$2 = p$3, x$1 = p$3;
					continue;
				}
				if (A$2 === ">" || p$3 === d$2 - 1) {
					y$2 += a$2(r$2.slice(x$1, c$2)), b$2 = r$2.slice(c$2, p$3 + 1), C$2 = n$3(b$2), y$2 += f$3(c$2, y$2.length, C$2, b$2, i$3(b$2)), x$1 = p$3 + 1, c$2 = !1;
					continue;
				}
				if (A$2 === "\"" || A$2 === "'") for (var E = 1, L$2 = r$2.charAt(p$3 - E); L$2.trim() === "" || L$2 === "=";) {
					if (L$2 === "=") {
						I$1 = A$2;
						continue e;
					}
					L$2 = r$2.charAt(p$3 - ++E);
				}
			} else if (A$2 === I$1) {
				I$1 = !1;
				continue;
			}
		}
		return x$1 < d$2 && (y$2 += a$2(r$2.substr(x$1))), y$2;
	}
	var g$4 = /[^a-zA-Z0-9\\_:.-]/gim;
	function e$1(r$2, f$3) {
		var a$2 = 0, y$2 = 0, x$1 = [], c$2 = !1, I$1 = r$2.length;
		function p$3(E, L$2) {
			if (E = t$1.trim(E), E = E.replace(g$4, "").toLowerCase(), !(E.length < 1)) {
				var F$2 = f$3(E, L$2 || "");
				F$2 && x$1.push(F$2);
			}
		}
		for (var d$2 = 0; d$2 < I$1; d$2++) {
			var C$2 = r$2.charAt(d$2), b$2, A$2;
			if (c$2 === !1 && C$2 === "=") {
				c$2 = r$2.slice(a$2, d$2), a$2 = d$2 + 1, y$2 = r$2.charAt(a$2) === "\"" || r$2.charAt(a$2) === "'" ? a$2 : u$4(r$2, d$2 + 1);
				continue;
			}
			if (c$2 !== !1 && d$2 === y$2) {
				if (A$2 = r$2.indexOf(C$2, d$2 + 1), A$2 === -1) break;
				b$2 = t$1.trim(r$2.slice(y$2 + 1, A$2)), p$3(c$2, b$2), c$2 = !1, d$2 = A$2, a$2 = d$2 + 1;
				continue;
			}
			if (/\s|\n|\t/.test(C$2)) if (r$2 = r$2.replace(/\s|\n|\t/g, " "), c$2 === !1) if (A$2 = v$2(r$2, d$2), A$2 === -1) {
				b$2 = t$1.trim(r$2.slice(a$2, d$2)), p$3(b$2), c$2 = !1, a$2 = d$2 + 1;
				continue;
			} else {
				d$2 = A$2 - 1;
				continue;
			}
			else if (A$2 = T$1(r$2, d$2 - 1), A$2 === -1) {
				b$2 = t$1.trim(r$2.slice(a$2, d$2)), b$2 = S$2(b$2), p$3(c$2, b$2), c$2 = !1, a$2 = d$2 + 1;
				continue;
			} else continue;
		}
		return a$2 < r$2.length && (c$2 === !1 ? p$3(r$2.slice(a$2)) : p$3(c$2, S$2(t$1.trim(r$2.slice(a$2))))), t$1.trim(x$1.join(" "));
	}
	function v$2(r$2, f$3) {
		for (; f$3 < r$2.length; f$3++) {
			var a$2 = r$2[f$3];
			if (a$2 !== " ") return a$2 === "=" ? f$3 : -1;
		}
	}
	function u$4(r$2, f$3) {
		for (; f$3 < r$2.length; f$3++) {
			var a$2 = r$2[f$3];
			if (a$2 !== " ") return a$2 === "'" || a$2 === "\"" ? f$3 : -1;
		}
	}
	function T$1(r$2, f$3) {
		for (; f$3 > 0; f$3--) {
			var a$2 = r$2[f$3];
			if (a$2 !== " ") return a$2 === "=" ? f$3 : -1;
		}
	}
	function k$2(r$2) {
		return r$2[0] === "\"" && r$2[r$2.length - 1] === "\"" || r$2[0] === "'" && r$2[r$2.length - 1] === "'";
	}
	function S$2(r$2) {
		return k$2(r$2) ? r$2.substr(1, r$2.length - 2) : r$2;
	}
	return B.parseTag = s$2, B.parseAttr = e$1, B;
}
var Y, ge;
function Le() {
	if (ge) return Y;
	ge = 1;
	var t$1 = ee().FilterCSS, n$3 = me(), i$3 = be(), s$2 = i$3.parseTag, g$4 = i$3.parseAttr, e$1 = re();
	function v$2(r$2) {
		return r$2 == null;
	}
	function u$4(r$2) {
		var f$3 = e$1.spaceIndex(r$2);
		if (f$3 === -1) return {
			html: "",
			closing: r$2[r$2.length - 2] === "/"
		};
		r$2 = e$1.trim(r$2.slice(f$3 + 1, -1));
		var a$2 = r$2[r$2.length - 1] === "/";
		return a$2 && (r$2 = e$1.trim(r$2.slice(0, -1))), {
			html: r$2,
			closing: a$2
		};
	}
	function T$1(r$2) {
		var f$3 = {};
		for (var a$2 in r$2) f$3[a$2] = r$2[a$2];
		return f$3;
	}
	function k$2(r$2) {
		var f$3 = {};
		for (var a$2 in r$2) Array.isArray(r$2[a$2]) ? f$3[a$2.toLowerCase()] = r$2[a$2].map(function(y$2) {
			return y$2.toLowerCase();
		}) : f$3[a$2.toLowerCase()] = r$2[a$2];
		return f$3;
	}
	function S$2(r$2) {
		r$2 = T$1(r$2 || {}), r$2.stripIgnoreTag && (r$2.onIgnoreTag && console.error("Notes: cannot use these two options \"stripIgnoreTag\" and \"onIgnoreTag\" at the same time"), r$2.onIgnoreTag = n$3.onIgnoreTagStripAll), r$2.whiteList || r$2.allowList ? r$2.whiteList = k$2(r$2.whiteList || r$2.allowList) : r$2.whiteList = n$3.whiteList, this.attributeWrapSign = r$2.singleQuotedAttributeValue === !0 ? "'" : n$3.attributeWrapSign, r$2.onTag = r$2.onTag || n$3.onTag, r$2.onTagAttr = r$2.onTagAttr || n$3.onTagAttr, r$2.onIgnoreTag = r$2.onIgnoreTag || n$3.onIgnoreTag, r$2.onIgnoreTagAttr = r$2.onIgnoreTagAttr || n$3.onIgnoreTagAttr, r$2.safeAttrValue = r$2.safeAttrValue || n$3.safeAttrValue, r$2.escapeHtml = r$2.escapeHtml || n$3.escapeHtml, this.options = r$2, r$2.css === !1 ? this.cssFilter = !1 : (r$2.css = r$2.css || {}, this.cssFilter = new t$1(r$2.css));
	}
	return S$2.prototype.process = function(r$2) {
		if (r$2 = r$2 || "", r$2 = r$2.toString(), !r$2) return "";
		var f$3 = this, a$2 = f$3.options, y$2 = a$2.whiteList, x$1 = a$2.onTag, c$2 = a$2.onIgnoreTag, I$1 = a$2.onTagAttr, p$3 = a$2.onIgnoreTagAttr, d$2 = a$2.safeAttrValue, C$2 = a$2.escapeHtml, b$2 = f$3.attributeWrapSign, A$2 = f$3.cssFilter;
		a$2.stripBlankChar && (r$2 = n$3.stripBlankChar(r$2)), a$2.allowCommentTag || (r$2 = n$3.stripCommentTag(r$2));
		var E = !1;
		a$2.stripIgnoreTagBody && (E = n$3.StripTagBody(a$2.stripIgnoreTagBody, c$2), c$2 = E.onIgnoreTag);
		var L$2 = s$2(r$2, function(F$2, $$1, R$4, P$2, H$2) {
			var X$1 = {
				sourcePosition: F$2,
				position: $$1,
				isClosing: H$2,
				isWhite: Object.prototype.hasOwnProperty.call(y$2, R$4)
			}, D$2 = x$1(R$4, P$2, X$1);
			if (!v$2(D$2)) return D$2;
			if (X$1.isWhite) {
				if (X$1.isClosing) return "</" + R$4 + ">";
				var o$2 = u$4(P$2), m$2 = y$2[R$4], l$2 = g$4(o$2.html, function(h$6, O$3) {
					var W$2 = e$1.indexOf(m$2, h$6) !== -1, _$2 = I$1(R$4, h$6, O$3, W$2);
					return v$2(_$2) ? W$2 ? (O$3 = d$2(R$4, h$6, O$3, A$2), O$3 ? h$6 + "=" + b$2 + O$3 + b$2 : h$6) : (_$2 = p$3(R$4, h$6, O$3, W$2), v$2(_$2) ? void 0 : _$2) : _$2;
				});
				return P$2 = "<" + R$4, l$2 && (P$2 += " " + l$2), o$2.closing && (P$2 += " /"), P$2 += ">", P$2;
			} else return D$2 = c$2(R$4, P$2, X$1), v$2(D$2) ? C$2(P$2) : D$2;
		}, C$2);
		return E && (L$2 = E.remove(L$2)), L$2;
	}, Y = S$2, Y;
}
var de;
function _e() {
	return de || (de = 1, (function(t$1, n$3) {
		var i$3 = me(), s$2 = be(), g$4 = Le();
		function e$1(u$4, T$1) {
			return new g$4(T$1).process(u$4);
		}
		n$3 = t$1.exports = e$1, n$3.filterXSS = e$1, n$3.FilterXSS = g$4, (function() {
			for (var u$4 in i$3) n$3[u$4] = i$3[u$4];
			for (var T$1 in s$2) n$3[T$1] = s$2[T$1];
		})(), typeof window < "u" && (window.filterXSS = t$1.exports);
		function v$2() {
			return typeof self < "u" && typeof DedicatedWorkerGlobalScope < "u" && self instanceof DedicatedWorkerGlobalScope;
		}
		v$2() && (self.filterXSS = t$1.exports);
	})(z, z.exports)), z.exports;
}
var U = _e();
var Ie = /* @__PURE__ */ Se(U), Re = /* @__PURE__ */ xe({
	__proto__: null,
	default: Ie
}, [U]), pe = {
	img: ["class"],
	input: [
		"class",
		"disabled",
		"type",
		"checked"
	],
	iframe: [
		"class",
		"width",
		"height",
		"src",
		"title",
		"border",
		"frameborder",
		"framespacing",
		"allow",
		"allowfullscreen"
	]
}, Fe = (t$1, n$3) => {
	const { extendedWhiteList: i$3 = {}, xss: s$2 = {} } = n$3;
	let g$4;
	if (typeof s$2 == "function") g$4 = new U.FilterXSS(s$2(Re));
	else {
		const e$1 = U.getDefaultWhiteList();
		[...Object.keys(i$3), ...Object.keys(pe)].forEach((u$4) => {
			const T$1 = e$1[u$4] || [], k$2 = pe[u$4] || [], S$2 = i$3[u$4] || [];
			e$1[u$4] = [.../* @__PURE__ */ new Set([
				...T$1,
				...k$2,
				...S$2
			])];
		}), g$4 = new U.FilterXSS({
			whiteList: e$1,
			...s$2
		});
	}
	t$1.core.ruler.after("linkify", "xss", (e$1) => {
		for (let v$2 = 0; v$2 < e$1.tokens.length; v$2++) {
			const u$4 = e$1.tokens[v$2];
			switch (u$4.type) {
				case "html_block":
					u$4.content = g$4.process(u$4.content);
					break;
				case "inline":
					(u$4.children || []).forEach((k$2) => {
						k$2.type === "html_inline" && (k$2.content = g$4.process(k$2.content));
					});
					break;
			}
		}
	});
}, De = () => {
	Object.keys(M).forEach((t$1) => {
		const n$3 = document.getElementById(M[t$1]);
		n$3 && n$3.remove();
	});
};

//#endregion
export { h as DropdownToolbar, W as MdCatalog, ve as MdEditor, S as MdModal, ae as MdPreview, o as ModalToolbar, Q as NormalFooterToolbar, n as NormalToolbar, p as StrIcon, Fe as XSSPlugin, b as allFooter, k as allToolbar, De as clearSideEffects, j as config, y as editorExtensionsAttrs, a as en_US, p$1 as prefix, s as zh_CN };
//# sourceMappingURL=md-editor-v3.js.map