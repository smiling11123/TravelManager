import { __commonJS, __export, __toESM } from "./chunk-DbKvDyjX.js";
import { __assign, __awaiter, __extends, __generator, __read, __rest, __spreadArray, __spreadArrays, __values, add, angle, color as color$1, distance as distance$6, dot as dot$2, exactEquals, length, max as max$1, min as min$1, normalize, rgb, scale as scale$3, sub, subtract, transformMat3 as transformMat3$1, transformMat3$1 as transformMat3 } from "./tslib.es6-D1XDhKGm.js";
import { isArray_default } from "./uniqueId-C2seAQqT.js";
import "./lodash-Bxm8jLSF.js";

//#region node_modules/gl-matrix/esm/mat3.js
/**
* Inverts a mat3
*
* @param {mat3} out the receiving matrix
* @param {ReadonlyMat3} a the source matrix
* @returns {mat3 | null} out, or null if source matrix is not invertible
*/
function invert$1(out, a) {
	var a00 = a[0], a01 = a[1], a02 = a[2];
	var a10 = a[3], a11 = a[4], a12 = a[5];
	var a20 = a[6], a21 = a[7], a22 = a[8];
	var b01 = a22 * a11 - a12 * a21;
	var b11 = -a22 * a10 + a12 * a20;
	var b21 = a21 * a10 - a11 * a20;
	var det = a00 * b01 + a01 * b11 + a02 * b21;
	if (!det) return null;
	det = 1 / det;
	out[0] = b01 * det;
	out[1] = (-a22 * a01 + a02 * a21) * det;
	out[2] = (a12 * a01 - a02 * a11) * det;
	out[3] = b11 * det;
	out[4] = (a22 * a00 - a02 * a20) * det;
	out[5] = (-a12 * a00 + a02 * a10) * det;
	out[6] = b21 * det;
	out[7] = (-a21 * a00 + a01 * a20) * det;
	out[8] = (a11 * a00 - a01 * a10) * det;
	return out;
}
/**
* Multiplies two mat3's
*
* @param {mat3} out the receiving matrix
* @param {ReadonlyMat3} a the first operand
* @param {ReadonlyMat3} b the second operand
* @returns {mat3} out
*/
function multiply(out, a, b) {
	var a00 = a[0], a01 = a[1], a02 = a[2];
	var a10 = a[3], a11 = a[4], a12 = a[5];
	var a20 = a[6], a21 = a[7], a22 = a[8];
	var b00 = b[0], b01 = b[1], b02 = b[2];
	var b10 = b[3], b11 = b[4], b12 = b[5];
	var b20 = b[6], b21 = b[7], b22 = b[8];
	out[0] = b00 * a00 + b01 * a10 + b02 * a20;
	out[1] = b00 * a01 + b01 * a11 + b02 * a21;
	out[2] = b00 * a02 + b01 * a12 + b02 * a22;
	out[3] = b10 * a00 + b11 * a10 + b12 * a20;
	out[4] = b10 * a01 + b11 * a11 + b12 * a21;
	out[5] = b10 * a02 + b11 * a12 + b12 * a22;
	out[6] = b20 * a00 + b21 * a10 + b22 * a20;
	out[7] = b20 * a01 + b21 * a11 + b22 * a21;
	out[8] = b20 * a02 + b21 * a12 + b22 * a22;
	return out;
}
/**
* Creates a matrix from a vector translation
* This is equivalent to (but much faster than):
*
*     mat3.identity(dest);
*     mat3.translate(dest, dest, vec);
*
* @param {mat3} out mat3 receiving operation result
* @param {ReadonlyVec2} v Translation vector
* @returns {mat3} out
*/
function fromTranslation(out, v) {
	out[0] = 1;
	out[1] = 0;
	out[2] = 0;
	out[3] = 0;
	out[4] = 1;
	out[5] = 0;
	out[6] = v[0];
	out[7] = v[1];
	out[8] = 1;
	return out;
}
/**
* Creates a matrix from a given angle
* This is equivalent to (but much faster than):
*
*     mat3.identity(dest);
*     mat3.rotate(dest, dest, rad);
*
* @param {mat3} out mat3 receiving operation result
* @param {Number} rad the angle to rotate the matrix by
* @returns {mat3} out
*/
function fromRotation(out, rad) {
	var s = Math.sin(rad), c = Math.cos(rad);
	out[0] = c;
	out[1] = s;
	out[2] = 0;
	out[3] = -s;
	out[4] = c;
	out[5] = 0;
	out[6] = 0;
	out[7] = 0;
	out[8] = 1;
	return out;
}
/**
* Creates a matrix from a vector scaling
* This is equivalent to (but much faster than):
*
*     mat3.identity(dest);
*     mat3.scale(dest, dest, vec);
*
* @param {mat3} out mat3 receiving operation result
* @param {ReadonlyVec2} v Scaling vector
* @returns {mat3} out
*/
function fromScaling(out, v) {
	out[0] = v[0];
	out[1] = 0;
	out[2] = 0;
	out[3] = 0;
	out[4] = v[1];
	out[5] = 0;
	out[6] = 0;
	out[7] = 0;
	out[8] = 1;
	return out;
}

//#endregion
//#region node_modules/@antv/util/esm/is-array-like.js
var isArrayLike = function(value$1) {
	/**
	* isArrayLike([1, 2, 3]) => true
	* isArrayLike(document.body.children) => true
	* isArrayLike('abc') => true
	* isArrayLike(Function) => false
	*/
	return value$1 !== null && typeof value$1 !== "function" && isFinite(value$1.length);
};
var is_array_like_default = isArrayLike;

//#endregion
//#region node_modules/@antv/util/esm/contains.js
var contains = function(arr, value$1) {
	if (!is_array_like_default(arr)) return false;
	return arr.indexOf(value$1) > -1;
};
var contains_default = contains;

//#endregion
//#region node_modules/@antv/util/esm/filter.js
var filter = function(arr, func) {
	if (!is_array_like_default(arr)) return arr;
	var result = [];
	for (var index = 0; index < arr.length; index++) {
		var value$1 = arr[index];
		if (func(value$1, index)) result.push(value$1);
	}
	return result;
};
var filter_default = filter;

//#endregion
//#region node_modules/@antv/util/esm/difference.js
/**
* Flattens `array` a single level deep.
*
* @param {Array} arr The array to inspect.
* @param {Array} values The values to exclude.
* @return {Array} Returns the new array of filtered values.
* @example
* difference([2, 1], [2, 3]);  // => [1]
*/
var difference = function(arr, values$1) {
	if (values$1 === void 0) values$1 = [];
	return filter_default(arr, function(value$1) {
		return !contains_default(values$1, value$1);
	});
};
var difference_default = difference;

//#endregion
//#region node_modules/@antv/util/esm/is-type.js
var toString$2 = {}.toString;
var isType$1 = function(value$1, type) {
	return toString$2.call(value$1) === "[object " + type + "]";
};
var is_type_default = isType$1;

//#endregion
//#region node_modules/@antv/util/esm/is-function.js
var is_function_default = (function(value$1) {
	return is_type_default(value$1, "Function");
});

//#endregion
//#region node_modules/@antv/util/esm/is-nil.js
var isNil = function(value$1) {
	/**
	* isNil(null) => true
	* isNil() => true
	*/
	return value$1 === null || value$1 === void 0;
};
var is_nil_default = isNil;

//#endregion
//#region node_modules/@antv/util/esm/is-array.js
var is_array_default = (function(value$1) {
	return Array.isArray ? Array.isArray(value$1) : is_type_default(value$1, "Array");
});

//#endregion
//#region node_modules/@antv/util/esm/is-object.js
var is_object_default = (function(value$1) {
	/**
	* isObject({}) => true
	* isObject([1, 2, 3]) => true
	* isObject(Function) => true
	* isObject(null) => false
	*/
	var type = typeof value$1;
	return value$1 !== null && type === "object" || type === "function";
});

//#endregion
//#region node_modules/@antv/util/esm/each.js
function each$1(elements, func) {
	if (!elements) return;
	var rst;
	if (is_array_default(elements)) for (var i = 0, len = elements.length; i < len; i++) {
		rst = func(elements[i], i);
		if (rst === false) break;
	}
	else if (is_object_default(elements)) {
		for (var k in elements) if (elements.hasOwnProperty(k)) {
			rst = func(elements[k], k);
			if (rst === false) break;
		}
	}
}
var each_default = each$1;

//#endregion
//#region node_modules/@antv/util/esm/keys.js
var keys = Object.keys ? function(obj) {
	return Object.keys(obj);
} : function(obj) {
	var result = [];
	each_default(obj, function(value$1, key) {
		if (!(is_function_default(obj) && key === "prototype")) result.push(key);
	});
	return result;
};
var keys_default = keys;

//#endregion
//#region node_modules/@antv/util/esm/is-match.js
function isMatch(obj, attrs) {
	var _keys = keys_default(attrs);
	var length$1 = _keys.length;
	if (is_nil_default(obj)) return !length$1;
	for (var i = 0; i < length$1; i += 1) {
		var key = _keys[i];
		if (attrs[key] !== obj[key] || !(key in obj)) return false;
	}
	return true;
}
var is_match_default = isMatch;

//#endregion
//#region node_modules/@antv/util/esm/is-object-like.js
var isObjectLike$1 = function(value$1) {
	/**
	* isObjectLike({}) => true
	* isObjectLike([1, 2, 3]) => true
	* isObjectLike(Function) => false
	* isObjectLike(null) => false
	*/
	return typeof value$1 === "object" && value$1 !== null;
};
var is_object_like_default = isObjectLike$1;

//#endregion
//#region node_modules/@antv/util/esm/is-plain-object.js
var isPlainObject$1 = function(value$1) {
	/**
	* isObjectLike(new Foo) => false
	* isObjectLike([1, 2, 3]) => false
	* isObjectLike({ x: 0, y: 0 }) => true
	* isObjectLike(Object.create(null)) => true
	*/
	if (!is_object_like_default(value$1) || !is_type_default(value$1, "Object")) return false;
	if (Object.getPrototypeOf(value$1) === null) return true;
	var proto = value$1;
	while (Object.getPrototypeOf(proto) !== null) proto = Object.getPrototypeOf(proto);
	return Object.getPrototypeOf(value$1) === proto;
};
var is_plain_object_default = isPlainObject$1;

//#endregion
//#region node_modules/@antv/util/esm/find.js
function find$1(arr, predicate) {
	if (!is_array_default(arr)) return null;
	var _predicate;
	if (is_function_default(predicate)) _predicate = predicate;
	if (is_plain_object_default(predicate)) _predicate = function(a) {
		return is_match_default(a, predicate);
	};
	if (_predicate) {
		for (var i = 0; i < arr.length; i += 1) if (_predicate(arr[i])) return arr[i];
	}
	return null;
}
var find_default = find$1;

//#endregion
//#region node_modules/@antv/util/esm/find-index.js
function findIndex(arr, predicate, fromIndex) {
	if (fromIndex === void 0) fromIndex = 0;
	for (var i = fromIndex; i < arr.length; i++) if (predicate(arr[i], i)) return i;
	return -1;
}
var find_index_default = findIndex;

//#endregion
//#region node_modules/@antv/util/esm/first-value.js
var firstValue = function(data$2, name) {
	var rst = null;
	for (var i = 0; i < data$2.length; i++) {
		var value$1 = data$2[i][name];
		if (!is_nil_default(value$1)) {
			if (is_array_default(value$1)) rst = value$1[0];
			else rst = value$1;
			break;
		}
	}
	return rst;
};
var first_value_default = firstValue;

//#endregion
//#region node_modules/@antv/util/esm/flatten.js
/**
* Flattens `array` a single level deep.
*
* @param {Array} arr The array to flatten.
* @return {Array} Returns the new flattened array.
* @example
*
* flatten([1, [2, [3, [4]], 5]]);  // => [1, 2, [3, [4]], 5]
*/
var flatten = function(arr) {
	if (!is_array_default(arr)) return [];
	var rst = [];
	for (var i = 0; i < arr.length; i++) rst = rst.concat(arr[i]);
	return rst;
};
var flatten_default = flatten;

//#endregion
//#region node_modules/@antv/util/esm/max.js
/**
* @param {Array} arr The array to iterate over.
* @return {*} Returns the maximum value.
* @example
*
* max([1, 2]);
* // => 2
*
* max([]);
* // => undefined
*
* const data = new Array(1250010).fill(1).map((d,idx) => idx);
*
* max(data);
* // => 1250010
* // Math.max(...data) will encounter "Maximum call stack size exceeded" error
*/
var max_default = (function(arr) {
	if (!is_array_default(arr)) return;
	return arr.reduce(function(prev, curr) {
		return Math.max(prev, curr);
	}, arr[0]);
});

//#endregion
//#region node_modules/@antv/util/esm/min.js
/**
* @param {Array} arr The array to iterate over.
* @return {*} Returns the minimum value.
* @example
*
* min([1, 2]);
* // => 1
*
* min([]);
* // => undefined
*
* const data = new Array(1250010).fill(1).map((d,idx) => idx);
*
* min(data);
* // => 1250010
* // Math.min(...data) will encounter "Maximum call stack size exceeded" error
*/
var min_default = (function(arr) {
	if (!is_array_default(arr)) return;
	return arr.reduce(function(prev, curr) {
		return Math.min(prev, curr);
	}, arr[0]);
});

//#endregion
//#region node_modules/@antv/util/esm/get-range.js
var getRange = function(values$1) {
	var filterValues = values$1.filter(function(v) {
		return !isNaN(v);
	});
	if (!filterValues.length) return {
		min: 0,
		max: 0
	};
	if (is_array_default(values$1[0])) {
		var tmp = [];
		for (var i = 0; i < values$1.length; i++) tmp = tmp.concat(values$1[i]);
		filterValues = tmp;
	}
	var max$2 = max_default(filterValues);
	return {
		min: min_default(filterValues),
		max: max$2
	};
};
var get_range_default = getRange;

//#endregion
//#region node_modules/@antv/util/esm/pull.js
var arrPrototype = Array.prototype;
var splice$1 = arrPrototype.splice;
var indexOf$1 = arrPrototype.indexOf;

//#endregion
//#region node_modules/@antv/util/esm/pull-at.js
var splice = Array.prototype.splice;
var pullAt = function pullAt$1(arr, indexes) {
	if (!is_array_like_default(arr)) return [];
	var length$1 = arr ? indexes.length : 0;
	var last$1 = length$1 - 1;
	while (length$1--) {
		var previous = void 0;
		var index = indexes[length$1];
		if (length$1 === last$1 || index !== previous) {
			previous = index;
			splice.call(arr, index, 1);
		}
	}
	return arr;
};
var pull_at_default = pullAt;

//#endregion
//#region node_modules/@antv/util/esm/reduce.js
var reduce = function(arr, fn, init) {
	if (!is_array_default(arr) && !is_plain_object_default(arr)) return arr;
	var result = init;
	each_default(arr, function(data$2, i) {
		result = fn(result, data$2, i);
	});
	return result;
};
var reduce_default = reduce;

//#endregion
//#region node_modules/@antv/util/esm/remove.js
var remove = function(arr, predicate) {
	/**
	* const arr = [1, 2, 3, 4]
	* const evens = remove(arr, n => n % 2 == 0)
	* console.log(arr) // => [1, 3]
	* console.log(evens) // => [2, 4]
	*/
	var result = [];
	if (!is_array_like_default(arr)) return result;
	var i = -1;
	var indexes = [];
	var length$1 = arr.length;
	while (++i < length$1) {
		var value$1 = arr[i];
		if (predicate(value$1, i, arr)) {
			result.push(value$1);
			indexes.push(i);
		}
	}
	pull_at_default(arr, indexes);
	return result;
};
var remove_default = remove;

//#endregion
//#region node_modules/@antv/util/esm/is-string.js
var is_string_default = (function(str) {
	return is_type_default(str, "String");
});

//#endregion
//#region node_modules/@antv/util/esm/sort-by.js
function sortBy(arr, key) {
	var comparer;
	if (is_function_default(key)) comparer = function(a, b) {
		return key(a) - key(b);
	};
	else {
		var keys_1 = [];
		if (is_string_default(key)) keys_1.push(key);
		else if (is_array_default(key)) keys_1 = key;
		comparer = function(a, b) {
			for (var i = 0; i < keys_1.length; i += 1) {
				var prop = keys_1[i];
				if (a[prop] > b[prop]) return 1;
				if (a[prop] < b[prop]) return -1;
			}
			return 0;
		};
	}
	arr.sort(comparer);
	return arr;
}
var sort_by_default = sortBy;

//#endregion
//#region node_modules/@antv/util/esm/uniq.js
function uniq(arr, cache$2) {
	if (cache$2 === void 0) cache$2 = /* @__PURE__ */ new Map();
	var r = [];
	if (Array.isArray(arr)) for (var i = 0, len = arr.length; i < len; i++) {
		var item = arr[i];
		if (!cache$2.has(item)) {
			r.push(item);
			cache$2.set(item, true);
		}
	}
	return r;
}

//#endregion
//#region node_modules/@antv/util/esm/values-of-key.js
var values_of_key_default = (function(data$2, name) {
	var rst = [];
	var tmpMap = {};
	for (var i = 0; i < data$2.length; i++) {
		var value$1 = data$2[i][name];
		if (!is_nil_default(value$1)) {
			if (!is_array_default(value$1)) value$1 = [value$1];
			for (var j = 0; j < value$1.length; j++) {
				var val = value$1[j];
				if (!tmpMap[val]) {
					rst.push(val);
					tmpMap[val] = true;
				}
			}
		}
	}
	return rst;
});

//#endregion
//#region node_modules/@antv/util/esm/head.js
function head(o) {
	if (is_array_like_default(o)) return o[0];
}

//#endregion
//#region node_modules/@antv/util/esm/last.js
function last(o) {
	if (is_array_like_default(o)) {
		var arr = o;
		return arr[arr.length - 1];
	}
}

//#endregion
//#region node_modules/@antv/util/esm/every.js
/**
* 只要有一个不满足条件就返回 false
* @param arr
* @param func
*/
var every = function(arr, func) {
	for (var i = 0; i < arr.length; i++) if (!func(arr[i], i)) return false;
	return true;
};
var every_default = every;

//#endregion
//#region node_modules/@antv/util/esm/some.js
/**
* 只要有一个满足条件就返回 true
* @param arr
* @param func
*/
var some = function(arr, func) {
	for (var i = 0; i < arr.length; i++) if (func(arr[i], i)) return true;
	return false;
};
var some_default = some;

//#endregion
//#region node_modules/@antv/util/esm/group-by.js
var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function groupBy(data$2, condition) {
	if (!condition || !is_array_default(data$2)) return {};
	var result = {};
	var predicate = is_function_default(condition) ? condition : function(item$1) {
		return item$1[condition];
	};
	var key;
	for (var i = 0; i < data$2.length; i++) {
		var item = data$2[i];
		key = predicate(item);
		if (hasOwnProperty$2.call(result, key)) result[key].push(item);
		else result[key] = [item];
	}
	return result;
}
var group_by_default = groupBy;

//#endregion
//#region node_modules/@antv/util/esm/group-to-map.js
/**
* 将数据分组成 map
* @param data
* @param condition
*/
function groupToMap(data$2, condition) {
	if (!condition) return { 0: data$2 };
	if (!is_function_default(condition)) {
		var paramscondition_1 = is_array_default(condition) ? condition : condition.replace(/\s+/g, "").split("*");
		condition = function(row) {
			var unique = "_";
			for (var i = 0, l = paramscondition_1.length; i < l; i++) unique += row[paramscondition_1[i]] && row[paramscondition_1[i]].toString();
			return unique;
		};
	}
	return group_by_default(data$2, condition);
}

//#endregion
//#region node_modules/@antv/util/esm/group.js
var group_default$3 = (function(data$2, condition) {
	if (!condition) return [data$2];
	var groups = groupToMap(data$2, condition);
	var array = [];
	for (var i in groups) array.push(groups[i]);
	return array;
});

//#endregion
//#region node_modules/@antv/util/esm/clamp.js
var clamp = function(a, min$2, max$2) {
	if (a < min$2) return min$2;
	else if (a > max$2) return max$2;
	return a;
};
var clamp_default = clamp;

//#endregion
//#region node_modules/@antv/util/esm/fixed-base.js
var fixedBase = function(v, base) {
	var str = base.toString();
	var index = str.indexOf(".");
	if (index === -1) return Math.round(v);
	var length$1 = str.substr(index + 1).length;
	if (length$1 > 20) length$1 = 20;
	return parseFloat(v.toFixed(length$1));
};
var fixed_base_default = fixedBase;

//#endregion
//#region node_modules/@antv/util/esm/is-number.js
var isNumber$1 = function(value$1) {
	return is_type_default(value$1, "Number");
};
var is_number_default = isNumber$1;

//#endregion
//#region node_modules/@antv/util/esm/is-integer.js
var isInteger = Number.isInteger ? Number.isInteger : function(num) {
	return is_number_default(num) && num % 1 === 0;
};

//#endregion
//#region node_modules/@antv/util/esm/is-number-equal.js
var PRECISION = 1e-5;
function isNumberEqual(a, b, precision) {
	if (precision === void 0) precision = PRECISION;
	return Math.abs(a - b) < precision;
}

//#endregion
//#region node_modules/@antv/util/esm/max-by.js
/**
* @param {Array} arr The array to iterate over.
* @param {Function} [fn] The iteratee invoked per element.
* @return {*} Returns the maximum value.
* @example
*
* var objects = [{ 'n': 1 }, { 'n': 2 }];
*
* maxBy(objects, function(o) { return o.n; });
* // => { 'n': 2 }
*
* maxBy(objects, 'n');
* // => { 'n': 2 }
*/
var max_by_default = (function(arr, fn) {
	if (!is_array_default(arr)) return;
	var maxItem;
	var max$2 = -Infinity;
	for (var i = 0; i < arr.length; i++) {
		var item = arr[i];
		var v = is_function_default(fn) ? fn(item) : item[fn];
		if (v > max$2) {
			maxItem = item;
			max$2 = v;
		}
	}
	return maxItem;
});

//#endregion
//#region node_modules/@antv/util/esm/min-by.js
/**
* @param {Array} arr The array to iterate over.
* @param {Function} [fn] The iteratee invoked per element.
* @return {*} Returns the minimum value.
* @example
*
* var objects = [{ 'n': 1 }, { 'n': 2 }];
*
* minBy(objects, function(o) { return o.n; });
* // => { 'n': 1 }
*
* minBy(objects, 'n');
* // => { 'n': 1 }
*/
var min_by_default = (function(arr, fn) {
	if (!is_array_default(arr)) return;
	var minItem;
	var min$2 = Infinity;
	for (var i = 0; i < arr.length; i++) {
		var item = arr[i];
		var v = is_function_default(fn) ? fn(item) : item[fn];
		if (v < min$2) {
			minItem = item;
			min$2 = v;
		}
	}
	return minItem;
});

//#endregion
//#region node_modules/@antv/util/esm/mod.js
var mod$1 = function(n, m) {
	return (n % m + m) % m;
};
var esm_default$2 = mod$1;

//#endregion
//#region node_modules/@antv/util/esm/to-degree.js
var DEGREE = 180 / Math.PI;

//#endregion
//#region node_modules/@antv/util/esm/to-radian.js
var RADIAN = Math.PI / 180;
var toRadian = function(degree) {
	return RADIAN * degree;
};
var to_radian_default = toRadian;

//#endregion
//#region node_modules/@antv/util/esm/for-in.js
var for_in_default = each_default;

//#endregion
//#region node_modules/@antv/util/esm/has.js
var has_default = (function(obj, key) {
	return obj.hasOwnProperty(key);
});

//#endregion
//#region node_modules/@antv/util/esm/has-key.js
var has_key_default = has_default;

//#endregion
//#region node_modules/@antv/util/esm/values.js
var values = Object.values ? function(obj) {
	return Object.values(obj);
} : function(obj) {
	var result = [];
	each_default(obj, function(value$1, key) {
		if (!(is_function_default(obj) && key === "prototype")) result.push(value$1);
	});
	return result;
};
var values_default = values;

//#endregion
//#region node_modules/@antv/util/esm/to-string.js
var to_string_default = (function(value$1) {
	if (is_nil_default(value$1)) return "";
	return value$1.toString();
});

//#endregion
//#region node_modules/@antv/util/esm/lower-case.js
var lowerCase = function(str) {
	return to_string_default(str).toLowerCase();
};
var lower_case_default = lowerCase;

//#endregion
//#region node_modules/@antv/util/esm/substitute.js
function substitute(str, o) {
	if (!str || !o) return str;
	return str.replace(/\\?\{([^{}]+)\}/g, function(match, name) {
		if (match.charAt(0) === "\\") return match.slice(1);
		return o[name] === void 0 ? "" : o[name];
	});
}
var substitute_default = substitute;

//#endregion
//#region node_modules/@antv/util/esm/upper-first.js
var upperFirst = function(value$1) {
	var str = to_string_default(value$1);
	return str.charAt(0).toUpperCase() + str.substring(1);
};
var upper_first_default = upperFirst;

//#endregion
//#region node_modules/@antv/util/esm/get-type.js
var toString$1 = {}.toString;
var getType = function(value$1) {
	return toString$1.call(value$1).replace(/^\[object /, "").replace(/]$/, "");
};
var get_type_default = getType;

//#endregion
//#region node_modules/@antv/util/esm/is-boolean.js
var isBoolean = function(value$1) {
	return is_type_default(value$1, "Boolean");
};
var is_boolean_default = isBoolean;

//#endregion
//#region node_modules/@antv/util/esm/is-date.js
var isDate = function(value$1) {
	return is_type_default(value$1, "Date");
};
var is_date_default = isDate;

//#endregion
//#region node_modules/@antv/util/esm/is-null.js
var isNull = function(value$1) {
	return value$1 === null;
};
var is_null_default = isNull;

//#endregion
//#region node_modules/@antv/util/esm/is-prototype.js
var objectProto = Object.prototype;
var isPrototype = function(value$1) {
	var Ctor = value$1 && value$1.constructor;
	var proto = typeof Ctor === "function" && Ctor.prototype || objectProto;
	return value$1 === proto;
};
var is_prototype_default = isPrototype;

//#endregion
//#region node_modules/@antv/util/esm/is-undefined.js
var isUndefined = function(value$1) {
	return value$1 === void 0;
};
var is_undefined_default = isUndefined;

//#endregion
//#region node_modules/@antv/util/esm/is-element.js
/**
* 判断是否HTML元素
* @return {Boolean} 是否HTML元素
*/
var isElement = function(o) {
	return o instanceof Element || o instanceof HTMLDocument;
};
var is_element_default = isElement;

//#endregion
//#region node_modules/@antv/util/esm/request-animation-frame.js
function requestAnimationFrame(fn) {
	return (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function(f) {
		return setTimeout(f, 16);
	})(fn);
}

//#endregion
//#region node_modules/@antv/util/esm/clear-animation-frame.js
function cancelAnimationFrame(handler) {
	(window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame || clearTimeout)(handler);
}

//#endregion
//#region node_modules/@antv/util/esm/mix.js
function _mix(dist, obj) {
	for (var key in obj) if (obj.hasOwnProperty(key) && key !== "constructor" && obj[key] !== void 0) dist[key] = obj[key];
}
function mix(dist, src1, src2, src3) {
	if (src1) _mix(dist, src1);
	if (src2) _mix(dist, src2);
	if (src3) _mix(dist, src3);
	return dist;
}

//#endregion
//#region node_modules/@antv/util/esm/clone.js
var clone = function(obj) {
	if (typeof obj !== "object" || obj === null) return obj;
	var rst;
	if (is_array_default(obj)) {
		rst = [];
		for (var i = 0, l = obj.length; i < l; i++) if (typeof obj[i] === "object" && obj[i] != null) rst[i] = clone(obj[i]);
		else rst[i] = obj[i];
	} else {
		rst = {};
		for (var k in obj) if (typeof obj[k] === "object" && obj[k] != null) rst[k] = clone(obj[k]);
		else rst[k] = obj[k];
	}
	return rst;
};
var clone_default = clone;

//#endregion
//#region node_modules/@antv/util/esm/debounce.js
function debounce(func, wait, immediate) {
	var timeout$1;
	return function() {
		var context = this, args = arguments;
		var later = function() {
			timeout$1 = null;
			if (!immediate) func.apply(context, args);
		};
		var callNow = immediate && !timeout$1;
		clearTimeout(timeout$1);
		timeout$1 = setTimeout(later, wait);
		if (callNow) func.apply(context, args);
	};
}
var debounce_default = debounce;

//#endregion
//#region node_modules/@antv/util/esm/memoize.js
/**
* _.memoize(calColor);
* _.memoize(calColor, (...args) => args[0]);
* @param f
* @param resolver
*/
var memoize_default = (function(f, resolver) {
	if (!is_function_default(f)) throw new TypeError("Expected a function");
	var memoized = function() {
		var args = [];
		for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
		var key = resolver ? resolver.apply(this, args) : args[0];
		var cache$2 = memoized.cache;
		if (cache$2.has(key)) return cache$2.get(key);
		var result = f.apply(this, args);
		cache$2.set(key, result);
		return result;
	};
	memoized.cache = /* @__PURE__ */ new Map();
	return memoized;
});

//#endregion
//#region node_modules/@antv/util/esm/deep-mix.js
var MAX_MIX_LEVEL$1 = 5;
function _deepMix(dist, src, level, maxLevel) {
	level = level || 0;
	maxLevel = maxLevel || MAX_MIX_LEVEL$1;
	for (var key in src) if (src.hasOwnProperty(key)) {
		var value$1 = src[key];
		if (value$1 !== null && is_plain_object_default(value$1)) {
			if (!is_plain_object_default(dist[key])) dist[key] = {};
			if (level < maxLevel) _deepMix(dist[key], value$1, level + 1, maxLevel);
			else dist[key] = src[key];
		} else if (is_array_default(value$1)) {
			dist[key] = [];
			dist[key] = dist[key].concat(value$1);
		} else if (value$1 !== void 0) dist[key] = value$1;
	}
}
var deepMix = function(rst) {
	var args = [];
	for (var _i = 1; _i < arguments.length; _i++) args[_i - 1] = arguments[_i];
	for (var i = 0; i < args.length; i += 1) _deepMix(rst, args[i]);
	return rst;
};
var deep_mix_default = deepMix;

//#endregion
//#region node_modules/@antv/util/esm/index-of.js
var indexOf = function(arr, obj) {
	if (!is_array_like_default(arr)) return -1;
	var m = Array.prototype.indexOf;
	if (m) return m.call(arr, obj);
	var index = -1;
	for (var i = 0; i < arr.length; i++) if (arr[i] === obj) {
		index = i;
		break;
	}
	return index;
};
var index_of_default = indexOf;

//#endregion
//#region node_modules/@antv/util/esm/is-empty.js
var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
function isEmpty(value$1) {
	/**
	* isEmpty(null) => true
	* isEmpty() => true
	* isEmpty(true) => true
	* isEmpty(1) => true
	* isEmpty([1, 2, 3]) => false
	* isEmpty('abc') => false
	* isEmpty({ a: 1 }) => false
	*/
	if (is_nil_default(value$1)) return true;
	if (is_array_like_default(value$1)) return !value$1.length;
	var type = get_type_default(value$1);
	if (type === "Map" || type === "Set") return !value$1.size;
	if (is_prototype_default(value$1)) return !Object.keys(value$1).length;
	for (var key in value$1) if (hasOwnProperty$1.call(value$1, key)) return false;
	return true;
}
var is_empty_default = isEmpty;

//#endregion
//#region node_modules/@antv/util/esm/is-equal.js
var isEqual$1 = function(value$1, other$1) {
	if (value$1 === other$1) return true;
	if (!value$1 || !other$1) return false;
	if (is_string_default(value$1) || is_string_default(other$1)) return false;
	if (is_array_like_default(value$1) || is_array_like_default(other$1)) {
		if (value$1.length !== other$1.length) return false;
		var rst = true;
		for (var i = 0; i < value$1.length; i++) {
			rst = isEqual$1(value$1[i], other$1[i]);
			if (!rst) break;
		}
		return rst;
	}
	if (is_object_like_default(value$1) || is_object_like_default(other$1)) {
		var valueKeys = Object.keys(value$1);
		var otherKeys = Object.keys(other$1);
		if (valueKeys.length !== otherKeys.length) return false;
		var rst = true;
		for (var i = 0; i < valueKeys.length; i++) {
			rst = isEqual$1(value$1[valueKeys[i]], other$1[valueKeys[i]]);
			if (!rst) break;
		}
		return rst;
	}
	return false;
};
var is_equal_default = isEqual$1;

//#endregion
//#region node_modules/@antv/util/esm/map.js
var map$2 = function(arr, func) {
	if (!is_array_like_default(arr)) return arr;
	var result = [];
	for (var index = 0; index < arr.length; index++) {
		var value$1 = arr[index];
		result.push(func(value$1, index));
	}
	return result;
};
var map_default = map$2;

//#endregion
//#region node_modules/@antv/util/esm/map-values.js
var identity = function(v) {
	return v;
};
var map_values_default = (function(object, func) {
	if (func === void 0) func = identity;
	var r = {};
	if (is_object_default(object) && !is_nil_default(object)) Object.keys(object).forEach(function(key) {
		r[key] = func(object[key], key);
	});
	return r;
});

//#endregion
//#region node_modules/@antv/util/esm/get.js
/**
* https://github.com/developit/dlv/blob/master/index.js
* @param obj
* @param key
* @param defaultValue
*/
var get_default = (function(obj, key, defaultValue) {
	var p = 0;
	var keyArr = is_string_default(key) ? key.split(".") : key;
	while (obj && p < keyArr.length) obj = obj[keyArr[p++]];
	return obj === void 0 || p < keyArr.length ? defaultValue : obj;
});

//#endregion
//#region node_modules/@antv/util/esm/set.js
/**
* https://github.com/developit/dlv/blob/master/index.js
* @param obj
* @param path
* @param value
*/
var set_default = (function(obj, path, value$1) {
	var o = obj;
	var keyArr = is_string_default(path) ? path.split(".") : path;
	keyArr.forEach(function(key, idx) {
		if (idx < keyArr.length - 1) {
			if (!is_object_default(o[key])) o[key] = is_number_default(keyArr[idx + 1]) ? [] : {};
			o = o[key];
		} else o[key] = value$1;
	});
	return obj;
});

//#endregion
//#region node_modules/@antv/util/esm/pick.js
var hasOwnProperty = Object.prototype.hasOwnProperty;
var pick_default = (function(object, keys$1) {
	if (object === null || !is_plain_object_default(object)) return {};
	var result = {};
	each_default(keys$1, function(key) {
		if (hasOwnProperty.call(object, key)) result[key] = object[key];
	});
	return result;
});

//#endregion
//#region node_modules/@antv/util/esm/omit.js
var omit_default = (function(obj, keys$1) {
	return reduce_default(obj, function(r, curr, key) {
		if (!keys$1.includes(key)) r[key] = curr;
		return r;
	}, {});
});

//#endregion
//#region node_modules/@antv/util/esm/throttle.js
var throttle_default = (function(func, wait, options) {
	var timeout$1, context, args, result;
	var previous = 0;
	if (!options) options = {};
	var later = function() {
		previous = options.leading === false ? 0 : Date.now();
		timeout$1 = null;
		result = func.apply(context, args);
		if (!timeout$1) context = args = null;
	};
	var throttled = function() {
		var now$1 = Date.now();
		if (!previous && options.leading === false) previous = now$1;
		var remaining = wait - (now$1 - previous);
		context = this;
		args = arguments;
		if (remaining <= 0 || remaining > wait) {
			if (timeout$1) {
				clearTimeout(timeout$1);
				timeout$1 = null;
			}
			previous = now$1;
			result = func.apply(context, args);
			if (!timeout$1) context = args = null;
		} else if (!timeout$1 && options.trailing !== false) timeout$1 = setTimeout(later, remaining);
		return result;
	};
	throttled.cancel = function() {
		clearTimeout(timeout$1);
		previous = 0;
		timeout$1 = context = args = null;
	};
	return throttled;
});

//#endregion
//#region node_modules/@antv/util/esm/to-array.js
var to_array_default = (function(value$1) {
	return is_array_like_default(value$1) ? Array.prototype.slice.call(value$1) : [];
});

//#endregion
//#region node_modules/@antv/util/esm/unique-id.js
var map$1 = {};
var unique_id_default = (function(prefix) {
	prefix = prefix || "g";
	if (!map$1[prefix]) map$1[prefix] = 1;
	else map$1[prefix] += 1;
	return prefix + map$1[prefix];
});

//#endregion
//#region node_modules/@antv/util/esm/noop.js
var noop_default = (function() {});

//#endregion
//#region node_modules/@antv/util/esm/size.js
function size(o) {
	if (is_nil_default(o)) return 0;
	if (is_array_like_default(o)) return o.length;
	return Object.keys(o).length;
}

//#endregion
//#region node_modules/@antv/util/esm/measure-text-width.js
var ctx$2;
/**
* 计算文本的宽度
*/
var measure_text_width_default = memoize_default(function(text, font) {
	if (font === void 0) font = {};
	var fontSize = font.fontSize, fontFamily = font.fontFamily, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
	if (!ctx$2) ctx$2 = document.createElement("canvas").getContext("2d");
	ctx$2.font = [
		fontStyle,
		fontVariant,
		fontWeight,
		fontSize + "px",
		fontFamily
	].join(" ");
	return ctx$2.measureText(is_string_default(text) ? text : "").width;
}, function(text, font) {
	if (font === void 0) font = {};
	return __spreadArrays([text], values_default(font)).join("");
});

//#endregion
//#region node_modules/@antv/util/esm/get-ellipsis-text.js
/**
* 获取文本的 ... 文本。
* 算法（减少每次 measureText 的长度，measureText 的性能跟字符串时间相关）：
* 1. 先通过 STEP 逐步计算，找到最后一个小于 maxWidth 的字符串
* 2. 然后对最后这个字符串二分计算
* @param text 需要计算的文本, 由于历史原因 除了支持string，还支持空值,number和数组等
* @param maxWidth 最大宽度
* @param font 字体
* @param str 要替换的文本
*/
var get_ellipsis_text_default = (function(text, maxWidth, font, str) {
	if (str === void 0) str = "...";
	var STEP = 16;
	var PLACEHOLDER_WIDTH = measure_text_width_default(str, font);
	var leftText = !is_string_default(text) ? to_string_default(text) : text;
	var leftWidth = maxWidth;
	var r = [];
	var currentText;
	var currentWidth;
	if (measure_text_width_default(text, font) <= maxWidth) return text;
	while (true) {
		currentText = leftText.substr(0, STEP);
		currentWidth = measure_text_width_default(currentText, font);
		if (currentWidth + PLACEHOLDER_WIDTH > leftWidth) {
			if (currentWidth > leftWidth) break;
		}
		r.push(currentText);
		leftWidth -= currentWidth;
		leftText = leftText.substr(STEP);
		if (!leftText) return r.join("");
	}
	while (true) {
		currentText = leftText.substr(0, 1);
		currentWidth = measure_text_width_default(currentText, font);
		if (currentWidth + PLACEHOLDER_WIDTH > leftWidth) break;
		r.push(currentText);
		leftWidth -= currentWidth;
		leftText = leftText.substr(1);
		if (!leftText) return r.join("");
	}
	return "" + r.join("") + str;
});

//#endregion
//#region node_modules/@antv/util/esm/cache.js
/**
* k-v 存储
*/
var default_1 = function() {
	function default_1$1() {
		this.map = {};
	}
	default_1$1.prototype.has = function(key) {
		return this.map[key] !== void 0;
	};
	default_1$1.prototype.get = function(key, def) {
		var v = this.map[key];
		return v === void 0 ? def : v;
	};
	default_1$1.prototype.set = function(key, value$1) {
		this.map[key] = value$1;
	};
	default_1$1.prototype.clear = function() {
		this.map = {};
	};
	default_1$1.prototype.delete = function(key) {
		delete this.map[key];
	};
	default_1$1.prototype.size = function() {
		return Object.keys(this.map).length;
	};
	return default_1$1;
}();
var cache_default = default_1;

//#endregion
//#region node_modules/@antv/g2/esm/constant.js
/**
* view 中三层 group 分层 key
*/
var LAYER;
(function(LAYER$1) {
	/** 前景层 */
	LAYER$1["FORE"] = "fore";
	/** 中间层 */
	LAYER$1["MID"] = "mid";
	/** 背景层 */
	LAYER$1["BG"] = "bg";
})(LAYER || (LAYER = {}));
/**
* 组件在画布的布局方位 12 方位
*/
var DIRECTION;
(function(DIRECTION$1) {
	DIRECTION$1["TOP"] = "top";
	DIRECTION$1["TOP_LEFT"] = "top-left";
	DIRECTION$1["TOP_RIGHT"] = "top-right";
	DIRECTION$1["RIGHT"] = "right";
	DIRECTION$1["RIGHT_TOP"] = "right-top";
	DIRECTION$1["RIGHT_BOTTOM"] = "right-bottom";
	DIRECTION$1["LEFT"] = "left";
	DIRECTION$1["LEFT_TOP"] = "left-top";
	DIRECTION$1["LEFT_BOTTOM"] = "left-bottom";
	DIRECTION$1["BOTTOM"] = "bottom";
	DIRECTION$1["BOTTOM_LEFT"] = "bottom-left";
	DIRECTION$1["BOTTOM_RIGHT"] = "bottom-right";
	DIRECTION$1["RADIUS"] = "radius";
	DIRECTION$1["CIRCLE"] = "circle";
	DIRECTION$1["NONE"] = "none";
})(DIRECTION || (DIRECTION = {}));
/**
* 组件的类型，可能会影响到布局算法
*/
var COMPONENT_TYPE;
(function(COMPONENT_TYPE$1) {
	/** axis 组件 */
	COMPONENT_TYPE$1["AXIS"] = "axis";
	/** grid 组件 */
	COMPONENT_TYPE$1["GRID"] = "grid";
	/** legend 组件 */
	COMPONENT_TYPE$1["LEGEND"] = "legend";
	/** tooltip 组件 */
	COMPONENT_TYPE$1["TOOLTIP"] = "tooltip";
	/** annotation 组件 */
	COMPONENT_TYPE$1["ANNOTATION"] = "annotation";
	/** 缩略轴组件 */
	COMPONENT_TYPE$1["SLIDER"] = "slider";
	/** 滚动条组件 */
	COMPONENT_TYPE$1["SCROLLBAR"] = "scrollbar";
	/** 其他组件，自定义组件 */
	COMPONENT_TYPE$1["OTHER"] = "other";
})(COMPONENT_TYPE || (COMPONENT_TYPE = {}));
/**
* 三层 group 的 z index
*/
var GROUP_Z_INDEX = {
	FORE: 3,
	MID: 2,
	BG: 1
};
/**
* View 的生命周期阶段（和 3.x 的生命周期略有不同）
* 我们需要先确定在那写场景需要用到生命周期，如果只是为了在生命周期插入一下什么组件之类的，那么在现有架构就是不需要的
*/
var VIEW_LIFE_CIRCLE;
(function(VIEW_LIFE_CIRCLE$1) {
	VIEW_LIFE_CIRCLE$1["BEFORE_RENDER"] = "beforerender";
	VIEW_LIFE_CIRCLE$1["AFTER_RENDER"] = "afterrender";
	VIEW_LIFE_CIRCLE$1["BEFORE_PAINT"] = "beforepaint";
	VIEW_LIFE_CIRCLE$1["AFTER_PAINT"] = "afterpaint";
	VIEW_LIFE_CIRCLE$1["BEFORE_CHANGE_DATA"] = "beforechangedata";
	VIEW_LIFE_CIRCLE$1["AFTER_CHANGE_DATA"] = "afterchangedata";
	VIEW_LIFE_CIRCLE$1["BEFORE_CLEAR"] = "beforeclear";
	VIEW_LIFE_CIRCLE$1["AFTER_CLEAR"] = "afterclear";
	VIEW_LIFE_CIRCLE$1["BEFORE_DESTROY"] = "beforedestroy";
	VIEW_LIFE_CIRCLE$1["BEFORE_CHANGE_SIZE"] = "beforechangesize";
	VIEW_LIFE_CIRCLE$1["AFTER_CHANGE_SIZE"] = "afterchangesize";
})(VIEW_LIFE_CIRCLE || (VIEW_LIFE_CIRCLE = {}));
/**
* geometry 的生命周期
*/
var GEOMETRY_LIFE_CIRCLE;
(function(GEOMETRY_LIFE_CIRCLE$1) {
	GEOMETRY_LIFE_CIRCLE$1["BEFORE_DRAW_ANIMATE"] = "beforeanimate";
	GEOMETRY_LIFE_CIRCLE$1["AFTER_DRAW_ANIMATE"] = "afteranimate";
	GEOMETRY_LIFE_CIRCLE$1["BEFORE_RENDER_LABEL"] = "beforerenderlabel";
	GEOMETRY_LIFE_CIRCLE$1["AFTER_RENDER_LABEL"] = "afterrenderlabel";
})(GEOMETRY_LIFE_CIRCLE || (GEOMETRY_LIFE_CIRCLE = {}));
/**
* 绘图区的事件列表
*/
var PLOT_EVENTS;
(function(PLOT_EVENTS$1) {
	PLOT_EVENTS$1["MOUSE_ENTER"] = "plot:mouseenter";
	PLOT_EVENTS$1["MOUSE_DOWN"] = "plot:mousedown";
	PLOT_EVENTS$1["MOUSE_MOVE"] = "plot:mousemove";
	PLOT_EVENTS$1["MOUSE_UP"] = "plot:mouseup";
	PLOT_EVENTS$1["MOUSE_LEAVE"] = "plot:mouseleave";
	PLOT_EVENTS$1["TOUCH_START"] = "plot:touchstart";
	PLOT_EVENTS$1["TOUCH_MOVE"] = "plot:touchmove";
	PLOT_EVENTS$1["TOUCH_END"] = "plot:touchend";
	PLOT_EVENTS$1["TOUCH_CANCEL"] = "plot:touchcancel";
	PLOT_EVENTS$1["CLICK"] = "plot:click";
	PLOT_EVENTS$1["DBLCLICK"] = "plot:dblclick";
	PLOT_EVENTS$1["CONTEXTMENU"] = "plot:contextmenu";
	PLOT_EVENTS$1["LEAVE"] = "plot:leave";
	PLOT_EVENTS$1["ENTER"] = "plot:enter";
})(PLOT_EVENTS || (PLOT_EVENTS = {}));
/**
* Element 图形交互状态
*/
var ELEMENT_STATE;
(function(ELEMENT_STATE$1) {
	ELEMENT_STATE$1["ACTIVE"] = "active";
	ELEMENT_STATE$1["INACTIVE"] = "inactive";
	ELEMENT_STATE$1["SELECTED"] = "selected";
	ELEMENT_STATE$1["DEFAULT"] = "default";
})(ELEMENT_STATE || (ELEMENT_STATE = {}));
/** 参与分组的图形属性名 */
var GROUP_ATTRS = [
	"color",
	"shape",
	"size"
];
/** 存储原始数据的字段名 */
var FIELD_ORIGIN = "_origin";
/** 最小的图表宽度 */
var MIN_CHART_WIDTH = 1;
/** 最小的图表高度 */
var MIN_CHART_HEIGHT = 1;
/** 辅助组件占图表的尺寸的最大比例：如图表上方的图例最多占图表高度的25% */
var COMPONENT_MAX_VIEW_PERCENTAGE = .25;

//#endregion
//#region node_modules/@antv/g2/esm/engine/index.js
var ENGINES = {};
/**
* 通过名字获取渲染 engine
* @param name 渲染引擎名字
* @returns G engine
*/
function getEngine(name) {
	var G = ENGINES[name];
	if (!G) throw new Error("G engine '".concat(name, "' is not exist, please register it at first."));
	return G;
}
/**
* 注册渲染引擎
* @param name
* @param engine
*/
function registerEngine(name, engine) {
	ENGINES[name] = engine;
}

//#endregion
//#region node_modules/@antv/dom-util/esm/add-event-listener.js
function addEventListener(target, eventType, callback) {
	if (target) {
		if (typeof target.addEventListener === "function") {
			target.addEventListener(eventType, callback, false);
			return { remove: function() {
				target.removeEventListener(eventType, callback, false);
			} };
		}
		if (typeof target.attachEvent === "function") {
			target.attachEvent("on" + eventType, callback);
			return { remove: function() {
				target.detachEvent("on" + eventType, callback);
			} };
		}
	}
}

//#endregion
//#region node_modules/@antv/dom-util/esm/create-dom.js
/**
* 创建DOM 节点
* @param  {String} str Dom 字符串
* @return {HTMLElement}  DOM 节点
*/
var TABLE;
var TABLE_TR;
var FRAGMENT_REG;
var CONTAINERS;
function initConstants() {
	TABLE = document.createElement("table");
	TABLE_TR = document.createElement("tr");
	FRAGMENT_REG = /^\s*<(\w+|!)[^>]*>/;
	CONTAINERS = {
		tr: document.createElement("tbody"),
		tbody: TABLE,
		thead: TABLE,
		tfoot: TABLE,
		td: TABLE_TR,
		th: TABLE_TR,
		"*": document.createElement("div")
	};
}
function createDom$1(str) {
	if (!TABLE) initConstants();
	var name = FRAGMENT_REG.test(str) && RegExp.$1;
	if (!name || !(name in CONTAINERS)) name = "*";
	var container = CONTAINERS[name];
	str = typeof str === "string" ? str.replace(/(^\s*)|(\s*$)/g, "") : str;
	container.innerHTML = "" + str;
	var dom = container.childNodes[0];
	if (dom && container.contains(dom)) container.removeChild(dom);
	return dom;
}

//#endregion
//#region node_modules/@antv/dom-util/esm/get-style.js
/**
* 获取样式
* @param  {Object} dom DOM节点
* @param  {String} name 样式名
* @param  {Any} defaultValue 默认值
* @return {String} 属性值
*/
function getStyle$1(dom, name, defaultValue) {
	var v;
	try {
		v = window.getComputedStyle ? window.getComputedStyle(dom, null)[name] : dom.style[name];
	} catch (e) {} finally {
		v = v === void 0 ? defaultValue : v;
	}
	return v;
}

//#endregion
//#region node_modules/@antv/dom-util/esm/get-height.js
function getHeight$1(el, defaultValue) {
	var height = getStyle$1(el, "height", defaultValue);
	if (height === "auto") height = el.offsetHeight;
	return parseFloat(height);
}

//#endregion
//#region node_modules/@antv/dom-util/esm/get-outer-height.js
function getOuterHeight(el, defaultValue) {
	var height = getHeight$1(el, defaultValue);
	var bTop = parseFloat(getStyle$1(el, "borderTopWidth")) || 0;
	var pTop = parseFloat(getStyle$1(el, "paddingTop")) || 0;
	var pBottom = parseFloat(getStyle$1(el, "paddingBottom")) || 0;
	var bBottom = parseFloat(getStyle$1(el, "borderBottomWidth")) || 0;
	var mTop = parseFloat(getStyle$1(el, "marginTop")) || 0;
	var mBottom = parseFloat(getStyle$1(el, "marginBottom")) || 0;
	return height + bTop + bBottom + pTop + pBottom + mTop + mBottom;
}

//#endregion
//#region node_modules/@antv/dom-util/esm/get-width.js
function getHeight(el, defaultValue) {
	var width = getStyle$1(el, "width", defaultValue);
	if (width === "auto") width = el.offsetWidth;
	return parseFloat(width);
}

//#endregion
//#region node_modules/@antv/dom-util/esm/get-outer-width.js
function getOuterWidth(el, defaultValue) {
	var width = getHeight(el, defaultValue);
	var bLeft = parseFloat(getStyle$1(el, "borderLeftWidth")) || 0;
	var pLeft = parseFloat(getStyle$1(el, "paddingLeft")) || 0;
	var pRight = parseFloat(getStyle$1(el, "paddingRight")) || 0;
	var bRight = parseFloat(getStyle$1(el, "borderRightWidth")) || 0;
	var mRight = parseFloat(getStyle$1(el, "marginRight")) || 0;
	var mLeft = parseFloat(getStyle$1(el, "marginLeft")) || 0;
	return width + bLeft + bRight + pLeft + pRight + mLeft + mRight;
}

//#endregion
//#region node_modules/@antv/dom-util/esm/modify-css.js
function modifyCSS(dom, css) {
	if (dom) {
		for (var key in css) if (css.hasOwnProperty(key)) dom.style[key] = css[key];
	}
	return dom;
}

//#endregion
//#region node_modules/@antv/g2/esm/util/dom.js
/**
* get the element's bounding size
* @param ele dom element
* @returns the element width and height
*/
function getElementSize(ele) {
	var style = getComputedStyle(ele);
	return {
		width: (ele.clientWidth || parseInt(style.width, 10)) - parseInt(style.paddingLeft, 10) - parseInt(style.paddingRight, 10),
		height: (ele.clientHeight || parseInt(style.height, 10)) - parseInt(style.paddingTop, 10) - parseInt(style.paddingBottom, 10)
	};
}
/**
* is value a valid number
* @param v the input value
* @returns whether it is a number
*/
function isNumber(v) {
	return typeof v === "number" && !isNaN(v);
}
/**
* @ignore
* calculate the chart size
* @param ele DOM element
* @param autoFit should auto fit
* @param width chart width which is set by user
* @param height chart height which is set by user
* @returns the chart width and height
*/
function getChartSize(ele, autoFit, width, height) {
	var w = width;
	var h = height;
	if (autoFit) {
		var size$1 = getElementSize(ele);
		w = size$1.width ? size$1.width : w;
		h = size$1.height ? size$1.height : h;
	}
	return {
		width: Math.max(isNumber(w) ? w : MIN_CHART_WIDTH, MIN_CHART_WIDTH),
		height: Math.max(isNumber(h) ? h : MIN_CHART_HEIGHT, MIN_CHART_HEIGHT)
	};
}
/**
* @ignore
* remove html element from its parent
* @param dom
*/
function removeDom(dom) {
	var parent = dom.parentNode;
	if (parent) parent.removeChild(dom);
}

//#endregion
//#region node_modules/@antv/event-emitter/esm/index.js
var WILDCARD$1 = "*";
var EventEmitter = function() {
	function EventEmitter$1() {
		this._events = {};
	}
	/**
	* 监听一个事件
	* @param evt
	* @param callback
	* @param once
	*/
	EventEmitter$1.prototype.on = function(evt, callback, once) {
		if (!this._events[evt]) this._events[evt] = [];
		this._events[evt].push({
			callback,
			once: !!once
		});
		return this;
	};
	/**
	* 监听一个事件一次
	* @param evt
	* @param callback
	*/
	EventEmitter$1.prototype.once = function(evt, callback) {
		return this.on(evt, callback, true);
	};
	/**
	* 触发一个事件
	* @param evt
	* @param args
	*/
	EventEmitter$1.prototype.emit = function(evt) {
		var _this = this;
		var args = [];
		for (var _i = 1; _i < arguments.length; _i++) args[_i - 1] = arguments[_i];
		var events = this._events[evt] || [];
		var wildcardEvents = this._events[WILDCARD$1] || [];
		var doEmit = function(es) {
			var length$1 = es.length;
			for (var i = 0; i < length$1; i++) {
				if (!es[i]) continue;
				var _a$5 = es[i], callback = _a$5.callback;
				if (_a$5.once) {
					es.splice(i, 1);
					if (es.length === 0) delete _this._events[evt];
					length$1--;
					i--;
				}
				callback.apply(_this, args);
			}
		};
		doEmit(events);
		doEmit(wildcardEvents);
	};
	/**
	* 取消监听一个事件，或者一个channel
	* @param evt
	* @param callback
	*/
	EventEmitter$1.prototype.off = function(evt, callback) {
		if (!evt) this._events = {};
		else if (!callback) delete this._events[evt];
		else {
			var events = this._events[evt] || [];
			var length_1 = events.length;
			for (var i = 0; i < length_1; i++) if (events[i].callback === callback) {
				events.splice(i, 1);
				length_1--;
				i--;
			}
			if (events.length === 0) delete this._events[evt];
		}
		return this;
	};
	EventEmitter$1.prototype.getEvents = function() {
		return this._events;
	};
	return EventEmitter$1;
}();
var esm_default$1 = EventEmitter;

//#endregion
//#region node_modules/@antv/g2/esm/base.js
/**
* G2 Chart、View、Geometry 以及 Element 等的基类，提供事件以及一些通用的方法。
*/
var Base$1 = function(_super) {
	__extends(Base$2, _super);
	function Base$2(cfg) {
		var _this = _super.call(this) || this;
		/** 标识对象是否已销毁 */
		_this.destroyed = false;
		var _a$5 = cfg.visible;
		_this.visible = _a$5 === void 0 ? true : _a$5;
		return _this;
	}
	/**
	* 显示。
	*/
	Base$2.prototype.show = function() {
		if (!this.visible) this.changeVisible(true);
	};
	/**
	* 隐藏。
	*/
	Base$2.prototype.hide = function() {
		if (this.visible) this.changeVisible(false);
	};
	/**
	* 销毁。
	*/
	Base$2.prototype.destroy = function() {
		this.off();
		this.destroyed = true;
	};
	/**
	* 显示或者隐藏。
	* @param visible
	* @returns
	*/
	Base$2.prototype.changeVisible = function(visible) {
		if (this.visible === visible) return;
		this.visible = visible;
	};
	return Base$2;
}(esm_default$1);
var base_default$9 = Base$1;

//#endregion
//#region node_modules/@antv/g-base/esm/util/path.js
var path_exports = /* @__PURE__ */ __export({
	catmullRomToBezier: () => catmullRomToBezier,
	fillPath: () => fillPath,
	fillPathByDiff: () => fillPathByDiff,
	formatPath: () => formatPath,
	intersection: () => intersection,
	parsePathArray: () => parsePathArray,
	parsePathString: () => parsePathString$3,
	pathToAbsolute: () => pathToAbsolute$1,
	pathToCurve: () => pathToCurve,
	rectPath: () => rectPath
});
var SPACES$5 = "	\n\v\f\r \xA0 ᠎             　\u2028\u2029";
var PATH_COMMAND$5 = new RegExp("([a-z])[" + SPACES$5 + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + SPACES$5 + "]*,?[" + SPACES$5 + "]*)+)", "ig");
var PATH_VALUES$5 = new RegExp("(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[" + SPACES$5 + "]*,?[" + SPACES$5 + "]*", "ig");
var parsePathString$3 = function(pathString) {
	if (!pathString) return null;
	if (is_array_default(pathString)) return pathString;
	var paramCounts = {
		a: 7,
		c: 6,
		o: 2,
		h: 1,
		l: 2,
		m: 2,
		r: 4,
		q: 4,
		s: 4,
		t: 2,
		v: 1,
		u: 3,
		z: 0
	};
	var data$2 = [];
	String(pathString).replace(PATH_COMMAND$5, function(a, b, c) {
		var params = [];
		var name = b.toLowerCase();
		c.replace(PATH_VALUES$5, function(a$1, b$1) {
			b$1 && params.push(+b$1);
		});
		if (name === "m" && params.length > 2) {
			data$2.push([b].concat(params.splice(0, 2)));
			name = "l";
			b = b === "m" ? "l" : "L";
		}
		if (name === "o" && params.length === 1) data$2.push([b, params[0]]);
		if (name === "r") data$2.push([b].concat(params));
		else while (params.length >= paramCounts[name]) {
			data$2.push([b].concat(params.splice(0, paramCounts[name])));
			if (!paramCounts[name]) break;
		}
		return pathString;
	});
	return data$2;
};
var catmullRomToBezier = function(crp, z) {
	var d = [];
	for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
		var p = [
			{
				x: +crp[i - 2],
				y: +crp[i - 1]
			},
			{
				x: +crp[i],
				y: +crp[i + 1]
			},
			{
				x: +crp[i + 2],
				y: +crp[i + 3]
			},
			{
				x: +crp[i + 4],
				y: +crp[i + 5]
			}
		];
		if (z) {
			if (!i) p[0] = {
				x: +crp[iLen - 2],
				y: +crp[iLen - 1]
			};
			else if (iLen - 4 === i) p[3] = {
				x: +crp[0],
				y: +crp[1]
			};
			else if (iLen - 2 === i) {
				p[2] = {
					x: +crp[0],
					y: +crp[1]
				};
				p[3] = {
					x: +crp[2],
					y: +crp[3]
				};
			}
		} else if (iLen - 4 === i) p[3] = p[2];
		else if (!i) p[0] = {
			x: +crp[i],
			y: +crp[i + 1]
		};
		d.push([
			"C",
			(-p[0].x + 6 * p[1].x + p[2].x) / 6,
			(-p[0].y + 6 * p[1].y + p[2].y) / 6,
			(p[1].x + 6 * p[2].x - p[3].x) / 6,
			(p[1].y + 6 * p[2].y - p[3].y) / 6,
			p[2].x,
			p[2].y
		]);
	}
	return d;
};
var ellipsePath = function(x, y, rx, ry, a) {
	var res = [];
	if (a === null && ry === null) ry = rx;
	x = +x;
	y = +y;
	rx = +rx;
	ry = +ry;
	if (a !== null) {
		var rad = Math.PI / 180;
		var x1 = x + rx * Math.cos(-ry * rad);
		var x2 = x + rx * Math.cos(-a * rad);
		var y1 = y + rx * Math.sin(-ry * rad);
		var y2 = y + rx * Math.sin(-a * rad);
		res = [[
			"M",
			x1,
			y1
		], [
			"A",
			rx,
			rx,
			0,
			+(a - ry > 180),
			0,
			x2,
			y2
		]];
	} else res = [
		[
			"M",
			x,
			y
		],
		[
			"m",
			0,
			-ry
		],
		[
			"a",
			rx,
			ry,
			0,
			1,
			1,
			0,
			2 * ry
		],
		[
			"a",
			rx,
			ry,
			0,
			1,
			1,
			0,
			-2 * ry
		],
		["z"]
	];
	return res;
};
var pathToAbsolute$1 = function(pathArray) {
	pathArray = parsePathString$3(pathArray);
	if (!pathArray || !pathArray.length) return [[
		"M",
		0,
		0
	]];
	var res = [];
	var x = 0;
	var y = 0;
	var mx = 0;
	var my = 0;
	var start = 0;
	var pa0;
	var dots;
	if (pathArray[0][0] === "M") {
		x = +pathArray[0][1];
		y = +pathArray[0][2];
		mx = x;
		my = y;
		start++;
		res[0] = [
			"M",
			x,
			y
		];
	}
	var crz = pathArray.length === 3 && pathArray[0][0] === "M" && pathArray[1][0].toUpperCase() === "R" && pathArray[2][0].toUpperCase() === "Z";
	for (var r = void 0, pa = void 0, i = start, ii = pathArray.length; i < ii; i++) {
		res.push(r = []);
		pa = pathArray[i];
		pa0 = pa[0];
		if (pa0 !== pa0.toUpperCase()) {
			r[0] = pa0.toUpperCase();
			switch (r[0]) {
				case "A":
					r[1] = pa[1];
					r[2] = pa[2];
					r[3] = pa[3];
					r[4] = pa[4];
					r[5] = pa[5];
					r[6] = +pa[6] + x;
					r[7] = +pa[7] + y;
					break;
				case "V":
					r[1] = +pa[1] + y;
					break;
				case "H":
					r[1] = +pa[1] + x;
					break;
				case "R":
					dots = [x, y].concat(pa.slice(1));
					for (var j = 2, jj = dots.length; j < jj; j++) {
						dots[j] = +dots[j] + x;
						dots[++j] = +dots[j] + y;
					}
					res.pop();
					res = res.concat(catmullRomToBezier(dots, crz));
					break;
				case "O":
					res.pop();
					dots = ellipsePath(x, y, pa[1], pa[2]);
					dots.push(dots[0]);
					res = res.concat(dots);
					break;
				case "U":
					res.pop();
					res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
					r = ["U"].concat(res[res.length - 1].slice(-2));
					break;
				case "M":
					mx = +pa[1] + x;
					my = +pa[2] + y;
					break;
				default: for (var j = 1, jj = pa.length; j < jj; j++) r[j] = +pa[j] + (j % 2 ? x : y);
			}
		} else if (pa0 === "R") {
			dots = [x, y].concat(pa.slice(1));
			res.pop();
			res = res.concat(catmullRomToBezier(dots, crz));
			r = ["R"].concat(pa.slice(-2));
		} else if (pa0 === "O") {
			res.pop();
			dots = ellipsePath(x, y, pa[1], pa[2]);
			dots.push(dots[0]);
			res = res.concat(dots);
		} else if (pa0 === "U") {
			res.pop();
			res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
			r = ["U"].concat(res[res.length - 1].slice(-2));
		} else for (var k = 0, kk = pa.length; k < kk; k++) r[k] = pa[k];
		pa0 = pa0.toUpperCase();
		if (pa0 !== "O") switch (r[0]) {
			case "Z":
				x = +mx;
				y = +my;
				break;
			case "H":
				x = r[1];
				break;
			case "V":
				y = r[1];
				break;
			case "M":
				mx = r[r.length - 2];
				my = r[r.length - 1];
				break;
			default:
				x = r[r.length - 2];
				y = r[r.length - 1];
		}
	}
	return res;
};
var l2c = function(x1, y1, x2, y2) {
	return [
		x1,
		y1,
		x2,
		y2,
		x2,
		y2
	];
};
var q2c = function(x1, y1, ax, ay, x2, y2) {
	var _13 = 1 / 3;
	var _23 = 2 / 3;
	return [
		_13 * x1 + _23 * ax,
		_13 * y1 + _23 * ay,
		_13 * x2 + _23 * ax,
		_13 * y2 + _23 * ay,
		x2,
		y2
	];
};
var a2c = function(x1, y1, rx, ry, angle$1, large_arc_flag, sweep_flag, x2, y2, recursive) {
	if (rx === ry) rx += 1;
	var _120 = Math.PI * 120 / 180;
	var rad = Math.PI / 180 * (+angle$1 || 0);
	var res = [];
	var xy;
	var f1;
	var f2;
	var cx;
	var cy;
	var rotate$2 = function(x$1, y$1, rad$1) {
		var X = x$1 * Math.cos(rad$1) - y$1 * Math.sin(rad$1);
		var Y = x$1 * Math.sin(rad$1) + y$1 * Math.cos(rad$1);
		return {
			x: X,
			y: Y
		};
	};
	if (!recursive) {
		xy = rotate$2(x1, y1, -rad);
		x1 = xy.x;
		y1 = xy.y;
		xy = rotate$2(x2, y2, -rad);
		x2 = xy.x;
		y2 = xy.y;
		if (x1 === x2 && y1 === y2) {
			x2 += 1;
			y2 += 1;
		}
		var x = (x1 - x2) / 2;
		var y = (y1 - y2) / 2;
		var h = x * x / (rx * rx) + y * y / (ry * ry);
		if (h > 1) {
			h = Math.sqrt(h);
			rx = h * rx;
			ry = h * ry;
		}
		var rx2 = rx * rx;
		var ry2 = ry * ry;
		var k = (large_arc_flag === sweep_flag ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
		cx = k * rx * y / ry + (x1 + x2) / 2;
		cy = k * -ry * x / rx + (y1 + y2) / 2;
		f1 = Math.asin(((y1 - cy) / ry).toFixed(9));
		f2 = Math.asin(((y2 - cy) / ry).toFixed(9));
		f1 = x1 < cx ? Math.PI - f1 : f1;
		f2 = x2 < cx ? Math.PI - f2 : f2;
		f1 < 0 && (f1 = Math.PI * 2 + f1);
		f2 < 0 && (f2 = Math.PI * 2 + f2);
		if (sweep_flag && f1 > f2) f1 = f1 - Math.PI * 2;
		if (!sweep_flag && f2 > f1) f2 = f2 - Math.PI * 2;
	} else {
		f1 = recursive[0];
		f2 = recursive[1];
		cx = recursive[2];
		cy = recursive[3];
	}
	var df = f2 - f1;
	if (Math.abs(df) > _120) {
		var f2old = f2;
		var x2old = x2;
		var y2old = y2;
		f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
		x2 = cx + rx * Math.cos(f2);
		y2 = cy + ry * Math.sin(f2);
		res = a2c(x2, y2, rx, ry, angle$1, 0, sweep_flag, x2old, y2old, [
			f2,
			f2old,
			cx,
			cy
		]);
	}
	df = f2 - f1;
	var c1 = Math.cos(f1);
	var s1 = Math.sin(f1);
	var c2 = Math.cos(f2);
	var s2 = Math.sin(f2);
	var t = Math.tan(df / 4);
	var hx = 4 / 3 * rx * t;
	var hy = 4 / 3 * ry * t;
	var m1 = [x1, y1];
	var m2 = [x1 + hx * s1, y1 - hy * c1];
	var m3 = [x2 + hx * s2, y2 - hy * c2];
	var m4 = [x2, y2];
	m2[0] = 2 * m1[0] - m2[0];
	m2[1] = 2 * m1[1] - m2[1];
	if (recursive) return [
		m2,
		m3,
		m4
	].concat(res);
	res = [
		m2,
		m3,
		m4
	].concat(res).join().split(",");
	var newres = [];
	for (var i = 0, ii = res.length; i < ii; i++) newres[i] = i % 2 ? rotate$2(res[i - 1], res[i], rad).y : rotate$2(res[i], res[i + 1], rad).x;
	return newres;
};
var pathToCurve = function(path, path2) {
	var p = pathToAbsolute$1(path);
	var p2 = path2 && pathToAbsolute$1(path2);
	var attrs = {
		x: 0,
		y: 0,
		bx: 0,
		by: 0,
		X: 0,
		Y: 0,
		qx: null,
		qy: null
	};
	var attrs2 = {
		x: 0,
		y: 0,
		bx: 0,
		by: 0,
		X: 0,
		Y: 0,
		qx: null,
		qy: null
	};
	var pcoms1 = [];
	var pcoms2 = [];
	var pfirst = "";
	var pcom = "";
	var ii;
	var processPath = function(path$1, d, pcom$1) {
		var nx;
		var ny;
		if (!path$1) return [
			"C",
			d.x,
			d.y,
			d.x,
			d.y,
			d.x,
			d.y
		];
		!(path$1[0] in {
			T: 1,
			Q: 1
		}) && (d.qx = d.qy = null);
		switch (path$1[0]) {
			case "M":
				d.X = path$1[1];
				d.Y = path$1[2];
				break;
			case "A":
				path$1 = ["C"].concat(a2c.apply(0, [d.x, d.y].concat(path$1.slice(1))));
				break;
			case "S":
				if (pcom$1 === "C" || pcom$1 === "S") {
					nx = d.x * 2 - d.bx;
					ny = d.y * 2 - d.by;
				} else {
					nx = d.x;
					ny = d.y;
				}
				path$1 = [
					"C",
					nx,
					ny
				].concat(path$1.slice(1));
				break;
			case "T":
				if (pcom$1 === "Q" || pcom$1 === "T") {
					d.qx = d.x * 2 - d.qx;
					d.qy = d.y * 2 - d.qy;
				} else {
					d.qx = d.x;
					d.qy = d.y;
				}
				path$1 = ["C"].concat(q2c(d.x, d.y, d.qx, d.qy, path$1[1], path$1[2]));
				break;
			case "Q":
				d.qx = path$1[1];
				d.qy = path$1[2];
				path$1 = ["C"].concat(q2c(d.x, d.y, path$1[1], path$1[2], path$1[3], path$1[4]));
				break;
			case "L":
				path$1 = ["C"].concat(l2c(d.x, d.y, path$1[1], path$1[2]));
				break;
			case "H":
				path$1 = ["C"].concat(l2c(d.x, d.y, path$1[1], d.y));
				break;
			case "V":
				path$1 = ["C"].concat(l2c(d.x, d.y, d.x, path$1[1]));
				break;
			case "Z":
				path$1 = ["C"].concat(l2c(d.x, d.y, d.X, d.Y));
				break;
			default: break;
		}
		return path$1;
	};
	var fixArc = function(pp, i$1) {
		if (pp[i$1].length > 7) {
			pp[i$1].shift();
			var pi$1 = pp[i$1];
			while (pi$1.length) {
				pcoms1[i$1] = "A";
				p2 && (pcoms2[i$1] = "A");
				pp.splice(i$1++, 0, ["C"].concat(pi$1.splice(0, 6)));
			}
			pp.splice(i$1, 1);
			ii = Math.max(p.length, p2 && p2.length || 0);
		}
	};
	var fixM = function(path1, path2$1, a1, a2, i$1) {
		if (path1 && path2$1 && path1[i$1][0] === "M" && path2$1[i$1][0] !== "M") {
			path2$1.splice(i$1, 0, [
				"M",
				a2.x,
				a2.y
			]);
			a1.bx = 0;
			a1.by = 0;
			a1.x = path1[i$1][1];
			a1.y = path1[i$1][2];
			ii = Math.max(p.length, p2 && p2.length || 0);
		}
	};
	ii = Math.max(p.length, p2 && p2.length || 0);
	for (var i = 0; i < ii; i++) {
		p[i] && (pfirst = p[i][0]);
		if (pfirst !== "C") {
			pcoms1[i] = pfirst;
			i && (pcom = pcoms1[i - 1]);
		}
		p[i] = processPath(p[i], attrs, pcom);
		if (pcoms1[i] !== "A" && pfirst === "C") pcoms1[i] = "C";
		fixArc(p, i);
		if (p2) {
			p2[i] && (pfirst = p2[i][0]);
			if (pfirst !== "C") {
				pcoms2[i] = pfirst;
				i && (pcom = pcoms2[i - 1]);
			}
			p2[i] = processPath(p2[i], attrs2, pcom);
			if (pcoms2[i] !== "A" && pfirst === "C") pcoms2[i] = "C";
			fixArc(p2, i);
		}
		fixM(p, p2, attrs, attrs2, i);
		fixM(p2, p, attrs2, attrs, i);
		var seg = p[i];
		var seg2 = p2 && p2[i];
		var seglen = seg.length;
		var seg2len = p2 && seg2.length;
		attrs.x = seg[seglen - 2];
		attrs.y = seg[seglen - 1];
		attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
		attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
		attrs2.bx = p2 && (parseFloat(seg2[seg2len - 4]) || attrs2.x);
		attrs2.by = p2 && (parseFloat(seg2[seg2len - 3]) || attrs2.y);
		attrs2.x = p2 && seg2[seg2len - 2];
		attrs2.y = p2 && seg2[seg2len - 1];
	}
	return p2 ? [p, p2] : p;
};
var p2s = /,?([a-z]),?/gi;
var parsePathArray = function(path) {
	return path.join(",").replace(p2s, "$1");
};
var base3 = function(t, p1, p2, p3, p4) {
	var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4;
	var t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
	return t * t2 - 3 * p1 + 3 * p2;
};
var bezlen = function(x1, y1, x2, y2, x3, y3, x4, y4, z) {
	if (z === null) z = 1;
	z = z > 1 ? 1 : z < 0 ? 0 : z;
	var z2 = z / 2;
	var n = 12;
	var Tvalues = [
		-.1252,
		.1252,
		-.3678,
		.3678,
		-.5873,
		.5873,
		-.7699,
		.7699,
		-.9041,
		.9041,
		-.9816,
		.9816
	];
	var Cvalues = [
		.2491,
		.2491,
		.2335,
		.2335,
		.2032,
		.2032,
		.1601,
		.1601,
		.1069,
		.1069,
		.0472,
		.0472
	];
	var sum = 0;
	for (var i = 0; i < n; i++) {
		var ct = z2 * Tvalues[i] + z2;
		var xbase = base3(ct, x1, x2, x3, x4);
		var ybase = base3(ct, y1, y2, y3, y4);
		var comb = xbase * xbase + ybase * ybase;
		sum += Cvalues[i] * Math.sqrt(comb);
	}
	return z2 * sum;
};
var curveDim = function(x0, y0, x1, y1, x2, y2, x3, y3) {
	var tvalues = [];
	var bounds = [[], []];
	var a;
	var b;
	var c;
	var t;
	for (var i = 0; i < 2; ++i) {
		if (i === 0) {
			b = 6 * x0 - 12 * x1 + 6 * x2;
			a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
			c = 3 * x1 - 3 * x0;
		} else {
			b = 6 * y0 - 12 * y1 + 6 * y2;
			a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
			c = 3 * y1 - 3 * y0;
		}
		if (Math.abs(a) < 1e-12) {
			if (Math.abs(b) < 1e-12) continue;
			t = -c / b;
			if (t > 0 && t < 1) tvalues.push(t);
			continue;
		}
		var b2ac = b * b - 4 * c * a;
		var sqrtb2ac = Math.sqrt(b2ac);
		if (b2ac < 0) continue;
		var t1 = (-b + sqrtb2ac) / (2 * a);
		if (t1 > 0 && t1 < 1) tvalues.push(t1);
		var t2 = (-b - sqrtb2ac) / (2 * a);
		if (t2 > 0 && t2 < 1) tvalues.push(t2);
	}
	var j = tvalues.length;
	var jlen = j;
	var mt;
	while (j--) {
		t = tvalues[j];
		mt = 1 - t;
		bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
		bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
	}
	bounds[0][jlen] = x0;
	bounds[1][jlen] = y0;
	bounds[0][jlen + 1] = x3;
	bounds[1][jlen + 1] = y3;
	bounds[0].length = bounds[1].length = jlen + 2;
	return {
		min: {
			x: Math.min.apply(0, bounds[0]),
			y: Math.min.apply(0, bounds[1])
		},
		max: {
			x: Math.max.apply(0, bounds[0]),
			y: Math.max.apply(0, bounds[1])
		}
	};
};
var intersect$1 = function(x1, y1, x2, y2, x3, y3, x4, y4) {
	if (Math.max(x1, x2) < Math.min(x3, x4) || Math.min(x1, x2) > Math.max(x3, x4) || Math.max(y1, y2) < Math.min(y3, y4) || Math.min(y1, y2) > Math.max(y3, y4)) return;
	var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4);
	var ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4);
	var denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
	if (!denominator) return;
	var px = nx / denominator;
	var py = ny / denominator;
	var px2 = +px.toFixed(2);
	var py2 = +py.toFixed(2);
	if (px2 < +Math.min(x1, x2).toFixed(2) || px2 > +Math.max(x1, x2).toFixed(2) || px2 < +Math.min(x3, x4).toFixed(2) || px2 > +Math.max(x3, x4).toFixed(2) || py2 < +Math.min(y1, y2).toFixed(2) || py2 > +Math.max(y1, y2).toFixed(2) || py2 < +Math.min(y3, y4).toFixed(2) || py2 > +Math.max(y3, y4).toFixed(2)) return;
	return {
		x: px,
		y: py
	};
};
var isPointInsideBBox = function(bbox, x, y) {
	return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;
};
var rectPath = function(x, y, w, h, r) {
	if (r) return [
		[
			"M",
			+x + +r,
			y
		],
		[
			"l",
			w - r * 2,
			0
		],
		[
			"a",
			r,
			r,
			0,
			0,
			1,
			r,
			r
		],
		[
			"l",
			0,
			h - r * 2
		],
		[
			"a",
			r,
			r,
			0,
			0,
			1,
			-r,
			r
		],
		[
			"l",
			r * 2 - w,
			0
		],
		[
			"a",
			r,
			r,
			0,
			0,
			1,
			-r,
			-r
		],
		[
			"l",
			0,
			r * 2 - h
		],
		[
			"a",
			r,
			r,
			0,
			0,
			1,
			r,
			-r
		],
		["z"]
	];
	var res = [
		[
			"M",
			x,
			y
		],
		[
			"l",
			w,
			0
		],
		[
			"l",
			0,
			h
		],
		[
			"l",
			-w,
			0
		],
		["z"]
	];
	res.parsePathArray = parsePathArray;
	return res;
};
var box = function(x, y, width, height) {
	if (x === null) x = y = width = height = 0;
	if (y === null) {
		y = x.y;
		width = x.width;
		height = x.height;
		x = x.x;
	}
	return {
		x,
		y,
		width,
		w: width,
		height,
		h: height,
		x2: x + width,
		y2: y + height,
		cx: x + width / 2,
		cy: y + height / 2,
		r1: Math.min(width, height) / 2,
		r2: Math.max(width, height) / 2,
		r0: Math.sqrt(width * width + height * height) / 2,
		path: rectPath(x, y, width, height),
		vb: [
			x,
			y,
			width,
			height
		].join(" ")
	};
};
var isBBoxIntersect = function(bbox1, bbox2) {
	bbox1 = box(bbox1);
	bbox2 = box(bbox2);
	return isPointInsideBBox(bbox2, bbox1.x, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2) || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
};
var bezierBBox = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
	if (!is_array_default(p1x)) p1x = [
		p1x,
		p1y,
		c1x,
		c1y,
		c2x,
		c2y,
		p2x,
		p2y
	];
	var bbox = curveDim.apply(null, p1x);
	return box(bbox.min.x, bbox.min.y, bbox.max.x - bbox.min.x, bbox.max.y - bbox.min.y);
};
var findDotsAtSegment = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
	var t1 = 1 - t;
	var t13 = Math.pow(t1, 3);
	var t12 = Math.pow(t1, 2);
	var t2 = t * t;
	var t3 = t2 * t;
	var x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x;
	var y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y;
	var mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x);
	var my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y);
	var nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x);
	var ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y);
	var ax = t1 * p1x + t * c1x;
	var ay = t1 * p1y + t * c1y;
	var cx = t1 * c2x + t * p2x;
	var cy = t1 * c2y + t * p2y;
	var alpha = 90 - Math.atan2(mx - nx, my - ny) * 180 / Math.PI;
	return {
		x,
		y,
		m: {
			x: mx,
			y: my
		},
		n: {
			x: nx,
			y: ny
		},
		start: {
			x: ax,
			y: ay
		},
		end: {
			x: cx,
			y: cy
		},
		alpha
	};
};
var interHelper = function(bez1, bez2, justCount) {
	var bbox1 = bezierBBox(bez1);
	var bbox2 = bezierBBox(bez2);
	if (!isBBoxIntersect(bbox1, bbox2)) return justCount ? 0 : [];
	var l1 = bezlen.apply(0, bez1);
	var l2 = bezlen.apply(0, bez2);
	var n1 = ~~(l1 / 8);
	var n2 = ~~(l2 / 8);
	var dots1 = [];
	var dots2 = [];
	var xy = {};
	var res = justCount ? 0 : [];
	for (var i = 0; i < n1 + 1; i++) {
		var d = findDotsAtSegment.apply(0, bez1.concat(i / n1));
		dots1.push({
			x: d.x,
			y: d.y,
			t: i / n1
		});
	}
	for (var i = 0; i < n2 + 1; i++) {
		var d = findDotsAtSegment.apply(0, bez2.concat(i / n2));
		dots2.push({
			x: d.x,
			y: d.y,
			t: i / n2
		});
	}
	for (var i = 0; i < n1; i++) for (var j = 0; j < n2; j++) {
		var di = dots1[i];
		var di1 = dots1[i + 1];
		var dj = dots2[j];
		var dj1 = dots2[j + 1];
		var ci = Math.abs(di1.x - di.x) < .001 ? "y" : "x";
		var cj = Math.abs(dj1.x - dj.x) < .001 ? "y" : "x";
		var is = intersect$1(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
		if (is) {
			if (xy[is.x.toFixed(4)] === is.y.toFixed(4)) continue;
			xy[is.x.toFixed(4)] = is.y.toFixed(4);
			var t1 = di.t + Math.abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t);
			var t2 = dj.t + Math.abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
			if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) if (justCount) res += 1;
			else res.push({
				x: is.x,
				y: is.y,
				t1,
				t2
			});
		}
	}
	return res;
};
var interPathHelper = function(path1, path2, justCount) {
	path1 = pathToCurve(path1);
	path2 = pathToCurve(path2);
	var x1;
	var y1;
	var x2;
	var y2;
	var x1m;
	var y1m;
	var x2m;
	var y2m;
	var bez1;
	var bez2;
	var res = justCount ? 0 : [];
	for (var i = 0, ii = path1.length; i < ii; i++) {
		var pi$1 = path1[i];
		if (pi$1[0] === "M") {
			x1 = x1m = pi$1[1];
			y1 = y1m = pi$1[2];
		} else {
			if (pi$1[0] === "C") {
				bez1 = [x1, y1].concat(pi$1.slice(1));
				x1 = bez1[6];
				y1 = bez1[7];
			} else {
				bez1 = [
					x1,
					y1,
					x1,
					y1,
					x1m,
					y1m,
					x1m,
					y1m
				];
				x1 = x1m;
				y1 = y1m;
			}
			for (var j = 0, jj = path2.length; j < jj; j++) {
				var pj = path2[j];
				if (pj[0] === "M") {
					x2 = x2m = pj[1];
					y2 = y2m = pj[2];
				} else {
					if (pj[0] === "C") {
						bez2 = [x2, y2].concat(pj.slice(1));
						x2 = bez2[6];
						y2 = bez2[7];
					} else {
						bez2 = [
							x2,
							y2,
							x2,
							y2,
							x2m,
							y2m,
							x2m,
							y2m
						];
						x2 = x2m;
						y2 = y2m;
					}
					var intr = interHelper(bez1, bez2, justCount);
					if (justCount) res += intr;
					else {
						for (var k = 0, kk = intr.length; k < kk; k++) {
							intr[k].segment1 = i;
							intr[k].segment2 = j;
							intr[k].bez1 = bez1;
							intr[k].bez2 = bez2;
						}
						res = res.concat(intr);
					}
				}
			}
		}
	}
	return res;
};
var intersection = function(path1, path2) {
	return interPathHelper(path1, path2);
};
function decasteljau(points, t) {
	var left$1 = [];
	var right$1 = [];
	function recurse(points$1, t$1) {
		if (points$1.length === 1) {
			left$1.push(points$1[0]);
			right$1.push(points$1[0]);
		} else {
			var middlePoints = [];
			for (var i = 0; i < points$1.length - 1; i++) {
				if (i === 0) left$1.push(points$1[0]);
				if (i === points$1.length - 2) right$1.push(points$1[i + 1]);
				middlePoints[i] = [(1 - t$1) * points$1[i][0] + t$1 * points$1[i + 1][0], (1 - t$1) * points$1[i][1] + t$1 * points$1[i + 1][1]];
			}
			recurse(middlePoints, t$1);
		}
	}
	if (points.length) recurse(points, t);
	return {
		left: left$1,
		right: right$1.reverse()
	};
}
function splitCurve(start, end, count$1) {
	var points = [[start[1], start[2]]];
	count$1 = count$1 || 2;
	var segments = [];
	if (end[0] === "A") {
		points.push(end[6]);
		points.push(end[7]);
	} else if (end[0] === "C") {
		points.push([end[1], end[2]]);
		points.push([end[3], end[4]]);
		points.push([end[5], end[6]]);
	} else if (end[0] === "S" || end[0] === "Q") {
		points.push([end[1], end[2]]);
		points.push([end[3], end[4]]);
	} else points.push([end[1], end[2]]);
	var leftSegments = points;
	var t = 1 / count$1;
	for (var i = 0; i < count$1 - 1; i++) {
		var rt = t / (1 - t * i);
		var split = decasteljau(leftSegments, rt);
		segments.push(split.left);
		leftSegments = split.right;
	}
	segments.push(leftSegments);
	return segments.map(function(segment) {
		var cmd = [];
		if (segment.length === 4) {
			cmd.push("C");
			cmd = cmd.concat(segment[2]);
		}
		if (segment.length >= 3) {
			if (segment.length === 3) cmd.push("Q");
			cmd = cmd.concat(segment[1]);
		}
		if (segment.length === 2) cmd.push("L");
		cmd = cmd.concat(segment[segment.length - 1]);
		return cmd;
	});
}
var splitSegment = function(start, end, count$1) {
	if (count$1 === 1) return [[].concat(start)];
	var segments = [];
	if (end[0] === "L" || end[0] === "C" || end[0] === "Q") segments = segments.concat(splitCurve(start, end, count$1));
	else {
		var temp = [].concat(start);
		if (temp[0] === "M") temp[0] = "L";
		for (var i = 0; i <= count$1 - 1; i++) segments.push(temp);
	}
	return segments;
};
var fillPath = function(source, target) {
	if (source.length === 1) return source;
	var sourceLen = source.length - 1;
	var targetLen = target.length - 1;
	var ratio = sourceLen / targetLen;
	var segmentsToFill = [];
	if (source.length === 1 && source[0][0] === "M") {
		for (var i = 0; i < targetLen - sourceLen; i++) source.push(source[0]);
		return source;
	}
	for (var i = 0; i < targetLen; i++) {
		var index = Math.floor(ratio * i);
		segmentsToFill[index] = (segmentsToFill[index] || 0) + 1;
	}
	var filled = segmentsToFill.reduce(function(filled$1, count$1, i$1) {
		if (i$1 === sourceLen) return filled$1.concat(source[sourceLen]);
		return filled$1.concat(splitSegment(source[i$1], source[i$1 + 1], count$1));
	}, []);
	filled.unshift(source[0]);
	if (target[targetLen] === "Z" || target[targetLen] === "z") filled.push("Z");
	return filled;
};
var isEqual = function(obj1, obj2) {
	if (obj1.length !== obj2.length) return false;
	var result = true;
	each_default(obj1, function(item, i) {
		if (item !== obj2[i]) {
			result = false;
			return false;
		}
	});
	return result;
};
function getMinDiff(del, add$1, modify) {
	var type = null;
	var min$2 = modify;
	if (add$1 < min$2) {
		min$2 = add$1;
		type = "add";
	}
	if (del < min$2) {
		min$2 = del;
		type = "del";
	}
	return {
		type,
		min: min$2
	};
}
var levenshteinDistance = function(source, target) {
	var sourceLen = source.length;
	var targetLen = target.length;
	var sourceSegment;
	var targetSegment;
	var temp = 0;
	if (sourceLen === 0 || targetLen === 0) return null;
	var dist = [];
	for (var i = 0; i <= sourceLen; i++) {
		dist[i] = [];
		dist[i][0] = { min: i };
	}
	for (var j = 0; j <= targetLen; j++) dist[0][j] = { min: j };
	for (var i = 1; i <= sourceLen; i++) {
		sourceSegment = source[i - 1];
		for (var j = 1; j <= targetLen; j++) {
			targetSegment = target[j - 1];
			if (isEqual(sourceSegment, targetSegment)) temp = 0;
			else temp = 1;
			var del = dist[i - 1][j].min + 1;
			var add$1 = dist[i][j - 1].min + 1;
			var modify = dist[i - 1][j - 1].min + temp;
			dist[i][j] = getMinDiff(del, add$1, modify);
		}
	}
	return dist;
};
var fillPathByDiff = function(source, target) {
	var diffMatrix = levenshteinDistance(source, target);
	var sourceLen = source.length;
	var targetLen = target.length;
	var changes = [];
	var index = 1;
	var minPos = 1;
	if (diffMatrix[sourceLen][targetLen].min !== sourceLen) {
		for (var i = 1; i <= sourceLen; i++) {
			var min$2 = diffMatrix[i][i].min;
			minPos = i;
			for (var j = index; j <= targetLen; j++) if (diffMatrix[i][j].min < min$2) {
				min$2 = diffMatrix[i][j].min;
				minPos = j;
			}
			index = minPos;
			if (diffMatrix[i][index].type) changes.push({
				index: i - 1,
				type: diffMatrix[i][index].type
			});
		}
		for (var i = changes.length - 1; i >= 0; i--) {
			index = changes[i].index;
			if (changes[i].type === "add") source.splice(index, 0, [].concat(source[index]));
			else source.splice(index, 1);
		}
	}
	sourceLen = source.length;
	var diff$1 = targetLen - sourceLen;
	if (sourceLen < targetLen) for (var i = 0; i < diff$1; i++) {
		if (source[sourceLen - 1][0] === "z" || source[sourceLen - 1][0] === "Z") source.splice(sourceLen - 2, 0, source[sourceLen - 2]);
		else source.push(source[sourceLen - 1]);
		sourceLen += 1;
	}
	return source;
};
function _splitPoints(points, former, count$1) {
	var result = [].concat(points);
	var index;
	var t = 1 / (count$1 + 1);
	var formerEnd = _getSegmentPoints(former)[0];
	for (var i = 1; i <= count$1; i++) {
		t *= i;
		index = Math.floor(points.length * t);
		if (index === 0) result.unshift([formerEnd[0] * t + points[index][0] * (1 - t), formerEnd[1] * t + points[index][1] * (1 - t)]);
		else result.splice(index, 0, [formerEnd[0] * t + points[index][0] * (1 - t), formerEnd[1] * t + points[index][1] * (1 - t)]);
	}
	return result;
}
function _getSegmentPoints(segment) {
	var points = [];
	switch (segment[0]) {
		case "M":
			points.push([segment[1], segment[2]]);
			break;
		case "L":
			points.push([segment[1], segment[2]]);
			break;
		case "A":
			points.push([segment[6], segment[7]]);
			break;
		case "Q":
			points.push([segment[3], segment[4]]);
			points.push([segment[1], segment[2]]);
			break;
		case "T":
			points.push([segment[1], segment[2]]);
			break;
		case "C":
			points.push([segment[5], segment[6]]);
			points.push([segment[1], segment[2]]);
			points.push([segment[3], segment[4]]);
			break;
		case "S":
			points.push([segment[3], segment[4]]);
			points.push([segment[1], segment[2]]);
			break;
		case "H":
			points.push([segment[1], segment[1]]);
			break;
		case "V":
			points.push([segment[1], segment[1]]);
			break;
		default:
	}
	return points;
}
var formatPath = function(fromPath, toPath) {
	if (fromPath.length <= 1) return fromPath;
	var points;
	for (var i = 0; i < toPath.length; i++) if (fromPath[i][0] !== toPath[i][0]) {
		points = _getSegmentPoints(fromPath[i]);
		switch (toPath[i][0]) {
			case "M":
				fromPath[i] = ["M"].concat(points[0]);
				break;
			case "L":
				fromPath[i] = ["L"].concat(points[0]);
				break;
			case "A":
				fromPath[i] = [].concat(toPath[i]);
				fromPath[i][6] = points[0][0];
				fromPath[i][7] = points[0][1];
				break;
			case "Q":
				if (points.length < 2) if (i > 0) points = _splitPoints(points, fromPath[i - 1], 1);
				else {
					fromPath[i] = toPath[i];
					break;
				}
				fromPath[i] = ["Q"].concat(points.reduce(function(arr, i$1) {
					return arr.concat(i$1);
				}, []));
				break;
			case "T":
				fromPath[i] = ["T"].concat(points[0]);
				break;
			case "C":
				if (points.length < 3) if (i > 0) points = _splitPoints(points, fromPath[i - 1], 2);
				else {
					fromPath[i] = toPath[i];
					break;
				}
				fromPath[i] = ["C"].concat(points.reduce(function(arr, i$1) {
					return arr.concat(i$1);
				}, []));
				break;
			case "S":
				if (points.length < 2) if (i > 0) points = _splitPoints(points, fromPath[i - 1], 1);
				else {
					fromPath[i] = toPath[i];
					break;
				}
				fromPath[i] = ["S"].concat(points.reduce(function(arr, i$1) {
					return arr.concat(i$1);
				}, []));
				break;
			default: fromPath[i] = toPath[i];
		}
	}
	return fromPath;
};

//#endregion
//#region node_modules/@antv/g-base/esm/event/graph-event.js
var GraphEvent = function() {
	function GraphEvent$1(type, event) {
		/**
		* 是否允许冒泡
		* @type {boolean}
		*/
		this.bubbles = true;
		/**
		* 触发对象
		* @type {object}
		*/
		this.target = null;
		/**
		* 监听对象
		* @type {object}
		*/
		this.currentTarget = null;
		/**
		* 委托对象
		* @type {object}
		*/
		this.delegateTarget = null;
		/**
		* 委托事件监听对象的代理对象，即 ev.delegateObject = ev.currentTarget.get('delegateObject')
		* @type {object}
		*/
		this.delegateObject = null;
		/**
		* 是否阻止了原生事件
		* @type {boolean}
		*/
		this.defaultPrevented = false;
		/**
		* 是否阻止传播（向上冒泡）
		* @type {boolean}
		*/
		this.propagationStopped = false;
		/**
		* 触发事件的图形
		* @type {IShape}
		*/
		this.shape = null;
		/**
		* 开始触发事件的图形
		* @type {IShape}
		*/
		this.fromShape = null;
		/**
		* 事件结束时的触发图形
		* @type {IShape}
		*/
		this.toShape = null;
		this.propagationPath = [];
		this.type = type;
		this.name = type;
		this.originalEvent = event;
		this.timeStamp = event.timeStamp;
	}
	/**
	* 阻止浏览器默认的行为
	*/
	GraphEvent$1.prototype.preventDefault = function() {
		this.defaultPrevented = true;
		if (this.originalEvent.preventDefault) this.originalEvent.preventDefault();
	};
	/**
	* 阻止冒泡
	*/
	GraphEvent$1.prototype.stopPropagation = function() {
		this.propagationStopped = true;
	};
	GraphEvent$1.prototype.toString = function() {
		return "[Event (type=" + this.type + ")]";
	};
	GraphEvent$1.prototype.save = function() {};
	GraphEvent$1.prototype.restore = function() {};
	return GraphEvent$1;
}();
var graph_event_default = GraphEvent;

//#endregion
//#region node_modules/@antv/g-base/esm/util/util.js
function removeFromArray(arr, obj) {
	var index = arr.indexOf(obj);
	if (index !== -1) arr.splice(index, 1);
}
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
function isParent(container, shape) {
	if (container.isCanvas()) return true;
	var parent = shape.getParent();
	var isParent$1 = false;
	while (parent) {
		if (parent === container) {
			isParent$1 = true;
			break;
		}
		parent = parent.getParent();
	}
	return isParent$1;
}
function isAllowCapture(element) {
	return element.cfg.visible && element.cfg.capture;
}

//#endregion
//#region node_modules/@antv/g-base/esm/abstract/base.js
var Base = function(_super) {
	__extends(Base$2, _super);
	function Base$2(cfg) {
		var _this = _super.call(this) || this;
		/**
		* 是否被销毁
		* @type {boolean}
		*/
		_this.destroyed = false;
		var defaultCfg = _this.getDefaultCfg();
		_this.cfg = mix(defaultCfg, cfg);
		return _this;
	}
	/**
	* @protected
	* 默认的配置项
	* @returns {object} 默认的配置项
	*/
	Base$2.prototype.getDefaultCfg = function() {
		return {};
	};
	Base$2.prototype.get = function(name) {
		return this.cfg[name];
	};
	Base$2.prototype.set = function(name, value$1) {
		this.cfg[name] = value$1;
	};
	Base$2.prototype.destroy = function() {
		this.cfg = { destroyed: true };
		this.off();
		this.destroyed = true;
	};
	return Base$2;
}(esm_default$1);
var base_default$15 = Base;

//#endregion
//#region node_modules/detect-browser/es/index.js
var __spreadArray$1 = void 0 && (void 0).__spreadArray || function(to, from, pack$1) {
	if (pack$1 || arguments.length === 2) {
		for (var i = 0, l = from.length, ar; i < l; i++) if (ar || !(i in from)) {
			if (!ar) ar = Array.prototype.slice.call(from, 0, i);
			ar[i] = from[i];
		}
	}
	return to.concat(ar || Array.prototype.slice.call(from));
};
var BrowserInfo = function() {
	function BrowserInfo$1(name, version$3, os) {
		this.name = name;
		this.version = version$3;
		this.os = os;
		this.type = "browser";
	}
	return BrowserInfo$1;
}();
var NodeInfo = function() {
	function NodeInfo$1(version$3) {
		this.version = version$3;
		this.type = "node";
		this.name = "node";
		this.os = process.platform;
	}
	return NodeInfo$1;
}();
var SearchBotDeviceInfo = function() {
	function SearchBotDeviceInfo$1(name, version$3, os, bot) {
		this.name = name;
		this.version = version$3;
		this.os = os;
		this.bot = bot;
		this.type = "bot-device";
	}
	return SearchBotDeviceInfo$1;
}();
var BotInfo = function() {
	function BotInfo$1() {
		this.type = "bot";
		this.bot = true;
		this.name = "bot";
		this.version = null;
		this.os = null;
	}
	return BotInfo$1;
}();
var ReactNativeInfo = function() {
	function ReactNativeInfo$1() {
		this.type = "react-native";
		this.name = "react-native";
		this.version = null;
		this.os = null;
	}
	return ReactNativeInfo$1;
}();
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
	["aol", /AOLShield\/([0-9\._]+)/],
	["edge", /Edge\/([0-9\._]+)/],
	["edge-ios", /EdgiOS\/([0-9\._]+)/],
	["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
	["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
	["samsung", /SamsungBrowser\/([0-9\.]+)/],
	["silk", /\bSilk\/([0-9._-]+)\b/],
	["miui", /MiuiBrowser\/([0-9\.]+)$/],
	["beaker", /BeakerBrowser\/([0-9\.]+)/],
	["edge-chromium", /EdgA?\/([0-9\.]+)/],
	["chromium-webview", /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
	["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
	["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
	["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
	["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
	["fxios", /FxiOS\/([0-9\.]+)/],
	["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
	["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
	["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
	["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
	["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
	["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
	["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
	["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
	["ie", /MSIE\s(7\.0)/],
	["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
	["android", /Android\s([0-9\.]+)/],
	["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
	["safari", /Version\/([0-9\._]+).*Safari/],
	["facebook", /FB[AS]V\/([0-9\.]+)/],
	["instagram", /Instagram\s([0-9\.]+)/],
	["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
	["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
	["curl", /^curl\/([0-9\.]+)$/],
	["searchbot", SEARCHBOX_UA_REGEX]
];
var operatingSystemRules = [
	["iOS", /iP(hone|od|ad)/],
	["Android OS", /Android/],
	["BlackBerry OS", /BlackBerry|BB10/],
	["Windows Mobile", /IEMobile/],
	["Amazon OS", /Kindle/],
	["Windows 3.11", /Win16/],
	["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
	["Windows 98", /(Windows 98)|(Win98)/],
	["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
	["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
	["Windows Server 2003", /(Windows NT 5.2)/],
	["Windows Vista", /(Windows NT 6.0)/],
	["Windows 7", /(Windows NT 6.1)/],
	["Windows 8", /(Windows NT 6.2)/],
	["Windows 8.1", /(Windows NT 6.3)/],
	["Windows 10", /(Windows NT 10.0)/],
	["Windows ME", /Windows ME/],
	["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
	["Open BSD", /OpenBSD/],
	["Sun OS", /SunOS/],
	["Chrome OS", /CrOS/],
	["Linux", /(Linux)|(X11)/],
	["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
	["QNX", /QNX/],
	["BeOS", /BeOS/],
	["OS/2", /OS\/2/]
];
function detect(userAgent) {
	if (!!userAgent) return parseUserAgent(userAgent);
	if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") return new ReactNativeInfo();
	if (typeof navigator !== "undefined") return parseUserAgent(navigator.userAgent);
	return getNodeVersion();
}
function matchUserAgent(ua) {
	return ua !== "" && userAgentRules.reduce(function(matched, _a$5) {
		var browser$1 = _a$5[0], regex = _a$5[1];
		if (matched) return matched;
		var uaMatch = regex.exec(ua);
		return !!uaMatch && [browser$1, uaMatch];
	}, false);
}
function parseUserAgent(ua) {
	var matchedRule = matchUserAgent(ua);
	if (!matchedRule) return null;
	var name = matchedRule[0], match = matchedRule[1];
	if (name === "searchbot") return new BotInfo();
	var versionParts = match[1] && match[1].split(".").join("_").split("_").slice(0, 3);
	if (versionParts) {
		if (versionParts.length < REQUIRED_VERSION_PARTS) versionParts = __spreadArray$1(__spreadArray$1([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
	} else versionParts = [];
	var version$3 = versionParts.join(".");
	var os = detectOS(ua);
	var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
	if (searchBotMatch && searchBotMatch[1]) return new SearchBotDeviceInfo(name, version$3, os, searchBotMatch[1]);
	return new BrowserInfo(name, version$3, os);
}
function detectOS(ua) {
	for (var ii = 0, count$1 = operatingSystemRules.length; ii < count$1; ii++) {
		var _a$5 = operatingSystemRules[ii], os = _a$5[0];
		if (_a$5[1].exec(ua)) return os;
	}
	return null;
}
function getNodeVersion() {
	return typeof process !== "undefined" && process.version ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count$1) {
	var output = [];
	for (var ii = 0; ii < count$1; ii++) output.push("0");
	return output;
}

//#endregion
//#region node_modules/@antv/matrix-util/esm/ext.js
function leftTranslate(out, a, v) {
	var transMat = [
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0
	];
	fromTranslation(transMat, v);
	return multiply(out, transMat, a);
}
function leftRotate(out, a, rad) {
	var rotateMat = [
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0
	];
	fromRotation(rotateMat, rad);
	return multiply(out, rotateMat, a);
}
function leftScale(out, a, v) {
	var scaleMat = [
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0
	];
	fromScaling(scaleMat, v);
	return multiply(out, scaleMat, a);
}
function leftMultiply(out, a, a1) {
	return multiply(out, a1, a);
}
/**
* 根据 actions 来做 transform
* @param m
* @param actions
*/
function transform$6(m, actions) {
	var matrix = m ? [].concat(m) : [
		1,
		0,
		0,
		0,
		1,
		0,
		0,
		0,
		1
	];
	for (var i = 0, len = actions.length; i < len; i++) {
		var action = actions[i];
		switch (action[0]) {
			case "t":
				leftTranslate(matrix, matrix, [action[1], action[2]]);
				break;
			case "s":
				leftScale(matrix, matrix, [action[1], action[2]]);
				break;
			case "r":
				leftRotate(matrix, matrix, action[1]);
				break;
			case "m":
				leftMultiply(matrix, matrix, action[1]);
				break;
			default: break;
		}
	}
	return matrix;
}
/**
* 向量 v1 到 向量 v2 夹角的方向
* @param  {Array} v1 向量
* @param  {Array} v2 向量
* @return {Boolean} >= 0 顺时针 < 0 逆时针
*/
function direction(v1, v2) {
	return v1[0] * v2[1] - v2[0] * v1[1];
}
/**
* 二维向量 v1 到 v2 的夹角
* @param v1
* @param v2
* @param direct
*/
function angleTo(v1, v2, direct) {
	var ang = angle(v1, v2);
	var angleLargeThanPI = direction(v1, v2) >= 0;
	if (direct) {
		if (angleLargeThanPI) return Math.PI * 2 - ang;
		return ang;
	}
	if (angleLargeThanPI) return ang;
	return Math.PI * 2 - ang;
}

//#endregion
//#region node_modules/@antv/g-base/esm/util/matrix.js
/**
* @fileoverview 矩阵运算，本来是要引入 gl-matrix, 但是考虑到 g-mobile 对大小有限制，同时 g-webgl 使用的 matrix 不一致
* 所以，这里仅实现 2D 几个运算，上层自己引入 gl-matrix
* @author dxq613@gmail.com
*/
/**
* 3阶矩阵相乘
* @param {number[]} a 矩阵1
* @param {number[]} b 矩阵2
*/
function multiplyMatrix(a, b) {
	var out = [];
	var a00 = a[0];
	var a01 = a[1];
	var a02 = a[2];
	var a10 = a[3];
	var a11 = a[4];
	var a12 = a[5];
	var a20 = a[6];
	var a21 = a[7];
	var a22 = a[8];
	var b00 = b[0];
	var b01 = b[1];
	var b02 = b[2];
	var b10 = b[3];
	var b11 = b[4];
	var b12 = b[5];
	var b20 = b[6];
	var b21 = b[7];
	var b22 = b[8];
	out[0] = b00 * a00 + b01 * a10 + b02 * a20;
	out[1] = b00 * a01 + b01 * a11 + b02 * a21;
	out[2] = b00 * a02 + b01 * a12 + b02 * a22;
	out[3] = b10 * a00 + b11 * a10 + b12 * a20;
	out[4] = b10 * a01 + b11 * a11 + b12 * a21;
	out[5] = b10 * a02 + b11 * a12 + b12 * a22;
	out[6] = b20 * a00 + b21 * a10 + b22 * a20;
	out[7] = b20 * a01 + b21 * a11 + b22 * a21;
	out[8] = b20 * a02 + b21 * a12 + b22 * a22;
	return out;
}
/**
* 3阶矩阵同2阶向量相乘
* @param {number[]} m 矩阵
* @param {number[]} v 二阶向量
*/
function multiplyVec2(m, v) {
	var out = [];
	var x = v[0];
	var y = v[1];
	out[0] = m[0] * x + m[3] * y + m[6];
	out[1] = m[1] * x + m[4] * y + m[7];
	return out;
}
/**
* 矩阵的逆
* @param {number[]} a 矩阵
*/
function invert(a) {
	var out = [];
	var a00 = a[0];
	var a01 = a[1];
	var a02 = a[2];
	var a10 = a[3];
	var a11 = a[4];
	var a12 = a[5];
	var a20 = a[6];
	var a21 = a[7];
	var a22 = a[8];
	var b01 = a22 * a11 - a12 * a21;
	var b11 = -a22 * a10 + a12 * a20;
	var b21 = a21 * a10 - a11 * a20;
	var det = a00 * b01 + a01 * b11 + a02 * b21;
	if (!det) return null;
	det = 1 / det;
	out[0] = b01 * det;
	out[1] = (-a22 * a01 + a02 * a21) * det;
	out[2] = (a12 * a01 - a02 * a11) * det;
	out[3] = b11 * det;
	out[4] = (a22 * a00 - a02 * a20) * det;
	out[5] = (-a12 * a00 + a02 * a10) * det;
	out[6] = b21 * det;
	out[7] = (-a21 * a00 + a01 * a20) * det;
	out[8] = (a11 * a00 - a01 * a10) * det;
	return out;
}

//#endregion
//#region node_modules/@antv/g-base/esm/abstract/element.js
var transform$5 = transform$6;
var MATRIX = "matrix";
var CLONE_CFGS = [
	"zIndex",
	"capture",
	"visible",
	"type"
];
var RESERVED_PORPS = ["repeat"];
var DELEGATION_SPLIT = ":";
var WILDCARD = "*";
function _cloneArrayAttr(arr) {
	var result = [];
	for (var i = 0; i < arr.length; i++) if (is_array_default(arr[i])) result.push([].concat(arr[i]));
	else result.push(arr[i]);
	return result;
}
function getFormatFromAttrs(toAttrs, shape) {
	var fromAttrs = {};
	var attrs = shape.attrs;
	for (var k in toAttrs) fromAttrs[k] = attrs[k];
	return fromAttrs;
}
function getFormatToAttrs(props, shape) {
	var toAttrs = {};
	var attrs = shape.attr();
	each_default(props, function(v, k) {
		if (RESERVED_PORPS.indexOf(k) === -1 && !is_equal_default(attrs[k], v)) toAttrs[k] = v;
	});
	return toAttrs;
}
function checkExistedAttrs(animations, animation$6) {
	if (animation$6.onFrame) return animations;
	var startTime = animation$6.startTime, delay = animation$6.delay, duration = animation$6.duration;
	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;
	each_default(animations, function(item) {
		if (startTime + delay < item.startTime + item.delay + item.duration && duration > item.delay) each_default(animation$6.toAttrs, function(v, k) {
			if (hasOwnProperty$3.call(item.toAttrs, k)) {
				delete item.toAttrs[k];
				delete item.fromAttrs[k];
			}
		});
	});
	return animations;
}
var Element$2 = function(_super) {
	__extends(Element$3, _super);
	function Element$3(cfg) {
		var _this = _super.call(this, cfg) || this;
		/**
		* @protected
		* 图形属性
		* @type {ShapeAttrs}
		*/
		_this.attrs = {};
		var attrs = _this.getDefaultAttrs();
		mix(attrs, cfg.attrs);
		_this.attrs = attrs;
		_this.initAttrs(attrs);
		_this.initAnimate();
		return _this;
	}
	Element$3.prototype.getDefaultCfg = function() {
		return {
			visible: true,
			capture: true,
			zIndex: 0
		};
	};
	/**
	* @protected
	* 获取默认的属相
	*/
	Element$3.prototype.getDefaultAttrs = function() {
		return {
			matrix: this.getDefaultMatrix(),
			opacity: 1
		};
	};
	/**
	* @protected
	* 一些方法调用会引起画布变化
	* @param {ChangeType} changeType 改变的类型
	*/
	Element$3.prototype.onCanvasChange = function(changeType) {};
	/**
	* @protected
	* 初始化属性，有些属性需要加工
	* @param {object} attrs 属性值
	*/
	Element$3.prototype.initAttrs = function(attrs) {};
	/**
	* @protected
	* 初始化动画
	*/
	Element$3.prototype.initAnimate = function() {
		this.set("animable", true);
		this.set("animating", false);
	};
	Element$3.prototype.isGroup = function() {
		return false;
	};
	Element$3.prototype.getParent = function() {
		return this.get("parent");
	};
	Element$3.prototype.getCanvas = function() {
		return this.get("canvas");
	};
	Element$3.prototype.attr = function() {
		var _a$5;
		var args = [];
		for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
		var name = args[0], value$1 = args[1];
		if (!name) return this.attrs;
		if (is_object_default(name)) {
			for (var k in name) this.setAttr(k, name[k]);
			this.afterAttrsChange(name);
			return this;
		}
		if (args.length === 2) {
			this.setAttr(name, value$1);
			this.afterAttrsChange((_a$5 = {}, _a$5[name] = value$1, _a$5));
			return this;
		}
		return this.attrs[name];
	};
	Element$3.prototype.isClipped = function(refX, refY) {
		var clip = this.getClip();
		return clip && !clip.isHit(refX, refY);
	};
	/**
	* 内部设置属性值的接口
	* @param {string} name 属性名
	* @param {any} value 属性值
	*/
	Element$3.prototype.setAttr = function(name, value$1) {
		var originValue = this.attrs[name];
		if (originValue !== value$1) {
			this.attrs[name] = value$1;
			this.onAttrChange(name, value$1, originValue);
		}
	};
	/**
	* @protected
	* 属性值发生改变
	* @param {string} name 属性名
	* @param {any} value 属性值
	* @param {any} originValue 属性值
	*/
	Element$3.prototype.onAttrChange = function(name, value$1, originValue) {
		if (name === "matrix") this.set("totalMatrix", null);
	};
	/**
	* 属性更改后需要做的事情
	* @protected
	*/
	Element$3.prototype.afterAttrsChange = function(targetAttrs) {
		if (this.cfg.isClipShape) {
			var applyTo = this.cfg.applyTo;
			if (applyTo) applyTo.onCanvasChange("clip");
		} else this.onCanvasChange("attr");
	};
	Element$3.prototype.show = function() {
		this.set("visible", true);
		this.onCanvasChange("show");
		return this;
	};
	Element$3.prototype.hide = function() {
		this.set("visible", false);
		this.onCanvasChange("hide");
		return this;
	};
	Element$3.prototype.setZIndex = function(zIndex) {
		this.set("zIndex", zIndex);
		var parent = this.getParent();
		if (parent) parent.sort();
		return this;
	};
	Element$3.prototype.toFront = function() {
		var parent = this.getParent();
		if (!parent) return;
		var children = parent.getChildren();
		this.get("el");
		var index = children.indexOf(this);
		children.splice(index, 1);
		children.push(this);
		this.onCanvasChange("zIndex");
	};
	Element$3.prototype.toBack = function() {
		var parent = this.getParent();
		if (!parent) return;
		var children = parent.getChildren();
		this.get("el");
		var index = children.indexOf(this);
		children.splice(index, 1);
		children.unshift(this);
		this.onCanvasChange("zIndex");
	};
	Element$3.prototype.remove = function(destroy) {
		if (destroy === void 0) destroy = true;
		var parent = this.getParent();
		if (parent) {
			removeFromArray(parent.getChildren(), this);
			if (!parent.get("clearing")) this.onCanvasChange("remove");
		} else this.onCanvasChange("remove");
		if (destroy) this.destroy();
	};
	Element$3.prototype.resetMatrix = function() {
		this.attr(MATRIX, this.getDefaultMatrix());
		this.onCanvasChange("matrix");
	};
	Element$3.prototype.getMatrix = function() {
		return this.attr(MATRIX);
	};
	Element$3.prototype.setMatrix = function(m) {
		this.attr(MATRIX, m);
		this.onCanvasChange("matrix");
	};
	Element$3.prototype.getTotalMatrix = function() {
		var totalMatrix = this.cfg.totalMatrix;
		if (!totalMatrix) {
			var currentMatrix = this.attr("matrix");
			var parentMatrix = this.cfg.parentMatrix;
			if (parentMatrix && currentMatrix) totalMatrix = multiplyMatrix(parentMatrix, currentMatrix);
			else totalMatrix = currentMatrix || parentMatrix;
			this.set("totalMatrix", totalMatrix);
		}
		return totalMatrix;
	};
	Element$3.prototype.applyMatrix = function(matrix) {
		var currentMatrix = this.attr("matrix");
		var totalMatrix = null;
		if (matrix && currentMatrix) totalMatrix = multiplyMatrix(matrix, currentMatrix);
		else totalMatrix = currentMatrix || matrix;
		this.set("totalMatrix", totalMatrix);
		this.set("parentMatrix", matrix);
	};
	/**
	* @protected
	* 获取默认的矩阵
	* @returns {number[]|null} 默认的矩阵
	*/
	Element$3.prototype.getDefaultMatrix = function() {
		return null;
	};
	Element$3.prototype.applyToMatrix = function(v) {
		var matrix = this.attr("matrix");
		if (matrix) return multiplyVec2(matrix, v);
		return v;
	};
	Element$3.prototype.invertFromMatrix = function(v) {
		var matrix = this.attr("matrix");
		if (matrix) {
			var invertMatrix = invert(matrix);
			if (invertMatrix) return multiplyVec2(invertMatrix, v);
		}
		return v;
	};
	Element$3.prototype.setClip = function(clipCfg) {
		var canvas = this.getCanvas();
		var clipShape = null;
		if (clipCfg) {
			var ShapeBase$3 = this.getShapeBase();
			var shapeType = upper_first_default(clipCfg.type);
			var Cons = ShapeBase$3[shapeType];
			if (Cons) clipShape = new Cons({
				type: clipCfg.type,
				isClipShape: true,
				applyTo: this,
				attrs: clipCfg.attrs,
				canvas
			});
		}
		this.set("clipShape", clipShape);
		this.onCanvasChange("clip");
		return clipShape;
	};
	Element$3.prototype.getClip = function() {
		var clipShape = this.cfg.clipShape;
		if (!clipShape) return null;
		return clipShape;
	};
	Element$3.prototype.clone = function() {
		var _this = this;
		var originAttrs = this.attrs;
		var attrs = {};
		each_default(originAttrs, function(i, k) {
			if (is_array_default(originAttrs[k])) attrs[k] = _cloneArrayAttr(originAttrs[k]);
			else attrs[k] = originAttrs[k];
		});
		var cons = this.constructor;
		var clone$1 = new cons({ attrs });
		each_default(CLONE_CFGS, function(cfgName) {
			clone$1.set(cfgName, _this.get(cfgName));
		});
		return clone$1;
	};
	Element$3.prototype.destroy = function() {
		if (this.destroyed) return;
		this.attrs = {};
		_super.prototype.destroy.call(this);
	};
	/**
	* 是否处于动画暂停状态
	* @return {boolean} 是否处于动画暂停状态
	*/
	Element$3.prototype.isAnimatePaused = function() {
		return this.get("_pause").isPaused;
	};
	/**
	* 执行动画，支持多种函数签名
	* 1. animate(toAttrs: ElementAttrs, duration: number, easing?: string, callback?: () => void, delay?: number)
	* 2. animate(onFrame: OnFrame, duration: number, easing?: string, callback?: () => void, delay?: number)
	* 3. animate(toAttrs: ElementAttrs, cfg: AnimateCfg)
	* 4. animate(onFrame: OnFrame, cfg: AnimateCfg)
	* 各个参数的含义为:
	*   toAttrs  动画最终状态
	*   onFrame  自定义帧动画函数
	*   duration 动画执行时间
	*   easing   动画缓动效果
	*   callback 动画执行后的回调
	*   delay    动画延迟时间
	*/
	Element$3.prototype.animate = function() {
		var args = [];
		for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
		if (!this.get("timeline") && !this.get("canvas")) return;
		this.set("animating", true);
		var timeline = this.get("timeline");
		if (!timeline) {
			timeline = this.get("canvas").get("timeline");
			this.set("timeline", timeline);
		}
		var animations = this.get("animations") || [];
		if (!timeline.timer) timeline.initTimer();
		var toAttrs = args[0], duration = args[1], _a$5 = args[2], easing = _a$5 === void 0 ? "easeLinear" : _a$5, _b = args[3], callback = _b === void 0 ? noop_default : _b, _c = args[4], delay = _c === void 0 ? 0 : _c;
		var onFrame;
		var repeat;
		var pauseCallback;
		var resumeCallback;
		var animateCfg;
		if (is_function_default(toAttrs)) {
			onFrame = toAttrs;
			toAttrs = {};
		} else if (is_object_default(toAttrs) && toAttrs.onFrame) {
			onFrame = toAttrs.onFrame;
			repeat = toAttrs.repeat;
		}
		if (is_object_default(duration)) {
			animateCfg = duration;
			duration = animateCfg.duration;
			easing = animateCfg.easing || "easeLinear";
			delay = animateCfg.delay || 0;
			repeat = animateCfg.repeat || repeat || false;
			callback = animateCfg.callback || noop_default;
			pauseCallback = animateCfg.pauseCallback || noop_default;
			resumeCallback = animateCfg.resumeCallback || noop_default;
		} else {
			if (is_number_default(callback)) {
				delay = callback;
				callback = null;
			}
			if (is_function_default(easing)) {
				callback = easing;
				easing = "easeLinear";
			} else easing = easing || "easeLinear";
		}
		var formatToAttrs = getFormatToAttrs(toAttrs, this);
		var animation$6 = {
			fromAttrs: getFormatFromAttrs(formatToAttrs, this),
			toAttrs: formatToAttrs,
			duration,
			easing,
			repeat,
			callback,
			pauseCallback,
			resumeCallback,
			delay,
			startTime: timeline.getTime(),
			id: unique_id_default(),
			onFrame,
			pathFormatted: false
		};
		if (animations.length > 0) animations = checkExistedAttrs(animations, animation$6);
		else timeline.addAnimator(this);
		animations.push(animation$6);
		this.set("animations", animations);
		this.set("_pause", { isPaused: false });
	};
	/**
	* 停止动画
	* @param {boolean} toEnd 是否到动画的最终状态
	*/
	Element$3.prototype.stopAnimate = function(toEnd) {
		var _this = this;
		if (toEnd === void 0) toEnd = true;
		var animations = this.get("animations");
		each_default(animations, function(animation$6) {
			if (toEnd) if (animation$6.onFrame) _this.attr(animation$6.onFrame(1));
			else _this.attr(animation$6.toAttrs);
			if (animation$6.callback) animation$6.callback();
		});
		this.set("animating", false);
		this.set("animations", []);
	};
	/**
	* 暂停动画
	*/
	Element$3.prototype.pauseAnimate = function() {
		var timeline = this.get("timeline");
		var animations = this.get("animations");
		var pauseTime = timeline.getTime();
		each_default(animations, function(animation$6) {
			animation$6._paused = true;
			animation$6._pauseTime = pauseTime;
			if (animation$6.pauseCallback) animation$6.pauseCallback();
		});
		this.set("_pause", {
			isPaused: true,
			pauseTime
		});
		return this;
	};
	/**
	* 恢复动画
	*/
	Element$3.prototype.resumeAnimate = function() {
		var current = this.get("timeline").getTime();
		var animations = this.get("animations");
		var pauseTime = this.get("_pause").pauseTime;
		each_default(animations, function(animation$6) {
			animation$6.startTime = animation$6.startTime + (current - pauseTime);
			animation$6._paused = false;
			animation$6._pauseTime = null;
			if (animation$6.resumeCallback) animation$6.resumeCallback();
		});
		this.set("_pause", { isPaused: false });
		this.set("animations", animations);
		return this;
	};
	/**
	* 触发委托事件
	* @param  {string}     type 事件类型
	* @param  {GraphEvent} eventObj 事件对象
	*/
	Element$3.prototype.emitDelegation = function(type, eventObj) {
		var _this = this;
		var paths = eventObj.propagationPath;
		this.getEvents();
		var relativeShape;
		if (type === "mouseenter") relativeShape = eventObj.fromShape;
		else if (type === "mouseleave") relativeShape = eventObj.toShape;
		var _loop_1 = function(i$1) {
			var element = paths[i$1];
			var name_1 = element.get("name");
			if (name_1) {
				if ((element.isGroup() || element.isCanvas && element.isCanvas()) && relativeShape && isParent(element, relativeShape)) return "break";
				if (is_array_default(name_1)) each_default(name_1, function(subName) {
					_this.emitDelegateEvent(element, subName, eventObj);
				});
				else this_1.emitDelegateEvent(element, name_1, eventObj);
			}
		};
		var this_1 = this;
		for (var i = 0; i < paths.length; i++) if (_loop_1(i) === "break") break;
	};
	Element$3.prototype.emitDelegateEvent = function(element, name, eventObj) {
		var events = this.getEvents();
		var eventName = name + DELEGATION_SPLIT + eventObj.type;
		if (events[eventName] || events[WILDCARD]) {
			eventObj.name = eventName;
			eventObj.currentTarget = element;
			eventObj.delegateTarget = this;
			eventObj.delegateObject = element.get("delegateObject");
			this.emit(eventName, eventObj);
		}
	};
	/**
	* 移动元素
	* @param {number} translateX 水平移动距离
	* @param {number} translateY 垂直移动距离
	* @return {IElement} 元素
	*/
	Element$3.prototype.translate = function(translateX, translateY) {
		if (translateX === void 0) translateX = 0;
		if (translateY === void 0) translateY = 0;
		var matrix = this.getMatrix();
		var newMatrix = transform$5(matrix, [[
			"t",
			translateX,
			translateY
		]]);
		this.setMatrix(newMatrix);
		return this;
	};
	/**
	* 移动元素到目标位置
	* @param {number} targetX 目标位置的水平坐标
	* @param {number} targetX 目标位置的垂直坐标
	* @return {IElement} 元素
	*/
	Element$3.prototype.move = function(targetX, targetY) {
		var x = this.attr("x") || 0;
		var y = this.attr("y") || 0;
		this.translate(targetX - x, targetY - y);
		return this;
	};
	/**
	* 移动元素到目标位置，等价于 move 方法。由于 moveTo 的语义性更强，因此在文档中推荐使用 moveTo 方法
	* @param {number} targetX 目标位置的 x 轴坐标
	* @param {number} targetY 目标位置的 y 轴坐标
	* @return {IElement} 元素
	*/
	Element$3.prototype.moveTo = function(targetX, targetY) {
		return this.move(targetX, targetY);
	};
	/**
	* 缩放元素
	* @param {number} ratioX 水平缩放比例
	* @param {number} ratioY 垂直缩放比例
	* @return {IElement} 元素
	*/
	Element$3.prototype.scale = function(ratioX, ratioY) {
		var matrix = this.getMatrix();
		var newMatrix = transform$5(matrix, [[
			"s",
			ratioX,
			ratioY || ratioX
		]]);
		this.setMatrix(newMatrix);
		return this;
	};
	/**
	* 以画布左上角 (0, 0) 为中心旋转元素
	* @param {number} radian 旋转角度(弧度值)
	* @return {IElement} 元素
	*/
	Element$3.prototype.rotate = function(radian) {
		var matrix = this.getMatrix();
		var newMatrix = transform$5(matrix, [["r", radian]]);
		this.setMatrix(newMatrix);
		return this;
	};
	/**
	* 以起始点为中心旋转元素
	* @param {number} radian 旋转角度(弧度值)
	* @return {IElement} 元素
	*/
	Element$3.prototype.rotateAtStart = function(rotate$2) {
		var _a$5 = this.attr(), x = _a$5.x, y = _a$5.y;
		var matrix = this.getMatrix();
		var newMatrix = transform$5(matrix, [
			[
				"t",
				-x,
				-y
			],
			["r", rotate$2],
			[
				"t",
				x,
				y
			]
		]);
		this.setMatrix(newMatrix);
		return this;
	};
	/**
	* 以任意点 (x, y) 为中心旋转元素
	* @param {number} radian 旋转角度(弧度值)
	* @return {IElement} 元素
	*/
	Element$3.prototype.rotateAtPoint = function(x, y, rotate$2) {
		var matrix = this.getMatrix();
		var newMatrix = transform$5(matrix, [
			[
				"t",
				-x,
				-y
			],
			["r", rotate$2],
			[
				"t",
				x,
				y
			]
		]);
		this.setMatrix(newMatrix);
		return this;
	};
	return Element$3;
}(base_default$15);
var element_default$1 = Element$2;

//#endregion
//#region node_modules/@antv/g-base/esm/abstract/container.js
var SHAPE_MAP = {};
var INDEX = "_INDEX";
/**
* 设置 canvas
* @param {IElement} element 元素
* @param {ICanvas}  canvas  画布
*/
function setCanvas(element, canvas) {
	element.set("canvas", canvas);
	if (element.isGroup()) {
		var children = element.get("children");
		if (children.length) children.forEach(function(child) {
			setCanvas(child, canvas);
		});
	}
}
/**
* 设置 timeline
* @param {IElement} element  元素
* @param {Timeline} timeline 时间轴
*/
function setTimeline(element, timeline) {
	element.set("timeline", timeline);
	if (element.isGroup()) {
		var children = element.get("children");
		if (children.length) children.forEach(function(child) {
			setTimeline(child, timeline);
		});
	}
}
function removeChild(container, element, destroy) {
	if (destroy === void 0) destroy = true;
	if (destroy) element.destroy();
	else {
		element.set("parent", null);
		element.set("canvas", null);
	}
	removeFromArray(container.getChildren(), element);
}
function getComparer(compare$1) {
	return function(left$1, right$1) {
		var result = compare$1(left$1, right$1);
		return result === 0 ? left$1[INDEX] - right$1[INDEX] : result;
	};
}
var Container = function(_super) {
	__extends(Container$1, _super);
	function Container$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	Container$1.prototype.isCanvas = function() {
		return false;
	};
	Container$1.prototype.getBBox = function() {
		var minX = Infinity;
		var maxX = -Infinity;
		var minY = Infinity;
		var maxY$1 = -Infinity;
		var children = this.getChildren().filter(function(child) {
			return child.get("visible") && (!child.isGroup() || child.isGroup() && child.getChildren().length > 0);
		});
		if (children.length > 0) each_default(children, function(child) {
			var _a$5 = child.getBBox(), childMinX = _a$5.minX, childMaxX = _a$5.maxX, childMinY = _a$5.minY, childMaxY = _a$5.maxY;
			if (childMinX < minX) minX = childMinX;
			if (childMaxX > maxX) maxX = childMaxX;
			if (childMinY < minY) minY = childMinY;
			if (childMaxY > maxY$1) maxY$1 = childMaxY;
		});
		else {
			minX = 0;
			maxX = 0;
			minY = 0;
			maxY$1 = 0;
		}
		return {
			x: minX,
			y: minY,
			minX,
			minY,
			maxX,
			maxY: maxY$1,
			width: maxX - minX,
			height: maxY$1 - minY
		};
	};
	Container$1.prototype.getCanvasBBox = function() {
		var minX = Infinity;
		var maxX = -Infinity;
		var minY = Infinity;
		var maxY$1 = -Infinity;
		var children = this.getChildren().filter(function(child) {
			return child.get("visible") && (!child.isGroup() || child.isGroup() && child.getChildren().length > 0);
		});
		if (children.length > 0) each_default(children, function(child) {
			var _a$5 = child.getCanvasBBox(), childMinX = _a$5.minX, childMaxX = _a$5.maxX, childMinY = _a$5.minY, childMaxY = _a$5.maxY;
			if (childMinX < minX) minX = childMinX;
			if (childMaxX > maxX) maxX = childMaxX;
			if (childMinY < minY) minY = childMinY;
			if (childMaxY > maxY$1) maxY$1 = childMaxY;
		});
		else {
			minX = 0;
			maxX = 0;
			minY = 0;
			maxY$1 = 0;
		}
		return {
			x: minX,
			y: minY,
			minX,
			minY,
			maxX,
			maxY: maxY$1,
			width: maxX - minX,
			height: maxY$1 - minY
		};
	};
	Container$1.prototype.getDefaultCfg = function() {
		var cfg = _super.prototype.getDefaultCfg.call(this);
		cfg["children"] = [];
		return cfg;
	};
	Container$1.prototype.onAttrChange = function(name, value$1, originValue) {
		_super.prototype.onAttrChange.call(this, name, value$1, originValue);
		if (name === "matrix") {
			var totalMatrix = this.getTotalMatrix();
			this._applyChildrenMarix(totalMatrix);
		}
	};
	Container$1.prototype.applyMatrix = function(matrix) {
		var preTotalMatrix = this.getTotalMatrix();
		_super.prototype.applyMatrix.call(this, matrix);
		var totalMatrix = this.getTotalMatrix();
		if (totalMatrix === preTotalMatrix) return;
		this._applyChildrenMarix(totalMatrix);
	};
	Container$1.prototype._applyChildrenMarix = function(totalMatrix) {
		var children = this.getChildren();
		each_default(children, function(child) {
			child.applyMatrix(totalMatrix);
		});
	};
	Container$1.prototype.addShape = function() {
		var args = [];
		for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
		var type = args[0];
		var cfg = args[1];
		if (is_object_default(type)) cfg = type;
		else cfg["type"] = type;
		var shapeType = SHAPE_MAP[cfg.type];
		if (!shapeType) {
			shapeType = upper_first_default(cfg.type);
			SHAPE_MAP[cfg.type] = shapeType;
		}
		var shape = new (this.getShapeBase())[shapeType](cfg);
		this.add(shape);
		return shape;
	};
	Container$1.prototype.addGroup = function() {
		var args = [];
		for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
		var groupClass = args[0], cfg = args[1];
		var group$1;
		if (is_function_default(groupClass)) if (cfg) group$1 = new groupClass(cfg);
		else group$1 = new groupClass({ parent: this });
		else {
			var tmpCfg = groupClass || {};
			group$1 = new (this.getGroupBase())(tmpCfg);
		}
		this.add(group$1);
		return group$1;
	};
	Container$1.prototype.getCanvas = function() {
		var canvas;
		if (this.isCanvas()) canvas = this;
		else canvas = this.get("canvas");
		return canvas;
	};
	Container$1.prototype.getShape = function(x, y, ev) {
		if (!isAllowCapture(this)) return null;
		var children = this.getChildren();
		var shape;
		if (!this.isCanvas()) {
			var v = [
				x,
				y,
				1
			];
			v = this.invertFromMatrix(v);
			if (!this.isClipped(v[0], v[1])) shape = this._findShape(children, v[0], v[1], ev);
		} else shape = this._findShape(children, x, y, ev);
		return shape;
	};
	Container$1.prototype._findShape = function(children, x, y, ev) {
		var shape = null;
		for (var i = children.length - 1; i >= 0; i--) {
			var child = children[i];
			if (isAllowCapture(child)) {
				if (child.isGroup()) shape = child.getShape(x, y, ev);
				else if (child.isHit(x, y)) shape = child;
			}
			if (shape) break;
		}
		return shape;
	};
	Container$1.prototype.add = function(element) {
		var canvas = this.getCanvas();
		var children = this.getChildren();
		var timeline = this.get("timeline");
		var preParent = element.getParent();
		if (preParent) removeChild(preParent, element, false);
		element.set("parent", this);
		if (canvas) setCanvas(element, canvas);
		if (timeline) setTimeline(element, timeline);
		children.push(element);
		element.onCanvasChange("add");
		this._applyElementMatrix(element);
	};
	Container$1.prototype._applyElementMatrix = function(element) {
		var totalMatrix = this.getTotalMatrix();
		if (totalMatrix) element.applyMatrix(totalMatrix);
	};
	Container$1.prototype.getChildren = function() {
		return this.get("children") || [];
	};
	Container$1.prototype.sort = function() {
		var children = this.getChildren();
		each_default(children, function(child, index) {
			child[INDEX] = index;
			return child;
		});
		children.sort(getComparer(function(obj1, obj2) {
			return obj1.get("zIndex") - obj2.get("zIndex");
		}));
		this.onCanvasChange("sort");
	};
	Container$1.prototype.clear = function() {
		this.set("clearing", true);
		if (this.destroyed) return;
		var children = this.getChildren();
		for (var i = children.length - 1; i >= 0; i--) children[i].destroy();
		this.set("children", []);
		this.onCanvasChange("clear");
		this.set("clearing", false);
	};
	Container$1.prototype.destroy = function() {
		if (this.get("destroyed")) return;
		this.clear();
		_super.prototype.destroy.call(this);
	};
	/**
	* 获取第一个子元素
	* @return {IElement} 第一个元素
	*/
	Container$1.prototype.getFirst = function() {
		return this.getChildByIndex(0);
	};
	/**
	* 获取最后一个子元素
	* @return {IElement} 元素
	*/
	Container$1.prototype.getLast = function() {
		var children = this.getChildren();
		return this.getChildByIndex(children.length - 1);
	};
	/**
	* 根据索引获取子元素
	* @return {IElement} 第一个元素
	*/
	Container$1.prototype.getChildByIndex = function(index) {
		return this.getChildren()[index];
	};
	/**
	* 子元素的数量
	* @return {number} 子元素数量
	*/
	Container$1.prototype.getCount = function() {
		return this.getChildren().length;
	};
	/**
	* 是否包含对应元素
	* @param {IElement} element 元素
	* @return {boolean}
	*/
	Container$1.prototype.contain = function(element) {
		return this.getChildren().indexOf(element) > -1;
	};
	/**
	* 移除对应子元素
	* @param {IElement} element 子元素
	* @param {boolean} destroy 是否销毁子元素，默认为 true
	*/
	Container$1.prototype.removeChild = function(element, destroy) {
		if (destroy === void 0) destroy = true;
		if (this.contain(element)) element.remove(destroy);
	};
	/**
	* 查找所有匹配的元素
	* @param  {ElementFilterFn}   fn  匹配函数
	* @return {IElement[]} 元素数组
	*/
	Container$1.prototype.findAll = function(fn) {
		var rst = [];
		var children = this.getChildren();
		each_default(children, function(element) {
			if (fn(element)) rst.push(element);
			if (element.isGroup()) rst = rst.concat(element.findAll(fn));
		});
		return rst;
	};
	/**
	* 查找元素，找到第一个返回
	* @param  {ElementFilterFn} fn    匹配函数
	* @return {IElement|null} 元素，可以为空
	*/
	Container$1.prototype.find = function(fn) {
		var rst = null;
		var children = this.getChildren();
		each_default(children, function(element) {
			if (fn(element)) rst = element;
			else if (element.isGroup()) rst = element.find(fn);
			if (rst) return false;
		});
		return rst;
	};
	/**
	* 根据 ID 查找元素
	* @param {string} id 元素 id
	* @return {IElement|null} 元素
	*/
	Container$1.prototype.findById = function(id$1) {
		return this.find(function(element) {
			return element.get("id") === id$1;
		});
	};
	/**
	* 该方法即将废弃，不建议使用
	* 根据 className 查找元素
	* TODO: 该方式定义暂时只给 G6 3.3 以后的版本使用，待 G6 中的 findByClassName 方法移除后，G 也需要同步移除
	* @param {string} className 元素 className
	* @return {IElement | null} 元素
	*/
	Container$1.prototype.findByClassName = function(className) {
		return this.find(function(element) {
			return element.get("className") === className;
		});
	};
	/**
	* 根据 name 查找元素列表
	* @param {string}      name 元素名称
	* @return {IElement[]} 元素
	*/
	Container$1.prototype.findAllByName = function(name) {
		return this.findAll(function(element) {
			return element.get("name") === name;
		});
	};
	return Container$1;
}(element_default$1);
var container_default = Container;

//#endregion
//#region node_modules/d3-timer/src/timer.js
var frame = 0, timeout = 0, interval$1 = 0, pokeDelay = 1e3, taskHead, taskTail, clockLast = 0, clockNow = 0, clockSkew = 0, clock = typeof performance === "object" && performance.now ? performance : Date, setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
	setTimeout(f, 17);
};
function now() {
	return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
	clockNow = 0;
}
function Timer() {
	this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
	constructor: Timer,
	restart: function(callback, delay, time) {
		if (typeof callback !== "function") throw new TypeError("callback is not a function");
		time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
		if (!this._next && taskTail !== this) {
			if (taskTail) taskTail._next = this;
			else taskHead = this;
			taskTail = this;
		}
		this._call = callback;
		this._time = time;
		sleep();
	},
	stop: function() {
		if (this._call) {
			this._call = null;
			this._time = Infinity;
			sleep();
		}
	}
};
function timer(callback, delay, time) {
	var t = new Timer();
	t.restart(callback, delay, time);
	return t;
}
function timerFlush() {
	now();
	++frame;
	var t = taskHead, e;
	while (t) {
		if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
		t = t._next;
	}
	--frame;
}
function wake() {
	clockNow = (clockLast = clock.now()) + clockSkew;
	frame = timeout = 0;
	try {
		timerFlush();
	} finally {
		frame = 0;
		nap();
		clockNow = 0;
	}
}
function poke() {
	var now$1 = clock.now(), delay = now$1 - clockLast;
	if (delay > pokeDelay) clockSkew -= delay, clockLast = now$1;
}
function nap() {
	var t0, t1 = taskHead, t2, time = Infinity;
	while (t1) if (t1._call) {
		if (time > t1._time) time = t1._time;
		t0 = t1, t1 = t1._next;
	} else {
		t2 = t1._next, t1._next = null;
		t1 = t0 ? t0._next = t2 : taskHead = t2;
	}
	taskTail = t0;
	sleep(time);
}
function sleep(time) {
	if (frame) return;
	if (timeout) timeout = clearTimeout(timeout);
	if (time - clockNow > 24) {
		if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
		if (interval$1) interval$1 = clearInterval(interval$1);
	} else {
		if (!interval$1) clockLast = clock.now(), interval$1 = setInterval(poke, pokeDelay);
		frame = 1, setFrame(wake);
	}
}

//#endregion
//#region node_modules/d3-interpolate/src/basis.js
function basis(t1, v0, v1, v2, v3) {
	var t2 = t1 * t1, t3 = t2 * t1;
	return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
}
function basis_default(values$1) {
	var n = values$1.length - 1;
	return function(t) {
		var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values$1[i], v2 = values$1[i + 1], v0 = i > 0 ? values$1[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values$1[i + 2] : 2 * v2 - v1;
		return basis((t - i / n) * n, v0, v1, v2, v3);
	};
}

//#endregion
//#region node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default(values$1) {
	var n = values$1.length;
	return function(t) {
		var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values$1[(i + n - 1) % n], v1 = values$1[i % n], v2 = values$1[(i + 1) % n], v3 = values$1[(i + 2) % n];
		return basis((t - i / n) * n, v0, v1, v2, v3);
	};
}

//#endregion
//#region node_modules/d3-interpolate/src/constant.js
var constant_default$1 = (x) => () => x;

//#endregion
//#region node_modules/d3-interpolate/src/color.js
function linear$2(a, d) {
	return function(t) {
		return a + t * d;
	};
}
function exponential(a, b, y) {
	return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
		return Math.pow(a + t * b, y);
	};
}
function gamma(y) {
	return (y = +y) === 1 ? nogamma : function(a, b) {
		return b - a ? exponential(a, b, y) : constant_default$1(isNaN(a) ? b : a);
	};
}
function nogamma(a, b) {
	var d = b - a;
	return d ? linear$2(a, d) : constant_default$1(isNaN(a) ? b : a);
}

//#endregion
//#region node_modules/d3-interpolate/src/rgb.js
var rgb_default = (function rgbGamma(y) {
	var color$2 = gamma(y);
	function rgb$1(start, end) {
		var r = color$2((start = rgb(start)).r, (end = rgb(end)).r), g = color$2(start.g, end.g), b = color$2(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
		return function(t) {
			start.r = r(t);
			start.g = g(t);
			start.b = b(t);
			start.opacity = opacity(t);
			return start + "";
		};
	}
	rgb$1.gamma = rgbGamma;
	return rgb$1;
})(1);
function rgbSpline(spline) {
	return function(colors) {
		var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color$2;
		for (i = 0; i < n; ++i) {
			color$2 = rgb(colors[i]);
			r[i] = color$2.r || 0;
			g[i] = color$2.g || 0;
			b[i] = color$2.b || 0;
		}
		r = spline(r);
		g = spline(g);
		b = spline(b);
		color$2.opacity = 1;
		return function(t) {
			color$2.r = r(t);
			color$2.g = g(t);
			color$2.b = b(t);
			return color$2 + "";
		};
	};
}
var rgbBasis = rgbSpline(basis_default);
var rgbBasisClosed = rgbSpline(basisClosed_default);

//#endregion
//#region node_modules/d3-interpolate/src/numberArray.js
function numberArray_default(a, b) {
	if (!b) b = [];
	var n = a ? Math.min(b.length, a.length) : 0, c = b.slice(), i;
	return function(t) {
		for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
		return c;
	};
}
function isNumberArray(x) {
	return ArrayBuffer.isView(x) && !(x instanceof DataView);
}

//#endregion
//#region node_modules/d3-interpolate/src/array.js
function array_default$1(a, b) {
	return (isNumberArray(b) ? numberArray_default : genericArray)(a, b);
}
function genericArray(a, b) {
	var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x = new Array(na), c = new Array(nb), i;
	for (i = 0; i < na; ++i) x[i] = value_default(a[i], b[i]);
	for (; i < nb; ++i) c[i] = b[i];
	return function(t) {
		for (i = 0; i < na; ++i) c[i] = x[i](t);
		return c;
	};
}

//#endregion
//#region node_modules/d3-interpolate/src/date.js
function date_default(a, b) {
	var d = /* @__PURE__ */ new Date();
	return a = +a, b = +b, function(t) {
		return d.setTime(a * (1 - t) + b * t), d;
	};
}

//#endregion
//#region node_modules/d3-interpolate/src/number.js
function number_default(a, b) {
	return a = +a, b = +b, function(t) {
		return a * (1 - t) + b * t;
	};
}

//#endregion
//#region node_modules/d3-interpolate/src/object.js
function object_default(a, b) {
	var i = {}, c = {}, k;
	if (a === null || typeof a !== "object") a = {};
	if (b === null || typeof b !== "object") b = {};
	for (k in b) if (k in a) i[k] = value_default(a[k], b[k]);
	else c[k] = b[k];
	return function(t) {
		for (k in i) c[k] = i[k](t);
		return c;
	};
}

//#endregion
//#region node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
function zero(b) {
	return function() {
		return b;
	};
}
function one(b) {
	return function(t) {
		return b(t) + "";
	};
}
function string_default(a, b) {
	var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
	a = a + "", b = b + "";
	while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
		if ((bs = bm.index) > bi) {
			bs = b.slice(bi, bs);
			if (s[i]) s[i] += bs;
			else s[++i] = bs;
		}
		if ((am = am[0]) === (bm = bm[0])) if (s[i]) s[i] += bm;
		else s[++i] = bm;
		else {
			s[++i] = null;
			q.push({
				i,
				x: number_default(am, bm)
			});
		}
		bi = reB.lastIndex;
	}
	if (bi < b.length) {
		bs = b.slice(bi);
		if (s[i]) s[i] += bs;
		else s[++i] = bs;
	}
	return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t) {
		for (var i$1 = 0, o; i$1 < b; ++i$1) s[(o = q[i$1]).i] = o.x(t);
		return s.join("");
	});
}

//#endregion
//#region node_modules/d3-interpolate/src/value.js
function value_default(a, b) {
	var t = typeof b, c;
	return b == null || t === "boolean" ? constant_default$1(b) : (t === "number" ? number_default : t === "string" ? (c = color$1(b)) ? (b = c, rgb_default) : string_default : b instanceof color$1 ? rgb_default : b instanceof Date ? date_default : isNumberArray(b) ? numberArray_default : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object_default : number_default)(a, b);
}

//#endregion
//#region node_modules/d3-ease/src/linear.js
function linear$1(t) {
	return +t;
}

//#endregion
//#region node_modules/d3-ease/src/quad.js
function quadIn(t) {
	return t * t;
}
function quadOut(t) {
	return t * (2 - t);
}
function quadInOut(t) {
	return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
}

//#endregion
//#region node_modules/d3-ease/src/cubic.js
function cubicIn(t) {
	return t * t * t;
}
function cubicOut(t) {
	return --t * t * t + 1;
}
function cubicInOut(t) {
	return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

//#endregion
//#region node_modules/d3-ease/src/poly.js
var exponent = 3;
var polyIn = (function custom(e) {
	e = +e;
	function polyIn$1(t) {
		return Math.pow(t, e);
	}
	polyIn$1.exponent = custom;
	return polyIn$1;
})(exponent);
var polyOut = (function custom(e) {
	e = +e;
	function polyOut$1(t) {
		return 1 - Math.pow(1 - t, e);
	}
	polyOut$1.exponent = custom;
	return polyOut$1;
})(exponent);
var polyInOut = (function custom(e) {
	e = +e;
	function polyInOut$1(t) {
		return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
	}
	polyInOut$1.exponent = custom;
	return polyInOut$1;
})(exponent);

//#endregion
//#region node_modules/d3-ease/src/sin.js
var pi = Math.PI, halfPi = pi / 2;
function sinIn(t) {
	return +t === 1 ? 1 : 1 - Math.cos(t * halfPi);
}
function sinOut(t) {
	return Math.sin(t * halfPi);
}
function sinInOut(t) {
	return (1 - Math.cos(pi * t)) / 2;
}

//#endregion
//#region node_modules/d3-ease/src/math.js
function tpmt(x) {
	return (Math.pow(2, -10 * x) - .0009765625) * 1.0009775171065494;
}

//#endregion
//#region node_modules/d3-ease/src/exp.js
function expIn(t) {
	return tpmt(1 - +t);
}
function expOut(t) {
	return 1 - tpmt(t);
}
function expInOut(t) {
	return ((t *= 2) <= 1 ? tpmt(1 - t) : 2 - tpmt(t - 1)) / 2;
}

//#endregion
//#region node_modules/d3-ease/src/circle.js
function circleIn(t) {
	return 1 - Math.sqrt(1 - t * t);
}
function circleOut(t) {
	return Math.sqrt(1 - --t * t);
}
function circleInOut(t) {
	return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
}

//#endregion
//#region node_modules/d3-ease/src/bounce.js
var b1 = 4 / 11, b2 = 6 / 11, b3 = 8 / 11, b4 = 3 / 4, b5 = 9 / 11, b6 = 10 / 11, b7 = 15 / 16, b8 = 21 / 22, b9 = 63 / 64, b0 = 1 / b1 / b1;
function bounceIn(t) {
	return 1 - bounceOut(1 - t);
}
function bounceOut(t) {
	return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
}
function bounceInOut(t) {
	return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
}

//#endregion
//#region node_modules/d3-ease/src/back.js
var overshoot = 1.70158;
var backIn = (function custom(s) {
	s = +s;
	function backIn$1(t) {
		return (t = +t) * t * (s * (t - 1) + t);
	}
	backIn$1.overshoot = custom;
	return backIn$1;
})(overshoot);
var backOut = (function custom(s) {
	s = +s;
	function backOut$1(t) {
		return --t * t * ((t + 1) * s + t) + 1;
	}
	backOut$1.overshoot = custom;
	return backOut$1;
})(overshoot);
var backInOut = (function custom(s) {
	s = +s;
	function backInOut$1(t) {
		return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
	}
	backInOut$1.overshoot = custom;
	return backInOut$1;
})(overshoot);

//#endregion
//#region node_modules/d3-ease/src/elastic.js
var tau = 2 * Math.PI, amplitude = 1, period = .3;
var elasticIn = (function custom(a, p) {
	var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
	function elasticIn$1(t) {
		return a * tpmt(- --t) * Math.sin((s - t) / p);
	}
	elasticIn$1.amplitude = function(a$1) {
		return custom(a$1, p * tau);
	};
	elasticIn$1.period = function(p$1) {
		return custom(a, p$1);
	};
	return elasticIn$1;
})(amplitude, period);
var elasticOut = (function custom(a, p) {
	var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
	function elasticOut$1(t) {
		return 1 - a * tpmt(t = +t) * Math.sin((t + s) / p);
	}
	elasticOut$1.amplitude = function(a$1) {
		return custom(a$1, p * tau);
	};
	elasticOut$1.period = function(p$1) {
		return custom(a, p$1);
	};
	return elasticOut$1;
})(amplitude, period);
var elasticInOut = (function custom(a, p) {
	var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
	function elasticInOut$1(t) {
		return ((t = t * 2 - 1) < 0 ? a * tpmt(-t) * Math.sin((s - t) / p) : 2 - a * tpmt(t) * Math.sin((s + t) / p)) / 2;
	}
	elasticInOut$1.amplitude = function(a$1) {
		return custom(a$1, p * tau);
	};
	elasticInOut$1.period = function(p$1) {
		return custom(a, p$1);
	};
	return elasticInOut$1;
})(amplitude, period);

//#endregion
//#region node_modules/d3-ease/src/index.js
var src_exports$2 = /* @__PURE__ */ __export({
	easeBack: () => backInOut,
	easeBackIn: () => backIn,
	easeBackInOut: () => backInOut,
	easeBackOut: () => backOut,
	easeBounce: () => bounceOut,
	easeBounceIn: () => bounceIn,
	easeBounceInOut: () => bounceInOut,
	easeBounceOut: () => bounceOut,
	easeCircle: () => circleInOut,
	easeCircleIn: () => circleIn,
	easeCircleInOut: () => circleInOut,
	easeCircleOut: () => circleOut,
	easeCubic: () => cubicInOut,
	easeCubicIn: () => cubicIn,
	easeCubicInOut: () => cubicInOut,
	easeCubicOut: () => cubicOut,
	easeElastic: () => elasticOut,
	easeElasticIn: () => elasticIn,
	easeElasticInOut: () => elasticInOut,
	easeElasticOut: () => elasticOut,
	easeExp: () => expInOut,
	easeExpIn: () => expIn,
	easeExpInOut: () => expInOut,
	easeExpOut: () => expOut,
	easeLinear: () => linear$1,
	easePoly: () => polyInOut,
	easePolyIn: () => polyIn,
	easePolyInOut: () => polyInOut,
	easePolyOut: () => polyOut,
	easeQuad: () => quadInOut,
	easeQuadIn: () => quadIn,
	easeQuadInOut: () => quadInOut,
	easeQuadOut: () => quadOut,
	easeSin: () => sinInOut,
	easeSinIn: () => sinIn,
	easeSinInOut: () => sinInOut,
	easeSinOut: () => sinOut
});

//#endregion
//#region node_modules/@antv/g-base/esm/animate/register.js
var EASING_MAP = {};
/**
* 根据名称获取对应的动画缓动函数
* @param type 动画缓动函数名称
*/
function getEasing(type) {
	return EASING_MAP[type.toLowerCase()] || src_exports$2[type];
}
/**
* 注册动画缓动函数
* @param type 动画缓动函数名称
* @param easeFn 动画缓动函数
*/
function registerEasing(type, easeFn) {
	EASING_MAP[type.toLowerCase()] = easeFn;
}

//#endregion
//#region node_modules/@antv/g-base/esm/util/color.js
var isColorProp = function(prop) {
	return [
		"fill",
		"stroke",
		"fillStyle",
		"strokeStyle"
	].includes(prop);
};
var isGradientColor$1 = function(val) {
	return /^[r,R,L,l]{1}[\s]*\(/.test(val);
};

//#endregion
//#region node_modules/@antv/g-base/esm/animate/timeline.js
var IDENTITY_MATRIX = [
	1,
	0,
	0,
	0,
	1,
	0,
	0,
	0,
	1
];
/**
* 使用 ratio 进行插值计算来更新属性
* @param {IElement}  shape    元素
* @param {Animation} animation 动画
* @param {number}    ratio    比例
* @return {boolean}  动画是否执行完成
*/
function _update(shape, animation$6, ratio) {
	var cProps = {};
	var fromAttrs = animation$6.fromAttrs, toAttrs = animation$6.toAttrs;
	if (shape.destroyed) return;
	var interf;
	for (var k in toAttrs) if (!is_equal_default(fromAttrs[k], toAttrs[k])) {
		if (k === "path") {
			var toPath = toAttrs[k];
			var fromPath = fromAttrs[k];
			if (toPath.length > fromPath.length) {
				toPath = parsePathString$3(toAttrs[k]);
				fromPath = parsePathString$3(fromAttrs[k]);
				fromPath = fillPathByDiff(fromPath, toPath);
				fromPath = formatPath(fromPath, toPath);
				animation$6.fromAttrs.path = fromPath;
				animation$6.toAttrs.path = toPath;
			} else if (!animation$6.pathFormatted) {
				toPath = parsePathString$3(toAttrs[k]);
				fromPath = parsePathString$3(fromAttrs[k]);
				fromPath = formatPath(fromPath, toPath);
				animation$6.fromAttrs.path = fromPath;
				animation$6.toAttrs.path = toPath;
				animation$6.pathFormatted = true;
			}
			cProps[k] = [];
			for (var i = 0; i < toPath.length; i++) {
				var toPathPoint = toPath[i];
				var fromPathPoint = fromPath[i];
				var cPathPoint = [];
				for (var j = 0; j < toPathPoint.length; j++) if (is_number_default(toPathPoint[j]) && fromPathPoint && is_number_default(fromPathPoint[j])) {
					interf = value_default(fromPathPoint[j], toPathPoint[j]);
					cPathPoint.push(interf(ratio));
				} else cPathPoint.push(toPathPoint[j]);
				cProps[k].push(cPathPoint);
			}
		} else if (k === "matrix") cProps[k] = array_default$1(fromAttrs[k] || IDENTITY_MATRIX, toAttrs[k] || IDENTITY_MATRIX)(ratio);
		else if (isColorProp(k) && isGradientColor$1(toAttrs[k])) cProps[k] = toAttrs[k];
		else if (!is_function_default(toAttrs[k])) {
			interf = value_default(fromAttrs[k], toAttrs[k]);
			cProps[k] = interf(ratio);
		}
	}
	shape.attr(cProps);
}
/**
* 根据自定义帧动画函数 onFrame 来更新属性
* @param {IElement}  shape    元素
* @param {Animation} animation 动画
* @param {number}    elapsed  动画执行时间(毫秒)
* @return {boolean}  动画是否执行完成
*/
function update(shape, animation$6, elapsed) {
	var startTime = animation$6.startTime, delay = animation$6.delay;
	if (elapsed < startTime + delay || animation$6._paused) return false;
	var ratio;
	var duration = animation$6.duration;
	var easing = animation$6.easing;
	var easeFn = getEasing(easing);
	elapsed = elapsed - startTime - animation$6.delay;
	if (animation$6.repeat) {
		ratio = elapsed % duration / duration;
		ratio = easeFn(ratio);
	} else {
		ratio = elapsed / duration;
		if (ratio < 1) ratio = easeFn(ratio);
		else {
			if (animation$6.onFrame) shape.attr(animation$6.onFrame(1));
			else shape.attr(animation$6.toAttrs);
			return true;
		}
	}
	if (animation$6.onFrame) {
		var attrs = animation$6.onFrame(ratio);
		shape.attr(attrs);
	} else _update(shape, animation$6, ratio);
	return false;
}
var Timeline = function() {
	/**
	* 时间轴构造函数，依赖于画布
	* @param {}
	*/
	function Timeline$1(canvas) {
		/**
		* 执行动画的元素列表
		* @type {IElement[]}
		*/
		this.animators = [];
		/**
		* 当前时间
		* @type {number}
		*/
		this.current = 0;
		/**
		* 定时器
		* @type {d3Timer.Timer}
		*/
		this.timer = null;
		this.canvas = canvas;
	}
	/**
	* 初始化定时器
	*/
	Timeline$1.prototype.initTimer = function() {
		var _this = this;
		var isFinished = false;
		var shape;
		var animations;
		var animation$6;
		this.timer = timer(function(elapsed) {
			_this.current = elapsed;
			if (_this.animators.length > 0) {
				for (var i = _this.animators.length - 1; i >= 0; i--) {
					shape = _this.animators[i];
					if (shape.destroyed) {
						_this.removeAnimator(i);
						continue;
					}
					if (!shape.isAnimatePaused()) {
						animations = shape.get("animations");
						for (var j = animations.length - 1; j >= 0; j--) {
							animation$6 = animations[j];
							isFinished = update(shape, animation$6, elapsed);
							if (isFinished) {
								animations.splice(j, 1);
								isFinished = false;
								if (animation$6.callback) animation$6.callback();
							}
						}
					}
					if (animations.length === 0) _this.removeAnimator(i);
				}
				if (!_this.canvas.get("autoDraw")) _this.canvas.draw();
			}
		});
	};
	/**
	* 增加动画元素
	*/
	Timeline$1.prototype.addAnimator = function(shape) {
		this.animators.push(shape);
	};
	/**
	* 移除动画元素
	*/
	Timeline$1.prototype.removeAnimator = function(index) {
		this.animators.splice(index, 1);
	};
	/**
	* 是否有动画在执行
	*/
	Timeline$1.prototype.isAnimating = function() {
		return !!this.animators.length;
	};
	/**
	* 停止定时器
	*/
	Timeline$1.prototype.stop = function() {
		if (this.timer) this.timer.stop();
	};
	/**
	* 停止时间轴上所有元素的动画，并置空动画元素列表
	* @param {boolean} toEnd 是否到动画的最终状态，用来透传给动画元素的 stopAnimate 方法
	*/
	Timeline$1.prototype.stopAllAnimations = function(toEnd) {
		if (toEnd === void 0) toEnd = true;
		this.animators.forEach(function(animator) {
			animator.stopAnimate(toEnd);
		});
		this.animators = [];
		this.canvas.draw();
	};
	/**
	* 获取当前时间
	*/
	Timeline$1.prototype.getTime = function() {
		return this.current;
	};
	return Timeline$1;
}();
var timeline_default = Timeline;

//#endregion
//#region node_modules/@antv/g-base/esm/event/event-contoller.js
var CLICK_OFFSET = 40;
var LEFT_BTN_CODE = 0;
var EVENTS$2 = [
	"mousedown",
	"mouseup",
	"dblclick",
	"mouseout",
	"mouseover",
	"mousemove",
	"mouseleave",
	"mouseenter",
	"touchstart",
	"touchmove",
	"touchend",
	"dragenter",
	"dragover",
	"dragleave",
	"drop",
	"contextmenu",
	"mousewheel"
];
function emitTargetEvent(target, type, eventObj) {
	eventObj.name = type;
	eventObj.target = target;
	eventObj.currentTarget = target;
	eventObj.delegateTarget = target;
	target.emit(type, eventObj);
}
function bubbleEvent(container, type, eventObj) {
	if (eventObj.bubbles) {
		var relativeShape = void 0;
		var isOverEvent = false;
		if (type === "mouseenter") {
			relativeShape = eventObj.fromShape;
			isOverEvent = true;
		} else if (type === "mouseleave") {
			isOverEvent = true;
			relativeShape = eventObj.toShape;
		}
		if (container.isCanvas() && isOverEvent) return;
		if (relativeShape && isParent(container, relativeShape)) {
			eventObj.bubbles = false;
			return;
		}
		eventObj.name = type;
		eventObj.currentTarget = container;
		eventObj.delegateTarget = container;
		container.emit(type, eventObj);
	}
}
var EventController = function() {
	function EventController$1(cfg) {
		var _this = this;
		this.draggingShape = null;
		this.dragging = false;
		this.currentShape = null;
		this.mousedownShape = null;
		this.mousedownPoint = null;
		this._eventCallback = function(ev) {
			var type = ev.type;
			_this._triggerEvent(type, ev);
		};
		this._onDocumentMove = function(ev) {
			if (_this.canvas.get("el") !== ev.target) {
				if (_this.dragging || _this.currentShape) {
					var pointInfo = _this._getPointInfo(ev);
					if (_this.dragging) _this._emitEvent("drag", ev, pointInfo, _this.draggingShape);
				}
			}
		};
		this._onDocumentMouseUp = function(ev) {
			if (_this.canvas.get("el") !== ev.target) {
				if (_this.dragging) {
					var pointInfo = _this._getPointInfo(ev);
					if (_this.draggingShape) _this._emitEvent("drop", ev, pointInfo, null);
					_this._emitEvent("dragend", ev, pointInfo, _this.draggingShape);
					_this._afterDrag(_this.draggingShape, pointInfo, ev);
				}
			}
		};
		this.canvas = cfg.canvas;
	}
	EventController$1.prototype.init = function() {
		this._bindEvents();
	};
	EventController$1.prototype._bindEvents = function() {
		var _this = this;
		var el = this.canvas.get("el");
		each_default(EVENTS$2, function(eventName) {
			el.addEventListener(eventName, _this._eventCallback);
		});
		if (document) {
			document.addEventListener("mousemove", this._onDocumentMove);
			document.addEventListener("mouseup", this._onDocumentMouseUp);
		}
	};
	EventController$1.prototype._clearEvents = function() {
		var _this = this;
		var el = this.canvas.get("el");
		each_default(EVENTS$2, function(eventName) {
			el.removeEventListener(eventName, _this._eventCallback);
		});
		if (document) {
			document.removeEventListener("mousemove", this._onDocumentMove);
			document.removeEventListener("mouseup", this._onDocumentMouseUp);
		}
	};
	EventController$1.prototype._getEventObj = function(type, event, point$1, target, fromShape, toShape) {
		var eventObj = new graph_event_default(type, event);
		eventObj.fromShape = fromShape;
		eventObj.toShape = toShape;
		eventObj.x = point$1.x;
		eventObj.y = point$1.y;
		eventObj.clientX = point$1.clientX;
		eventObj.clientY = point$1.clientY;
		eventObj.propagationPath.push(target);
		return eventObj;
	};
	EventController$1.prototype._getShape = function(point$1, ev) {
		return this.canvas.getShape(point$1.x, point$1.y, ev);
	};
	EventController$1.prototype._getPointInfo = function(ev) {
		var canvas = this.canvas;
		var clientPoint = canvas.getClientByEvent(ev);
		var point$1 = canvas.getPointByEvent(ev);
		return {
			x: point$1.x,
			y: point$1.y,
			clientX: clientPoint.x,
			clientY: clientPoint.y
		};
	};
	EventController$1.prototype._triggerEvent = function(type, ev) {
		var pointInfo = this._getPointInfo(ev);
		var shape = this._getShape(pointInfo, ev);
		var method = this["_on" + type];
		var leaveCanvas = false;
		if (method) method.call(this, pointInfo, shape, ev);
		else {
			var preShape = this.currentShape;
			if (type === "mouseenter" || type === "dragenter" || type === "mouseover") {
				this._emitEvent(type, ev, pointInfo, null, null, shape);
				if (shape) this._emitEvent(type, ev, pointInfo, shape, null, shape);
				if (type === "mouseenter" && this.draggingShape) this._emitEvent("dragenter", ev, pointInfo, null);
			} else if (type === "mouseleave" || type === "dragleave" || type === "mouseout") {
				leaveCanvas = true;
				if (preShape) this._emitEvent(type, ev, pointInfo, preShape, preShape, null);
				this._emitEvent(type, ev, pointInfo, null, preShape, null);
				if (type === "mouseleave" && this.draggingShape) this._emitEvent("dragleave", ev, pointInfo, null);
			} else this._emitEvent(type, ev, pointInfo, shape, null, null);
		}
		if (!leaveCanvas) this.currentShape = shape;
		if (shape && !shape.get("destroyed")) {
			var canvas = this.canvas;
			var el = canvas.get("el");
			el.style.cursor = shape.attr("cursor") || canvas.get("cursor");
		}
	};
	EventController$1.prototype._onmousedown = function(pointInfo, shape, event) {
		if (event.button === LEFT_BTN_CODE) {
			this.mousedownShape = shape;
			this.mousedownPoint = pointInfo;
			this.mousedownTimeStamp = event.timeStamp;
		}
		this._emitEvent("mousedown", event, pointInfo, shape, null, null);
	};
	EventController$1.prototype._emitMouseoverEvents = function(event, pointInfo, fromShape, toShape) {
		var el = this.canvas.get("el");
		if (fromShape !== toShape) {
			if (fromShape) {
				this._emitEvent("mouseout", event, pointInfo, fromShape, fromShape, toShape);
				this._emitEvent("mouseleave", event, pointInfo, fromShape, fromShape, toShape);
				if (!toShape || toShape.get("destroyed")) el.style.cursor = this.canvas.get("cursor");
			}
			if (toShape) {
				this._emitEvent("mouseover", event, pointInfo, toShape, fromShape, toShape);
				this._emitEvent("mouseenter", event, pointInfo, toShape, fromShape, toShape);
			}
		}
	};
	EventController$1.prototype._emitDragoverEvents = function(event, pointInfo, fromShape, toShape, isCanvasEmit) {
		if (toShape) {
			if (toShape !== fromShape) {
				if (fromShape) this._emitEvent("dragleave", event, pointInfo, fromShape, fromShape, toShape);
				this._emitEvent("dragenter", event, pointInfo, toShape, fromShape, toShape);
			}
			if (!isCanvasEmit) this._emitEvent("dragover", event, pointInfo, toShape);
		} else if (fromShape) this._emitEvent("dragleave", event, pointInfo, fromShape, fromShape, toShape);
		if (isCanvasEmit) this._emitEvent("dragover", event, pointInfo, toShape);
	};
	EventController$1.prototype._afterDrag = function(draggingShape, pointInfo, event) {
		if (draggingShape) {
			draggingShape.set("capture", true);
			this.draggingShape = null;
		}
		this.dragging = false;
		var shape = this._getShape(pointInfo, event);
		if (shape !== draggingShape) this._emitMouseoverEvents(event, pointInfo, draggingShape, shape);
		this.currentShape = shape;
	};
	EventController$1.prototype._onmouseup = function(pointInfo, shape, event) {
		if (event.button === LEFT_BTN_CODE) {
			var draggingShape = this.draggingShape;
			if (this.dragging) {
				if (draggingShape) this._emitEvent("drop", event, pointInfo, shape);
				this._emitEvent("dragend", event, pointInfo, draggingShape);
				this._afterDrag(draggingShape, pointInfo, event);
			} else {
				this._emitEvent("mouseup", event, pointInfo, shape);
				if (shape === this.mousedownShape) this._emitEvent("click", event, pointInfo, shape);
				this.mousedownShape = null;
				this.mousedownPoint = null;
			}
		}
	};
	EventController$1.prototype._ondragover = function(pointInfo, shape, event) {
		event.preventDefault();
		var preShape = this.currentShape;
		this._emitDragoverEvents(event, pointInfo, preShape, shape, true);
	};
	EventController$1.prototype._onmousemove = function(pointInfo, shape, event) {
		var canvas = this.canvas;
		var preShape = this.currentShape;
		var draggingShape = this.draggingShape;
		if (this.dragging) {
			if (draggingShape) this._emitDragoverEvents(event, pointInfo, preShape, shape, false);
			this._emitEvent("drag", event, pointInfo, draggingShape);
		} else {
			var mousedownPoint = this.mousedownPoint;
			if (mousedownPoint) {
				var mousedownShape = this.mousedownShape;
				var timeWindow = event.timeStamp - this.mousedownTimeStamp;
				var dx = mousedownPoint.clientX - pointInfo.clientX;
				var dy = mousedownPoint.clientY - pointInfo.clientY;
				var dist = dx * dx + dy * dy;
				if (timeWindow > 120 || dist > CLICK_OFFSET) if (mousedownShape && mousedownShape.get("draggable")) {
					draggingShape = this.mousedownShape;
					draggingShape.set("capture", false);
					this.draggingShape = draggingShape;
					this.dragging = true;
					this._emitEvent("dragstart", event, pointInfo, draggingShape);
					this.mousedownShape = null;
					this.mousedownPoint = null;
				} else if (!mousedownShape && canvas.get("draggable")) {
					this.dragging = true;
					this._emitEvent("dragstart", event, pointInfo, null);
					this.mousedownShape = null;
					this.mousedownPoint = null;
				} else {
					this._emitMouseoverEvents(event, pointInfo, preShape, shape);
					this._emitEvent("mousemove", event, pointInfo, shape);
				}
				else {
					this._emitMouseoverEvents(event, pointInfo, preShape, shape);
					this._emitEvent("mousemove", event, pointInfo, shape);
				}
			} else {
				this._emitMouseoverEvents(event, pointInfo, preShape, shape);
				this._emitEvent("mousemove", event, pointInfo, shape);
			}
		}
	};
	EventController$1.prototype._emitEvent = function(type, event, pointInfo, shape, fromShape, toShape) {
		var eventObj = this._getEventObj(type, event, pointInfo, shape, fromShape, toShape);
		if (shape) {
			eventObj.shape = shape;
			emitTargetEvent(shape, type, eventObj);
			var parent_1 = shape.getParent();
			while (parent_1) {
				parent_1.emitDelegation(type, eventObj);
				if (!eventObj.propagationStopped) bubbleEvent(parent_1, type, eventObj);
				eventObj.propagationPath.push(parent_1);
				parent_1 = parent_1.getParent();
			}
		} else {
			var canvas = this.canvas;
			emitTargetEvent(canvas, type, eventObj);
		}
	};
	EventController$1.prototype.destroy = function() {
		this._clearEvents();
		this.canvas = null;
		this.currentShape = null;
		this.draggingShape = null;
		this.mousedownPoint = null;
		this.mousedownShape = null;
		this.mousedownTimeStamp = null;
	};
	return EventController$1;
}();
var event_contoller_default = EventController;

//#endregion
//#region node_modules/@antv/g-base/esm/abstract/canvas.js
var PX_SUFFIX = "px";
var browser = detect();
var isFirefox = browser && browser.name === "firefox";
var Canvas$2 = function(_super) {
	__extends(Canvas$3, _super);
	function Canvas$3(cfg) {
		var _this = _super.call(this, cfg) || this;
		_this.initContainer();
		_this.initDom();
		_this.initEvents();
		_this.initTimeline();
		return _this;
	}
	Canvas$3.prototype.getDefaultCfg = function() {
		var cfg = _super.prototype.getDefaultCfg.call(this);
		cfg["cursor"] = "default";
		cfg["supportCSSTransform"] = false;
		return cfg;
	};
	/**
	* @protected
	* 初始化容器
	*/
	Canvas$3.prototype.initContainer = function() {
		var container = this.get("container");
		if (is_string_default(container)) {
			container = document.getElementById(container);
			this.set("container", container);
		}
	};
	/**
	* @protected
	* 初始化 DOM
	*/
	Canvas$3.prototype.initDom = function() {
		var el = this.createDom();
		this.set("el", el);
		this.get("container").appendChild(el);
		this.setDOMSize(this.get("width"), this.get("height"));
	};
	/**
	* @protected
	* 初始化绑定的事件
	*/
	Canvas$3.prototype.initEvents = function() {
		var eventController = new event_contoller_default({ canvas: this });
		eventController.init();
		this.set("eventController", eventController);
	};
	/**
	* @protected
	* 初始化时间轴
	*/
	Canvas$3.prototype.initTimeline = function() {
		var timeline = new timeline_default(this);
		this.set("timeline", timeline);
	};
	/**
	* @protected
	* 修改画布对应的 DOM 的大小
	* @param {number} width  宽度
	* @param {number} height 高度
	*/
	Canvas$3.prototype.setDOMSize = function(width, height) {
		var el = this.get("el");
		if (isBrowser) {
			el.style.width = width + PX_SUFFIX;
			el.style.height = height + PX_SUFFIX;
		}
	};
	Canvas$3.prototype.changeSize = function(width, height) {
		this.setDOMSize(width, height);
		this.set("width", width);
		this.set("height", height);
		this.onCanvasChange("changeSize");
	};
	/**
	* 获取当前的渲染引擎
	* @return {Renderer} 返回当前的渲染引擎
	*/
	Canvas$3.prototype.getRenderer = function() {
		return this.get("renderer");
	};
	/**
	* 获取画布的 cursor 样式
	* @return {Cursor}
	*/
	Canvas$3.prototype.getCursor = function() {
		return this.get("cursor");
	};
	/**
	* 设置画布的 cursor 样式
	* @param {Cursor} cursor  cursor 样式
	*/
	Canvas$3.prototype.setCursor = function(cursor) {
		this.set("cursor", cursor);
		var el = this.get("el");
		if (isBrowser && el) el.style.cursor = cursor;
	};
	Canvas$3.prototype.getPointByEvent = function(ev) {
		if (this.get("supportCSSTransform")) {
			if (isFirefox && !is_nil_default(ev.layerX) && ev.layerX !== ev.offsetX) return {
				x: ev.layerX,
				y: ev.layerY
			};
			if (!is_nil_default(ev.offsetX)) return {
				x: ev.offsetX,
				y: ev.offsetY
			};
		}
		var _a$5 = this.getClientByEvent(ev), clientX = _a$5.x, clientY = _a$5.y;
		return this.getPointByClient(clientX, clientY);
	};
	Canvas$3.prototype.getClientByEvent = function(ev) {
		var clientInfo = ev;
		if (ev.touches) if (ev.type === "touchend") clientInfo = ev.changedTouches[0];
		else clientInfo = ev.touches[0];
		return {
			x: clientInfo.clientX,
			y: clientInfo.clientY
		};
	};
	Canvas$3.prototype.getPointByClient = function(clientX, clientY) {
		var bbox = this.get("el").getBoundingClientRect();
		return {
			x: clientX - bbox.left,
			y: clientY - bbox.top
		};
	};
	Canvas$3.prototype.getClientByPoint = function(x, y) {
		var bbox = this.get("el").getBoundingClientRect();
		return {
			x: x + bbox.left,
			y: y + bbox.top
		};
	};
	Canvas$3.prototype.draw = function() {};
	/**
	* @protected
	* 销毁 DOM 容器
	*/
	Canvas$3.prototype.removeDom = function() {
		var el = this.get("el");
		el.parentNode.removeChild(el);
	};
	/**
	* @protected
	* 清理所有的事件
	*/
	Canvas$3.prototype.clearEvents = function() {
		this.get("eventController").destroy();
	};
	Canvas$3.prototype.isCanvas = function() {
		return true;
	};
	Canvas$3.prototype.getParent = function() {
		return null;
	};
	Canvas$3.prototype.destroy = function() {
		var timeline = this.get("timeline");
		if (this.get("destroyed")) return;
		this.clear();
		if (timeline) timeline.stop();
		this.clearEvents();
		this.removeDom();
		_super.prototype.destroy.call(this);
	};
	return Canvas$3;
}(container_default);
var canvas_default$1 = Canvas$2;

//#endregion
//#region node_modules/@antv/g-base/esm/abstract/group.js
var AbstractGroup = function(_super) {
	__extends(AbstractGroup$1, _super);
	function AbstractGroup$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	AbstractGroup$1.prototype.isGroup = function() {
		return true;
	};
	AbstractGroup$1.prototype.isEntityGroup = function() {
		return false;
	};
	AbstractGroup$1.prototype.clone = function() {
		var clone$1 = _super.prototype.clone.call(this);
		var children = this.getChildren();
		for (var i = 0; i < children.length; i++) {
			var child = children[i];
			clone$1.add(child.clone());
		}
		return clone$1;
	};
	return AbstractGroup$1;
}(container_default);
var group_default$1 = AbstractGroup;

//#endregion
//#region node_modules/@antv/g-base/esm/abstract/shape.js
var AbstractShape = function(_super) {
	__extends(AbstractShape$1, _super);
	function AbstractShape$1(cfg) {
		return _super.call(this, cfg) || this;
	}
	AbstractShape$1.prototype._isInBBox = function(refX, refY) {
		var bbox = this.getBBox();
		return bbox.minX <= refX && bbox.maxX >= refX && bbox.minY <= refY && bbox.maxY >= refY;
	};
	/**
	* 属性更改后需要做的事情
	* @protected
	* @param {ShapeAttrs} targetAttrs 渲染的图像属性
	*/
	AbstractShape$1.prototype.afterAttrsChange = function(targetAttrs) {
		_super.prototype.afterAttrsChange.call(this, targetAttrs);
		this.clearCacheBBox();
	};
	AbstractShape$1.prototype.getBBox = function() {
		var bbox = this.cfg.bbox;
		if (!bbox) {
			bbox = this.calculateBBox();
			this.set("bbox", bbox);
		}
		return bbox;
	};
	AbstractShape$1.prototype.getCanvasBBox = function() {
		var canvasBBox = this.cfg.canvasBBox;
		if (!canvasBBox) {
			canvasBBox = this.calculateCanvasBBox();
			this.set("canvasBBox", canvasBBox);
		}
		return canvasBBox;
	};
	AbstractShape$1.prototype.applyMatrix = function(matrix) {
		_super.prototype.applyMatrix.call(this, matrix);
		this.set("canvasBBox", null);
	};
	/**
	* 计算相对于画布的包围盒，默认等同于 bbox
	* @return {BBox} 包围盒
	*/
	AbstractShape$1.prototype.calculateCanvasBBox = function() {
		var bbox = this.getBBox();
		var totalMatrix = this.getTotalMatrix();
		var minX = bbox.minX, minY = bbox.minY, maxX = bbox.maxX, maxY$1 = bbox.maxY;
		if (totalMatrix) {
			var topLeft = multiplyVec2(totalMatrix, [bbox.minX, bbox.minY]);
			var topRight = multiplyVec2(totalMatrix, [bbox.maxX, bbox.minY]);
			var bottomLeft = multiplyVec2(totalMatrix, [bbox.minX, bbox.maxY]);
			var bottomRight = multiplyVec2(totalMatrix, [bbox.maxX, bbox.maxY]);
			minX = Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
			maxX = Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
			minY = Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
			maxY$1 = Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
		}
		var attrs = this.attrs;
		if (attrs.shadowColor) {
			var _a$5 = attrs.shadowBlur, shadowBlur = _a$5 === void 0 ? 0 : _a$5, _b = attrs.shadowOffsetX, shadowOffsetX = _b === void 0 ? 0 : _b, _c = attrs.shadowOffsetY, shadowOffsetY = _c === void 0 ? 0 : _c;
			var shadowLeft = minX - shadowBlur + shadowOffsetX;
			var shadowRight = maxX + shadowBlur + shadowOffsetX;
			var shadowTop = minY - shadowBlur + shadowOffsetY;
			var shadowBottom = maxY$1 + shadowBlur + shadowOffsetY;
			minX = Math.min(minX, shadowLeft);
			maxX = Math.max(maxX, shadowRight);
			minY = Math.min(minY, shadowTop);
			maxY$1 = Math.max(maxY$1, shadowBottom);
		}
		return {
			x: minX,
			y: minY,
			minX,
			minY,
			maxX,
			maxY: maxY$1,
			width: maxX - minX,
			height: maxY$1 - minY
		};
	};
	/**
	* @protected
	* 清理缓存的 bbox
	*/
	AbstractShape$1.prototype.clearCacheBBox = function() {
		this.set("bbox", null);
		this.set("canvasBBox", null);
	};
	AbstractShape$1.prototype.isClipShape = function() {
		return this.get("isClipShape");
	};
	/**
	* @protected
	* 不同的图形自己实现是否在图形内部的逻辑，要判断边和填充区域
	* @param  {number}  refX 相对于图形的坐标 x
	* @param  {number}  refY 相对于图形的坐标 Y
	* @return {boolean} 点是否在图形内部
	*/
	AbstractShape$1.prototype.isInShape = function(refX, refY) {
		return false;
	};
	/**
	* 是否仅仅使用 BBox 检测就可以判定拾取到图形
	* 默认是 false，但是有些图形例如 image、marker 等都可直接使用 BBox 的检测而不需要使用图形拾取
	* @return {Boolean} 仅仅使用 BBox 进行拾取
	*/
	AbstractShape$1.prototype.isOnlyHitBox = function() {
		return false;
	};
	AbstractShape$1.prototype.isHit = function(x, y) {
		var startArrowShape = this.get("startArrowShape");
		var endArrowShape = this.get("endArrowShape");
		var vec = [
			x,
			y,
			1
		];
		vec = this.invertFromMatrix(vec);
		var refX = vec[0], refY = vec[1];
		var inBBox = this._isInBBox(refX, refY);
		if (this.isOnlyHitBox()) return inBBox;
		if (inBBox && !this.isClipped(refX, refY)) {
			if (this.isInShape(refX, refY)) return true;
			if (startArrowShape && startArrowShape.isHit(refX, refY)) return true;
			if (endArrowShape && endArrowShape.isHit(refX, refY)) return true;
		}
		return false;
	};
	return AbstractShape$1;
}(element_default$1);
var shape_default = AbstractShape;

//#endregion
//#region node_modules/@antv/g-base/esm/bbox/register.js
var cache$1 = /* @__PURE__ */ new Map();
/**
* 注册计算包围盒的算法
* @param type 方法名
* @param method 方法
*/
function register(type, method) {
	cache$1.set(type, method);
}
/**
* 获取计算包围盒的算法
* @param type 方法名
*/
function getMethod(type) {
	return cache$1.get(type);
}

//#endregion
//#region node_modules/@antv/g-base/esm/bbox/rect.js
function rect_default$5(shape) {
	var attrs = shape.attr();
	var x = attrs.x, y = attrs.y, width = attrs.width, height = attrs.height;
	return {
		x,
		y,
		width,
		height
	};
}

//#endregion
//#region node_modules/@antv/g-base/esm/bbox/circle.js
function circle_default$8(shape) {
	var _a$5 = shape.attr(), x = _a$5.x, y = _a$5.y, r = _a$5.r;
	return {
		x: x - r,
		y: y - r,
		width: r * 2,
		height: r * 2
	};
}

//#endregion
//#region node_modules/@antv/g-math/esm/util.js
/**
* 两点之间的距离
* @param {number} x1 起始点 x
* @param {number} y1 起始点 y
* @param {number} x2 结束点 x
* @param {number} y2 结束点 y
* @return {number} 距离
*/
function distance$5(x1, y1, x2, y2) {
	var dx = x1 - x2;
	var dy = y1 - y2;
	return Math.sqrt(dx * dx + dy * dy);
}
function isNumberEqual$1(v1, v2) {
	return Math.abs(v1 - v2) < .001;
}
function getBBoxByArray(xArr, yArr) {
	var minX = min_default(xArr);
	var minY = min_default(yArr);
	var maxX = max_default(xArr);
	var maxY$1 = max_default(yArr);
	return {
		x: minX,
		y: minY,
		width: maxX - minX,
		height: maxY$1 - minY
	};
}
function piMod(angle$1) {
	return (angle$1 + Math.PI * 2) % (Math.PI * 2);
}

//#endregion
//#region node_modules/@antv/g-math/esm/line.js
var line_default$2 = {
	box: function(x1, y1, x2, y2) {
		return getBBoxByArray([x1, x2], [y1, y2]);
	},
	length: function(x1, y1, x2, y2) {
		return distance$5(x1, y1, x2, y2);
	},
	pointAt: function(x1, y1, x2, y2, t) {
		return {
			x: (1 - t) * x1 + t * x2,
			y: (1 - t) * y1 + t * y2
		};
	},
	pointDistance: function(x1, y1, x2, y2, x, y) {
		var cross = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);
		if (cross < 0) return distance$5(x1, y1, x, y);
		var lengthSquare = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
		if (cross > lengthSquare) return distance$5(x2, y2, x, y);
		return this.pointToLine(x1, y1, x2, y2, x, y);
	},
	pointToLine: function(x1, y1, x2, y2, x, y) {
		var d = [x2 - x1, y2 - y1];
		if (exactEquals(d, [0, 0])) return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));
		var u = [-d[1], d[0]];
		normalize(u, u);
		var a = [x - x1, y - y1];
		return Math.abs(dot$2(a, u));
	},
	tangentAngle: function(x1, y1, x2, y2) {
		return Math.atan2(y2 - y1, x2 - x1);
	}
};

//#endregion
//#region node_modules/@antv/g-math/esm/bezier.js
var EPSILON = 1e-4;
/**
* 使用牛顿切割法求最近的点
* @param {number[]} xArr      点的 x 数组
* @param {number[]} yArr      点的 y 数组
* @param {number}   x         指定的点 x
* @param {number}   y         指定的点 y
* @param {Function} tCallback 差值函数
*/
function nearestPoint(xArr, yArr, x, y, tCallback, length$1) {
	var t;
	var d = Infinity;
	var v0 = [x, y];
	var segNum = 20;
	if (length$1 && length$1 > 200) segNum = length$1 / 10;
	var increaseRate = 1 / segNum;
	var interval$2 = increaseRate / 10;
	for (var i = 0; i <= segNum; i++) {
		var _t = i * increaseRate;
		var v1 = [tCallback.apply(null, xArr.concat([_t])), tCallback.apply(null, yArr.concat([_t]))];
		var d1 = distance$5(v0[0], v0[1], v1[0], v1[1]);
		if (d1 < d) {
			t = _t;
			d = d1;
		}
	}
	if (t === 0) return {
		x: xArr[0],
		y: yArr[0]
	};
	if (t === 1) {
		var count$1 = xArr.length;
		return {
			x: xArr[count$1 - 1],
			y: yArr[count$1 - 1]
		};
	}
	d = Infinity;
	for (var i = 0; i < 32; i++) {
		if (interval$2 < EPSILON) break;
		var prev = t - interval$2;
		var next = t + interval$2;
		var v1 = [tCallback.apply(null, xArr.concat([prev])), tCallback.apply(null, yArr.concat([prev]))];
		var d1 = distance$5(v0[0], v0[1], v1[0], v1[1]);
		if (prev >= 0 && d1 < d) {
			t = prev;
			d = d1;
		} else {
			var v2 = [tCallback.apply(null, xArr.concat([next])), tCallback.apply(null, yArr.concat([next]))];
			var d2 = distance$5(v0[0], v0[1], v2[0], v2[1]);
			if (next <= 1 && d2 < d) {
				t = next;
				d = d2;
			} else interval$2 *= .5;
		}
	}
	return {
		x: tCallback.apply(null, xArr.concat([t])),
		y: tCallback.apply(null, yArr.concat([t]))
	};
}
function snapLength(xArr, yArr) {
	var totalLength = 0;
	var count$1 = xArr.length;
	for (var i = 0; i < count$1; i++) {
		var x = xArr[i];
		var y = yArr[i];
		var nextX = xArr[(i + 1) % count$1];
		var nextY = yArr[(i + 1) % count$1];
		totalLength += distance$5(x, y, nextX, nextY);
	}
	return totalLength / 2;
}

//#endregion
//#region node_modules/@antv/g-math/esm/quadratic.js
function quadraticAt(p0, p1, p2, t) {
	var onet = 1 - t;
	return onet * onet * p0 + 2 * t * onet * p1 + t * t * p2;
}
function extrema$1(p0, p1, p2) {
	var a = p0 + p2 - 2 * p1;
	if (isNumberEqual$1(a, 0)) return [.5];
	var rst = (p0 - p1) / a;
	if (rst <= 1 && rst >= 0) return [rst];
	return [];
}
function derivativeAt$1(p0, p1, p2, t) {
	return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);
}
function divideQuadratic(x1, y1, x2, y2, x3, y3, t) {
	var xt = quadraticAt(x1, x2, x3, t);
	var yt = quadraticAt(y1, y2, y3, t);
	var controlPoint1 = line_default$2.pointAt(x1, y1, x2, y2, t);
	var controlPoint2 = line_default$2.pointAt(x2, y2, x3, y3, t);
	return [[
		x1,
		y1,
		controlPoint1.x,
		controlPoint1.y,
		xt,
		yt
	], [
		xt,
		yt,
		controlPoint2.x,
		controlPoint2.y,
		x3,
		y3
	]];
}
function quadraticLength(x1, y1, x2, y2, x3, y3, iterationCount) {
	if (iterationCount === 0) return (distance$5(x1, y1, x2, y2) + distance$5(x2, y2, x3, y3) + distance$5(x1, y1, x3, y3)) / 2;
	var quadratics = divideQuadratic(x1, y1, x2, y2, x3, y3, .5);
	var left$1 = quadratics[0];
	var right$1 = quadratics[1];
	left$1.push(iterationCount - 1);
	right$1.push(iterationCount - 1);
	return quadraticLength.apply(null, left$1) + quadraticLength.apply(null, right$1);
}
var quadratic_default = {
	box: function(x1, y1, x2, y2, x3, y3) {
		var xExtrema$1 = extrema$1(x1, x2, x3)[0];
		var yExtrema$1 = extrema$1(y1, y2, y3)[0];
		var xArr = [x1, x3];
		var yArr = [y1, y3];
		if (xExtrema$1 !== void 0) xArr.push(quadraticAt(x1, x2, x3, xExtrema$1));
		if (yExtrema$1 !== void 0) yArr.push(quadraticAt(y1, y2, y3, yExtrema$1));
		return getBBoxByArray(xArr, yArr);
	},
	length: function(x1, y1, x2, y2, x3, y3) {
		return quadraticLength(x1, y1, x2, y2, x3, y3, 3);
	},
	nearestPoint: function(x1, y1, x2, y2, x3, y3, x0, y0) {
		return nearestPoint([
			x1,
			x2,
			x3
		], [
			y1,
			y2,
			y3
		], x0, y0, quadraticAt);
	},
	pointDistance: function(x1, y1, x2, y2, x3, y3, x0, y0) {
		var point$1 = this.nearestPoint(x1, y1, x2, y2, x3, y3, x0, y0);
		return distance$5(point$1.x, point$1.y, x0, y0);
	},
	interpolationAt: quadraticAt,
	pointAt: function(x1, y1, x2, y2, x3, y3, t) {
		return {
			x: quadraticAt(x1, x2, x3, t),
			y: quadraticAt(y1, y2, y3, t)
		};
	},
	divide: function(x1, y1, x2, y2, x3, y3, t) {
		return divideQuadratic(x1, y1, x2, y2, x3, y3, t);
	},
	tangentAngle: function(x1, y1, x2, y2, x3, y3, t) {
		var dx = derivativeAt$1(x1, x2, x3, t);
		var dy = derivativeAt$1(y1, y2, y3, t);
		return piMod(Math.atan2(dy, dx));
	}
};

//#endregion
//#region node_modules/@antv/g-math/esm/cubic.js
function cubicAt(p0, p1, p2, p3, t) {
	var onet = 1 - t;
	return onet * onet * onet * p0 + 3 * p1 * t * onet * onet + 3 * p2 * t * t * onet + p3 * t * t * t;
}
function derivativeAt(p0, p1, p2, p3, t) {
	var onet = 1 - t;
	return 3 * (onet * onet * (p1 - p0) + 2 * onet * t * (p2 - p1) + t * t * (p3 - p2));
}
function extrema(p0, p1, p2, p3) {
	var a = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;
	var b = 6 * p0 - 12 * p1 + 6 * p2;
	var c = 3 * p1 - 3 * p0;
	var extremas = [];
	var t1;
	var t2;
	var discSqrt;
	if (isNumberEqual$1(a, 0)) {
		if (!isNumberEqual$1(b, 0)) {
			t1 = -c / b;
			if (t1 >= 0 && t1 <= 1) extremas.push(t1);
		}
	} else {
		var disc = b * b - 4 * a * c;
		if (isNumberEqual$1(disc, 0)) extremas.push(-b / (2 * a));
		else if (disc > 0) {
			discSqrt = Math.sqrt(disc);
			t1 = (-b + discSqrt) / (2 * a);
			t2 = (-b - discSqrt) / (2 * a);
			if (t1 >= 0 && t1 <= 1) extremas.push(t1);
			if (t2 >= 0 && t2 <= 1) extremas.push(t2);
		}
	}
	return extremas;
}
function divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t) {
	var xt = cubicAt(x1, x2, x3, x4, t);
	var yt = cubicAt(y1, y2, y3, y4, t);
	var c1 = line_default$2.pointAt(x1, y1, x2, y2, t);
	var c2 = line_default$2.pointAt(x2, y2, x3, y3, t);
	var c3 = line_default$2.pointAt(x3, y3, x4, y4, t);
	var c12 = line_default$2.pointAt(c1.x, c1.y, c2.x, c2.y, t);
	var c23 = line_default$2.pointAt(c2.x, c2.y, c3.x, c3.y, t);
	return [[
		x1,
		y1,
		c1.x,
		c1.y,
		c12.x,
		c12.y,
		xt,
		yt
	], [
		xt,
		yt,
		c23.x,
		c23.y,
		c3.x,
		c3.y,
		x4,
		y4
	]];
}
function cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, iterationCount) {
	if (iterationCount === 0) return snapLength([
		x1,
		x2,
		x3,
		x4
	], [
		y1,
		y2,
		y3,
		y4
	]);
	var cubics = divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, .5);
	var left$1 = cubics[0];
	var right$1 = cubics[1];
	left$1.push(iterationCount - 1);
	right$1.push(iterationCount - 1);
	return cubicLength.apply(null, left$1) + cubicLength.apply(null, right$1);
}
var cubic_default = {
	extrema,
	box: function(x1, y1, x2, y2, x3, y3, x4, y4) {
		var xArr = [x1, x4];
		var yArr = [y1, y4];
		var xExtrema$1 = extrema(x1, x2, x3, x4);
		var yExtrema$1 = extrema(y1, y2, y3, y4);
		for (var i = 0; i < xExtrema$1.length; i++) xArr.push(cubicAt(x1, x2, x3, x4, xExtrema$1[i]));
		for (var i = 0; i < yExtrema$1.length; i++) yArr.push(cubicAt(y1, y2, y3, y4, yExtrema$1[i]));
		return getBBoxByArray(xArr, yArr);
	},
	length: function(x1, y1, x2, y2, x3, y3, x4, y4) {
		return cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, 3);
	},
	nearestPoint: function(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length$1) {
		return nearestPoint([
			x1,
			x2,
			x3,
			x4
		], [
			y1,
			y2,
			y3,
			y4
		], x0, y0, cubicAt, length$1);
	},
	pointDistance: function(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length$1) {
		var point$1 = this.nearestPoint(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length$1);
		return distance$5(point$1.x, point$1.y, x0, y0);
	},
	interpolationAt: cubicAt,
	pointAt: function(x1, y1, x2, y2, x3, y3, x4, y4, t) {
		return {
			x: cubicAt(x1, x2, x3, x4, t),
			y: cubicAt(y1, y2, y3, y4, t)
		};
	},
	divide: function(x1, y1, x2, y2, x3, y3, x4, y4, t) {
		return divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t);
	},
	tangentAngle: function(x1, y1, x2, y2, x3, y3, x4, y4, t) {
		var dx = derivativeAt(x1, x2, x3, x4, t);
		var dy = derivativeAt(y1, y2, y3, y4, t);
		return piMod(Math.atan2(dy, dx));
	}
};

//#endregion
//#region node_modules/@antv/g-math/esm/ellipse.js
function copysign(v1, v2) {
	var absv = Math.abs(v1);
	return v2 > 0 ? absv : absv * -1;
}
var ellipse_default$3 = {
	box: function(x, y, rx, ry) {
		return {
			x: x - rx,
			y: y - ry,
			width: rx * 2,
			height: ry * 2
		};
	},
	length: function(x, y, rx, ry) {
		return Math.PI * (3 * (rx + ry) - Math.sqrt((3 * rx + ry) * (rx + 3 * ry)));
	},
	nearestPoint: function(x, y, rx, ry, x0, y0) {
		var a = rx;
		var b = ry;
		if (a === 0 || b === 0) return {
			x,
			y
		};
		var relativeX = x0 - x;
		var relativeY = y0 - y;
		var px = Math.abs(relativeX);
		var py = Math.abs(relativeY);
		var squareA = a * a;
		var squareB = b * b;
		var t = Math.PI / 4;
		var nearestX;
		var nearestY;
		for (var i = 0; i < 4; i++) {
			nearestX = a * Math.cos(t);
			nearestY = b * Math.sin(t);
			var ex = (squareA - squareB) * Math.pow(Math.cos(t), 3) / a;
			var ey = (squareB - squareA) * Math.pow(Math.sin(t), 3) / b;
			var rx1 = nearestX - ex;
			var ry1 = nearestY - ey;
			var qx = px - ex;
			var qy = py - ey;
			var r = Math.hypot(ry1, rx1);
			var q = Math.hypot(qy, qx);
			var delta_t = r * Math.asin((rx1 * qy - ry1 * qx) / (r * q)) / Math.sqrt(squareA + squareB - nearestX * nearestX - nearestY * nearestY);
			t += delta_t;
			t = Math.min(Math.PI / 2, Math.max(0, t));
		}
		return {
			x: x + copysign(nearestX, relativeX),
			y: y + copysign(nearestY, relativeY)
		};
	},
	pointDistance: function(x, y, rx, ry, x0, y0) {
		var nearestPoint$1 = this.nearestPoint(x, y, rx, ry, x0, y0);
		return distance$5(nearestPoint$1.x, nearestPoint$1.y, x0, y0);
	},
	pointAt: function(x, y, rx, ry, t) {
		var angle$1 = 2 * Math.PI * t;
		return {
			x: x + rx * Math.cos(angle$1),
			y: y + ry * Math.sin(angle$1)
		};
	},
	tangentAngle: function(x, y, rx, ry, t) {
		var angle$1 = 2 * Math.PI * t;
		var tangentAngle = Math.atan2(ry * Math.cos(angle$1), -rx * Math.sin(angle$1));
		return piMod(tangentAngle);
	}
};

//#endregion
//#region node_modules/@antv/g-math/esm/arc.js
function derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle$1) {
	return -1 * rx * Math.cos(xRotation) * Math.sin(angle$1) - ry * Math.sin(xRotation) * Math.cos(angle$1);
}
function derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle$1) {
	return -1 * rx * Math.sin(xRotation) * Math.sin(angle$1) + ry * Math.cos(xRotation) * Math.cos(angle$1);
}
function xExtrema(rx, ry, xRotation) {
	return Math.atan(-ry / rx * Math.tan(xRotation));
}
function yExtrema(rx, ry, xRotation) {
	return Math.atan(ry / (rx * Math.tan(xRotation)));
}
function xAt(cx, cy, rx, ry, xRotation, angle$1) {
	return rx * Math.cos(xRotation) * Math.cos(angle$1) - ry * Math.sin(xRotation) * Math.sin(angle$1) + cx;
}
function yAt(cx, cy, rx, ry, xRotation, angle$1) {
	return rx * Math.sin(xRotation) * Math.cos(angle$1) + ry * Math.cos(xRotation) * Math.sin(angle$1) + cy;
}
function getAngle$2(rx, ry, x0, y0) {
	return (Math.atan2(y0 * rx, x0 * ry) + Math.PI * 2) % (Math.PI * 2);
}
function getPoint(rx, ry, angle$1) {
	return {
		x: rx * Math.cos(angle$1),
		y: ry * Math.sin(angle$1)
	};
}
function rotate$1(x, y, angle$1) {
	var cos$1 = Math.cos(angle$1);
	var sin$1 = Math.sin(angle$1);
	return [x * cos$1 - y * sin$1, x * sin$1 + y * cos$1];
}
var arc_default$1 = {
	box: function(cx, cy, rx, ry, xRotation, startAngle, endAngle) {
		var xDim = xExtrema(rx, ry, xRotation);
		var minX = Infinity;
		var maxX = -Infinity;
		var xs = [startAngle, endAngle];
		for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {
			var xAngle = xDim + i;
			if (startAngle < endAngle) {
				if (startAngle < xAngle && xAngle < endAngle) xs.push(xAngle);
			} else if (endAngle < xAngle && xAngle < startAngle) xs.push(xAngle);
		}
		for (var i = 0; i < xs.length; i++) {
			var x = xAt(cx, cy, rx, ry, xRotation, xs[i]);
			if (x < minX) minX = x;
			if (x > maxX) maxX = x;
		}
		var yDim = yExtrema(rx, ry, xRotation);
		var minY = Infinity;
		var maxY$1 = -Infinity;
		var ys = [startAngle, endAngle];
		for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {
			var yAngle = yDim + i;
			if (startAngle < endAngle) {
				if (startAngle < yAngle && yAngle < endAngle) ys.push(yAngle);
			} else if (endAngle < yAngle && yAngle < startAngle) ys.push(yAngle);
		}
		for (var i = 0; i < ys.length; i++) {
			var y = yAt(cx, cy, rx, ry, xRotation, ys[i]);
			if (y < minY) minY = y;
			if (y > maxY$1) maxY$1 = y;
		}
		return {
			x: minX,
			y: minY,
			width: maxX - minX,
			height: maxY$1 - minY
		};
	},
	length: function(cx, cy, rx, ry, xRotation, startAngle, endAngle) {},
	nearestPoint: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {
		var relativeVector = rotate$1(x0 - cx, y0 - cy, -xRotation);
		var x1 = relativeVector[0], y1 = relativeVector[1];
		var relativePoint = ellipse_default$3.nearestPoint(0, 0, rx, ry, x1, y1);
		var angle$1 = getAngle$2(rx, ry, relativePoint.x, relativePoint.y);
		if (angle$1 < startAngle) relativePoint = getPoint(rx, ry, startAngle);
		else if (angle$1 > endAngle) relativePoint = getPoint(rx, ry, endAngle);
		var vector = rotate$1(relativePoint.x, relativePoint.y, xRotation);
		return {
			x: vector[0] + cx,
			y: vector[1] + cy
		};
	},
	pointDistance: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {
		var nearestPoint$1 = this.nearestPoint(cx, cy, rx, ry, x0, y0);
		return distance$5(nearestPoint$1.x, nearestPoint$1.y, x0, y0);
	},
	pointAt: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {
		var angle$1 = (endAngle - startAngle) * t + startAngle;
		return {
			x: xAt(cx, cy, rx, ry, xRotation, angle$1),
			y: yAt(cx, cy, rx, ry, xRotation, angle$1)
		};
	},
	tangentAngle: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {
		var angle$1 = (endAngle - startAngle) * t + startAngle;
		var dx = derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle$1);
		var dy = derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle$1);
		return piMod(Math.atan2(dy, dx));
	}
};

//#endregion
//#region node_modules/@antv/g-math/esm/segments.js
function analyzePoints(points) {
	var totalLength = 0;
	var segments = [];
	for (var i = 0; i < points.length - 1; i++) {
		var from = points[i];
		var to = points[i + 1];
		var length_1 = distance$5(from[0], from[1], to[0], to[1]);
		var seg = {
			from,
			to,
			length: length_1
		};
		segments.push(seg);
		totalLength += length_1;
	}
	return {
		segments,
		totalLength
	};
}
function lengthOfSegment(points) {
	if (points.length < 2) return 0;
	var totalLength = 0;
	for (var i = 0; i < points.length - 1; i++) {
		var from = points[i];
		var to = points[i + 1];
		totalLength += distance$5(from[0], from[1], to[0], to[1]);
	}
	return totalLength;
}
/**
* 按照比例在数据片段中获取点
* @param {array} points 点的集合
* @param {number} t 百分比 0-1
* @return {object} 点的坐标
*/
function pointAtSegments(points, t) {
	if (t > 1 || t < 0 || points.length < 2) return null;
	var _a$5 = analyzePoints(points), segments = _a$5.segments, totalLength = _a$5.totalLength;
	if (totalLength === 0) return {
		x: points[0][0],
		y: points[0][1]
	};
	var startRatio = 0;
	var point$1 = null;
	for (var i = 0; i < segments.length; i++) {
		var seg = segments[i];
		var from = seg.from, to = seg.to;
		var currentRatio = seg.length / totalLength;
		if (t >= startRatio && t <= startRatio + currentRatio) {
			var localRatio = (t - startRatio) / currentRatio;
			point$1 = line_default$2.pointAt(from[0], from[1], to[0], to[1], localRatio);
			break;
		}
		startRatio += currentRatio;
	}
	return point$1;
}
/**
* 按照比例在数据片段中获取切线的角度
* @param {array} points 点的集合
* @param {number} t 百分比 0-1
*/
function angleAtSegments(points, t) {
	if (t > 1 || t < 0 || points.length < 2) return 0;
	var _a$5 = analyzePoints(points), segments = _a$5.segments, totalLength = _a$5.totalLength;
	var startRatio = 0;
	var angle$1 = 0;
	for (var i = 0; i < segments.length; i++) {
		var seg = segments[i];
		var from = seg.from, to = seg.to;
		var currentRatio = seg.length / totalLength;
		if (t >= startRatio && t <= startRatio + currentRatio) {
			angle$1 = Math.atan2(to[1] - from[1], to[0] - from[0]);
			break;
		}
		startRatio += currentRatio;
	}
	return angle$1;
}
function distanceAtSegment(points, x, y) {
	var minDistance = Infinity;
	for (var i = 0; i < points.length - 1; i++) {
		var point$1 = points[i];
		var nextPoint = points[i + 1];
		var distance_1 = line_default$2.pointDistance(point$1[0], point$1[1], nextPoint[0], nextPoint[1], x, y);
		if (distance_1 < minDistance) minDistance = distance_1;
	}
	return minDistance;
}

//#endregion
//#region node_modules/@antv/g-math/esm/polyline.js
var polyline_default$1 = {
	box: function(points) {
		var xArr = [];
		var yArr = [];
		for (var i = 0; i < points.length; i++) {
			var point$1 = points[i];
			xArr.push(point$1[0]);
			yArr.push(point$1[1]);
		}
		return getBBoxByArray(xArr, yArr);
	},
	length: function(points) {
		return lengthOfSegment(points);
	},
	pointAt: function(points, t) {
		return pointAtSegments(points, t);
	},
	pointDistance: function(points, x, y) {
		return distanceAtSegment(points, x, y);
	},
	tangentAngle: function(points, t) {
		return angleAtSegments(points, t);
	}
};

//#endregion
//#region node_modules/@antv/g-base/esm/bbox/util.js
function mergeBBox(bbox1, bbox2) {
	if (!bbox1 || !bbox2) return bbox1 || bbox2;
	return {
		minX: Math.min(bbox1.minX, bbox2.minX),
		minY: Math.min(bbox1.minY, bbox2.minY),
		maxX: Math.max(bbox1.maxX, bbox2.maxX),
		maxY: Math.max(bbox1.maxY, bbox2.maxY)
	};
}
function mergeArrowBBox(shape, bbox) {
	var startArrowShape = shape.get("startArrowShape");
	var endArrowShape = shape.get("endArrowShape");
	var startArrowBBox = null;
	var endArrowBBox = null;
	if (startArrowShape) {
		startArrowBBox = startArrowShape.getCanvasBBox();
		bbox = mergeBBox(bbox, startArrowBBox);
	}
	if (endArrowShape) {
		endArrowBBox = endArrowShape.getCanvasBBox();
		bbox = mergeBBox(bbox, endArrowBBox);
	}
	return bbox;
}

//#endregion
//#region node_modules/@antv/g-base/esm/bbox/polyline.js
function polyline_default$3(shape) {
	var points = shape.attr().points;
	var xArr = [];
	var yArr = [];
	for (var i = 0; i < points.length; i++) {
		var point$1 = points[i];
		xArr.push(point$1[0]);
		yArr.push(point$1[1]);
	}
	var _a$5 = getBBoxByArray(xArr, yArr), x = _a$5.x, y = _a$5.y, width = _a$5.width, height = _a$5.height;
	var bbox = {
		minX: x,
		minY: y,
		maxX: x + width,
		maxY: y + height
	};
	bbox = mergeArrowBBox(shape, bbox);
	return {
		x: bbox.minX,
		y: bbox.minY,
		width: bbox.maxX - bbox.minX,
		height: bbox.maxY - bbox.minY
	};
}

//#endregion
//#region node_modules/@antv/g-base/esm/bbox/polygon.js
function polygon_default$3(shape) {
	var points = shape.attr().points;
	var xArr = [];
	var yArr = [];
	for (var i = 0; i < points.length; i++) {
		var point$1 = points[i];
		xArr.push(point$1[0]);
		yArr.push(point$1[1]);
	}
	return getBBoxByArray(xArr, yArr);
}

//#endregion
//#region node_modules/@antv/g-base/esm/util/offscreen.js
var offScreenCtx = null;
function getOffScreenContext() {
	if (!offScreenCtx) {
		var canvas = document.createElement("canvas");
		canvas.width = 1;
		canvas.height = 1;
		offScreenCtx = canvas.getContext("2d");
	}
	return offScreenCtx;
}

//#endregion
//#region node_modules/@antv/g-base/esm/util/text.js
/**
* 获取文本的高度
* @param text 文本
* @param fontSize 字体大小
* @param lineHeight 行高，可以为空
*/
function getTextHeight(text, fontSize, lineHeight) {
	var lineCount = 1;
	if (is_string_default(text)) lineCount = text.split("\n").length;
	if (lineCount > 1) {
		var spaceingY = getLineSpaceing(fontSize, lineHeight);
		return fontSize * lineCount + spaceingY * (lineCount - 1);
	}
	return fontSize;
}
/**
* 获取行间距如果文本多行，需要获取文本间距
* @param fontSize 字体大小
* @param lineHeight 行高
*/
function getLineSpaceing(fontSize, lineHeight) {
	return lineHeight ? lineHeight - fontSize : fontSize * .14;
}
/**
* 字体宽度
* @param text 文本
* @param font 字体
*/
function getTextWidth(text, font) {
	var context = getOffScreenContext();
	var width = 0;
	if (is_nil_default(text) || text === "") return width;
	context.save();
	context.font = font;
	if (is_string_default(text) && text.includes("\n")) {
		var textArr = text.split("\n");
		each_default(textArr, function(subText) {
			var measureWidth = context.measureText(subText).width;
			if (width < measureWidth) width = measureWidth;
		});
	} else width = context.measureText(text).width;
	context.restore();
	return width;
}
function assembleFont(attrs) {
	var fontSize = attrs.fontSize, fontFamily = attrs.fontFamily, fontWeight = attrs.fontWeight, fontStyle = attrs.fontStyle, fontVariant = attrs.fontVariant;
	return [
		fontStyle,
		fontVariant,
		fontWeight,
		fontSize + "px",
		fontFamily
	].join(" ").trim();
}

//#endregion
//#region node_modules/@antv/g-base/esm/bbox/text.js
function text_default$3(shape) {
	var attrs = shape.attr();
	var x = attrs.x, y = attrs.y, text = attrs.text, fontSize = attrs.fontSize, lineHeight = attrs.lineHeight;
	var font = attrs.font;
	if (!font) font = assembleFont(attrs);
	var width = getTextWidth(text, font);
	var bbox;
	if (!width) bbox = {
		x,
		y,
		width: 0,
		height: 0
	};
	else {
		var textAlign = attrs.textAlign, textBaseline = attrs.textBaseline;
		var height = getTextHeight(text, fontSize, lineHeight);
		var point$1 = {
			x,
			y: y - height
		};
		if (textAlign) {
			if (textAlign === "end" || textAlign === "right") point$1.x -= width;
			else if (textAlign === "center") point$1.x -= width / 2;
		}
		if (textBaseline) {
			if (textBaseline === "top") point$1.y += height;
			else if (textBaseline === "middle") point$1.y += height / 2;
		}
		bbox = {
			x: point$1.x,
			y: point$1.y,
			width,
			height
		};
	}
	return bbox;
}

//#endregion
//#region node_modules/@antv/g-base/node_modules/@antv/path-util/esm/parse-path.js
var regexTags$1 = /[MLHVQTCSAZ]([^MLHVQTCSAZ]*)/gi;
var regexDot$1 = /[^\s\,]+/gi;
function parsePath$1(p) {
	var path = p || [];
	if (is_array_default(path)) return path;
	if (is_string_default(path)) {
		path = path.match(regexTags$1);
		each_default(path, function(item, index) {
			item = item.match(regexDot$1);
			if (item[0].length > 1) {
				var tag = item[0].charAt(0);
				item.splice(1, 0, item[0].substr(1));
				item[0] = tag;
			}
			each_default(item, function(sub$1, i) {
				if (!isNaN(sub$1)) item[i] = +sub$1;
			});
			path[index] = item;
		});
		return path;
	}
}
var parse_path_default$1 = parsePath$1;

//#endregion
//#region node_modules/@antv/g-base/node_modules/@antv/path-util/esm/parse-path-string.js
var SPACES$4 = "	\n\v\f\r \xA0 ᠎             　\u2028\u2029";
var PATH_COMMAND$4 = new RegExp("([a-z])[" + SPACES$4 + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + SPACES$4 + "]*,?[" + SPACES$4 + "]*)+)", "ig");
var PATH_VALUES$4 = new RegExp("(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[" + SPACES$4 + "]*,?[" + SPACES$4 + "]*", "ig");

//#endregion
//#region node_modules/@antv/g-base/node_modules/@antv/path-util/esm/process/arc-2-cubic.js
var TAU$4 = Math.PI * 2;

//#endregion
//#region node_modules/@antv/g-base/node_modules/@antv/path-util/esm/get-arc-params.js
function vMag$2(v) {
	return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
}
function vRatio$2(u, v) {
	return vMag$2(u) * vMag$2(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag$2(u) * vMag$2(v)) : 1;
}
function vAngle$2(u, v) {
	return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio$2(u, v));
}
/**
* 判断两个点是否重合，点坐标的格式为 [x, y]
* @param {Array} point1 第一个点
* @param {Array} point2 第二个点
*/
function isSamePoint$2(point1, point2) {
	return point1[0] === point2[0] && point1[1] === point2[1];
}
function getArcParams$2(startPoint, params) {
	var rx = params[1];
	var ry = params[2];
	var xRotation = esm_default$2(to_radian_default(params[3]), Math.PI * 2);
	var arcFlag = params[4];
	var sweepFlag = params[5];
	var x1 = startPoint[0];
	var y1 = startPoint[1];
	var x2 = params[6];
	var y2 = params[7];
	var xp = Math.cos(xRotation) * (x1 - x2) / 2 + Math.sin(xRotation) * (y1 - y2) / 2;
	var yp = -1 * Math.sin(xRotation) * (x1 - x2) / 2 + Math.cos(xRotation) * (y1 - y2) / 2;
	var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
	if (lambda > 1) {
		rx *= Math.sqrt(lambda);
		ry *= Math.sqrt(lambda);
	}
	var diff$1 = rx * rx * (yp * yp) + ry * ry * (xp * xp);
	var f = diff$1 ? Math.sqrt((rx * rx * (ry * ry) - diff$1) / diff$1) : 1;
	if (arcFlag === sweepFlag) f *= -1;
	if (isNaN(f)) f = 0;
	var cxp = ry ? f * rx * yp / ry : 0;
	var cyp = rx ? f * -ry * xp / rx : 0;
	var cx = (x1 + x2) / 2 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
	var cy = (y1 + y2) / 2 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
	var u = [(xp - cxp) / rx, (yp - cyp) / ry];
	var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
	var theta = vAngle$2([1, 0], u);
	var dTheta = vAngle$2(u, v);
	if (vRatio$2(u, v) <= -1) dTheta = Math.PI;
	if (vRatio$2(u, v) >= 1) dTheta = 0;
	if (sweepFlag === 0 && dTheta > 0) dTheta = dTheta - 2 * Math.PI;
	if (sweepFlag === 1 && dTheta < 0) dTheta = dTheta + 2 * Math.PI;
	return {
		cx,
		cy,
		rx: isSamePoint$2(startPoint, [x2, y2]) ? 0 : rx,
		ry: isSamePoint$2(startPoint, [x2, y2]) ? 0 : ry,
		startAngle: theta,
		endAngle: theta + dTheta,
		xRotation,
		arcFlag,
		sweepFlag
	};
}

//#endregion
//#region node_modules/@antv/g-base/node_modules/@antv/path-util/esm/path-2-segments.js
function toSymmetry$2(point$1, center$1) {
	return [center$1[0] + (center$1[0] - point$1[0]), center$1[1] + (center$1[1] - point$1[1])];
}
function getSegments$1(path) {
	path = parse_path_default$1(path);
	var segments = [];
	var currentPoint = null;
	var nextParams = null;
	var startMovePoint = null;
	var lastStartMovePointIndex = 0;
	var count$1 = path.length;
	for (var i = 0; i < count$1; i++) {
		var params = path[i];
		nextParams = path[i + 1];
		var command = params[0];
		var segment = {
			command,
			prePoint: currentPoint,
			params,
			startTangent: null,
			endTangent: null
		};
		switch (command) {
			case "M":
				startMovePoint = [params[1], params[2]];
				lastStartMovePointIndex = i;
				break;
			case "A":
				segment["arcParams"] = getArcParams$2(currentPoint, params);
				break;
			default: break;
		}
		if (command === "Z") {
			currentPoint = startMovePoint;
			nextParams = path[lastStartMovePointIndex + 1];
		} else {
			var len = params.length;
			currentPoint = [params[len - 2], params[len - 1]];
		}
		if (nextParams && nextParams[0] === "Z") {
			nextParams = path[lastStartMovePointIndex];
			if (segments[lastStartMovePointIndex]) segments[lastStartMovePointIndex].prePoint = currentPoint;
		}
		segment["currentPoint"] = currentPoint;
		if (segments[lastStartMovePointIndex] && isSamePoint$2(currentPoint, segments[lastStartMovePointIndex].currentPoint)) segments[lastStartMovePointIndex].prePoint = segment.prePoint;
		segment["nextPoint"] = nextParams ? [nextParams[nextParams.length - 2], nextParams[nextParams.length - 1]] : null;
		var prePoint = segment.prePoint;
		if ([
			"L",
			"H",
			"V"
		].includes(command)) {
			segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
			segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
		} else if (command === "Q") {
			var cp = [params[1], params[2]];
			segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
			segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
		} else if (command === "T") {
			var preSegment = segments[i - 1];
			var cp = toSymmetry$2(preSegment.currentPoint, prePoint);
			if (preSegment.command === "Q") {
				segment.command = "Q";
				segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
				segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
			} else {
				segment.command = "TL";
				segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
				segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
			}
		} else if (command === "C") {
			var cp1 = [params[1], params[2]];
			var cp2 = [params[3], params[4]];
			segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
			segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
			if (segment.startTangent[0] === 0 && segment.startTangent[1] === 0) segment.startTangent = [cp1[0] - cp2[0], cp1[1] - cp2[1]];
			if (segment.endTangent[0] === 0 && segment.endTangent[1] === 0) segment.endTangent = [cp2[0] - cp1[0], cp2[1] - cp1[1]];
		} else if (command === "S") {
			var preSegment = segments[i - 1];
			var cp1 = toSymmetry$2(preSegment.currentPoint, prePoint);
			var cp2 = [params[1], params[2]];
			if (preSegment.command === "C") {
				segment.command = "C";
				segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
				segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
			} else {
				segment.command = "SQ";
				segment.startTangent = [prePoint[0] - cp2[0], prePoint[1] - cp2[1]];
				segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
			}
		} else if (command === "A") {
			var d = .001;
			var _a$5 = segment["arcParams"] || {}, _b = _a$5.cx, cx = _b === void 0 ? 0 : _b, _c = _a$5.cy, cy = _c === void 0 ? 0 : _c, _d = _a$5.rx, rx = _d === void 0 ? 0 : _d, _e = _a$5.ry, ry = _e === void 0 ? 0 : _e, _f = _a$5.sweepFlag, sweepFlag = _f === void 0 ? 0 : _f, _g = _a$5.startAngle, startAngle = _g === void 0 ? 0 : _g, _h = _a$5.endAngle, endAngle = _h === void 0 ? 0 : _h;
			if (sweepFlag === 0) d *= -1;
			var dx1 = rx * Math.cos(startAngle - d) + cx;
			var dy1 = ry * Math.sin(startAngle - d) + cy;
			segment.startTangent = [dx1 - startMovePoint[0], dy1 - startMovePoint[1]];
			var dx2 = rx * Math.cos(startAngle + endAngle + d) + cx;
			var dy2 = ry * Math.sin(startAngle + endAngle - d) + cy;
			segment.endTangent = [prePoint[0] - dx2, prePoint[1] - dy2];
		}
		segments.push(segment);
	}
	return segments;
}

//#endregion
//#region node_modules/@antv/g-base/esm/bbox/path.js
function getPathBox(segments, lineWidth) {
	var xArr = [];
	var yArr = [];
	var segmentsWithAngle = [];
	for (var i = 0; i < segments.length; i++) {
		var segment = segments[i];
		var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint;
		var box$1 = void 0;
		switch (segment.command) {
			case "Q":
				box$1 = quadratic_default.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4]);
				break;
			case "C":
				box$1 = cubic_default.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6]);
				break;
			case "A":
				var arcParams = segment.arcParams;
				box$1 = arc_default$1.box(arcParams.cx, arcParams.cy, arcParams.rx, arcParams.ry, arcParams.xRotation, arcParams.startAngle, arcParams.endAngle);
				break;
			default:
				xArr.push(currentPoint[0]);
				yArr.push(currentPoint[1]);
				break;
		}
		if (box$1) {
			segment.box = box$1;
			xArr.push(box$1.x, box$1.x + box$1.width);
			yArr.push(box$1.y, box$1.y + box$1.height);
		}
		if (lineWidth && (segment.command === "L" || segment.command === "M") && segment.prePoint && segment.nextPoint) segmentsWithAngle.push(segment);
	}
	xArr = xArr.filter(function(item) {
		return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
	});
	yArr = yArr.filter(function(item) {
		return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
	});
	var minX = min_default(xArr);
	var minY = min_default(yArr);
	var maxX = max_default(xArr);
	var maxY$1 = max_default(yArr);
	if (segmentsWithAngle.length === 0) return {
		x: minX,
		y: minY,
		width: maxX - minX,
		height: maxY$1 - minY
	};
	for (var i = 0; i < segmentsWithAngle.length; i++) {
		var segment = segmentsWithAngle[i];
		var currentPoint = segment.currentPoint;
		var extra = void 0;
		if (currentPoint[0] === minX) {
			extra = getExtraFromSegmentWithAngle(segment, lineWidth);
			minX = minX - extra.xExtra;
		} else if (currentPoint[0] === maxX) {
			extra = getExtraFromSegmentWithAngle(segment, lineWidth);
			maxX = maxX + extra.xExtra;
		}
		if (currentPoint[1] === minY) {
			extra = getExtraFromSegmentWithAngle(segment, lineWidth);
			minY = minY - extra.yExtra;
		} else if (currentPoint[1] === maxY$1) {
			extra = getExtraFromSegmentWithAngle(segment, lineWidth);
			maxY$1 = maxY$1 + extra.yExtra;
		}
	}
	return {
		x: minX,
		y: minY,
		width: maxX - minX,
		height: maxY$1 - minY
	};
}
function getExtraFromSegmentWithAngle(segment, lineWidth) {
	var prePoint = segment.prePoint, currentPoint = segment.currentPoint, nextPoint = segment.nextPoint;
	var currentAndPre = Math.pow(currentPoint[0] - prePoint[0], 2) + Math.pow(currentPoint[1] - prePoint[1], 2);
	var currentAndNext = Math.pow(currentPoint[0] - nextPoint[0], 2) + Math.pow(currentPoint[1] - nextPoint[1], 2);
	var preAndNext = Math.pow(prePoint[0] - nextPoint[0], 2) + Math.pow(prePoint[1] - nextPoint[1], 2);
	var currentAngle = Math.acos((currentAndPre + currentAndNext - preAndNext) / (2 * Math.sqrt(currentAndPre) * Math.sqrt(currentAndNext)));
	if (!currentAngle || Math.sin(currentAngle) === 0 || isNumberEqual(currentAngle, 0)) return {
		xExtra: 0,
		yExtra: 0
	};
	var xAngle = Math.abs(Math.atan2(nextPoint[1] - currentPoint[1], nextPoint[0] - currentPoint[0]));
	var yAngle = Math.abs(Math.atan2(nextPoint[0] - currentPoint[0], nextPoint[1] - currentPoint[1]));
	xAngle = xAngle > Math.PI / 2 ? Math.PI - xAngle : xAngle;
	yAngle = yAngle > Math.PI / 2 ? Math.PI - yAngle : yAngle;
	return {
		xExtra: Math.cos(currentAngle / 2 - xAngle) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0,
		yExtra: Math.cos(yAngle - currentAngle / 2) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0
	};
}
function path_default$7(shape) {
	var attrs = shape.attr();
	var path = attrs.path;
	var lineWidth = attrs.stroke ? attrs.lineWidth : 0;
	var segments = shape.get("segments") || getSegments$1(path);
	var _a$5 = getPathBox(segments, lineWidth), x = _a$5.x, y = _a$5.y, width = _a$5.width, height = _a$5.height;
	var bbox = {
		minX: x,
		minY: y,
		maxX: x + width,
		maxY: y + height
	};
	bbox = mergeArrowBBox(shape, bbox);
	return {
		x: bbox.minX,
		y: bbox.minY,
		width: bbox.maxX - bbox.minX,
		height: bbox.maxY - bbox.minY
	};
}

//#endregion
//#region node_modules/@antv/g-base/esm/bbox/line.js
function line_default$8(shape) {
	var attrs = shape.attr();
	var x1 = attrs.x1, y1 = attrs.y1, x2 = attrs.x2, y2 = attrs.y2;
	var bbox = {
		minX: Math.min(x1, x2),
		maxX: Math.max(x1, x2),
		minY: Math.min(y1, y2),
		maxY: Math.max(y1, y2)
	};
	bbox = mergeArrowBBox(shape, bbox);
	return {
		x: bbox.minX,
		y: bbox.minY,
		width: bbox.maxX - bbox.minX,
		height: bbox.maxY - bbox.minY
	};
}

//#endregion
//#region node_modules/@antv/g-base/esm/bbox/ellipse.js
function ellipse_default$2(shape) {
	var attrs = shape.attr();
	var x = attrs.x, y = attrs.y, rx = attrs.rx, ry = attrs.ry;
	return {
		x: x - rx,
		y: y - ry,
		width: rx * 2,
		height: ry * 2
	};
}

//#endregion
//#region node_modules/@antv/g-base/esm/bbox/index.js
register("rect", rect_default$5);
register("image", rect_default$5);
register("circle", circle_default$8);
register("marker", circle_default$8);
register("polyline", polyline_default$3);
register("polygon", polygon_default$3);
register("text", text_default$3);
register("path", path_default$7);
register("line", line_default$8);
register("ellipse", ellipse_default$2);

//#endregion
//#region node_modules/@antv/adjust/esm/constant.js
var DEFAULT_Y = 0;
var MARGIN_RATIO = 1 / 2;
var DODGE_RATIO = 1 / 2;
var GAP = .05;

//#endregion
//#region node_modules/@antv/adjust/esm/adjusts/adjust.js
var Adjust = function() {
	function Adjust$1(cfg) {
		var xField = cfg.xField, yField = cfg.yField, _a$5 = cfg.adjustNames, adjustNames = _a$5 === void 0 ? ["x", "y"] : _a$5, dimValuesMap = cfg.dimValuesMap;
		this.adjustNames = adjustNames;
		this.xField = xField;
		this.yField = yField;
		this.dimValuesMap = dimValuesMap;
	}
	/**
	* 查看维度是否是 adjust 字段
	* @param dim
	*/
	Adjust$1.prototype.isAdjust = function(dim) {
		return this.adjustNames.indexOf(dim) >= 0;
	};
	Adjust$1.prototype.getAdjustRange = function(dim, dimValue, values$1) {
		var yField = this.yField;
		var index = values$1.indexOf(dimValue);
		var length$1 = values$1.length;
		var pre;
		var next;
		if (!yField && this.isAdjust("y")) {
			pre = 0;
			next = 1;
		} else if (length$1 > 1) {
			pre = values$1[index === 0 ? 0 : index - 1];
			next = values$1[index === length$1 - 1 ? length$1 - 1 : index + 1];
			if (index !== 0) pre += (dimValue - pre) / 2;
			else pre -= (next - dimValue) / 2;
			if (index !== length$1 - 1) next -= (next - dimValue) / 2;
			else next += (dimValue - values$1[length$1 - 2]) / 2;
		} else {
			pre = dimValue === 0 ? 0 : dimValue - .5;
			next = dimValue === 0 ? 1 : dimValue + .5;
		}
		return {
			pre,
			next
		};
	};
	Adjust$1.prototype.adjustData = function(groupedDataArray, mergedData) {
		var _this = this;
		var dimValuesMap = this.getDimValues(mergedData);
		each_default(groupedDataArray, function(dataArray, index) {
			each_default(dimValuesMap, function(values$1, dim) {
				_this.adjustDim(dim, values$1, dataArray, index);
			});
		});
	};
	/**
	* 对数据进行分组adjustData
	* @param data 数据
	* @param dim 分组的字段
	* @return 分组结果
	*/
	Adjust$1.prototype.groupData = function(data$2, dim) {
		each_default(data$2, function(record) {
			if (record[dim] === void 0) record[dim] = DEFAULT_Y;
		});
		return group_by_default(data$2, dim);
	};
	/** @override */
	Adjust$1.prototype.adjustDim = function(dim, values$1, data$2, index) {};
	/**
	* 获取可调整度量对应的值
	* @param mergedData 数据
	* @return 值的映射
	*/
	Adjust$1.prototype.getDimValues = function(mergedData) {
		var _a$5 = this, xField = _a$5.xField, yField = _a$5.yField;
		var dimValuesMap = mix({}, this.dimValuesMap);
		var dims = [];
		if (xField && this.isAdjust("x")) dims.push(xField);
		if (yField && this.isAdjust("y")) dims.push(yField);
		dims.forEach(function(dim$1) {
			if (dimValuesMap && dimValuesMap[dim$1]) return;
			dimValuesMap[dim$1] = values_of_key_default(mergedData, dim$1).sort(function(v1, v2) {
				return v1 - v2;
			});
		});
		if (!yField && this.isAdjust("y")) {
			var dim = "y";
			dimValuesMap[dim] = [DEFAULT_Y, 1];
		}
		return dimValuesMap;
	};
	return Adjust$1;
}();
var adjust_default = Adjust;

//#endregion
//#region node_modules/@antv/adjust/esm/factory.js
var ADJUST_MAP = {};
/**
* 根据类型获取 Adjust 类
* @param type
*/
var getAdjust = function(type) {
	return ADJUST_MAP[type.toLowerCase()];
};
/**
* 注册自定义 Adjust
* @param type
* @param ctor
*/
var registerAdjust = function(type, ctor) {
	if (getAdjust(type)) throw new Error("Adjust type '" + type + "' existed.");
	ADJUST_MAP[type.toLowerCase()] = ctor;
};

//#endregion
//#region node_modules/@antv/adjust/node_modules/tslib/tslib.es6.js
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d, b) {
	extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d$1, b$1) {
		d$1.__proto__ = b$1;
	} || function(d$1, b$1) {
		for (var p in b$1) if (b$1.hasOwnProperty(p)) d$1[p] = b$1[p];
	};
	return extendStatics(d, b);
};
function __extends$1(d, b) {
	extendStatics(d, b);
	function __() {
		this.constructor = d;
	}
	d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign$1 = function() {
	__assign$1 = Object.assign || function __assign$2(t) {
		for (var s, i = 1, n = arguments.length; i < n; i++) {
			s = arguments[i];
			for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
		}
		return t;
	};
	return __assign$1.apply(this, arguments);
};

//#endregion
//#region node_modules/@antv/adjust/esm/adjusts/dodge.js
var Dodge = function(_super) {
	__extends$1(Dodge$1, _super);
	function Dodge$1(cfg) {
		var _this = _super.call(this, cfg) || this;
		_this.cacheMap = {};
		_this.adjustDataArray = [];
		_this.mergeData = [];
		var _a$5 = cfg.marginRatio, marginRatio = _a$5 === void 0 ? MARGIN_RATIO : _a$5, _b = cfg.dodgeRatio, dodgeRatio = _b === void 0 ? DODGE_RATIO : _b, dodgeBy = cfg.dodgeBy, intervalPadding = cfg.intervalPadding, dodgePadding = cfg.dodgePadding, xDimensionLength = cfg.xDimensionLength, groupNum = cfg.groupNum, defaultSize = cfg.defaultSize, maxColumnWidth = cfg.maxColumnWidth, minColumnWidth = cfg.minColumnWidth, columnWidthRatio = cfg.columnWidthRatio, customOffset = cfg.customOffset;
		_this.marginRatio = marginRatio;
		_this.dodgeRatio = dodgeRatio;
		_this.dodgeBy = dodgeBy;
		_this.intervalPadding = intervalPadding;
		_this.dodgePadding = dodgePadding;
		_this.xDimensionLegenth = xDimensionLength;
		_this.groupNum = groupNum;
		_this.defaultSize = defaultSize;
		_this.maxColumnWidth = maxColumnWidth;
		_this.minColumnWidth = minColumnWidth;
		_this.columnWidthRatio = columnWidthRatio;
		_this.customOffset = customOffset;
		return _this;
	}
	Dodge$1.prototype.process = function(groupDataArray) {
		var groupedDataArray = clone_default(groupDataArray);
		var mergeData = flatten_default(groupedDataArray);
		var dodgeBy = this.dodgeBy;
		var adjustDataArray = dodgeBy ? group_default$3(mergeData, dodgeBy) : groupedDataArray;
		this.cacheMap = {};
		this.adjustDataArray = adjustDataArray;
		this.mergeData = mergeData;
		this.adjustData(adjustDataArray, mergeData);
		this.adjustDataArray = [];
		this.mergeData = [];
		return groupedDataArray;
	};
	Dodge$1.prototype.adjustDim = function(dim, values$1, data$2, frameIndex) {
		var _this = this;
		var customOffset = this.customOffset;
		var map$3 = this.getDistribution(dim);
		var groupData = this.groupData(data$2, dim);
		each_default(groupData, function(group$1, key) {
			var range;
			if (values$1.length === 1) range = {
				pre: values$1[0] - 1,
				next: values$1[0] + 1
			};
			else range = _this.getAdjustRange(dim, parseFloat(key), values$1);
			each_default(group$1, function(d) {
				var value$1 = d[dim];
				var valueArr = map$3[value$1];
				var valIndex = valueArr.indexOf(frameIndex);
				if (!is_nil_default(customOffset)) {
					var pre = range.pre, next = range.next;
					d[dim] = is_function_default(customOffset) ? customOffset(d, range) : (pre + next) / 2 + customOffset;
				} else d[dim] = _this.getDodgeOffset(range, valIndex, valueArr.length);
			});
		});
		return [];
	};
	Dodge$1.prototype.getDodgeOffset = function(range, idx, len) {
		var _a$5 = this, dodgeRatio = _a$5.dodgeRatio, marginRatio = _a$5.marginRatio, intervalPadding = _a$5.intervalPadding, dodgePadding = _a$5.dodgePadding;
		var pre = range.pre, next = range.next;
		var tickLength = next - pre;
		var position;
		if (!is_nil_default(intervalPadding) && is_nil_default(dodgePadding) && intervalPadding >= 0) {
			var offset = this.getIntervalOnlyOffset(len, idx);
			position = pre + offset;
		} else if (!is_nil_default(dodgePadding) && is_nil_default(intervalPadding) && dodgePadding >= 0) {
			var offset = this.getDodgeOnlyOffset(len, idx);
			position = pre + offset;
		} else if (!is_nil_default(intervalPadding) && !is_nil_default(dodgePadding) && intervalPadding >= 0 && dodgePadding >= 0) {
			var offset = this.getIntervalAndDodgeOffset(len, idx);
			position = pre + offset;
		} else {
			var width = tickLength * dodgeRatio / len;
			var margin = marginRatio * width;
			var offset = 1 / 2 * (tickLength - len * width - (len - 1) * margin) + ((idx + 1) * width + idx * margin) - 1 / 2 * width - 1 / 2 * tickLength;
			position = (pre + next) / 2 + offset;
		}
		return position;
	};
	Dodge$1.prototype.getIntervalOnlyOffset = function(len, idx) {
		var _a$5 = this, defaultSize = _a$5.defaultSize, intervalPadding = _a$5.intervalPadding, xDimensionLegenth = _a$5.xDimensionLegenth, groupNum = _a$5.groupNum, dodgeRatio = _a$5.dodgeRatio, maxColumnWidth = _a$5.maxColumnWidth, minColumnWidth = _a$5.minColumnWidth, columnWidthRatio = _a$5.columnWidthRatio;
		var normalizedIntervalPadding = intervalPadding / xDimensionLegenth;
		var normalizedDodgePadding = (1 - (groupNum - 1) * normalizedIntervalPadding) / groupNum * dodgeRatio / (len - 1);
		var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len - 1)) / len;
		geomWidth = !is_nil_default(columnWidthRatio) ? 1 / groupNum / len * columnWidthRatio : geomWidth;
		if (!is_nil_default(maxColumnWidth)) {
			var normalizedMaxWidht = maxColumnWidth / xDimensionLegenth;
			geomWidth = Math.min(geomWidth, normalizedMaxWidht);
		}
		if (!is_nil_default(minColumnWidth)) {
			var normalizedMinWidht = minColumnWidth / xDimensionLegenth;
			geomWidth = Math.max(geomWidth, normalizedMinWidht);
		}
		geomWidth = defaultSize ? defaultSize / xDimensionLegenth : geomWidth;
		normalizedDodgePadding = ((1 - (groupNum - 1) * normalizedIntervalPadding) / groupNum - len * geomWidth) / (len - 1);
		return ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding + 1 / 2 * normalizedIntervalPadding) * groupNum - normalizedIntervalPadding / 2;
	};
	Dodge$1.prototype.getDodgeOnlyOffset = function(len, idx) {
		var _a$5 = this, defaultSize = _a$5.defaultSize, dodgePadding = _a$5.dodgePadding, xDimensionLegenth = _a$5.xDimensionLegenth, groupNum = _a$5.groupNum, marginRatio = _a$5.marginRatio, maxColumnWidth = _a$5.maxColumnWidth, minColumnWidth = _a$5.minColumnWidth, columnWidthRatio = _a$5.columnWidthRatio;
		var normalizedDodgePadding = dodgePadding / xDimensionLegenth;
		var normalizedIntervalPadding = 1 * marginRatio / (groupNum - 1);
		var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len - 1)) / len;
		geomWidth = columnWidthRatio ? 1 / groupNum / len * columnWidthRatio : geomWidth;
		if (!is_nil_default(maxColumnWidth)) {
			var normalizedMaxWidht = maxColumnWidth / xDimensionLegenth;
			geomWidth = Math.min(geomWidth, normalizedMaxWidht);
		}
		if (!is_nil_default(minColumnWidth)) {
			var normalizedMinWidht = minColumnWidth / xDimensionLegenth;
			geomWidth = Math.max(geomWidth, normalizedMinWidht);
		}
		geomWidth = defaultSize ? defaultSize / xDimensionLegenth : geomWidth;
		normalizedIntervalPadding = (1 - (geomWidth * len + normalizedDodgePadding * (len - 1)) * groupNum) / (groupNum - 1);
		return ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding + 1 / 2 * normalizedIntervalPadding) * groupNum - normalizedIntervalPadding / 2;
	};
	Dodge$1.prototype.getIntervalAndDodgeOffset = function(len, idx) {
		var _a$5 = this, intervalPadding = _a$5.intervalPadding, dodgePadding = _a$5.dodgePadding, xDimensionLegenth = _a$5.xDimensionLegenth, groupNum = _a$5.groupNum;
		var normalizedIntervalPadding = intervalPadding / xDimensionLegenth;
		var normalizedDodgePadding = dodgePadding / xDimensionLegenth;
		var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len - 1)) / len;
		return ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding + 1 / 2 * normalizedIntervalPadding) * groupNum - normalizedIntervalPadding / 2;
	};
	Dodge$1.prototype.getDistribution = function(dim) {
		var groupedDataArray = this.adjustDataArray;
		var cacheMap = this.cacheMap;
		var map$3 = cacheMap[dim];
		if (!map$3) {
			map$3 = {};
			each_default(groupedDataArray, function(data$2, index) {
				var values$1 = values_of_key_default(data$2, dim);
				if (!values$1.length) values$1.push(0);
				each_default(values$1, function(val) {
					if (!map$3[val]) map$3[val] = [];
					map$3[val].push(index);
				});
			});
			cacheMap[dim] = map$3;
		}
		return map$3;
	};
	return Dodge$1;
}(adjust_default);
var dodge_default = Dodge;

//#endregion
//#region node_modules/@antv/adjust/esm/adjusts/jitter.js
function randomNumber(min$2, max$2) {
	return (max$2 - min$2) * Math.random() + min$2;
}
var Jitter = function(_super) {
	__extends$1(Jitter$1, _super);
	function Jitter$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	Jitter$1.prototype.process = function(groupDataArray) {
		var groupedDataArray = clone_default(groupDataArray);
		var mergeData = flatten_default(groupedDataArray);
		this.adjustData(groupedDataArray, mergeData);
		return groupedDataArray;
	};
	/**
	* 当前数据分组（index）中，按照维度 dim 进行 jitter 调整
	* @param dim
	* @param values
	* @param dataArray
	*/
	Jitter$1.prototype.adjustDim = function(dim, values$1, dataArray) {
		var _this = this;
		var groupDataArray = this.groupData(dataArray, dim);
		return each_default(groupDataArray, function(data$2, dimValue) {
			return _this.adjustGroup(data$2, dim, parseFloat(dimValue), values$1);
		});
	};
	Jitter$1.prototype.getAdjustOffset = function(range) {
		var pre = range.pre, next = range.next;
		var margin = (next - pre) * GAP;
		return randomNumber(pre + margin, next - margin);
	};
	Jitter$1.prototype.adjustGroup = function(group$1, dim, dimValue, values$1) {
		var _this = this;
		var range = this.getAdjustRange(dim, dimValue, values$1);
		each_default(group$1, function(data$2) {
			data$2[dim] = _this.getAdjustOffset(range);
		});
		return group$1;
	};
	return Jitter$1;
}(adjust_default);
var jitter_default = Jitter;

//#endregion
//#region node_modules/@antv/adjust/esm/adjusts/stack.js
var Cache = cache_default;
var Stack = function(_super) {
	__extends$1(Stack$1, _super);
	function Stack$1(cfg) {
		var _this = _super.call(this, cfg) || this;
		var _a$5 = cfg.adjustNames, adjustNames = _a$5 === void 0 ? ["y"] : _a$5, _b = cfg.height, height = _b === void 0 ? NaN : _b, _c = cfg.size, size$1 = _c === void 0 ? 10 : _c, _d = cfg.reverseOrder, reverseOrder = _d === void 0 ? false : _d;
		_this.adjustNames = adjustNames;
		_this.height = height;
		_this.size = size$1;
		_this.reverseOrder = reverseOrder;
		return _this;
	}
	/**
	* 方法入参是经过数据分组、数据数字化之后的二维数组
	* @param groupDataArray 分组之后的数据
	*/
	Stack$1.prototype.process = function(groupDataArray) {
		var _a$5 = this, yField = _a$5.yField, reverseOrder = _a$5.reverseOrder;
		var d = yField ? this.processStack(groupDataArray) : this.processOneDimStack(groupDataArray);
		return reverseOrder ? this.reverse(d) : d;
	};
	Stack$1.prototype.reverse = function(groupedDataArray) {
		return groupedDataArray.slice(0).reverse();
	};
	Stack$1.prototype.processStack = function(groupDataArray) {
		var _a$5 = this, xField = _a$5.xField, yField = _a$5.yField;
		var groupedDataArray = _a$5.reverseOrder ? this.reverse(groupDataArray) : groupDataArray;
		var positive = new Cache();
		var negative = new Cache();
		return groupedDataArray.map(function(dataArray) {
			return dataArray.map(function(data$2) {
				var _a$6;
				var x = get_default(data$2, xField, 0);
				var y = get_default(data$2, [yField]);
				var xKey = x.toString();
				y = is_array_default(y) ? y[1] : y;
				if (!is_nil_default(y)) {
					var cache$2 = y >= 0 ? positive : negative;
					if (!cache$2.has(xKey)) cache$2.set(xKey, 0);
					var xValue = cache$2.get(xKey);
					var newXValue = y + xValue;
					cache$2.set(xKey, newXValue);
					return __assign$1(__assign$1({}, data$2), (_a$6 = {}, _a$6[yField] = [xValue, newXValue], _a$6));
				}
				return data$2;
			});
		});
	};
	Stack$1.prototype.processOneDimStack = function(groupDataArray) {
		var _this = this;
		var _a$5 = this, xField = _a$5.xField, height = _a$5.height, reverseOrder = _a$5.reverseOrder;
		var yField = "y";
		var groupedDataArray = reverseOrder ? this.reverse(groupDataArray) : groupDataArray;
		var cache$2 = new Cache();
		return groupedDataArray.map(function(dataArray) {
			return dataArray.map(function(data$2) {
				var _a$6;
				var size$1 = _this.size;
				var xValue = data$2[xField];
				var stackHeight = size$1 * 2 / height;
				if (!cache$2.has(xValue)) cache$2.set(xValue, stackHeight / 2);
				var stackValue = cache$2.get(xValue);
				cache$2.set(xValue, stackValue + stackHeight);
				return __assign$1(__assign$1({}, data$2), (_a$6 = {}, _a$6[yField] = stackValue, _a$6));
			});
		});
	};
	return Stack$1;
}(adjust_default);
var stack_default = Stack;

//#endregion
//#region node_modules/@antv/adjust/esm/adjusts/symmetric.js
var Symmetric = function(_super) {
	__extends$1(Symmetric$1, _super);
	function Symmetric$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	Symmetric$1.prototype.process = function(groupDataArray) {
		var mergeData = flatten_default(groupDataArray);
		var _a$5 = this, xField = _a$5.xField, yField = _a$5.yField;
		var cache$2 = this.getXValuesMaxMap(mergeData);
		var max$2 = Math.max.apply(Math, Object.keys(cache$2).map(function(key) {
			return cache$2[key];
		}));
		return map_default(groupDataArray, function(dataArray) {
			return map_default(dataArray, function(data$2) {
				var _a$6, _b;
				var yValue = data$2[yField];
				var xValue = data$2[xField];
				if (is_array_default(yValue)) {
					var off_1 = (max$2 - cache$2[xValue]) / 2;
					return __assign$1(__assign$1({}, data$2), (_a$6 = {}, _a$6[yField] = map_default(yValue, function(y) {
						return off_1 + y;
					}), _a$6));
				}
				var offset = (max$2 - yValue) / 2;
				return __assign$1(__assign$1({}, data$2), (_b = {}, _b[yField] = [offset, yValue + offset], _b));
			});
		});
	};
	Symmetric$1.prototype.getXValuesMaxMap = function(mergeData) {
		var _this = this;
		var _a$5 = this, xField = _a$5.xField, yField = _a$5.yField;
		var groupDataArray = group_by_default(mergeData, function(data$2) {
			return data$2[xField];
		});
		return map_values_default(groupDataArray, function(dataArray) {
			return _this.getDimMaxValue(dataArray, yField);
		});
	};
	Symmetric$1.prototype.getDimMaxValue = function(mergeData, dim) {
		var dimValues = map_default(mergeData, function(data$2) {
			return get_default(data$2, dim, []);
		});
		var flattenValues = flatten_default(dimValues);
		return Math.max.apply(Math, flattenValues);
	};
	return Symmetric$1;
}(adjust_default);
var symmetric_default = Symmetric;

//#endregion
//#region node_modules/@antv/adjust/esm/index.js
registerAdjust("Dodge", dodge_default);
registerAdjust("Jitter", jitter_default);
registerAdjust("Stack", stack_default);
registerAdjust("Symmetric", symmetric_default);

//#endregion
//#region node_modules/@antv/attr/esm/attributes/base.js
var toScaleString = function(scale$4, value$1) {
	if (is_string_default(value$1)) return value$1;
	return scale$4.invert(scale$4.scale(value$1));
};
/**
* 所有视觉通道属性的基类
* @class Base
*/
var Attribute = function() {
	function Attribute$1(cfg) {
		this.names = [];
		this.scales = [];
		this.linear = false;
		this.values = [];
		this.callback = function() {
			return [];
		};
		this._parseCfg(cfg);
	}
	/**
	* 映射的值组成的数组
	* @param params 对应 scale 顺序的值传入
	*/
	Attribute$1.prototype.mapping = function() {
		var _this = this;
		var params = [];
		for (var _i = 0; _i < arguments.length; _i++) params[_i] = arguments[_i];
		var values$1 = params.map(function(param, idx) {
			return _this._toOriginParam(param, _this.scales[idx]);
		});
		return this.callback.apply(this, values$1);
	};
	/**
	* 如果进行线性映射，返回对应的映射值
	* @param percent
	*/
	Attribute$1.prototype.getLinearValue = function(percent$1) {
		var steps = this.values.length - 1;
		var step = Math.floor(steps * percent$1);
		var leftPercent = steps * percent$1 - step;
		var start = this.values[step];
		var end = step === steps ? start : this.values[step + 1];
		return start + (end - start) * leftPercent;
	};
	/**
	* 根据度量获取属性名
	*/
	Attribute$1.prototype.getNames = function() {
		var scales = this.scales;
		var names = this.names;
		var length$1 = Math.min(scales.length, names.length);
		var rst = [];
		for (var i = 0; i < length$1; i += 1) rst.push(names[i]);
		return rst;
	};
	/**
	* 获取所有的维度名
	*/
	Attribute$1.prototype.getFields = function() {
		return this.scales.map(function(scale$4) {
			return scale$4.field;
		});
	};
	/**
	* 根据名称获取度量
	* @param name
	*/
	Attribute$1.prototype.getScale = function(name) {
		return this.scales[this.names.indexOf(name)];
	};
	/**
	* 默认的回调函数（用户没有自定义 callback，或者用户自定义 callback 返回空的时候，使用 values 映射）
	* @param params
	*/
	Attribute$1.prototype.defaultCallback = function() {
		var _this = this;
		var params = [];
		for (var _i = 0; _i < arguments.length; _i++) params[_i] = arguments[_i];
		if (params.length === 0) return this.values;
		return params.map(function(param, idx) {
			var scale$4 = _this.scales[idx];
			return scale$4.type === "identity" ? scale$4.values[0] : _this._getAttributeValue(scale$4, param);
		});
	};
	Attribute$1.prototype._parseCfg = function(cfg) {
		var _this = this;
		var _a$5 = cfg.type, type = _a$5 === void 0 ? "base" : _a$5, _b = cfg.names, names = _b === void 0 ? [] : _b, _c = cfg.scales, scales = _c === void 0 ? [] : _c, _d = cfg.values, values$1 = _d === void 0 ? [] : _d, callback = cfg.callback;
		this.type = type;
		this.scales = scales;
		this.values = values$1;
		this.names = names;
		this.callback = function() {
			var params = [];
			for (var _i = 0; _i < arguments.length; _i++) params[_i] = arguments[_i];
			/**
			* 当用户设置的 callback 返回 null 时, 应该返回默认 callback 中的值
			*/
			if (callback) {
				var ret = callback.apply(void 0, params);
				if (!is_nil_default(ret)) return [ret];
			}
			return _this.defaultCallback.apply(_this, params);
		};
	};
	Attribute$1.prototype._getAttributeValue = function(scale$4, value$1) {
		if (scale$4.isCategory && !this.linear) {
			var idx = scale$4.translate(value$1);
			return this.values[idx % this.values.length];
		}
		var percent$1 = scale$4.scale(value$1);
		return this.getLinearValue(percent$1);
	};
	/**
	* 通过 scale 拿到数据对应的原始的参数
	* @param param
	* @param scale
	* @private
	*/
	Attribute$1.prototype._toOriginParam = function(param, scale$4) {
		return !scale$4.isLinear ? is_array_default(param) ? param.map(function(p) {
			return toScaleString(scale$4, p);
		}) : toScaleString(scale$4, param) : param;
	};
	return Attribute$1;
}();
var base_default$17 = Attribute;

//#endregion
//#region node_modules/@antv/color-util/esm/index.js
var RGB_REG = /rgba?\(([\s.,0-9]+)\)/;
var regexLG$2 = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG$2 = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexColorStop$2 = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;
var isGradientColor = function(val) {
	return /^[r,R,L,l]{1}[\s]*\(/.test(val);
};
var createTmp = function() {
	var i = document.createElement("i");
	i.title = "Web Colour Picker";
	i.style.display = "none";
	document.body.appendChild(i);
	return i;
};
var getValue = function(start, end, percent$1, index) {
	return start[index] + (end[index] - start[index]) * percent$1;
};
function arr2rgb(arr) {
	return "#" + toHex(arr[0]) + toHex(arr[1]) + toHex(arr[2]);
}
var rgb2arr = function(str) {
	return [
		parseInt(str.substr(1, 2), 16),
		parseInt(str.substr(3, 2), 16),
		parseInt(str.substr(5, 2), 16)
	];
};
var toHex = function(value$1) {
	var x16Value = Math.round(value$1).toString(16);
	return x16Value.length === 1 ? "0" + x16Value : x16Value;
};
var calColor = function(points, percent$1) {
	var fixedPercent = isNaN(Number(percent$1)) || percent$1 < 0 ? 0 : percent$1 > 1 ? 1 : Number(percent$1);
	var steps = points.length - 1;
	var step = Math.floor(steps * fixedPercent);
	var left$1 = steps * fixedPercent - step;
	var start = points[step];
	var end = step === steps ? start : points[step + 1];
	return arr2rgb([
		getValue(start, end, left$1, 0),
		getValue(start, end, left$1, 1),
		getValue(start, end, left$1, 2)
	]);
};
var iEl;
/**
* 将颜色转换到 rgb 的格式
* @param {color} color 颜色
* @return 将颜色转换到 '#ffffff' 的格式
*/
var toRGB = function(color$2) {
	if (color$2[0] === "#" && color$2.length === 7) return color$2;
	if (!iEl) iEl = createTmp();
	iEl.style.color = color$2;
	var rst = document.defaultView.getComputedStyle(iEl, "").getPropertyValue("color");
	var cArray = RGB_REG.exec(rst)[1].split(/\s*,\s*/).map(function(s) {
		return Number(s);
	});
	rst = arr2rgb(cArray);
	return rst;
};
/**
* 获取渐变函数
* @param colors 多个颜色
* @return 颜色值
*/
var gradient = function(colors) {
	var colorArray = is_string_default(colors) ? colors.split("-") : colors;
	var points = map_default(colorArray, function(color$2) {
		return rgb2arr(color$2.indexOf("#") === -1 ? toRGB(color$2) : color$2);
	});
	return function(percent$1) {
		return calColor(points, percent$1);
	};
};
var toCSSGradient = function(gradientColor) {
	if (isGradientColor(gradientColor)) {
		var cssColor_1;
		var steps = void 0;
		if (gradientColor[0] === "l") {
			var arr = regexLG$2.exec(gradientColor);
			var angle$1 = +arr[1] + 90;
			steps = arr[2];
			cssColor_1 = "linear-gradient(" + angle$1 + "deg, ";
		} else if (gradientColor[0] === "r") {
			cssColor_1 = "radial-gradient(";
			var arr = regexRG$2.exec(gradientColor);
			steps = arr[4];
		}
		var colorStops_1 = steps.match(regexColorStop$2);
		each_default(colorStops_1, function(item, index) {
			var itemArr = item.split(":");
			cssColor_1 += itemArr[1] + " " + itemArr[0] * 100 + "%";
			if (index !== colorStops_1.length - 1) cssColor_1 += ", ";
		});
		cssColor_1 += ")";
		return cssColor_1;
	}
	return gradientColor;
};
var esm_default = {
	rgb2arr,
	gradient,
	toRGB: memoize_default(toRGB),
	toCSSGradient
};

//#endregion
//#region node_modules/@antv/attr/esm/attributes/color.js
var Color = function(_super) {
	__extends(Color$1, _super);
	function Color$1(cfg) {
		var _this = _super.call(this, cfg) || this;
		_this.type = "color";
		_this.names = ["color"];
		if (is_string_default(_this.values)) _this.linear = true;
		_this.gradient = esm_default.gradient(_this.values);
		return _this;
	}
	/**
	* @override
	*/
	Color$1.prototype.getLinearValue = function(percent$1) {
		return this.gradient(percent$1);
	};
	return Color$1;
}(base_default$17);
var color_default = Color;

//#endregion
//#region node_modules/@antv/attr/esm/attributes/opacity.js
var Opacity = function(_super) {
	__extends(Opacity$1, _super);
	function Opacity$1(cfg) {
		var _this = _super.call(this, cfg) || this;
		_this.type = "opacity";
		_this.names = ["opacity"];
		return _this;
	}
	return Opacity$1;
}(base_default$17);
var opacity_default = Opacity;

//#endregion
//#region node_modules/@antv/attr/esm/attributes/position.js
var Position = function(_super) {
	__extends(Position$1, _super);
	function Position$1(cfg) {
		var _this = _super.call(this, cfg) || this;
		_this.names = ["x", "y"];
		_this.type = "position";
		return _this;
	}
	Position$1.prototype.mapping = function(x, y) {
		var _a$5 = this.scales, scaleX = _a$5[0], scaleY = _a$5[1];
		if (is_nil_default(x) || is_nil_default(y)) return [];
		return [is_array_default(x) ? x.map(function(xi) {
			return scaleX.scale(xi);
		}) : scaleX.scale(x), is_array_default(y) ? y.map(function(yi) {
			return scaleY.scale(yi);
		}) : scaleY.scale(y)];
	};
	return Position$1;
}(base_default$17);
var position_default = Position;

//#endregion
//#region node_modules/@antv/attr/esm/attributes/shape.js
var Shape = function(_super) {
	__extends(Shape$1, _super);
	function Shape$1(cfg) {
		var _this = _super.call(this, cfg) || this;
		_this.type = "shape";
		_this.names = ["shape"];
		return _this;
	}
	/**
	* @override
	*/
	Shape$1.prototype.getLinearValue = function(percent$1) {
		var idx = Math.round((this.values.length - 1) * percent$1);
		return this.values[idx];
	};
	return Shape$1;
}(base_default$17);
var shape_default$2 = Shape;

//#endregion
//#region node_modules/@antv/attr/esm/attributes/size.js
var Size = function(_super) {
	__extends(Size$1, _super);
	function Size$1(cfg) {
		var _this = _super.call(this, cfg) || this;
		_this.type = "size";
		_this.names = ["size"];
		return _this;
	}
	return Size$1;
}(base_default$17);
var size_default = Size;

//#endregion
//#region node_modules/@antv/scale/esm/tick-method/register.js
var methodCache = {};
/**
* 获取计算 ticks 的方法
* @param key 键值
* @returns 计算 ticks 的方法
*/
function getTickMethod(key) {
	return methodCache[key];
}
/**
* 注册计算 ticks 的方法
* @param key 键值
* @param method 方法
*/
function registerTickMethod(key, method) {
	methodCache[key] = method;
}

//#endregion
//#region node_modules/@antv/scale/esm/base.js
var Scale = function() {
	function Scale$1(cfg) {
		/**
		* 度量的类型
		*/
		this.type = "base";
		/**
		* 是否分类类型的度量
		*/
		this.isCategory = false;
		/**
		* 是否线性度量，有linear, time 度量
		*/
		this.isLinear = false;
		/**
		* 是否连续类型的度量，linear,time,log, pow, quantile, quantize 都支持
		*/
		this.isContinuous = false;
		/**
		* 是否是常量的度量，传入和传出一致
		*/
		this.isIdentity = false;
		this.values = [];
		this.range = [0, 1];
		this.ticks = [];
		this.__cfg__ = cfg;
		this.initCfg();
		this.init();
	}
	Scale$1.prototype.translate = function(v) {
		return v;
	};
	/** 重新初始化 */
	Scale$1.prototype.change = function(cfg) {
		mix(this.__cfg__, cfg);
		this.init();
	};
	Scale$1.prototype.clone = function() {
		return this.constructor(this.__cfg__);
	};
	/** 获取坐标轴需要的ticks */
	Scale$1.prototype.getTicks = function() {
		var _this = this;
		return map_default(this.ticks, function(tick, idx) {
			if (is_object_default(tick)) return tick;
			return {
				text: _this.getText(tick, idx),
				tickValue: tick,
				value: _this.scale(tick)
			};
		});
	};
	/** 获取Tick的格式化结果 */
	Scale$1.prototype.getText = function(value$1, key) {
		var formatter = this.formatter;
		var res = formatter ? formatter(value$1, key) : value$1;
		if (is_nil_default(res) || !is_function_default(res.toString)) return "";
		return res.toString();
	};
	Scale$1.prototype.getConfig = function(key) {
		return this.__cfg__[key];
	};
	Scale$1.prototype.init = function() {
		mix(this, this.__cfg__);
		this.setDomain();
		if (is_empty_default(this.getConfig("ticks"))) this.ticks = this.calculateTicks();
	};
	Scale$1.prototype.initCfg = function() {};
	Scale$1.prototype.setDomain = function() {};
	Scale$1.prototype.calculateTicks = function() {
		var tickMethod = this.tickMethod;
		var ticks = [];
		if (is_string_default(tickMethod)) {
			var method = getTickMethod(tickMethod);
			if (!method) throw new Error("There is no method to to calculate ticks!");
			ticks = method(this);
		} else if (is_function_default(tickMethod)) ticks = tickMethod(this);
		return ticks;
	};
	Scale$1.prototype.rangeMin = function() {
		return this.range[0];
	};
	Scale$1.prototype.rangeMax = function() {
		return this.range[1];
	};
	/** 定义域转 0~1 */
	Scale$1.prototype.calcPercent = function(value$1, min$2, max$2) {
		if (is_number_default(value$1)) return (value$1 - min$2) / (max$2 - min$2);
		return NaN;
	};
	/** 0~1转定义域 */
	Scale$1.prototype.calcValue = function(percent$1, min$2, max$2) {
		return min$2 + percent$1 * (max$2 - min$2);
	};
	return Scale$1;
}();
var base_default$8 = Scale;

//#endregion
//#region node_modules/@antv/scale/esm/category/base.js
/**
* 分类度量
* @class
*/
var Category$1 = function(_super) {
	__extends(Category$2, _super);
	function Category$2() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = "cat";
		_this.isCategory = true;
		return _this;
	}
	Category$2.prototype.buildIndexMap = function() {
		if (!this.translateIndexMap) {
			this.translateIndexMap = /* @__PURE__ */ new Map();
			for (var i = 0; i < this.values.length; i++) this.translateIndexMap.set(this.values[i], i);
		}
	};
	Category$2.prototype.translate = function(value$1) {
		this.buildIndexMap();
		var idx = this.translateIndexMap.get(value$1);
		if (idx === void 0) idx = is_number_default(value$1) ? value$1 : NaN;
		return idx;
	};
	Category$2.prototype.scale = function(value$1) {
		var order = this.translate(value$1);
		var percent$1 = this.calcPercent(order, this.min, this.max);
		return this.calcValue(percent$1, this.rangeMin(), this.rangeMax());
	};
	Category$2.prototype.invert = function(scaledValue) {
		var domainRange = this.max - this.min;
		var percent$1 = this.calcPercent(scaledValue, this.rangeMin(), this.rangeMax());
		var idx = Math.round(domainRange * percent$1) + this.min;
		if (idx < this.min || idx > this.max) return NaN;
		return this.values[idx];
	};
	Category$2.prototype.getText = function(value$1) {
		var args = [];
		for (var _i = 1; _i < arguments.length; _i++) args[_i - 1] = arguments[_i];
		var v = value$1;
		if (is_number_default(value$1) && !this.values.includes(value$1)) v = this.values[v];
		return _super.prototype.getText.apply(this, __spreadArrays([v], args));
	};
	Category$2.prototype.initCfg = function() {
		this.tickMethod = "cat";
	};
	Category$2.prototype.setDomain = function() {
		if (is_nil_default(this.getConfig("min"))) this.min = 0;
		if (is_nil_default(this.getConfig("max"))) {
			var size$1 = this.values.length;
			this.max = size$1 > 1 ? size$1 - 1 : size$1;
		}
		if (this.translateIndexMap) this.translateIndexMap = void 0;
	};
	return Category$2;
}(base_default$8);
var base_default$10 = Category$1;

//#endregion
//#region node_modules/fecha/lib/fecha.js
var fecha_exports = /* @__PURE__ */ __export({
	assign: () => assign,
	default: () => fecha_default,
	defaultI18n: () => defaultI18n,
	format: () => format,
	parse: () => parse,
	setGlobalDateI18n: () => setGlobalDateI18n,
	setGlobalDateMasks: () => setGlobalDateMasks
});
var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
var twoDigitsOptional = "\\d\\d?";
var twoDigits = "\\d\\d";
var threeDigits = "\\d{3}";
var fourDigits = "\\d{4}";
var word = "[^\\s]+";
var literal = /\[([^]*?)\]/gm;
function shorten(arr, sLen) {
	var newArr = [];
	for (var i = 0, len = arr.length; i < len; i++) newArr.push(arr[i].substr(0, sLen));
	return newArr;
}
var monthUpdate = function(arrName) {
	return function(v, i18n) {
		var index = i18n[arrName].map(function(v$1) {
			return v$1.toLowerCase();
		}).indexOf(v.toLowerCase());
		if (index > -1) return index;
		return null;
	};
};
function assign(origObj) {
	var args = [];
	for (var _i = 1; _i < arguments.length; _i++) args[_i - 1] = arguments[_i];
	for (var _a$5 = 0, args_1 = args; _a$5 < args_1.length; _a$5++) {
		var obj = args_1[_a$5];
		for (var key in obj) origObj[key] = obj[key];
	}
	return origObj;
}
var dayNames = [
	"Sunday",
	"Monday",
	"Tuesday",
	"Wednesday",
	"Thursday",
	"Friday",
	"Saturday"
];
var monthNames = [
	"January",
	"February",
	"March",
	"April",
	"May",
	"June",
	"July",
	"August",
	"September",
	"October",
	"November",
	"December"
];
var monthNamesShort = shorten(monthNames, 3);
var defaultI18n = {
	dayNamesShort: shorten(dayNames, 3),
	dayNames,
	monthNamesShort,
	monthNames,
	amPm: ["am", "pm"],
	DoFn: function(dayOfMonth) {
		return dayOfMonth + [
			"th",
			"st",
			"nd",
			"rd"
		][dayOfMonth % 10 > 3 ? 0 : (dayOfMonth - dayOfMonth % 10 !== 10 ? 1 : 0) * dayOfMonth % 10];
	}
};
var globalI18n = assign({}, defaultI18n);
var setGlobalDateI18n = function(i18n) {
	return globalI18n = assign(globalI18n, i18n);
};
var regexEscape = function(str) {
	return str.replace(/[|\\{()[^$+*?.-]/g, "\\$&");
};
var pad = function(val, len) {
	if (len === void 0) len = 2;
	val = String(val);
	while (val.length < len) val = "0" + val;
	return val;
};
var formatFlags = {
	D: function(dateObj) {
		return String(dateObj.getDate());
	},
	DD: function(dateObj) {
		return pad(dateObj.getDate());
	},
	Do: function(dateObj, i18n) {
		return i18n.DoFn(dateObj.getDate());
	},
	d: function(dateObj) {
		return String(dateObj.getDay());
	},
	dd: function(dateObj) {
		return pad(dateObj.getDay());
	},
	ddd: function(dateObj, i18n) {
		return i18n.dayNamesShort[dateObj.getDay()];
	},
	dddd: function(dateObj, i18n) {
		return i18n.dayNames[dateObj.getDay()];
	},
	M: function(dateObj) {
		return String(dateObj.getMonth() + 1);
	},
	MM: function(dateObj) {
		return pad(dateObj.getMonth() + 1);
	},
	MMM: function(dateObj, i18n) {
		return i18n.monthNamesShort[dateObj.getMonth()];
	},
	MMMM: function(dateObj, i18n) {
		return i18n.monthNames[dateObj.getMonth()];
	},
	YY: function(dateObj) {
		return pad(String(dateObj.getFullYear()), 4).substr(2);
	},
	YYYY: function(dateObj) {
		return pad(dateObj.getFullYear(), 4);
	},
	h: function(dateObj) {
		return String(dateObj.getHours() % 12 || 12);
	},
	hh: function(dateObj) {
		return pad(dateObj.getHours() % 12 || 12);
	},
	H: function(dateObj) {
		return String(dateObj.getHours());
	},
	HH: function(dateObj) {
		return pad(dateObj.getHours());
	},
	m: function(dateObj) {
		return String(dateObj.getMinutes());
	},
	mm: function(dateObj) {
		return pad(dateObj.getMinutes());
	},
	s: function(dateObj) {
		return String(dateObj.getSeconds());
	},
	ss: function(dateObj) {
		return pad(dateObj.getSeconds());
	},
	S: function(dateObj) {
		return String(Math.round(dateObj.getMilliseconds() / 100));
	},
	SS: function(dateObj) {
		return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
	},
	SSS: function(dateObj) {
		return pad(dateObj.getMilliseconds(), 3);
	},
	a: function(dateObj, i18n) {
		return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
	},
	A: function(dateObj, i18n) {
		return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
	},
	ZZ: function(dateObj) {
		var offset = dateObj.getTimezoneOffset();
		return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60) * 100 + Math.abs(offset) % 60, 4);
	},
	Z: function(dateObj) {
		var offset = dateObj.getTimezoneOffset();
		return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60), 2) + ":" + pad(Math.abs(offset) % 60, 2);
	}
};
var monthParse = function(v) {
	return +v - 1;
};
var emptyDigits = [null, twoDigitsOptional];
var emptyWord = [null, word];
var amPm = [
	"isPm",
	word,
	function(v, i18n) {
		var val = v.toLowerCase();
		if (val === i18n.amPm[0]) return 0;
		else if (val === i18n.amPm[1]) return 1;
		return null;
	}
];
var timezoneOffset = [
	"timezoneOffset",
	"[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z?",
	function(v) {
		var parts = (v + "").match(/([+-]|\d\d)/gi);
		if (parts) {
			var minutes = +parts[1] * 60 + parseInt(parts[2], 10);
			return parts[0] === "+" ? minutes : -minutes;
		}
		return 0;
	}
];
var parseFlags = {
	D: ["day", twoDigitsOptional],
	DD: ["day", twoDigits],
	Do: [
		"day",
		twoDigitsOptional + word,
		function(v) {
			return parseInt(v, 10);
		}
	],
	M: [
		"month",
		twoDigitsOptional,
		monthParse
	],
	MM: [
		"month",
		twoDigits,
		monthParse
	],
	YY: [
		"year",
		twoDigits,
		function(v) {
			var cent = +("" + (/* @__PURE__ */ new Date()).getFullYear()).substr(0, 2);
			return +("" + (+v > 68 ? cent - 1 : cent) + v);
		}
	],
	h: [
		"hour",
		twoDigitsOptional,
		void 0,
		"isPm"
	],
	hh: [
		"hour",
		twoDigits,
		void 0,
		"isPm"
	],
	H: ["hour", twoDigitsOptional],
	HH: ["hour", twoDigits],
	m: ["minute", twoDigitsOptional],
	mm: ["minute", twoDigits],
	s: ["second", twoDigitsOptional],
	ss: ["second", twoDigits],
	YYYY: ["year", fourDigits],
	S: [
		"millisecond",
		"\\d",
		function(v) {
			return +v * 100;
		}
	],
	SS: [
		"millisecond",
		twoDigits,
		function(v) {
			return +v * 10;
		}
	],
	SSS: ["millisecond", threeDigits],
	d: emptyDigits,
	dd: emptyDigits,
	ddd: emptyWord,
	dddd: emptyWord,
	MMM: [
		"month",
		word,
		monthUpdate("monthNamesShort")
	],
	MMMM: [
		"month",
		word,
		monthUpdate("monthNames")
	],
	a: amPm,
	A: amPm,
	ZZ: timezoneOffset,
	Z: timezoneOffset
};
var globalMasks = {
	default: "ddd MMM DD YYYY HH:mm:ss",
	shortDate: "M/D/YY",
	mediumDate: "MMM D, YYYY",
	longDate: "MMMM D, YYYY",
	fullDate: "dddd, MMMM D, YYYY",
	isoDate: "YYYY-MM-DD",
	isoDateTime: "YYYY-MM-DDTHH:mm:ssZ",
	shortTime: "HH:mm",
	mediumTime: "HH:mm:ss",
	longTime: "HH:mm:ss.SSS"
};
var setGlobalDateMasks = function(masks) {
	return assign(globalMasks, masks);
};
/***
* Format a date
* @method format
* @param {Date|number} dateObj
* @param {string} mask Format of the date, i.e. 'mm-dd-yy' or 'shortDate'
* @returns {string} Formatted date string
*/
var format = function(dateObj, mask, i18n) {
	if (mask === void 0) mask = globalMasks["default"];
	if (i18n === void 0) i18n = {};
	if (typeof dateObj === "number") dateObj = new Date(dateObj);
	if (Object.prototype.toString.call(dateObj) !== "[object Date]" || isNaN(dateObj.getTime())) throw new Error("Invalid Date pass to format");
	mask = globalMasks[mask] || mask;
	var literals = [];
	mask = mask.replace(literal, function($0, $1) {
		literals.push($1);
		return "@@@";
	});
	var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
	mask = mask.replace(token, function($0) {
		return formatFlags[$0](dateObj, combinedI18nSettings);
	});
	return mask.replace(/@@@/g, function() {
		return literals.shift();
	});
};
/**
* Parse a date string into a Javascript Date object /
* @method parse
* @param {string} dateStr Date string
* @param {string} format Date parse format
* @param {i18n} I18nSettingsOptional Full or subset of I18N settings
* @returns {Date|null} Returns Date object. Returns null what date string is invalid or doesn't match format
*/
function parse(dateStr, format$1, i18n) {
	if (i18n === void 0) i18n = {};
	if (typeof format$1 !== "string") throw new Error("Invalid format in fecha parse");
	format$1 = globalMasks[format$1] || format$1;
	if (dateStr.length > 1e3) return null;
	var dateInfo = {
		year: (/* @__PURE__ */ new Date()).getFullYear(),
		month: 0,
		day: 1,
		hour: 0,
		minute: 0,
		second: 0,
		millisecond: 0,
		isPm: null,
		timezoneOffset: null
	};
	var parseInfo = [];
	var literals = [];
	var newFormat = format$1.replace(literal, function($0, $1) {
		literals.push(regexEscape($1));
		return "@@@";
	});
	var specifiedFields = {};
	var requiredFields = {};
	newFormat = regexEscape(newFormat).replace(token, function($0) {
		var info = parseFlags[$0];
		var field$6 = info[0], regex = info[1], requiredField = info[3];
		if (specifiedFields[field$6]) throw new Error("Invalid format. " + field$6 + " specified twice in format");
		specifiedFields[field$6] = true;
		if (requiredField) requiredFields[requiredField] = true;
		parseInfo.push(info);
		return "(" + regex + ")";
	});
	Object.keys(requiredFields).forEach(function(field$6) {
		if (!specifiedFields[field$6]) throw new Error("Invalid format. " + field$6 + " is required in specified format");
	});
	newFormat = newFormat.replace(/@@@/g, function() {
		return literals.shift();
	});
	var matches = dateStr.match(new RegExp(newFormat, "i"));
	if (!matches) return null;
	var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
	for (var i = 1; i < matches.length; i++) {
		var _a$5 = parseInfo[i - 1], field$5 = _a$5[0], parser = _a$5[2];
		var value$1 = parser ? parser(matches[i], combinedI18nSettings) : +matches[i];
		if (value$1 == null) return null;
		dateInfo[field$5] = value$1;
	}
	if (dateInfo.isPm === 1 && dateInfo.hour != null && +dateInfo.hour !== 12) dateInfo.hour = +dateInfo.hour + 12;
	else if (dateInfo.isPm === 0 && +dateInfo.hour === 12) dateInfo.hour = 0;
	var dateTZ;
	if (dateInfo.timezoneOffset == null) {
		dateTZ = new Date(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute, dateInfo.second, dateInfo.millisecond);
		var validateFields = [
			["month", "getMonth"],
			["day", "getDate"],
			["hour", "getHours"],
			["minute", "getMinutes"],
			["second", "getSeconds"]
		];
		for (var i = 0, len = validateFields.length; i < len; i++) if (specifiedFields[validateFields[i][0]] && dateInfo[validateFields[i][0]] !== dateTZ[validateFields[i][1]]()) return null;
	} else {
		dateTZ = new Date(Date.UTC(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute - dateInfo.timezoneOffset, dateInfo.second, dateInfo.millisecond));
		if (dateInfo.month > 11 || dateInfo.month < 0 || dateInfo.day > 31 || dateInfo.day < 1 || dateInfo.hour > 23 || dateInfo.hour < 0 || dateInfo.minute > 59 || dateInfo.minute < 0 || dateInfo.second > 59 || dateInfo.second < 0) return null;
	}
	return dateTZ;
}
var fecha = {
	format,
	parse,
	defaultI18n,
	setGlobalDateI18n,
	setGlobalDateMasks
};
var fecha_default = fecha;

//#endregion
//#region node_modules/@antv/scale/esm/util/bisector.js
/**
* 二分右侧查找
* https://github.com/d3/d3-array/blob/master/src/bisector.js
*/
function bisector_default(getter) {
	/**
	* x: 目标值
	* lo: 起始位置
	* hi: 结束位置
	*/
	return function(a, x, _lo, _hi) {
		var lo = is_nil_default(_lo) ? 0 : _lo;
		var hi = is_nil_default(_hi) ? a.length : _hi;
		while (lo < hi) {
			var mid$1 = lo + hi >>> 1;
			if (getter(a[mid$1]) > x) hi = mid$1;
			else lo = mid$1 + 1;
		}
		return lo;
	};
}

//#endregion
//#region node_modules/@antv/scale/esm/util/time.js
var FORMAT_METHOD = "format";
function timeFormat(time, mask) {
	return (fecha_exports[FORMAT_METHOD] || fecha_default[FORMAT_METHOD])(time, mask);
}
/**
* 转换成时间戳
* @param value 时间值
*/
function toTimeStamp(value$1) {
	if (is_string_default(value$1)) if (value$1.indexOf("T") > 0) value$1 = new Date(value$1).getTime();
	else value$1 = new Date(value$1.replace(/-/gi, "/")).getTime();
	if (is_date_default(value$1)) value$1 = value$1.getTime();
	return value$1;
}
var SECOND = 1e3;
var MINUTE = 60 * SECOND;
var HOUR = 60 * MINUTE;
var DAY = 24 * HOUR;
var MONTH = DAY * 31;
var YEAR = DAY * 365;
var intervals = [
	["HH:mm:ss", SECOND],
	["HH:mm:ss", SECOND * 10],
	["HH:mm:ss", SECOND * 30],
	["HH:mm", MINUTE],
	["HH:mm", MINUTE * 10],
	["HH:mm", MINUTE * 30],
	["HH", HOUR],
	["HH", HOUR * 6],
	["HH", HOUR * 12],
	["YYYY-MM-DD", DAY],
	["YYYY-MM-DD", DAY * 4],
	["YYYY-WW", DAY * 7],
	["YYYY-MM", MONTH],
	["YYYY-MM", MONTH * 4],
	["YYYY-MM", MONTH * 6],
	["YYYY", DAY * 380]
];
function getTickInterval(min$2, max$2, tickCount) {
	var target = (max$2 - min$2) / tickCount;
	var idx = bisector_default(function(o) {
		return o[1];
	})(intervals, target) - 1;
	var interval$2 = intervals[idx];
	if (idx < 0) interval$2 = intervals[0];
	else if (idx >= intervals.length) interval$2 = last(intervals);
	return interval$2;
}

//#endregion
//#region node_modules/@antv/scale/esm/category/time.js
/**
* 时间分类度量
* @class
*/
var TimeCat = function(_super) {
	__extends(TimeCat$1, _super);
	function TimeCat$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = "timeCat";
		return _this;
	}
	/**
	* @override
	*/
	TimeCat$1.prototype.translate = function(value$1) {
		value$1 = toTimeStamp(value$1);
		var index = this.values.indexOf(value$1);
		if (index === -1) if (is_number_default(value$1) && value$1 < this.values.length) index = value$1;
		else index = NaN;
		return index;
	};
	/**
	* 由于时间类型数据需要转换一下，所以复写 getText
	* @override
	*/
	TimeCat$1.prototype.getText = function(value$1, tickIndex) {
		var index = this.translate(value$1);
		if (index > -1) {
			var result = this.values[index];
			var formatter = this.formatter;
			result = formatter ? formatter(result, tickIndex) : timeFormat(result, this.mask);
			return result;
		}
		return value$1;
	};
	TimeCat$1.prototype.initCfg = function() {
		this.tickMethod = "time-cat";
		this.mask = "YYYY-MM-DD";
		this.tickCount = 7;
	};
	TimeCat$1.prototype.setDomain = function() {
		var values$1 = this.values;
		each_default(values$1, function(v, i) {
			values$1[i] = toTimeStamp(v);
		});
		values$1.sort(function(v1, v2) {
			return v1 - v2;
		});
		_super.prototype.setDomain.call(this);
	};
	return TimeCat$1;
}(base_default$10);
var time_default = TimeCat;

//#endregion
//#region node_modules/@antv/scale/esm/continuous/base.js
/**
* 连续度量的基类
* @class
*/
var Continuous = function(_super) {
	__extends(Continuous$1, _super);
	function Continuous$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.isContinuous = true;
		return _this;
	}
	Continuous$1.prototype.scale = function(value$1) {
		if (is_nil_default(value$1)) return NaN;
		var rangeMin = this.rangeMin();
		var rangeMax = this.rangeMax();
		var max$2 = this.max;
		var min$2 = this.min;
		if (max$2 === min$2) return rangeMin;
		var percent$1 = this.getScalePercent(value$1);
		return rangeMin + percent$1 * (rangeMax - rangeMin);
	};
	Continuous$1.prototype.init = function() {
		_super.prototype.init.call(this);
		var ticks = this.ticks;
		var firstTick = head(ticks);
		var lastTick = last(ticks);
		if (firstTick < this.min) this.min = firstTick;
		if (lastTick > this.max) this.max = lastTick;
		if (!is_nil_default(this.minLimit)) this.min = firstTick;
		if (!is_nil_default(this.maxLimit)) this.max = lastTick;
	};
	Continuous$1.prototype.setDomain = function() {
		var _a$5 = get_range_default(this.values), min$2 = _a$5.min, max$2 = _a$5.max;
		if (is_nil_default(this.min)) this.min = min$2;
		if (is_nil_default(this.max)) this.max = max$2;
		if (this.min > this.max) {
			this.min = min$2;
			this.max = max$2;
		}
	};
	Continuous$1.prototype.calculateTicks = function() {
		var _this = this;
		var ticks = _super.prototype.calculateTicks.call(this);
		if (!this.nice) ticks = filter_default(ticks, function(tick) {
			return tick >= _this.min && tick <= _this.max;
		});
		return ticks;
	};
	Continuous$1.prototype.getScalePercent = function(value$1) {
		var max$2 = this.max;
		var min$2 = this.min;
		return (value$1 - min$2) / (max$2 - min$2);
	};
	Continuous$1.prototype.getInvertPercent = function(value$1) {
		return (value$1 - this.rangeMin()) / (this.rangeMax() - this.rangeMin());
	};
	return Continuous$1;
}(base_default$8);
var base_default$16 = Continuous;

//#endregion
//#region node_modules/@antv/scale/esm/continuous/linear.js
/**
* 线性度量
* @class
*/
var Linear = function(_super) {
	__extends(Linear$1, _super);
	function Linear$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = "linear";
		_this.isLinear = true;
		return _this;
	}
	Linear$1.prototype.invert = function(value$1) {
		var percent$1 = this.getInvertPercent(value$1);
		return this.min + percent$1 * (this.max - this.min);
	};
	Linear$1.prototype.initCfg = function() {
		this.tickMethod = "wilkinson-extended";
		this.nice = false;
	};
	return Linear$1;
}(base_default$16);
var linear_default = Linear;

//#endregion
//#region node_modules/@antv/scale/esm/util/math.js
function calBase(a, b) {
	var e = Math.E;
	var value$1;
	if (b >= 0) value$1 = Math.pow(e, Math.log(b) / a);
	else value$1 = Math.pow(e, Math.log(-b) / a) * -1;
	return value$1;
}
function log$1(a, b) {
	if (a === 1) return 1;
	return Math.log(b) / Math.log(a);
}
function getLogPositiveMin(values$1, base, max$2) {
	if (is_nil_default(max$2)) max$2 = Math.max.apply(null, values$1);
	var positiveMin = max$2;
	each_default(values$1, function(value$1) {
		if (value$1 > 0 && value$1 < positiveMin) positiveMin = value$1;
	});
	if (positiveMin === max$2) positiveMin = max$2 / base;
	if (positiveMin > 1) positiveMin = 1;
	return positiveMin;
}

//#endregion
//#region node_modules/@antv/scale/esm/continuous/log.js
/**
* Log 度量，处理非均匀分布
*/
var Log = function(_super) {
	__extends(Log$1, _super);
	function Log$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = "log";
		return _this;
	}
	/**
	* @override
	*/
	Log$1.prototype.invert = function(value$1) {
		var base = this.base;
		var max$2 = log$1(base, this.max);
		var rangeMin = this.rangeMin();
		var range = this.rangeMax() - rangeMin;
		var min$2;
		var positiveMin = this.positiveMin;
		if (positiveMin) {
			if (value$1 === 0) return 0;
			min$2 = log$1(base, positiveMin / base);
			var appendPercent = 1 / (max$2 - min$2) * range;
			if (value$1 < appendPercent) return value$1 / appendPercent * positiveMin;
		} else min$2 = log$1(base, this.min);
		var tmp = (value$1 - rangeMin) / range * (max$2 - min$2) + min$2;
		return Math.pow(base, tmp);
	};
	Log$1.prototype.initCfg = function() {
		this.tickMethod = "log";
		this.base = 10;
		this.tickCount = 6;
		this.nice = true;
	};
	Log$1.prototype.setDomain = function() {
		_super.prototype.setDomain.call(this);
		var min$2 = this.min;
		if (min$2 < 0) throw new Error("When you use log scale, the minimum value must be greater than zero!");
		if (min$2 === 0) this.positiveMin = getLogPositiveMin(this.values, this.base, this.max);
	};
	Log$1.prototype.getScalePercent = function(value$1) {
		var max$2 = this.max;
		var min$2 = this.min;
		if (max$2 === min$2) return 0;
		if (value$1 <= 0) return 0;
		var base = this.base;
		var positiveMin = this.positiveMin;
		if (positiveMin) min$2 = positiveMin * 1 / base;
		var percent$1;
		if (value$1 < positiveMin) percent$1 = value$1 / positiveMin / (log$1(base, max$2) - log$1(base, min$2));
		else percent$1 = (log$1(base, value$1) - log$1(base, min$2)) / (log$1(base, max$2) - log$1(base, min$2));
		return percent$1;
	};
	return Log$1;
}(base_default$16);
var log_default = Log;

//#endregion
//#region node_modules/@antv/scale/esm/continuous/pow.js
/**
* Pow 度量，处理非均匀分布
*/
var Pow = function(_super) {
	__extends(Pow$1, _super);
	function Pow$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = "pow";
		return _this;
	}
	/**
	* @override
	*/
	Pow$1.prototype.invert = function(value$1) {
		var percent$1 = this.getInvertPercent(value$1);
		var exponent$1 = this.exponent;
		var max$2 = calBase(exponent$1, this.max);
		var min$2 = calBase(exponent$1, this.min);
		var tmp = percent$1 * (max$2 - min$2) + min$2;
		var factor = tmp >= 0 ? 1 : -1;
		return Math.pow(tmp, exponent$1) * factor;
	};
	Pow$1.prototype.initCfg = function() {
		this.tickMethod = "pow";
		this.exponent = 2;
		this.tickCount = 5;
		this.nice = true;
	};
	Pow$1.prototype.getScalePercent = function(value$1) {
		var max$2 = this.max;
		var min$2 = this.min;
		if (max$2 === min$2) return 0;
		var exponent$1 = this.exponent;
		return (calBase(exponent$1, value$1) - calBase(exponent$1, min$2)) / (calBase(exponent$1, max$2) - calBase(exponent$1, min$2));
	};
	return Pow$1;
}(base_default$16);
var pow_default = Pow;

//#endregion
//#region node_modules/@antv/scale/esm/continuous/time.js
/**
* 时间度量
* @class
*/
var Time = function(_super) {
	__extends(Time$1, _super);
	function Time$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = "time";
		return _this;
	}
	/**
	* @override
	*/
	Time$1.prototype.getText = function(value$1, index) {
		var numberValue = this.translate(value$1);
		var formatter = this.formatter;
		return formatter ? formatter(numberValue, index) : timeFormat(numberValue, this.mask);
	};
	/**
	* @override
	*/
	Time$1.prototype.scale = function(value$1) {
		var v = value$1;
		if (is_string_default(v) || is_date_default(v)) v = this.translate(v);
		return _super.prototype.scale.call(this, v);
	};
	/**
	* 将时间转换成数字
	* @override
	*/
	Time$1.prototype.translate = function(v) {
		return toTimeStamp(v);
	};
	Time$1.prototype.initCfg = function() {
		this.tickMethod = "time-pretty";
		this.mask = "YYYY-MM-DD";
		this.tickCount = 7;
		this.nice = false;
	};
	Time$1.prototype.setDomain = function() {
		var values$1 = this.values;
		var minConfig = this.getConfig("min");
		var maxConfig = this.getConfig("max");
		if (!is_nil_default(minConfig) || !is_number_default(minConfig)) this.min = this.translate(this.min);
		if (!is_nil_default(maxConfig) || !is_number_default(maxConfig)) this.max = this.translate(this.max);
		if (values$1 && values$1.length) {
			var timeStamps_1 = [];
			var min_1 = Infinity;
			var secondMin_1 = min_1;
			var max_1 = 0;
			each_default(values$1, function(v) {
				var timeStamp = toTimeStamp(v);
				if (isNaN(timeStamp)) throw new TypeError("Invalid Time: " + v + " in time scale!");
				if (min_1 > timeStamp) {
					secondMin_1 = min_1;
					min_1 = timeStamp;
				} else if (secondMin_1 > timeStamp) secondMin_1 = timeStamp;
				if (max_1 < timeStamp) max_1 = timeStamp;
				timeStamps_1.push(timeStamp);
			});
			if (values$1.length > 1) this.minTickInterval = secondMin_1 - min_1;
			if (is_nil_default(minConfig)) this.min = min_1;
			if (is_nil_default(maxConfig)) this.max = max_1;
		}
	};
	return Time$1;
}(linear_default);
var time_default$1 = Time;

//#endregion
//#region node_modules/@antv/scale/esm/continuous/quantize.js
/**
* 分段度量
*/
var Quantize = function(_super) {
	__extends(Quantize$1, _super);
	function Quantize$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = "quantize";
		return _this;
	}
	Quantize$1.prototype.invert = function(value$1) {
		var ticks = this.ticks;
		var length$1 = ticks.length;
		var percent$1 = this.getInvertPercent(value$1);
		var minIndex = Math.floor(percent$1 * (length$1 - 1));
		if (minIndex >= length$1 - 1) return last(ticks);
		if (minIndex < 0) return head(ticks);
		var minTick = ticks[minIndex];
		var nextTick = ticks[minIndex + 1];
		var minIndexPercent = minIndex / (length$1 - 1);
		var maxIndexPercent = (minIndex + 1) / (length$1 - 1);
		return minTick + (percent$1 - minIndexPercent) / (maxIndexPercent - minIndexPercent) * (nextTick - minTick);
	};
	Quantize$1.prototype.initCfg = function() {
		this.tickMethod = "r-pretty";
		this.tickCount = 5;
		this.nice = true;
	};
	Quantize$1.prototype.calculateTicks = function() {
		var ticks = _super.prototype.calculateTicks.call(this);
		if (!this.nice) {
			if (last(ticks) !== this.max) ticks.push(this.max);
			if (head(ticks) !== this.min) ticks.unshift(this.min);
		}
		return ticks;
	};
	Quantize$1.prototype.getScalePercent = function(value$1) {
		var ticks = this.ticks;
		if (value$1 < head(ticks)) return 0;
		if (value$1 > last(ticks)) return 1;
		var minIndex = 0;
		each_default(ticks, function(tick, index) {
			if (value$1 >= tick) minIndex = index;
			else return false;
		});
		return minIndex / (ticks.length - 1);
	};
	return Quantize$1;
}(base_default$16);
var quantize_default = Quantize;

//#endregion
//#region node_modules/@antv/scale/esm/continuous/quantile.js
var Quantile = function(_super) {
	__extends(Quantile$1, _super);
	function Quantile$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = "quantile";
		return _this;
	}
	Quantile$1.prototype.initCfg = function() {
		this.tickMethod = "quantile";
		this.tickCount = 5;
		this.nice = true;
	};
	return Quantile$1;
}(quantize_default);
var quantile_default = Quantile;

//#endregion
//#region node_modules/@antv/scale/esm/factory.js
var map = {};
function getClass(key) {
	return map[key];
}
function registerClass(key, cls) {
	if (getClass(key)) throw new Error("type '" + key + "' existed.");
	map[key] = cls;
}

//#endregion
//#region node_modules/@antv/scale/esm/identity/index.js
/**
* identity scale原则上是定义域和值域一致，scale/invert方法也是一致的
* 参考R的实现：https://github.com/r-lib/scales/blob/master/R/pal-identity.r
* 参考d3的实现（做了下转型）：https://github.com/d3/d3-scale/blob/master/src/identity.js
*/
var Identity = function(_super) {
	__extends(Identity$1, _super);
	function Identity$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = "identity";
		_this.isIdentity = true;
		return _this;
	}
	Identity$1.prototype.calculateTicks = function() {
		return this.values;
	};
	Identity$1.prototype.scale = function(value$1) {
		if (this.values[0] !== value$1 && is_number_default(value$1)) return value$1;
		return this.range[0];
	};
	Identity$1.prototype.invert = function(value$1) {
		var range = this.range;
		if (value$1 < range[0] || value$1 > range[1]) return NaN;
		return this.values[0];
	};
	return Identity$1;
}(base_default$8);
var identity_default = Identity;

//#endregion
//#region node_modules/@antv/scale/esm/tick-method/cat.js
/**
* 计算分类 ticks
* @param cfg 度量的配置项
* @returns 计算后的 ticks
*/
function calculateCatTicks(cfg) {
	var values$1 = cfg.values, tickInterval = cfg.tickInterval, tickCount = cfg.tickCount, showLast = cfg.showLast;
	if (is_number_default(tickInterval)) {
		var ticks_1 = filter_default(values$1, function(__, i$1) {
			return i$1 % tickInterval === 0;
		});
		var lastValue = last(values$1);
		if (showLast && last(ticks_1) !== lastValue) ticks_1.push(lastValue);
		return ticks_1;
	}
	var len = values$1.length;
	var min$2 = cfg.min, max$2 = cfg.max;
	if (is_nil_default(min$2)) min$2 = 0;
	if (is_nil_default(max$2)) max$2 = values$1.length - 1;
	if (!is_number_default(tickCount) || tickCount >= len) return values$1.slice(min$2, max$2 + 1);
	if (tickCount <= 0 || max$2 <= 0) return [];
	var interval$2 = tickCount === 1 ? len : Math.floor(len / (tickCount - 1));
	var ticks = [];
	var idx = min$2;
	for (var i = 0; i < tickCount; i++) {
		if (idx >= max$2) break;
		idx = Math.min(min$2 + i * interval$2, max$2);
		if (i === tickCount - 1 && showLast) ticks.push(values$1[max$2]);
		else ticks.push(values$1[idx]);
	}
	return ticks;
}

//#endregion
//#region node_modules/@antv/scale/esm/util/d3-linear.js
function d3Linear(cfg) {
	var min$2 = cfg.min, max$2 = cfg.max, nice = cfg.nice, tickCount = cfg.tickCount;
	var linear$3 = new D3Linear();
	linear$3.domain([min$2, max$2]);
	if (nice) linear$3.nice(tickCount);
	return linear$3.ticks(tickCount);
}
var DEFAULT_COUNT = 5;
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);
var D3Linear = function() {
	function D3Linear$1() {
		this._domain = [0, 1];
	}
	D3Linear$1.prototype.domain = function(domain) {
		if (domain) {
			this._domain = Array.from(domain, Number);
			return this;
		}
		return this._domain.slice();
	};
	D3Linear$1.prototype.nice = function(count$1) {
		var _a$5, _b;
		if (count$1 === void 0) count$1 = DEFAULT_COUNT;
		var d = this._domain.slice();
		var i0 = 0;
		var i1 = this._domain.length - 1;
		var start = this._domain[i0];
		var stop = this._domain[i1];
		var step;
		if (stop < start) {
			_a$5 = [stop, start], start = _a$5[0], stop = _a$5[1];
			_b = [i1, i0], i0 = _b[0], i1 = _b[1];
		}
		step = tickIncrement(start, stop, count$1);
		if (step > 0) {
			start = Math.floor(start / step) * step;
			stop = Math.ceil(stop / step) * step;
			step = tickIncrement(start, stop, count$1);
		} else if (step < 0) {
			start = Math.ceil(start * step) / step;
			stop = Math.floor(stop * step) / step;
			step = tickIncrement(start, stop, count$1);
		}
		if (step > 0) {
			d[i0] = Math.floor(start / step) * step;
			d[i1] = Math.ceil(stop / step) * step;
			this.domain(d);
		} else if (step < 0) {
			d[i0] = Math.ceil(start * step) / step;
			d[i1] = Math.floor(stop * step) / step;
			this.domain(d);
		}
		return this;
	};
	D3Linear$1.prototype.ticks = function(count$1) {
		if (count$1 === void 0) count$1 = DEFAULT_COUNT;
		return d3ArrayTicks(this._domain[0], this._domain[this._domain.length - 1], count$1 || DEFAULT_COUNT);
	};
	return D3Linear$1;
}();
function d3ArrayTicks(start, stop, count$1) {
	var reverse;
	var i = -1;
	var n;
	var ticks;
	var step;
	stop = +stop, start = +start, count$1 = +count$1;
	if (start === stop && count$1 > 0) return [start];
	if (reverse = stop < start) n = start, start = stop, stop = n;
	if ((step = tickIncrement(start, stop, count$1)) === 0 || !isFinite(step)) return [];
	if (step > 0) {
		start = Math.ceil(start / step);
		stop = Math.floor(stop / step);
		ticks = new Array(n = Math.ceil(stop - start + 1));
		while (++i < n) ticks[i] = (start + i) * step;
	} else {
		start = Math.floor(start * step);
		stop = Math.ceil(stop * step);
		ticks = new Array(n = Math.ceil(start - stop + 1));
		while (++i < n) ticks[i] = (start - i) / step;
	}
	if (reverse) ticks.reverse();
	return ticks;
}
function tickIncrement(start, stop, count$1) {
	var step = (stop - start) / Math.max(0, count$1);
	var power = Math.floor(Math.log(step) / Math.LN10);
	var error = step / Math.pow(10, power);
	return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

//#endregion
//#region node_modules/@antv/scale/esm/util/interval.js
function snapMultiple(v, base, snapType) {
	var div;
	if (snapType === "ceil") div = Math.ceil(v / base);
	else if (snapType === "floor") div = Math.floor(v / base);
	else div = Math.round(v / base);
	return div * base;
}
function intervalTicks(min$2, max$2, interval$2) {
	var minTick = snapMultiple(min$2, interval$2, "floor");
	var maxTick = snapMultiple(max$2, interval$2, "ceil");
	minTick = fixed_base_default(minTick, interval$2);
	maxTick = fixed_base_default(maxTick, interval$2);
	var ticks = [];
	var availableInterval = Math.max((maxTick - minTick) / (Math.pow(2, 12) - 1), interval$2);
	for (var i = minTick; i <= maxTick; i = i + availableInterval) {
		var tickValue = fixed_base_default(i, availableInterval);
		ticks.push(tickValue);
	}
	return {
		min: minTick,
		max: maxTick,
		ticks
	};
}

//#endregion
//#region node_modules/@antv/scale/esm/util/strict-limit.js
/**
* 按照给定的 minLimit/maxLimit/tickCount 均匀计算出刻度 ticks
*
* @param cfg Scale 配置项
* @return ticks
*/
function strictLimit(cfg, defaultMin, defaultMax) {
	var _a$5;
	var minLimit = cfg.minLimit, maxLimit = cfg.maxLimit, min$2 = cfg.min, max$2 = cfg.max, _b = cfg.tickCount, tickCount = _b === void 0 ? 5 : _b;
	var tickMin = is_nil_default(minLimit) ? is_nil_default(defaultMin) ? min$2 : defaultMin : minLimit;
	var tickMax = is_nil_default(maxLimit) ? is_nil_default(defaultMax) ? max$2 : defaultMax : maxLimit;
	if (tickMin > tickMax) _a$5 = [tickMin, tickMax], tickMax = _a$5[0], tickMin = _a$5[1];
	if (tickCount <= 2) return [tickMin, tickMax];
	var step = (tickMax - tickMin) / (tickCount - 1);
	var ticks = [];
	for (var i = 0; i < tickCount; i++) ticks.push(tickMin + step * i);
	return ticks;
}

//#endregion
//#region node_modules/@antv/scale/esm/tick-method/d3-linear.js
function d3LinearTickMethod(cfg) {
	var min$2 = cfg.min, max$2 = cfg.max, tickInterval = cfg.tickInterval, minLimit = cfg.minLimit, maxLimit = cfg.maxLimit;
	var ticks = d3Linear(cfg);
	if (!is_nil_default(minLimit) || !is_nil_default(maxLimit)) return strictLimit(cfg, head(ticks), last(ticks));
	if (tickInterval) return intervalTicks(min$2, max$2, tickInterval).ticks;
	return ticks;
}

//#endregion
//#region node_modules/@antv/scale/esm/util/pretty-number.js
function prettyNumber(n) {
	return Math.abs(n) < 1e-15 ? n : parseFloat(n.toFixed(15));
}

//#endregion
//#region node_modules/@antv/scale/esm/util/extended.js
var DEFAULT_Q = [
	1,
	5,
	2,
	2.5,
	4,
	3
];
var eps = Number.EPSILON * 100;
function mod(n, m) {
	return (n % m + m) % m;
}
function round(n) {
	return Math.round(n * 0xe8d4a51000) / 0xe8d4a51000;
}
function simplicity(q, Q, j, lmin, lmax, lstep) {
	var n = size(Q);
	var i = index_of_default(Q, q);
	var v = 0;
	var m = mod(lmin, lstep);
	if ((m < eps || lstep - m < eps) && lmin <= 0 && lmax >= 0) v = 1;
	return 1 - i / (n - 1) - j + v;
}
function simplicityMax(q, Q, j) {
	var n = size(Q);
	return 1 - index_of_default(Q, q) / (n - 1) - j + 1;
}
function density(k, m, dMin, dMax, lMin, lMax) {
	var r = (k - 1) / (lMax - lMin);
	var rt = (m - 1) / (Math.max(lMax, dMax) - Math.min(dMin, lMin));
	return 2 - Math.max(r / rt, rt / r);
}
function densityMax(k, m) {
	if (k >= m) return 2 - (k - 1) / (m - 1);
	return 1;
}
function coverage(dMin, dMax, lMin, lMax) {
	var range = dMax - dMin;
	return 1 - .5 * (Math.pow(dMax - lMax, 2) + Math.pow(dMin - lMin, 2)) / Math.pow(.1 * range, 2);
}
function coverageMax(dMin, dMax, span) {
	var range = dMax - dMin;
	if (span > range) {
		var half = (span - range) / 2;
		return 1 - Math.pow(half, 2) / Math.pow(.1 * range, 2);
	}
	return 1;
}
function legibility() {
	return 1;
}
/**
* An Extension of Wilkinson's Algorithm for Position Tick Labels on Axes
* https://www.yuque.com/preview/yuque/0/2019/pdf/185317/1546999150858-45c3b9c2-4e86-4223-bf1a-8a732e8195ed.pdf
* @param dMin 最小值
* @param dMax 最大值
* @param m tick个数
* @param onlyLoose 是否允许扩展min、max，不绝对强制，例如[3, 97]
* @param Q nice numbers集合
* @param w 四个优化组件的权重
*/
function extended(dMin, dMax, n, onlyLoose, Q, w) {
	if (n === void 0) n = 5;
	if (onlyLoose === void 0) onlyLoose = true;
	if (Q === void 0) Q = DEFAULT_Q;
	if (w === void 0) w = [
		.25,
		.2,
		.5,
		.05
	];
	var m = n < 0 ? 0 : Math.round(n);
	if (Number.isNaN(dMin) || Number.isNaN(dMax) || typeof dMin !== "number" || typeof dMax !== "number" || !m) return {
		min: 0,
		max: 0,
		ticks: []
	};
	if (dMax - dMin < 1e-15 || m === 1) return {
		min: dMin,
		max: dMax,
		ticks: [dMin]
	};
	if (dMax - dMin > 1e148) {
		var count$1 = n || 5;
		var step_1 = (dMax - dMin) / count$1;
		return {
			min: dMin,
			max: dMax,
			ticks: Array(count$1).fill(null).map(function(_, idx) {
				return prettyNumber(dMin + step_1 * idx);
			})
		};
	}
	var best = {
		score: -2,
		lmin: 0,
		lmax: 0,
		lstep: 0
	};
	var j = 1;
	while (j < Infinity) {
		for (var i = 0; i < Q.length; i += 1) {
			var q = Q[i];
			var sm = simplicityMax(q, Q, j);
			if (w[0] * sm + w[1] + w[2] + w[3] < best.score) {
				j = Infinity;
				break;
			}
			var k = 2;
			while (k < Infinity) {
				var dm = densityMax(k, m);
				if (w[0] * sm + w[1] + w[2] * dm + w[3] < best.score) break;
				var delta = (dMax - dMin) / (k + 1) / j / q;
				var z = Math.ceil(Math.log10(delta));
				while (z < Infinity) {
					var step = j * q * Math.pow(10, z);
					var cm = coverageMax(dMin, dMax, step * (k - 1));
					if (w[0] * sm + w[1] * cm + w[2] * dm + w[3] < best.score) break;
					var minStart = Math.floor(dMax / step) * j - (k - 1) * j;
					var maxStart = Math.ceil(dMin / step) * j;
					if (minStart <= maxStart) {
						var count$1 = maxStart - minStart;
						for (var i_1 = 0; i_1 <= count$1; i_1 += 1) {
							var lMin = (minStart + i_1) * (step / j);
							var lMax = lMin + step * (k - 1);
							var lStep = step;
							var s = simplicity(q, Q, j, lMin, lMax, lStep);
							var c = coverage(dMin, dMax, lMin, lMax);
							var g = density(k, m, dMin, dMax, lMin, lMax);
							var l = legibility();
							var score$1 = w[0] * s + w[1] * c + w[2] * g + w[3] * l;
							if (score$1 > best.score && (!onlyLoose || lMin <= dMin && lMax >= dMax)) {
								best.lmin = lMin;
								best.lmax = lMax;
								best.lstep = lStep;
								best.score = score$1;
							}
						}
					}
					z += 1;
				}
				k += 1;
			}
		}
		j += 1;
	}
	var lmax = prettyNumber(best.lmax);
	var lmin = prettyNumber(best.lmin);
	var lstep = prettyNumber(best.lstep);
	var tickCount = Math.floor(round((lmax - lmin) / lstep)) + 1;
	var ticks = new Array(tickCount);
	ticks[0] = prettyNumber(lmin);
	for (var i = 1; i < tickCount; i++) ticks[i] = prettyNumber(ticks[i - 1] + lstep);
	return {
		min: Math.min(dMin, head(ticks)),
		max: Math.max(dMax, last(ticks)),
		ticks
	};
}

//#endregion
//#region node_modules/@antv/scale/esm/tick-method/linear.js
/**
* 计算线性的 ticks，使用 wilkinson extended 方法
* @param cfg 度量的配置项
* @returns 计算后的 ticks
*/
function linear(cfg) {
	var min$2 = cfg.min, max$2 = cfg.max, tickCount = cfg.tickCount, nice = cfg.nice, tickInterval = cfg.tickInterval, minLimit = cfg.minLimit, maxLimit = cfg.maxLimit;
	var ticks = extended(min$2, max$2, tickCount, nice).ticks;
	if (!is_nil_default(minLimit) || !is_nil_default(maxLimit)) return strictLimit(cfg, head(ticks), last(ticks));
	if (tickInterval) return intervalTicks(min$2, max$2, tickInterval).ticks;
	return ticks;
}

//#endregion
//#region node_modules/@antv/scale/esm/tick-method/log.js
/**
* 计算 log 的 ticks，考虑 min = 0 的场景
* @param cfg 度量的配置项
* @returns 计算后的 ticks
*/
function calculateLogTicks(cfg) {
	var base = cfg.base, tickCount = cfg.tickCount, min$2 = cfg.min, max$2 = cfg.max, values$1 = cfg.values;
	var minTick;
	var maxTick = log$1(base, max$2);
	if (min$2 > 0) minTick = Math.floor(log$1(base, min$2));
	else {
		var positiveMin = getLogPositiveMin(values$1, base, max$2);
		minTick = Math.floor(log$1(base, positiveMin));
	}
	var count$1 = maxTick - minTick;
	var avg$1 = Math.ceil(count$1 / tickCount);
	var ticks = [];
	for (var i = minTick; i < maxTick + avg$1; i = i + avg$1) ticks.push(Math.pow(base, i));
	if (min$2 <= 0) ticks.unshift(0);
	return ticks;
}

//#endregion
//#region node_modules/@antv/scale/esm/util/pretty.js
function pretty(min$2, max$2, m) {
	if (m === void 0) m = 5;
	if (min$2 === max$2) return {
		max: max$2,
		min: min$2,
		ticks: [min$2]
	};
	var n = m < 0 ? 0 : Math.round(m);
	if (n === 0) return {
		max: max$2,
		min: min$2,
		ticks: []
	};
	var h = 1.5;
	var h5 = .5 + 1.5 * h;
	var c = (max$2 - min$2) / n;
	var base = Math.pow(10, Math.floor(Math.log10(c)));
	var unit = base;
	if (2 * base - c < h * (c - unit)) {
		unit = 2 * base;
		if (5 * base - c < h5 * (c - unit)) {
			unit = 5 * base;
			if (10 * base - c < h * (c - unit)) unit = 10 * base;
		}
	}
	var nu = Math.ceil(max$2 / unit);
	var ns = Math.floor(min$2 / unit);
	var hi = Math.max(nu * unit, max$2);
	var lo = Math.min(ns * unit, min$2);
	var size$1 = Math.floor((hi - lo) / unit) + 1;
	var ticks = new Array(size$1);
	for (var i = 0; i < size$1; i++) ticks[i] = prettyNumber(lo + i * unit);
	return {
		min: lo,
		max: hi,
		ticks
	};
}

//#endregion
//#region node_modules/@antv/scale/esm/tick-method/pow.js
/**
* 计算 Pow 的 ticks
* @param cfg 度量的配置项
* @returns 计算后的 ticks
*/
function calculatePowTicks(cfg) {
	var exponent$1 = cfg.exponent, tickCount = cfg.tickCount;
	var max$2 = Math.ceil(calBase(exponent$1, cfg.max));
	var min$2 = Math.floor(calBase(exponent$1, cfg.min));
	return pretty(min$2, max$2, tickCount).ticks.map(function(tick) {
		var factor = tick >= 0 ? 1 : -1;
		return Math.pow(tick, exponent$1) * factor;
	});
}

//#endregion
//#region node_modules/@antv/scale/esm/tick-method/quantile.js
/**
* 计算几分位 https://github.com/simple-statistics/simple-statistics/blob/master/src/quantile_sorted.js
* @param x  数组
* @param p  百分比
*/
function quantileSorted$1(x, p) {
	var idx = x.length * p;
	if (p === 1) return x[x.length - 1];
	else if (p === 0) return x[0];
	else if (idx % 1 !== 0) return x[Math.ceil(idx) - 1];
	else if (x.length % 2 === 0) return (x[idx - 1] + x[idx]) / 2;
	else return x[idx];
}
function calculateTicks(cfg) {
	var tickCount = cfg.tickCount, values$1 = cfg.values;
	if (!values$1 || !values$1.length) return [];
	var sorted = values$1.slice().sort(function(a, b) {
		return a - b;
	});
	var ticks = [];
	for (var i = 0; i < tickCount; i++) {
		var p = i / (tickCount - 1);
		ticks.push(quantileSorted$1(sorted, p));
	}
	return ticks;
}

//#endregion
//#region node_modules/@antv/scale/esm/tick-method/r-prettry.js
/**
* 计算线性的 ticks，使用 R's pretty 方法
* @param cfg 度量的配置项
* @returns 计算后的 ticks
*/
function linearPretty(cfg) {
	var min$2 = cfg.min, max$2 = cfg.max, tickCount = cfg.tickCount, tickInterval = cfg.tickInterval, minLimit = cfg.minLimit, maxLimit = cfg.maxLimit;
	var ticks = pretty(min$2, max$2, tickCount).ticks;
	if (!is_nil_default(minLimit) || !is_nil_default(maxLimit)) return strictLimit(cfg, head(ticks), last(ticks));
	if (tickInterval) return intervalTicks(min$2, max$2, tickInterval).ticks;
	return ticks;
}

//#endregion
//#region node_modules/@antv/scale/esm/tick-method/time.js
function calculateTimeTicks(cfg) {
	var min$2 = cfg.min, max$2 = cfg.max, minTickInterval = cfg.minTickInterval;
	var tickInterval = cfg.tickInterval;
	var tickCount = cfg.tickCount;
	if (tickInterval) tickCount = Math.ceil((max$2 - min$2) / tickInterval);
	else {
		tickInterval = getTickInterval(min$2, max$2, tickCount)[1];
		var ratio = (max$2 - min$2) / tickInterval / tickCount;
		if (ratio > 1) tickInterval = tickInterval * Math.ceil(ratio);
		if (minTickInterval && tickInterval < minTickInterval) tickInterval = minTickInterval;
	}
	tickInterval = Math.max(Math.floor((max$2 - min$2) / (Math.pow(2, 12) - 1)), tickInterval);
	var ticks = [];
	for (var i = min$2; i < max$2 + tickInterval; i += tickInterval) ticks.push(i);
	return ticks;
}

//#endregion
//#region node_modules/@antv/scale/esm/tick-method/time-cat.js
/**
* 计算时间分类的 ticks, 保头，保尾
* @param cfg 度量的配置项
* @returns 计算后的 ticks
*/
function timeCat(cfg) {
	return calculateCatTicks(__assign({ showLast: true }, cfg));
}

//#endregion
//#region node_modules/@antv/scale/esm/tick-method/time-pretty.js
function getYear(date) {
	return new Date(date).getFullYear();
}
function createYear(year) {
	return new Date(year, 0, 1).getTime();
}
function getMonth(date) {
	return new Date(date).getMonth();
}
function diffMonth(min$2, max$2) {
	var minYear = getYear(min$2);
	var maxYear = getYear(max$2);
	var minMonth = getMonth(min$2);
	var maxMonth = getMonth(max$2);
	return (maxYear - minYear) * 12 + (maxMonth - minMonth) % 12;
}
function creatMonth(year, month) {
	return new Date(year, month, 1).getTime();
}
function diffDay(min$2, max$2) {
	return Math.ceil((max$2 - min$2) / DAY);
}
function diffHour(min$2, max$2) {
	return Math.ceil((max$2 - min$2) / HOUR);
}
function diffMinus(min$2, max$2) {
	return Math.ceil((max$2 - min$2) / (60 * 1e3));
}
/**
* 计算 time 的 ticks，对 month, year 进行 pretty 处理
* @param cfg 度量的配置项
* @returns 计算后的 ticks
*/
function timePretty(cfg) {
	var min$2 = cfg.min, max$2 = cfg.max, minTickInterval = cfg.minTickInterval, tickCount = cfg.tickCount;
	var tickInterval = cfg.tickInterval;
	var ticks = [];
	if (!tickInterval) {
		tickInterval = (max$2 - min$2) / tickCount;
		if (minTickInterval && tickInterval < minTickInterval) tickInterval = minTickInterval;
	}
	tickInterval = Math.max(Math.floor((max$2 - min$2) / (Math.pow(2, 12) - 1)), tickInterval);
	var minYear = getYear(min$2);
	if (tickInterval > YEAR) {
		var maxYear = getYear(max$2);
		var yearInterval = Math.ceil(tickInterval / YEAR);
		for (var i = minYear; i <= maxYear + yearInterval; i = i + yearInterval) ticks.push(createYear(i));
	} else if (tickInterval > MONTH) {
		var monthInterval = Math.ceil(tickInterval / MONTH);
		var mmMoth = getMonth(min$2);
		var dMonths = diffMonth(min$2, max$2);
		for (var i = 0; i <= dMonths + monthInterval; i = i + monthInterval) ticks.push(creatMonth(minYear, i + mmMoth));
	} else if (tickInterval > DAY) {
		var date = new Date(min$2);
		var year = date.getFullYear();
		var month = date.getMonth();
		var mday = date.getDate();
		var day = Math.ceil(tickInterval / DAY);
		var ddays = diffDay(min$2, max$2);
		for (var i = 0; i < ddays + day; i = i + day) ticks.push(new Date(year, month, mday + i).getTime());
	} else if (tickInterval > HOUR) {
		var date = new Date(min$2);
		var year = date.getFullYear();
		var month = date.getMonth();
		var day = date.getDate();
		var hour = date.getHours();
		var hours = Math.ceil(tickInterval / HOUR);
		var dHours = diffHour(min$2, max$2);
		for (var i = 0; i <= dHours + hours; i = i + hours) ticks.push(new Date(year, month, day, hour + i).getTime());
	} else if (tickInterval > MINUTE) {
		var dMinus = diffMinus(min$2, max$2);
		var minutes = Math.ceil(tickInterval / MINUTE);
		for (var i = 0; i <= dMinus + minutes; i = i + minutes) ticks.push(min$2 + i * MINUTE);
	} else {
		var interval$2 = tickInterval;
		if (interval$2 < SECOND) interval$2 = SECOND;
		var minSecond = Math.floor(min$2 / SECOND) * SECOND;
		var dSeconds = Math.ceil((max$2 - min$2) / SECOND);
		var seconds = Math.ceil(interval$2 / SECOND);
		for (var i = 0; i < dSeconds + seconds; i = i + seconds) ticks.push(minSecond + i * SECOND);
	}
	if (ticks.length >= 512) console.warn("Notice: current ticks length(" + ticks.length + ") >= 512, may cause performance issues, even out of memory. Because of the configure \"tickInterval\"(in milliseconds, current is " + tickInterval + ") is too small, increase the value to solve the problem!");
	return ticks;
}

//#endregion
//#region node_modules/@antv/scale/esm/tick-method/index.js
registerTickMethod("cat", calculateCatTicks);
registerTickMethod("time-cat", timeCat);
registerTickMethod("wilkinson-extended", linear);
registerTickMethod("r-pretty", linearPretty);
registerTickMethod("time", calculateTimeTicks);
registerTickMethod("time-pretty", timePretty);
registerTickMethod("log", calculateLogTicks);
registerTickMethod("pow", calculatePowTicks);
registerTickMethod("quantile", calculateTicks);
registerTickMethod("d3-linear", d3LinearTickMethod);

//#endregion
//#region node_modules/@antv/scale/esm/index.js
registerClass("cat", base_default$10);
registerClass("category", base_default$10);
registerClass("identity", identity_default);
registerClass("linear", linear_default);
registerClass("log", log_default);
registerClass("pow", pow_default);
registerClass("time", time_default$1);
registerClass("timeCat", time_default);
registerClass("quantize", quantize_default);
registerClass("quantile", quantile_default);

//#endregion
//#region node_modules/@antv/attr/esm/factory.js
var ATTRIBUTE_MAP = {};
/**
* 通过类型获得 Attribute 类
* @param type
*/
var getAttribute = function(type) {
	return ATTRIBUTE_MAP[type.toLowerCase()];
};
var registerAttribute = function(type, ctor) {
	if (getAttribute(type)) throw new Error("Attribute type '".concat(type, "' existed."));
	ATTRIBUTE_MAP[type.toLowerCase()] = ctor;
};

//#endregion
//#region node_modules/@antv/attr/esm/index.js
registerAttribute("Color", color_default);
registerAttribute("Opacity", opacity_default);
registerAttribute("Position", position_default);
registerAttribute("Shape", shape_default$2);
registerAttribute("Size", size_default);

//#endregion
//#region node_modules/@antv/coord/esm/coord/base.js
/**
* Coordinate Base Class
*/
var Coordinate = function() {
	function Coordinate$1(cfg) {
		this.type = "coordinate";
		this.isRect = false;
		this.isHelix = false;
		this.isPolar = false;
		this.isReflectX = false;
		this.isReflectY = false;
		var start = cfg.start, end = cfg.end, _a$5 = cfg.matrix, matrix = _a$5 === void 0 ? [
			1,
			0,
			0,
			0,
			1,
			0,
			0,
			0,
			1
		] : _a$5, _b = cfg.isTransposed, isTransposed = _b === void 0 ? false : _b;
		this.start = start;
		this.end = end;
		this.matrix = matrix;
		this.originalMatrix = __spreadArray([], matrix);
		this.isTransposed = isTransposed;
	}
	/**
	* 初始化流程
	*/
	Coordinate$1.prototype.initial = function() {
		this.center = {
			x: (this.start.x + this.end.x) / 2,
			y: (this.start.y + this.end.y) / 2
		};
		this.width = Math.abs(this.end.x - this.start.x);
		this.height = Math.abs(this.end.y - this.start.y);
	};
	/**
	* 更新配置
	* @param cfg
	*/
	Coordinate$1.prototype.update = function(cfg) {
		mix(this, cfg);
		this.initial();
	};
	Coordinate$1.prototype.convertDim = function(percent$1, dim) {
		var _a$5;
		var _b = this[dim], start = _b.start, end = _b.end;
		if (this.isReflect(dim)) _a$5 = [end, start], start = _a$5[0], end = _a$5[1];
		return start + percent$1 * (end - start);
	};
	Coordinate$1.prototype.invertDim = function(value$1, dim) {
		var _a$5;
		var _b = this[dim], start = _b.start, end = _b.end;
		if (this.isReflect(dim)) _a$5 = [end, start], start = _a$5[0], end = _a$5[1];
		return (value$1 - start) / (end - start);
	};
	/**
	* 将坐标点进行矩阵变换
	* @param x   对应 x 轴画布坐标
	* @param y   对应 y 轴画布坐标
	* @param tag 默认为 0，可取值 0, 1
	* @return    返回变换后的三阶向量 [x, y, z]
	*/
	Coordinate$1.prototype.applyMatrix = function(x, y, tag) {
		if (tag === void 0) tag = 0;
		var matrix = this.matrix;
		var vector = [
			x,
			y,
			tag
		];
		transformMat3(vector, vector, matrix);
		return vector;
	};
	/**
	* 将坐标点进行矩阵逆变换
	* @param x   对应 x 轴画布坐标
	* @param y   对应 y 轴画布坐标
	* @param tag 默认为 0，可取值 0, 1
	* @return    返回矩阵逆变换后的三阶向量 [x, y, z]
	*/
	Coordinate$1.prototype.invertMatrix = function(x, y, tag) {
		if (tag === void 0) tag = 0;
		var matrix = this.matrix;
		var inverted = invert$1([
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0
		], matrix);
		var vector = [
			x,
			y,
			tag
		];
		if (inverted) transformMat3(vector, vector, inverted);
		return vector;
	};
	/**
	* 将归一化的坐标点数据转换为画布坐标，并根据坐标系当前矩阵进行变换
	* @param point 归一化的坐标点
	* @return      返回进行矩阵变换后的画布坐标
	*/
	Coordinate$1.prototype.convert = function(point$1) {
		var _a$5 = this.convertPoint(point$1), x = _a$5.x, y = _a$5.y;
		var vector = this.applyMatrix(x, y, 1);
		return {
			x: vector[0],
			y: vector[1]
		};
	};
	/**
	* 将进行过矩阵变换画布坐标转换为归一化坐标
	* @param point 画布坐标
	* @return      返回归一化的坐标点
	*/
	Coordinate$1.prototype.invert = function(point$1) {
		var vector = this.invertMatrix(point$1.x, point$1.y, 1);
		return this.invertPoint({
			x: vector[0],
			y: vector[1]
		});
	};
	/**
	* 坐标系旋转变换
	* @param  radian 旋转弧度
	* @return        返回坐标系对象
	*/
	Coordinate$1.prototype.rotate = function(radian) {
		var matrix = this.matrix;
		var center$1 = this.center;
		leftTranslate(matrix, matrix, [-center$1.x, -center$1.y]);
		leftRotate(matrix, matrix, radian);
		leftTranslate(matrix, matrix, [center$1.x, center$1.y]);
		return this;
	};
	/**
	* 坐标系反射变换
	* @param dim 反射维度
	* @return    返回坐标系对象
	*/
	Coordinate$1.prototype.reflect = function(dim) {
		if (dim === "x") this.isReflectX = !this.isReflectX;
		else this.isReflectY = !this.isReflectY;
		return this;
	};
	/**
	* 坐标系比例变换
	* @param s1 x 方向缩放比例
	* @param s2 y 方向缩放比例
	* @return     返回坐标系对象
	*/
	Coordinate$1.prototype.scale = function(s1, s2) {
		var matrix = this.matrix;
		var center$1 = this.center;
		leftTranslate(matrix, matrix, [-center$1.x, -center$1.y]);
		leftScale(matrix, matrix, [s1, s2]);
		leftTranslate(matrix, matrix, [center$1.x, center$1.y]);
		return this;
	};
	/**
	* 坐标系平移变换
	* @param x x 方向平移像素
	* @param y y 方向平移像素
	* @return    返回坐标系对象
	*/
	Coordinate$1.prototype.translate = function(x, y) {
		var matrix = this.matrix;
		leftTranslate(matrix, matrix, [x, y]);
		return this;
	};
	/**
	* 将坐标系 x y 两个轴进行转置
	* @return 返回坐标系对象
	*/
	Coordinate$1.prototype.transpose = function() {
		this.isTransposed = !this.isTransposed;
		return this;
	};
	Coordinate$1.prototype.getCenter = function() {
		return this.center;
	};
	Coordinate$1.prototype.getWidth = function() {
		return this.width;
	};
	Coordinate$1.prototype.getHeight = function() {
		return this.height;
	};
	Coordinate$1.prototype.getRadius = function() {
		return this.radius;
	};
	/**
	* whether has reflect
	* @param dim
	*/
	Coordinate$1.prototype.isReflect = function(dim) {
		return dim === "x" ? this.isReflectX : this.isReflectY;
	};
	/**
	* 重置 matrix
	* @param matrix 如果传入，则使用，否则使用构造函数中传入的默认 matrix
	*/
	Coordinate$1.prototype.resetMatrix = function(matrix) {
		this.matrix = matrix ? matrix : __spreadArray([], this.originalMatrix);
	};
	return Coordinate$1;
}();
var base_default$7 = Coordinate;

//#endregion
//#region node_modules/@antv/coord/esm/coord/cartesian.js
/**
* 笛卡尔坐标系
* https://www.zhihu.com/question/20665303
*/
var Cartesian = function(_super) {
	__extends(Cartesian$1, _super);
	function Cartesian$1(cfg) {
		var _this = _super.call(this, cfg) || this;
		_this.isRect = true;
		_this.type = "cartesian";
		_this.initial();
		return _this;
	}
	Cartesian$1.prototype.initial = function() {
		_super.prototype.initial.call(this);
		var start = this.start;
		var end = this.end;
		this.x = {
			start: start.x,
			end: end.x
		};
		this.y = {
			start: start.y,
			end: end.y
		};
	};
	Cartesian$1.prototype.convertPoint = function(point$1) {
		var _a$5;
		var x = point$1.x, y = point$1.y;
		if (this.isTransposed) _a$5 = [y, x], x = _a$5[0], y = _a$5[1];
		return {
			x: this.convertDim(x, "x"),
			y: this.convertDim(y, "y")
		};
	};
	Cartesian$1.prototype.invertPoint = function(point$1) {
		var _a$5;
		var x = this.invertDim(point$1.x, "x");
		var y = this.invertDim(point$1.y, "y");
		if (this.isTransposed) _a$5 = [y, x], x = _a$5[0], y = _a$5[1];
		return {
			x,
			y
		};
	};
	return Cartesian$1;
}(base_default$7);
var cartesian_default = Cartesian;

//#endregion
//#region node_modules/@antv/coord/esm/coord/helix.js
/**
* 螺旋坐标系
*/
var Helix = function(_super) {
	__extends(Helix$1, _super);
	function Helix$1(cfg) {
		var _this = _super.call(this, cfg) || this;
		_this.isHelix = true;
		_this.type = "helix";
		var _a$5 = cfg.startAngle, startAngle = _a$5 === void 0 ? 1.25 * Math.PI : _a$5, _b = cfg.endAngle, endAngle = _b === void 0 ? 7.25 * Math.PI : _b, _c = cfg.innerRadius, innerRadius = _c === void 0 ? 0 : _c, radius = cfg.radius;
		_this.startAngle = startAngle;
		_this.endAngle = endAngle;
		_this.innerRadius = innerRadius;
		_this.radius = radius;
		_this.initial();
		return _this;
	}
	Helix$1.prototype.initial = function() {
		_super.prototype.initial.call(this);
		var index = (this.endAngle - this.startAngle) / (2 * Math.PI) + 1;
		var maxRadius = Math.min(this.width, this.height) / 2;
		if (this.radius && this.radius >= 0 && this.radius <= 1) maxRadius = maxRadius * this.radius;
		this.d = Math.floor(maxRadius * (1 - this.innerRadius) / index);
		this.a = this.d / (Math.PI * 2);
		this.x = {
			start: this.startAngle,
			end: this.endAngle
		};
		this.y = {
			start: this.innerRadius * maxRadius,
			end: this.innerRadius * maxRadius + this.d * .99
		};
	};
	/**
	* 将百分比数据变成屏幕坐标
	* @param point 归一化的点坐标
	* @return      返回对应的屏幕坐标
	*/
	Helix$1.prototype.convertPoint = function(point$1) {
		var _a$5;
		var x = point$1.x, y = point$1.y;
		if (this.isTransposed) _a$5 = [y, x], x = _a$5[0], y = _a$5[1];
		var thi = this.convertDim(x, "x");
		var r = this.a * thi;
		var newY = this.convertDim(y, "y");
		return {
			x: this.center.x + Math.cos(thi) * (r + newY),
			y: this.center.y + Math.sin(thi) * (r + newY)
		};
	};
	/**
	* 将屏幕坐标点还原成百分比数据
	* @param point 屏幕坐标
	* @return      返回对应的归一化后的数据
	*/
	Helix$1.prototype.invertPoint = function(point$1) {
		var _a$5;
		var d = this.d + this.y.start;
		var v = subtract([0, 0], [point$1.x, point$1.y], [this.center.x, this.center.y]);
		var thi = angleTo(v, [1, 0], true);
		var rMin = thi * this.a;
		if (length(v) < rMin) rMin = length(v);
		thi = 2 * Math.floor((length(v) - rMin) / d) * Math.PI + thi;
		var r = this.a * thi;
		var newY = length(v) - r;
		newY = isNumberEqual(newY, 0) ? 0 : newY;
		var x = this.invertDim(thi, "x");
		var y = this.invertDim(newY, "y");
		x = isNumberEqual(x, 0) ? 0 : x;
		y = isNumberEqual(y, 0) ? 0 : y;
		if (this.isTransposed) _a$5 = [y, x], x = _a$5[0], y = _a$5[1];
		return {
			x,
			y
		};
	};
	return Helix$1;
}(base_default$7);
var helix_default = Helix;

//#endregion
//#region node_modules/@antv/coord/esm/coord/polar.js
var Polar = function(_super) {
	__extends(Polar$1, _super);
	function Polar$1(cfg) {
		var _this = _super.call(this, cfg) || this;
		_this.isPolar = true;
		_this.type = "polar";
		var _a$5 = cfg.startAngle, startAngle = _a$5 === void 0 ? -Math.PI / 2 : _a$5, _b = cfg.endAngle, endAngle = _b === void 0 ? Math.PI * 3 / 2 : _b, _c = cfg.innerRadius, innerRadius = _c === void 0 ? 0 : _c, radius = cfg.radius;
		_this.startAngle = startAngle;
		_this.endAngle = endAngle;
		_this.innerRadius = innerRadius;
		_this.radius = radius;
		_this.initial();
		return _this;
	}
	Polar$1.prototype.initial = function() {
		_super.prototype.initial.call(this);
		while (this.endAngle < this.startAngle) this.endAngle += Math.PI * 2;
		var oneBox = this.getOneBox();
		var oneWidth = oneBox.maxX - oneBox.minX;
		var oneHeight = oneBox.maxY - oneBox.minY;
		var left$1 = Math.abs(oneBox.minX) / oneWidth;
		var top = Math.abs(oneBox.minY) / oneHeight;
		var maxRadius;
		if (this.height / oneHeight > this.width / oneWidth) {
			maxRadius = this.width / oneWidth;
			this.circleCenter = {
				x: this.center.x - (.5 - left$1) * this.width,
				y: this.center.y - (.5 - top) * maxRadius * oneHeight
			};
		} else {
			maxRadius = this.height / oneHeight;
			this.circleCenter = {
				x: this.center.x - (.5 - left$1) * maxRadius * oneWidth,
				y: this.center.y - (.5 - top) * this.height
			};
		}
		this.polarRadius = this.radius;
		if (!this.radius) this.polarRadius = maxRadius;
		else if (this.radius > 0 && this.radius <= 1) this.polarRadius = maxRadius * this.radius;
		else if (this.radius <= 0 || this.radius > maxRadius) this.polarRadius = maxRadius;
		this.x = {
			start: this.startAngle,
			end: this.endAngle
		};
		this.y = {
			start: this.innerRadius * this.polarRadius,
			end: this.polarRadius
		};
	};
	Polar$1.prototype.getRadius = function() {
		return this.polarRadius;
	};
	Polar$1.prototype.convertPoint = function(point$1) {
		var _a$5;
		var center$1 = this.getCenter();
		var x = point$1.x, y = point$1.y;
		if (this.isTransposed) _a$5 = [y, x], x = _a$5[0], y = _a$5[1];
		x = this.convertDim(x, "x");
		y = this.convertDim(y, "y");
		return {
			x: center$1.x + Math.cos(x) * y,
			y: center$1.y + Math.sin(x) * y
		};
	};
	Polar$1.prototype.invertPoint = function(point$1) {
		var _a$5;
		var center$1 = this.getCenter();
		var vPoint = [point$1.x - center$1.x, point$1.y - center$1.y];
		var _b = this, startAngle = _b.startAngle, endAngle = _b.endAngle;
		if (this.isReflect("x")) _a$5 = [endAngle, startAngle], startAngle = _a$5[0], endAngle = _a$5[1];
		var m = [
			1,
			0,
			0,
			0,
			1,
			0,
			0,
			0,
			1
		];
		leftRotate(m, m, startAngle);
		var vStart3 = [
			1,
			0,
			0
		];
		transformMat3(vStart3, vStart3, m);
		var vStart2 = [vStart3[0], vStart3[1]];
		var angle$1 = angleTo(vStart2, vPoint, endAngle < startAngle);
		if (isNumberEqual(angle$1, Math.PI * 2)) angle$1 = 0;
		var radius = length(vPoint);
		var xPercent = angle$1 / (endAngle - startAngle);
		xPercent = endAngle - startAngle > 0 ? xPercent : -xPercent;
		var yPercent = this.invertDim(radius, "y");
		var rst = {
			x: 0,
			y: 0
		};
		rst.x = this.isTransposed ? yPercent : xPercent;
		rst.y = this.isTransposed ? xPercent : yPercent;
		return rst;
	};
	Polar$1.prototype.getCenter = function() {
		return this.circleCenter;
	};
	Polar$1.prototype.getOneBox = function() {
		var startAngle = this.startAngle;
		var endAngle = this.endAngle;
		if (Math.abs(endAngle - startAngle) >= Math.PI * 2) return {
			minX: -1,
			maxX: 1,
			minY: -1,
			maxY: 1
		};
		var xs = [
			0,
			Math.cos(startAngle),
			Math.cos(endAngle)
		];
		var ys = [
			0,
			Math.sin(startAngle),
			Math.sin(endAngle)
		];
		for (var i = Math.min(startAngle, endAngle); i < Math.max(startAngle, endAngle); i += Math.PI / 18) {
			xs.push(Math.cos(i));
			ys.push(Math.sin(i));
		}
		return {
			minX: Math.min.apply(Math, xs),
			maxX: Math.max.apply(Math, xs),
			minY: Math.min.apply(Math, ys),
			maxY: Math.max.apply(Math, ys)
		};
	};
	return Polar$1;
}(base_default$7);
var polar_default$1 = Polar;

//#endregion
//#region node_modules/@antv/coord/esm/factory.js
var COORDINATE_MAP = {};
/**
* 通过类型获得 coordinate 类
* @param type
*/
var getCoordinate = function(type) {
	return COORDINATE_MAP[type.toLowerCase()];
};
/**
* 注册 coordinate 类
* @param type
* @param ctor
*/
var registerCoordinate = function(type, ctor) {
	COORDINATE_MAP[type.toLowerCase()] = ctor;
};

//#endregion
//#region node_modules/@antv/coord/esm/index.js
registerCoordinate("rect", cartesian_default);
registerCoordinate("cartesian", cartesian_default);
registerCoordinate("polar", polar_default$1);
registerCoordinate("helix", helix_default);

//#endregion
//#region node_modules/@antv/component/esm/util/event.js
/**
*
* @param group 分组
* @param eventName 事件名
* @param eventObject 事件对象
*/
function propagationDelegate(group$1, eventName, eventObject) {
	var event = new graph_event_default(eventName, eventObject);
	event.target = group$1;
	event.propagationPath.push(group$1);
	group$1.emitDelegation(eventName, event);
	var parent = group$1.getParent();
	while (parent) {
		parent.emitDelegation(eventName, event);
		event.propagationPath.push(parent);
		parent = parent.getParent();
	}
}

//#endregion
//#region node_modules/@antv/component/esm/util/matrix.js
var identityMatrix = [
	1,
	0,
	0,
	0,
	1,
	0,
	0,
	0,
	1
];
function getMatrixByAngle(point$1, angle$1, matrix) {
	if (matrix === void 0) matrix = identityMatrix;
	if (!angle$1) return null;
	return transform$6(matrix, [
		[
			"t",
			-point$1.x,
			-point$1.y
		],
		["r", angle$1],
		[
			"t",
			point$1.x,
			point$1.y
		]
	]);
}
function getMatrixByTranslate(point$1, currentMatrix) {
	if (!point$1.x && !point$1.y) return null;
	return transform$6(currentMatrix || identityMatrix, [[
		"t",
		point$1.x,
		point$1.y
	]]);
}
function getAngleByMatrix(matrix) {
	var xVector = [
		1,
		0,
		0
	];
	var out = [
		0,
		0,
		0
	];
	transformMat3(out, xVector, matrix);
	return Math.atan2(out[1], out[0]);
}
function multiplyVec2$1(matrix, v) {
	var out = [0, 0];
	transformMat3$1(out, v, matrix);
	return out;
}
function applyMatrix2BBox(matrix, bbox) {
	var topLeft = multiplyVec2$1(matrix, [bbox.minX, bbox.minY]);
	var topRight = multiplyVec2$1(matrix, [bbox.maxX, bbox.minY]);
	var bottomLeft = multiplyVec2$1(matrix, [bbox.minX, bbox.maxY]);
	var bottomRight = multiplyVec2$1(matrix, [bbox.maxX, bbox.maxY]);
	var minX = Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
	var maxX = Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
	var minY = Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
	var maxY$1 = Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
	return {
		x: minX,
		y: minY,
		minX,
		minY,
		maxX,
		maxY: maxY$1,
		width: maxX - minX,
		height: maxY$1 - minY
	};
}
function applyRotate(shape, rotate$2, x, y) {
	if (rotate$2) {
		var matrix = getMatrixByAngle({
			x,
			y
		}, rotate$2, shape.getMatrix());
		shape.setMatrix(matrix);
	}
}
function applyTranslate(shape, x, y) {
	var translateMatrix = getMatrixByTranslate({
		x,
		y
	});
	shape.attr("matrix", translateMatrix);
}

//#endregion
//#region node_modules/@antv/component/esm/util/util.js
function formatPadding(padding$2) {
	var top = 0;
	var left$1 = 0;
	var right$1 = 0;
	var bottom = 0;
	if (is_number_default(padding$2)) top = left$1 = right$1 = bottom = padding$2;
	else if (is_array_default(padding$2)) {
		top = padding$2[0];
		right$1 = !is_nil_default(padding$2[1]) ? padding$2[1] : padding$2[0];
		bottom = !is_nil_default(padding$2[2]) ? padding$2[2] : padding$2[0];
		left$1 = !is_nil_default(padding$2[3]) ? padding$2[3] : right$1;
	}
	return [
		top,
		right$1,
		bottom,
		left$1
	];
}
function clearDom(container) {
	var children = container.childNodes;
	for (var i = children.length - 1; i >= 0; i--) container.removeChild(children[i]);
}
function hasClass(elements, cName) {
	return !!elements.className.match(/* @__PURE__ */ new RegExp("(\\s|^)" + cName + "(\\s|$)"));
}
function regionToBBox(region) {
	var start = region.start, end = region.end;
	var minX = Math.min(start.x, end.x);
	var minY = Math.min(start.y, end.y);
	var maxX = Math.max(start.x, end.x);
	var maxY$1 = Math.max(start.y, end.y);
	return {
		x: minX,
		y: minY,
		minX,
		minY,
		maxX,
		maxY: maxY$1,
		width: maxX - minX,
		height: maxY$1 - minY
	};
}
function pointsToBBox(points) {
	var xs = points.map(function(point$1) {
		return point$1.x;
	});
	var ys = points.map(function(point$1) {
		return point$1.y;
	});
	var minX = Math.min.apply(Math, xs);
	var minY = Math.min.apply(Math, ys);
	var maxX = Math.max.apply(Math, xs);
	var maxY$1 = Math.max.apply(Math, ys);
	return {
		x: minX,
		y: minY,
		minX,
		minY,
		maxX,
		maxY: maxY$1,
		width: maxX - minX,
		height: maxY$1 - minY
	};
}
function createBBox(x, y, width, height) {
	var maxX = x + width;
	var maxY$1 = y + height;
	return {
		x,
		y,
		width,
		height,
		minX: x,
		minY: y,
		maxX: isNaN(maxX) ? 0 : maxX,
		maxY: isNaN(maxY$1) ? 0 : maxY$1
	};
}
function getValueByPercent(min$2, max$2, percent$1) {
	return (1 - percent$1) * min$2 + max$2 * percent$1;
}
function getCirclePoint(center$1, radius, angle$1) {
	return {
		x: center$1.x + Math.cos(angle$1) * radius,
		y: center$1.y + Math.sin(angle$1) * radius
	};
}
function distance$4(p1, p2) {
	var dx = p2.x - p1.x;
	var dy = p2.y - p1.y;
	return Math.sqrt(dx * dx + dy * dy);
}
/**
* 判断两个数值 是否接近
* - 解决精度问题（由于无法确定精度上限，根据具体场景可传入 精度 参数）
*/
var near = function(x, y, e) {
	if (e === void 0) e = Math.pow(Number.EPSILON, .5);
	return [x, y].includes(Infinity) ? Math.abs(x) === Math.abs(y) : Math.abs(x - y) < e;
};
function intersectBBox$1(box1, box2) {
	var minX = Math.max(box1.minX, box2.minX);
	var minY = Math.max(box1.minY, box2.minY);
	var maxX = Math.min(box1.maxX, box2.maxX);
	var maxY$1 = Math.min(box1.maxY, box2.maxY);
	return createBBox(minX, minY, maxX - minX, maxY$1 - minY);
}
function getBBoxWithClip(element) {
	var clipShape = element.getClip();
	var clipBBox = clipShape && clipShape.getBBox();
	var bbox;
	if (!element.isGroup()) bbox = element.getBBox();
	else {
		var minX_1 = Infinity;
		var maxX_1 = -Infinity;
		var minY_1 = Infinity;
		var maxY_1 = -Infinity;
		var children = element.getChildren();
		if (children.length > 0) each_default(children, function(child) {
			if (child.get("visible")) {
				if (child.isGroup() && child.get("children").length === 0) return true;
				var box$1 = getBBoxWithClip(child);
				var leftTop = child.applyToMatrix([
					box$1.minX,
					box$1.minY,
					1
				]);
				var leftBottom = child.applyToMatrix([
					box$1.minX,
					box$1.maxY,
					1
				]);
				var rightTop = child.applyToMatrix([
					box$1.maxX,
					box$1.minY,
					1
				]);
				var rightBottom = child.applyToMatrix([
					box$1.maxX,
					box$1.maxY,
					1
				]);
				var boxMinX = Math.min(leftTop[0], leftBottom[0], rightTop[0], rightBottom[0]);
				var boxMaxX = Math.max(leftTop[0], leftBottom[0], rightTop[0], rightBottom[0]);
				var boxMinY = Math.min(leftTop[1], leftBottom[1], rightTop[1], rightBottom[1]);
				var boxMaxY = Math.max(leftTop[1], leftBottom[1], rightTop[1], rightBottom[1]);
				if (boxMinX < minX_1) minX_1 = boxMinX;
				if (boxMaxX > maxX_1) maxX_1 = boxMaxX;
				if (boxMinY < minY_1) minY_1 = boxMinY;
				if (boxMaxY > maxY_1) maxY_1 = boxMaxY;
			}
		});
		else {
			minX_1 = 0;
			maxX_1 = 0;
			minY_1 = 0;
			maxY_1 = 0;
		}
		bbox = createBBox(minX_1, minY_1, maxX_1 - minX_1, maxY_1 - minY_1);
	}
	if (clipBBox) return intersectBBox$1(bbox, clipBBox);
	else return bbox;
}
function updateClip(element, newElement) {
	if (!element.getClip() && !newElement.getClip()) return;
	var newClipShape = newElement.getClip();
	if (!newClipShape) {
		element.setClip(null);
		return;
	}
	var clipCfg = {
		type: newClipShape.get("type"),
		attrs: newClipShape.attr()
	};
	element.setClip(clipCfg);
}
function toPx(number) {
	return number + "px";
}
function getTextPoint(start, end, position, offset) {
	var lineLength = distance$4(start, end);
	var offsetPercent = offset / lineLength;
	var percent$1 = 0;
	if (position === "start") percent$1 = 0 - offsetPercent;
	else if (position === "end") percent$1 = 1 + offsetPercent;
	return {
		x: getValueByPercent(start.x, end.x, percent$1),
		y: getValueByPercent(start.y, end.y, percent$1)
	};
}

//#endregion
//#region node_modules/@antv/component/esm/abstract/component.js
var LOCATION_FIELD_MAP = {
	none: [],
	point: ["x", "y"],
	region: ["start", "end"],
	points: ["points"],
	circle: [
		"center",
		"radius",
		"startAngle",
		"endAngle"
	]
};
var Component = function(_super) {
	__extends(Component$1, _super);
	function Component$1(cfg) {
		var _this = _super.call(this, cfg) || this;
		_this.initCfg();
		return _this;
	}
	/**
	* @protected
	* 默认的配置项
	* @returns {object} 默认的配置项
	*/
	Component$1.prototype.getDefaultCfg = function() {
		return {
			id: "",
			name: "",
			type: "",
			locationType: "none",
			offsetX: 0,
			offsetY: 0,
			animate: false,
			capture: true,
			updateAutoRender: false,
			animateOption: {
				appear: null,
				update: {
					duration: 400,
					easing: "easeQuadInOut"
				},
				enter: {
					duration: 400,
					easing: "easeQuadInOut"
				},
				leave: {
					duration: 350,
					easing: "easeQuadIn"
				}
			},
			events: null,
			defaultCfg: {},
			visible: true
		};
	};
	/**
	* 清理组件的内容，一般配合 render 使用
	* @example
	* axis.clear();
	* axis.render();
	*/
	Component$1.prototype.clear = function() {};
	/**
	* 更新组件
	* @param {object} cfg 更新属性
	*/
	Component$1.prototype.update = function(cfg) {
		var _this = this;
		var defaultCfg = this.get("defaultCfg") || {};
		each_default(cfg, function(value$1, name) {
			var originCfg = _this.get(name);
			var newCfg = value$1;
			if (originCfg !== value$1) {
				if (is_object_default(value$1) && defaultCfg[name]) newCfg = deep_mix_default({}, defaultCfg[name], value$1);
				_this.set(name, newCfg);
			}
		});
		this.updateInner(cfg);
		this.afterUpdate(cfg);
	};
	Component$1.prototype.updateInner = function(cfg) {};
	Component$1.prototype.afterUpdate = function(cfg) {
		if (has_key_default(cfg, "visible")) if (cfg.visible) this.show();
		else this.hide();
		if (has_key_default(cfg, "capture")) this.setCapture(cfg.capture);
	};
	Component$1.prototype.getLayoutBBox = function() {
		return this.getBBox();
	};
	Component$1.prototype.getLocationType = function() {
		return this.get("locationType");
	};
	Component$1.prototype.getOffset = function() {
		return {
			offsetX: this.get("offsetX"),
			offsetY: this.get("offsetY")
		};
	};
	Component$1.prototype.setOffset = function(offsetX, offsetY) {
		this.update({
			offsetX,
			offsetY
		});
	};
	Component$1.prototype.setLocation = function(cfg) {
		var location = __assign({}, cfg);
		this.update(location);
	};
	Component$1.prototype.getLocation = function() {
		var _this = this;
		var location = {};
		var locationType = this.get("locationType");
		var fields = LOCATION_FIELD_MAP[locationType];
		each_default(fields, function(field$5) {
			location[field$5] = _this.get(field$5);
		});
		return location;
	};
	Component$1.prototype.isList = function() {
		return false;
	};
	Component$1.prototype.isSlider = function() {
		return false;
	};
	/**
	* @protected
	* 初始化，用于具体的组件继承
	*/
	Component$1.prototype.init = function() {};
	Component$1.prototype.initCfg = function() {
		var _this = this;
		var defaultCfg = this.get("defaultCfg");
		each_default(defaultCfg, function(value$1, name) {
			var cfg = _this.get(name);
			if (is_object_default(cfg)) {
				var newCfg = deep_mix_default({}, value$1, cfg);
				_this.set(name, newCfg);
			}
		});
	};
	return Component$1;
}(base_default$15);
var component_default = Component;

//#endregion
//#region node_modules/@antv/component/esm/abstract/group-component.js
var STATUS_UPDATE = "update_status";
var COPY_PROPERTIES = [
	"visible",
	"tip",
	"delegateObject"
];
var COPY_PROPERTIES_EXCLUDES = [
	"container",
	"group",
	"shapesMap",
	"isRegister",
	"isUpdating",
	"destroyed"
];
var GroupComponent = function(_super) {
	__extends(GroupComponent$1, _super);
	function GroupComponent$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	GroupComponent$1.prototype.getDefaultCfg = function() {
		var cfg = _super.prototype.getDefaultCfg.call(this);
		return __assign(__assign({}, cfg), {
			container: null,
			shapesMap: {},
			group: null,
			capture: true,
			isRegister: false,
			isUpdating: false,
			isInit: true
		});
	};
	GroupComponent$1.prototype.remove = function() {
		this.clear();
		this.get("group").remove();
	};
	GroupComponent$1.prototype.clear = function() {
		this.get("group").clear();
		this.set("shapesMap", {});
		this.clearOffScreenCache();
		this.set("isInit", true);
	};
	GroupComponent$1.prototype.getChildComponentById = function(id$1) {
		var group$1 = this.getElementById(id$1);
		return group$1 && group$1.get("component");
	};
	GroupComponent$1.prototype.getElementById = function(id$1) {
		return this.get("shapesMap")[id$1];
	};
	GroupComponent$1.prototype.getElementByLocalId = function(localId) {
		var id$1 = this.getElementId(localId);
		return this.getElementById(id$1);
	};
	GroupComponent$1.prototype.getElementsByName = function(name) {
		var rst = [];
		each_default(this.get("shapesMap"), function(elem) {
			if (elem.get("name") === name) rst.push(elem);
		});
		return rst;
	};
	GroupComponent$1.prototype.getContainer = function() {
		return this.get("container");
	};
	GroupComponent$1.prototype.updateInner = function(cfg) {
		this.offScreenRender();
		if (this.get("updateAutoRender")) this.render();
	};
	GroupComponent$1.prototype.render = function() {
		var offScreenGroup = this.get("offScreenGroup");
		if (!offScreenGroup) offScreenGroup = this.offScreenRender();
		var group$1 = this.get("group");
		this.updateElements(offScreenGroup, group$1);
		this.deleteElements();
		this.applyOffset();
		if (!this.get("eventInitted")) {
			this.initEvent();
			this.set("eventInitted", true);
		}
		this.set("isInit", false);
	};
	GroupComponent$1.prototype.show = function() {
		this.get("group").show();
		this.set("visible", true);
	};
	GroupComponent$1.prototype.hide = function() {
		this.get("group").hide();
		this.set("visible", false);
	};
	GroupComponent$1.prototype.setCapture = function(capture) {
		this.get("group").set("capture", capture);
		this.set("capture", capture);
	};
	GroupComponent$1.prototype.destroy = function() {
		this.removeEvent();
		this.remove();
		_super.prototype.destroy.call(this);
	};
	GroupComponent$1.prototype.getBBox = function() {
		return this.get("group").getCanvasBBox();
	};
	GroupComponent$1.prototype.getLayoutBBox = function() {
		var group$1 = this.get("group");
		var bbox = this.getInnerLayoutBBox();
		var matrix = group$1.getTotalMatrix();
		if (matrix) bbox = applyMatrix2BBox(matrix, bbox);
		return bbox;
	};
	GroupComponent$1.prototype.on = function(evt, callback, once) {
		this.get("group").on(evt, callback, once);
		return this;
	};
	GroupComponent$1.prototype.off = function(evt, callback) {
		var group$1 = this.get("group");
		group$1 && group$1.off(evt, callback);
		return this;
	};
	GroupComponent$1.prototype.emit = function(eventName, eventObject) {
		this.get("group").emit(eventName, eventObject);
	};
	GroupComponent$1.prototype.init = function() {
		_super.prototype.init.call(this);
		if (!this.get("group")) this.initGroup();
		this.offScreenRender();
	};
	GroupComponent$1.prototype.getInnerLayoutBBox = function() {
		return this.get("offScreenBBox") || this.get("group").getBBox();
	};
	GroupComponent$1.prototype.delegateEmit = function(eventName, eventObject) {
		var group$1 = this.get("group");
		eventObject.target = group$1;
		group$1.emit(eventName, eventObject);
		propagationDelegate(group$1, eventName, eventObject);
	};
	GroupComponent$1.prototype.createOffScreenGroup = function() {
		return new (this.get("group").getGroupBase())({ delegateObject: this.getDelegateObject() });
	};
	GroupComponent$1.prototype.applyOffset = function() {
		var offsetX = this.get("offsetX");
		var offsetY = this.get("offsetY");
		this.moveElementTo(this.get("group"), {
			x: offsetX,
			y: offsetY
		});
	};
	GroupComponent$1.prototype.initGroup = function() {
		var container = this.get("container");
		this.set("group", container.addGroup({
			id: this.get("id"),
			name: this.get("name"),
			capture: this.get("capture"),
			visible: this.get("visible"),
			isComponent: true,
			component: this,
			delegateObject: this.getDelegateObject()
		}));
	};
	GroupComponent$1.prototype.offScreenRender = function() {
		this.clearOffScreenCache();
		var offScreenGroup = this.createOffScreenGroup();
		this.renderInner(offScreenGroup);
		this.set("offScreenGroup", offScreenGroup);
		this.set("offScreenBBox", getBBoxWithClip(offScreenGroup));
		return offScreenGroup;
	};
	/**
	* @protected
	* 在组件上添加分组，主要解决 isReigeter 的问题
	* @param {IGroup} parent 父元素
	* @param {object} cfg    分组的配置项
	*/
	GroupComponent$1.prototype.addGroup = function(parent, cfg) {
		this.appendDelegateObject(parent, cfg);
		var group$1 = parent.addGroup(cfg);
		if (this.get("isRegister")) this.registerElement(group$1);
		return group$1;
	};
	/**
	* @protected
	* 在组件上添加图形，主要解决 isReigeter 的问题
	* @param {IGroup} parent 父元素
	* @param {object} cfg    分组的配置项
	*/
	GroupComponent$1.prototype.addShape = function(parent, cfg) {
		this.appendDelegateObject(parent, cfg);
		var shape = parent.addShape(cfg);
		if (this.get("isRegister")) this.registerElement(shape);
		return shape;
	};
	/**
	* 在组件上添加子组件
	*
	* @param parent 父元素
	* @param cfg 子组件配置项
	*/
	GroupComponent$1.prototype.addComponent = function(parent, cfg) {
		var id$1 = cfg.id, Ctor = cfg.component, restCfg = __rest(cfg, ["id", "component"]);
		var inst = new Ctor(__assign(__assign({}, restCfg), {
			id: id$1,
			container: parent,
			updateAutoRender: this.get("updateAutoRender")
		}));
		inst.init();
		inst.render();
		if (this.get("isRegister")) this.registerElement(inst.get("group"));
		return inst;
	};
	GroupComponent$1.prototype.initEvent = function() {};
	GroupComponent$1.prototype.removeEvent = function() {
		this.get("group").off();
	};
	GroupComponent$1.prototype.getElementId = function(localId) {
		var id$1 = this.get("id");
		var name = this.get("name");
		return id$1 + "-" + name + "-" + localId;
	};
	GroupComponent$1.prototype.registerElement = function(element) {
		var id$1 = element.get("id");
		this.get("shapesMap")[id$1] = element;
	};
	GroupComponent$1.prototype.unregisterElement = function(element) {
		var id$1 = element.get("id");
		delete this.get("shapesMap")[id$1];
	};
	GroupComponent$1.prototype.moveElementTo = function(element, point$1) {
		var matrix = getMatrixByTranslate(point$1);
		element.attr("matrix", matrix);
	};
	/**
	* 图形元素新出现时的动画，默认图形从透明度 0 到当前透明度
	* @protected
	* @param {string} elmentName 图形元素名称
	* @param {IElement} newElement  新的图形元素
	* @param {object} animateCfg 动画的配置项
	*/
	GroupComponent$1.prototype.addAnimation = function(elmentName, newElement, animateCfg) {
		var originOpacity = newElement.attr("opacity");
		if (is_nil_default(originOpacity)) originOpacity = 1;
		newElement.attr("opacity", 0);
		newElement.animate({ opacity: originOpacity }, animateCfg);
	};
	/**
	* 图形元素新出现时的动画，默认图形从透明度 0 到当前透明度
	* @protected
	* @param {string} elmentName 图形元素名称
	* @param {IElement} originElement 要删除的图形元素
	* @param {object} animateCfg 动画的配置项
	*/
	GroupComponent$1.prototype.removeAnimation = function(elementName, originElement, animateCfg) {
		originElement.animate({ opacity: 0 }, animateCfg);
	};
	/**
	* 图形元素的更新动画
	* @param {string} elmentName 图形元素名称
	* @param {IElement} originElement 现有的图形元素
	* @param {object} newAttrs  新的图形元素
	* @param {object} animateCfg 动画的配置项
	*/
	GroupComponent$1.prototype.updateAnimation = function(elementName, originElement, newAttrs, animateCfg) {
		originElement.animate(newAttrs, animateCfg);
	};
	GroupComponent$1.prototype.updateElements = function(newGroup, originGroup) {
		var _this = this;
		var animate = this.get("animate");
		var animateOption = this.get("animateOption");
		var children = newGroup.getChildren().slice(0);
		var preElement;
		each_default(children, function(element) {
			var elementId = element.get("id");
			var originElement = _this.getElementById(elementId);
			var elementName = element.get("name");
			if (originElement) if (element.get("isComponent")) {
				var childComponent = element.get("component");
				var origChildComponent = originElement.get("component");
				var newCfg = pick_default(childComponent.cfg, difference_default(keys_default(childComponent.cfg), COPY_PROPERTIES_EXCLUDES));
				origChildComponent.update(newCfg);
				originElement.set(STATUS_UPDATE, "update");
			} else {
				var replaceAttrs = _this.getReplaceAttrs(originElement, element);
				if (animate && animateOption.update) _this.updateAnimation(elementName, originElement, replaceAttrs, animateOption.update);
				else originElement.attr(replaceAttrs);
				if (element.isGroup()) _this.updateElements(element, originElement);
				each_default(COPY_PROPERTIES, function(name) {
					originElement.set(name, element.get(name));
				});
				updateClip(originElement, element);
				preElement = originElement;
				originElement.set(STATUS_UPDATE, "update");
			}
			else {
				originGroup.add(element);
				var siblings = originGroup.getChildren();
				siblings.splice(siblings.length - 1, 1);
				if (preElement) {
					var index = siblings.indexOf(preElement);
					siblings.splice(index + 1, 0, element);
				} else siblings.unshift(element);
				_this.registerElement(element);
				element.set(STATUS_UPDATE, "add");
				if (element.get("isComponent")) {
					var childComponent = element.get("component");
					childComponent.set("container", originGroup);
				} else if (element.isGroup()) _this.registerNewGroup(element);
				preElement = element;
				if (animate) {
					var animateCfg = _this.get("isInit") ? animateOption.appear : animateOption.enter;
					if (animateCfg) _this.addAnimation(elementName, element, animateCfg);
				}
			}
		});
	};
	GroupComponent$1.prototype.clearUpdateStatus = function(group$1) {
		var children = group$1.getChildren();
		each_default(children, function(el) {
			el.set(STATUS_UPDATE, null);
		});
	};
	GroupComponent$1.prototype.clearOffScreenCache = function() {
		var offScreenGroup = this.get("offScreenGroup");
		if (offScreenGroup) offScreenGroup.destroy();
		this.set("offScreenGroup", null);
		this.set("offScreenBBox", null);
	};
	GroupComponent$1.prototype.getDelegateObject = function() {
		var _a$5;
		var name = this.get("name");
		return _a$5 = {}, _a$5[name] = this, _a$5.component = this, _a$5;
	};
	GroupComponent$1.prototype.appendDelegateObject = function(parent, cfg) {
		var parentObject = parent.get("delegateObject");
		if (!cfg.delegateObject) cfg.delegateObject = {};
		mix(cfg.delegateObject, parentObject);
	};
	GroupComponent$1.prototype.getReplaceAttrs = function(originElement, newElement) {
		var originAttrs = originElement.attr();
		var newAttrs = newElement.attr();
		each_default(originAttrs, function(v, k) {
			if (newAttrs[k] === void 0) newAttrs[k] = void 0;
		});
		return newAttrs;
	};
	GroupComponent$1.prototype.registerNewGroup = function(group$1) {
		var _this = this;
		var children = group$1.getChildren();
		each_default(children, function(element) {
			_this.registerElement(element);
			element.set(STATUS_UPDATE, "add");
			if (element.isGroup()) _this.registerNewGroup(element);
		});
	};
	GroupComponent$1.prototype.deleteElements = function() {
		var _this = this;
		var shapesMap = this.get("shapesMap");
		var deleteArray = [];
		each_default(shapesMap, function(element, id$1) {
			if (!element.get(STATUS_UPDATE) || element.destroyed) deleteArray.push([id$1, element]);
			else element.set(STATUS_UPDATE, null);
		});
		var animate = this.get("animate");
		var animateOption = this.get("animateOption");
		each_default(deleteArray, function(item) {
			var id$1 = item[0], element = item[1];
			if (!element.destroyed) {
				var elementName = element.get("name");
				if (animate && animateOption.leave) {
					var callbackAnimCfg = mix({ callback: function() {
						_this.removeElement(element);
					} }, animateOption.leave);
					_this.removeAnimation(elementName, element, callbackAnimCfg);
				} else _this.removeElement(element);
			}
			delete shapesMap[id$1];
		});
	};
	GroupComponent$1.prototype.removeElement = function(element) {
		if (element.get("isGroup")) {
			var component$1 = element.get("component");
			if (component$1) component$1.destroy();
		}
		element.remove();
	};
	return GroupComponent$1;
}(component_default);
var group_component_default = GroupComponent;

//#endregion
//#region node_modules/@antv/component/esm/util/text.js
var ELLIPSIS_CODE$1 = "…";
/** 获取字符串长度 */
function strLen(str) {
	var len = 0;
	for (var i = 0; i < str.length; i++) len += charAtLength(str, i);
	return len;
}
/** 是否属于ASCII编码范畴 */
function charAtLength(str, i) {
	if (str.charCodeAt(i) > 0 && str.charCodeAt(i) < 128) return 1;
	else return 2;
}
/** 文本省略 */
function ellipsisString(str, reseveLength, position) {
	if (position === void 0) position = "tail";
	var count$1 = str.length;
	var rst = "";
	if (position === "tail") {
		for (var i = 0, index = 0; i < reseveLength;) {
			var charLength = charAtLength(str, index);
			if (i + charLength <= reseveLength) {
				rst += str[index];
				i += charAtLength(str, index);
				index++;
			} else break;
		}
		rst += ELLIPSIS_CODE$1;
	} else if (position === "head") {
		for (var i = 0, index = count$1 - 1; i < reseveLength;) {
			var charLength = charAtLength(str, index);
			if (i + charLength <= reseveLength) {
				rst += str[index];
				i += charAtLength(str, index);
				index--;
			} else break;
		}
		rst = ELLIPSIS_CODE$1 + rst;
	} else {
		var startStr = "";
		var endStr = "";
		for (var i = 0, startIndex = 0, endIndex = count$1 - 1; i < reseveLength;) {
			var startCodeLen = charAtLength(str, startIndex);
			var hasAdd = false;
			if (startCodeLen + i <= reseveLength) {
				startStr += str[startIndex];
				startIndex++;
				i += startCodeLen;
				hasAdd = true;
			}
			var endCodeLen = charAtLength(str, endIndex);
			if (endCodeLen + i <= reseveLength) {
				endStr = str[endIndex] + endStr;
				i += endCodeLen;
				endIndex--;
				hasAdd = true;
			}
			if (!hasAdd) break;
		}
		rst = startStr + ELLIPSIS_CODE$1 + endStr;
	}
	return rst;
}

//#endregion
//#region node_modules/@antv/component/esm/util/label.js
var ELLIPSIS_CODE = "…";
var ELLIPSIS_CODE_LENGTH = 2;
/** 大数据量阈值 */
var OPTIMIZE_THRESHOLD = 400;
/**
* 针对大数据量做优化的 getMaxLabelWidth，做法不是直接去比较每一个 label 的最大宽度
* 而是先通过比较每个 label 每个的字符串的长度，这里区分了下中英文字符
* 最终是去字符串最“长”的那个 label 的宽度。
* @param labels
*/
function getMaxLabelWidthOptimized(labels) {
	var texts = labels.map(function(label$16) {
		var text = label$16.attr("text");
		return is_nil_default(text) ? "" : "" + text;
	});
	var maxLen = 0;
	var maxIdx = 0;
	for (var i = 0; i < texts.length; i += 1) {
		var len = 0;
		for (var j = 0; j <= texts[i].length; j += 1) {
			var code$1 = texts[i].charCodeAt(j);
			if (code$1 >= 19968 && code$1 <= 40869) len += 2;
			else len += 1;
		}
		if (len > maxLen) {
			maxLen = len;
			maxIdx = i;
		}
	}
	return labels[maxIdx].getBBox().width;
}
/** 获取最长的 label */
function getMaxLabelWidth(labels) {
	if (labels.length > OPTIMIZE_THRESHOLD) return getMaxLabelWidthOptimized(labels);
	var max$2 = 0;
	each_default(labels, function(label$16) {
		var width = label$16.getBBox().width;
		if (max$2 < width) max$2 = width;
	});
	return max$2;
}
/** 获取label长度 */
function getLabelLength(isVertical$1, label$16) {
	var bbox = label$16.getCanvasBBox();
	return isVertical$1 ? bbox.width : bbox.height;
}
/** 处理 text shape 的自动省略 */
function ellipsisLabel(isVertical$1, label$16, limitLength, position) {
	var _a$5;
	if (position === void 0) position = "tail";
	var text = (_a$5 = label$16.attr("text")) !== null && _a$5 !== void 0 ? _a$5 : "";
	if (position === "tail") {
		var font = pick_default(label$16.attr(), [
			"fontSize",
			"fontFamily",
			"fontWeight",
			"fontStyle",
			"fontVariant"
		]);
		var ellipsisText = get_ellipsis_text_default(text, limitLength, font, "…");
		if (text !== ellipsisText) {
			label$16.attr("text", ellipsisText);
			label$16.set("tip", text);
			return true;
		}
		label$16.set("tip", null);
		return false;
	}
	var labelLength = getLabelLength(isVertical$1, label$16);
	var codeLength = strLen(text);
	var ellipsisFlag = false;
	if (limitLength < labelLength) {
		var reserveLength = Math.floor(limitLength / labelLength * codeLength) - ELLIPSIS_CODE_LENGTH;
		var newText = void 0;
		if (reserveLength >= 0) newText = ellipsisString(text, reserveLength, position);
		else newText = ELLIPSIS_CODE;
		if (newText) {
			label$16.attr("text", newText);
			ellipsisFlag = true;
		}
	}
	if (ellipsisFlag) label$16.set("tip", text);
	else label$16.set("tip", null);
	return ellipsisFlag;
}

//#endregion
//#region node_modules/@antv/component/esm/util/graphic.js
function renderTag$1(container, tagCfg) {
	var x = tagCfg.x, y = tagCfg.y, content = tagCfg.content, style = tagCfg.style, id$1 = tagCfg.id, name = tagCfg.name, rotate$2 = tagCfg.rotate, maxLength = tagCfg.maxLength, autoEllipsis = tagCfg.autoEllipsis, isVertical$1 = tagCfg.isVertical, ellipsisPosition = tagCfg.ellipsisPosition, background = tagCfg.background;
	var tagGroup = container.addGroup({
		id: id$1 + "-group",
		name: name + "-group",
		attrs: {
			x,
			y
		}
	});
	var text = tagGroup.addShape({
		type: "text",
		id: id$1,
		name,
		attrs: __assign({
			x: 0,
			y: 0,
			text: content
		}, style)
	});
	var padding$2 = formatPadding(get_default(background, "padding", 0));
	if (maxLength && autoEllipsis) {
		var maxTextLength = maxLength - (padding$2[1] + padding$2[3]);
		ellipsisLabel(!isVertical$1, text, maxTextLength, ellipsisPosition);
	}
	if (background) {
		var backgroundStyle = get_default(background, "style", {});
		var _a$5 = text.getCanvasBBox(), minX = _a$5.minX, minY = _a$5.minY, width = _a$5.width, height = _a$5.height;
		tagGroup.addShape("rect", {
			id: id$1 + "-bg",
			name: id$1 + "-bg",
			attrs: __assign({
				x: minX - padding$2[3],
				y: minY - padding$2[0],
				width: width + padding$2[1] + padding$2[3],
				height: height + padding$2[0] + padding$2[2]
			}, backgroundStyle)
		}).toBack();
	}
	applyTranslate(tagGroup, x, y);
	applyRotate(tagGroup, rotate$2, x, y);
}

//#endregion
//#region node_modules/@antv/component/esm/util/theme.js
var theme_default = {
	fontFamily: "\n  BlinkMacSystemFont, \"Segoe UI\", Roboto,\"Helvetica Neue\",\n  Helvetica, \"PingFang SC\", \"Hiragino Sans GB\", \"Microsoft YaHei\",\n  SimSun, \"sans-serif\"",
	textColor: "#2C3542",
	activeTextColor: "#333333",
	uncheckedColor: "#D8D8D8",
	lineColor: "#416180",
	regionColor: "#CCD7EB",
	verticalAxisRotate: -Math.PI / 4,
	horizontalAxisRotate: Math.PI / 4,
	descriptionIconStroke: "#fff",
	descriptionIconFill: "rgba(58, 73, 101, .25)"
};

//#endregion
//#region node_modules/@antv/component/esm/annotation/line.js
var LineAnnotation = function(_super) {
	__extends(LineAnnotation$1, _super);
	function LineAnnotation$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	/**
	* @protected
	* 默认的配置项
	* @returns {object} 默认的配置项
	*/
	LineAnnotation$1.prototype.getDefaultCfg = function() {
		var cfg = _super.prototype.getDefaultCfg.call(this);
		return __assign(__assign({}, cfg), {
			name: "annotation",
			type: "line",
			locationType: "region",
			start: null,
			end: null,
			style: {},
			text: null,
			defaultCfg: {
				style: {
					fill: theme_default.textColor,
					fontSize: 12,
					textAlign: "center",
					textBaseline: "bottom",
					fontFamily: theme_default.fontFamily
				},
				text: {
					position: "center",
					autoRotate: true,
					content: null,
					offsetX: 0,
					offsetY: 0,
					style: {
						stroke: theme_default.lineColor,
						lineWidth: 1
					}
				}
			}
		});
	};
	LineAnnotation$1.prototype.renderInner = function(group$1) {
		this.renderLine(group$1);
		if (this.get("text")) this.renderLabel(group$1);
	};
	LineAnnotation$1.prototype.renderLine = function(group$1) {
		var start = this.get("start");
		var end = this.get("end");
		var style = this.get("style");
		this.addShape(group$1, {
			type: "line",
			id: this.getElementId("line"),
			name: "annotation-line",
			attrs: __assign({
				x1: start.x,
				y1: start.y,
				x2: end.x,
				y2: end.y
			}, style)
		});
	};
	LineAnnotation$1.prototype.getLabelPoint = function(start, end, position) {
		var percent$1;
		if (position === "start") percent$1 = 0;
		else if (position === "center") percent$1 = .5;
		else if (is_string_default(position) && position.indexOf("%") !== -1) percent$1 = parseInt(position, 10) / 100;
		else if (is_number_default(position)) percent$1 = position;
		else percent$1 = 1;
		if (percent$1 > 1 || percent$1 < 0) percent$1 = 1;
		return {
			x: getValueByPercent(start.x, end.x, percent$1),
			y: getValueByPercent(start.y, end.y, percent$1)
		};
	};
	LineAnnotation$1.prototype.renderLabel = function(group$1) {
		var text = this.get("text");
		var start = this.get("start");
		var end = this.get("end");
		var position = text.position, content = text.content, style = text.style, offsetX = text.offsetX, offsetY = text.offsetY, autoRotate = text.autoRotate, maxLength = text.maxLength, autoEllipsis = text.autoEllipsis, ellipsisPosition = text.ellipsisPosition, background = text.background, _a$5 = text.isVertical, isVertical$1 = _a$5 === void 0 ? false : _a$5;
		var point$1 = this.getLabelPoint(start, end, position);
		var x = point$1.x + offsetX;
		var y = point$1.y + offsetY;
		var cfg = {
			id: this.getElementId("line-text"),
			name: "annotation-line-text",
			x,
			y,
			content,
			style,
			maxLength,
			autoEllipsis,
			ellipsisPosition,
			background,
			isVertical: isVertical$1
		};
		if (autoRotate) {
			var vector = [end.x - start.x, end.y - start.y];
			cfg.rotate = Math.atan2(vector[1], vector[0]);
		}
		renderTag$1(group$1, cfg);
	};
	return LineAnnotation$1;
}(group_component_default);
var line_default$7 = LineAnnotation;

//#endregion
//#region node_modules/@antv/component/esm/annotation/text.js
var TextAnnotation = function(_super) {
	__extends(TextAnnotation$1, _super);
	function TextAnnotation$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	/**
	* @protected
	* 默认的配置项
	* @returns {object} 默认的配置项
	*/
	TextAnnotation$1.prototype.getDefaultCfg = function() {
		var cfg = _super.prototype.getDefaultCfg.call(this);
		return __assign(__assign({}, cfg), {
			name: "annotation",
			type: "text",
			locationType: "point",
			x: 0,
			y: 0,
			content: "",
			rotate: null,
			style: {},
			background: null,
			maxLength: null,
			autoEllipsis: true,
			isVertical: false,
			ellipsisPosition: "tail",
			defaultCfg: { style: {
				fill: theme_default.textColor,
				fontSize: 12,
				textAlign: "center",
				textBaseline: "middle",
				fontFamily: theme_default.fontFamily
			} }
		});
	};
	TextAnnotation$1.prototype.setLocation = function(location) {
		this.set("x", location.x);
		this.set("y", location.y);
		this.resetLocation();
	};
	TextAnnotation$1.prototype.renderInner = function(group$1) {
		var _a$5 = this.getLocation(), x = _a$5.x, y = _a$5.y;
		var content = this.get("content");
		var style = this.get("style");
		var id$1 = this.getElementId("text");
		var name = this.get("name") + "-text";
		var maxLength = this.get("maxLength");
		var autoEllipsis = this.get("autoEllipsis");
		var isVertical$1 = this.get("isVertical");
		var ellipsisPosition = this.get("ellipsisPosition");
		var background = this.get("background");
		var rotate$2 = this.get("rotate");
		renderTag$1(group$1, {
			id: id$1,
			name,
			x,
			y,
			content,
			style,
			maxLength,
			autoEllipsis,
			isVertical: isVertical$1,
			ellipsisPosition,
			background,
			rotate: rotate$2
		});
	};
	TextAnnotation$1.prototype.resetLocation = function() {
		var textGroup = this.getElementByLocalId("text-group");
		if (textGroup) {
			var _a$5 = this.getLocation(), x = _a$5.x, y = _a$5.y;
			var rotate$2 = this.get("rotate");
			applyTranslate(textGroup, x, y);
			applyRotate(textGroup, rotate$2, x, y);
		}
	};
	return TextAnnotation$1;
}(group_component_default);
var text_default$2 = TextAnnotation;

//#endregion
//#region node_modules/@antv/component/esm/annotation/arc.js
var ArcAnnotation = function(_super) {
	__extends(ArcAnnotation$1, _super);
	function ArcAnnotation$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	/**
	* @protected
	* 默认的配置项
	* @returns {object} 默认的配置项
	*/
	ArcAnnotation$1.prototype.getDefaultCfg = function() {
		var cfg = _super.prototype.getDefaultCfg.call(this);
		return __assign(__assign({}, cfg), {
			name: "annotation",
			type: "arc",
			locationType: "circle",
			center: null,
			radius: 100,
			startAngle: -Math.PI / 2,
			endAngle: Math.PI * 3 / 2,
			style: {
				stroke: "#999",
				lineWidth: 1
			}
		});
	};
	ArcAnnotation$1.prototype.renderInner = function(group$1) {
		this.renderArc(group$1);
	};
	ArcAnnotation$1.prototype.getArcPath = function() {
		var _a$5 = this.getLocation(), center$1 = _a$5.center, radius = _a$5.radius, startAngle = _a$5.startAngle, endAngle = _a$5.endAngle;
		var startPoint = getCirclePoint(center$1, radius, startAngle);
		var endPoint = getCirclePoint(center$1, radius, endAngle);
		var largeFlag = endAngle - startAngle > Math.PI ? 1 : 0;
		var path = [[
			"M",
			startPoint.x,
			startPoint.y
		]];
		if (endAngle - startAngle === Math.PI * 2) {
			var middlePoint = getCirclePoint(center$1, radius, startAngle + Math.PI);
			path.push([
				"A",
				radius,
				radius,
				0,
				largeFlag,
				1,
				middlePoint.x,
				middlePoint.y
			]);
			path.push([
				"A",
				radius,
				radius,
				0,
				largeFlag,
				1,
				endPoint.x,
				endPoint.y
			]);
		} else path.push([
			"A",
			radius,
			radius,
			0,
			largeFlag,
			1,
			endPoint.x,
			endPoint.y
		]);
		return path;
	};
	ArcAnnotation$1.prototype.renderArc = function(group$1) {
		var path = this.getArcPath();
		var style = this.get("style");
		this.addShape(group$1, {
			type: "path",
			id: this.getElementId("arc"),
			name: "annotation-arc",
			attrs: __assign({ path }, style)
		});
	};
	return ArcAnnotation$1;
}(group_component_default);
var arc_default = ArcAnnotation;

//#endregion
//#region node_modules/@antv/component/esm/annotation/region.js
var RegionAnnotation = function(_super) {
	__extends(RegionAnnotation$1, _super);
	function RegionAnnotation$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	/**
	* @protected
	* 默认的配置项
	* @returns {object} 默认的配置项
	*/
	RegionAnnotation$1.prototype.getDefaultCfg = function() {
		var cfg = _super.prototype.getDefaultCfg.call(this);
		return __assign(__assign({}, cfg), {
			name: "annotation",
			type: "region",
			locationType: "region",
			start: null,
			end: null,
			style: {},
			defaultCfg: { style: {
				lineWidth: 0,
				fill: theme_default.regionColor,
				opacity: .4
			} }
		});
	};
	RegionAnnotation$1.prototype.renderInner = function(group$1) {
		this.renderRegion(group$1);
	};
	RegionAnnotation$1.prototype.renderRegion = function(group$1) {
		var start = this.get("start");
		var end = this.get("end");
		var style = this.get("style");
		var bbox = regionToBBox({
			start,
			end
		});
		this.addShape(group$1, {
			type: "rect",
			id: this.getElementId("region"),
			name: "annotation-region",
			attrs: __assign({
				x: bbox.x,
				y: bbox.y,
				width: bbox.width,
				height: bbox.height
			}, style)
		});
	};
	return RegionAnnotation$1;
}(group_component_default);
var region_default = RegionAnnotation;

//#endregion
//#region node_modules/@antv/component/esm/annotation/image.js
var ImageAnnotation = function(_super) {
	__extends(ImageAnnotation$1, _super);
	function ImageAnnotation$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	/**
	* @protected
	* 默认的配置项
	* @returns {object} 默认的配置项
	*/
	ImageAnnotation$1.prototype.getDefaultCfg = function() {
		var cfg = _super.prototype.getDefaultCfg.call(this);
		return __assign(__assign({}, cfg), {
			name: "annotation",
			type: "image",
			locationType: "region",
			start: null,
			end: null,
			src: null,
			style: {}
		});
	};
	ImageAnnotation$1.prototype.renderInner = function(group$1) {
		this.renderImage(group$1);
	};
	ImageAnnotation$1.prototype.getImageAttrs = function() {
		var start = this.get("start");
		var end = this.get("end");
		var style = this.get("style");
		var bbox = regionToBBox({
			start,
			end
		});
		var src = this.get("src");
		return __assign({
			x: bbox.x,
			y: bbox.y,
			img: src,
			width: bbox.width,
			height: bbox.height
		}, style);
	};
	ImageAnnotation$1.prototype.renderImage = function(group$1) {
		this.addShape(group$1, {
			type: "image",
			id: this.getElementId("image"),
			name: "annotation-image",
			attrs: this.getImageAttrs()
		});
	};
	return ImageAnnotation$1;
}(group_component_default);
var image_default$2 = ImageAnnotation;

//#endregion
//#region node_modules/@antv/component/esm/annotation/data-marker.js
var DataMarkerAnnotation = function(_super) {
	__extends(DataMarkerAnnotation$1, _super);
	function DataMarkerAnnotation$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	/**
	* 默认的配置项
	* @returns {object} 默认的配置项
	*/
	DataMarkerAnnotation$1.prototype.getDefaultCfg = function() {
		var cfg = _super.prototype.getDefaultCfg.call(this);
		return __assign(__assign({}, cfg), {
			name: "annotation",
			type: "dataMarker",
			locationType: "point",
			x: 0,
			y: 0,
			point: {},
			line: {},
			text: {},
			direction: "upward",
			autoAdjust: true,
			coordinateBBox: null,
			defaultCfg: {
				point: {
					display: true,
					style: {
						r: 3,
						fill: "#FFFFFF",
						stroke: "#1890FF",
						lineWidth: 2
					}
				},
				line: {
					display: true,
					length: 20,
					style: {
						stroke: theme_default.lineColor,
						lineWidth: 1
					}
				},
				text: {
					content: "",
					display: true,
					style: {
						fill: theme_default.textColor,
						opacity: .65,
						fontSize: 12,
						textAlign: "start",
						fontFamily: theme_default.fontFamily
					}
				}
			}
		});
	};
	DataMarkerAnnotation$1.prototype.renderInner = function(group$1) {
		if (get_default(this.get("line"), "display")) this.renderLine(group$1);
		if (get_default(this.get("text"), "display")) this.renderText(group$1);
		if (get_default(this.get("point"), "display")) this.renderPoint(group$1);
		if (this.get("autoAdjust")) this.autoAdjust(group$1);
	};
	DataMarkerAnnotation$1.prototype.applyOffset = function() {
		this.moveElementTo(this.get("group"), {
			x: this.get("x") + this.get("offsetX"),
			y: this.get("y") + this.get("offsetY")
		});
	};
	DataMarkerAnnotation$1.prototype.renderPoint = function(group$1) {
		var point$1 = this.getShapeAttrs().point;
		this.addShape(group$1, {
			type: "circle",
			id: this.getElementId("point"),
			name: "annotation-point",
			attrs: point$1
		});
	};
	DataMarkerAnnotation$1.prototype.renderLine = function(group$1) {
		var line$1 = this.getShapeAttrs().line;
		this.addShape(group$1, {
			type: "path",
			id: this.getElementId("line"),
			name: "annotation-line",
			attrs: line$1
		});
	};
	DataMarkerAnnotation$1.prototype.renderText = function(group$1) {
		var textAttrs = this.getShapeAttrs().text;
		var x = textAttrs.x, y = textAttrs.y, text = textAttrs.text, style = __rest(textAttrs, [
			"x",
			"y",
			"text"
		]);
		var _a$5 = this.get("text"), background = _a$5.background, maxLength = _a$5.maxLength, autoEllipsis = _a$5.autoEllipsis, isVertival = _a$5.isVertival, ellipsisPosition = _a$5.ellipsisPosition;
		var tagCfg = {
			x,
			y,
			id: this.getElementId("text"),
			name: "annotation-text",
			content: text,
			style,
			background,
			maxLength,
			autoEllipsis,
			isVertival,
			ellipsisPosition
		};
		renderTag$1(group$1, tagCfg);
	};
	DataMarkerAnnotation$1.prototype.autoAdjust = function(group$1) {
		var direction$1 = this.get("direction");
		var x = this.get("x");
		var y = this.get("y");
		var lineLength = get_default(this.get("line"), "length", 0);
		var coordinateBBox = this.get("coordinateBBox");
		var _a$5 = group$1.getBBox(), minX = _a$5.minX, maxX = _a$5.maxX, minY = _a$5.minY, maxY$1 = _a$5.maxY;
		var textGroup = group$1.findById(this.getElementId("text-group"));
		var textShape = group$1.findById(this.getElementId("text"));
		var lineShape = group$1.findById(this.getElementId("line"));
		if (!coordinateBBox) return;
		if (textGroup) {
			var translateX = textGroup.attr("x"), translateY = textGroup.attr("y");
			var _b = textShape.getCanvasBBox(), width = _b.width, height = _b.height;
			var xFactor = 0, yFactor = 0;
			if (x + minX <= coordinateBBox.minX) if (direction$1 === "leftward") xFactor = 1;
			else {
				var overflow = coordinateBBox.minX - (x + minX);
				translateX = textGroup.attr("x") + overflow;
			}
			else if (x + maxX >= coordinateBBox.maxX) if (direction$1 === "rightward") xFactor = -1;
			else {
				var overflow = x + maxX - coordinateBBox.maxX;
				translateX = textGroup.attr("x") - overflow;
			}
			if (!!xFactor) {
				if (lineShape) lineShape.attr("path", [[
					"M",
					0,
					0
				], [
					"L",
					lineLength * xFactor,
					0
				]]);
				translateX = (lineLength + 2 + width) * xFactor;
			}
			if (y + minY <= coordinateBBox.minY) if (direction$1 === "upward") yFactor = 1;
			else {
				var overflow = coordinateBBox.minY - (y + minY);
				translateY = textGroup.attr("y") + overflow;
			}
			else if (y + maxY$1 >= coordinateBBox.maxY) if (direction$1 === "downward") yFactor = -1;
			else {
				var overflow = y + maxY$1 - coordinateBBox.maxY;
				translateY = textGroup.attr("y") - overflow;
			}
			if (!!yFactor) {
				if (lineShape) lineShape.attr("path", [[
					"M",
					0,
					0
				], [
					"L",
					0,
					lineLength * yFactor
				]]);
				translateY = (lineLength + 2 + height) * yFactor;
			}
			if (translateX !== textGroup.attr("x") || translateY !== textGroup.attr("y")) applyTranslate(textGroup, translateX, translateY);
		}
	};
	DataMarkerAnnotation$1.prototype.getShapeAttrs = function() {
		var lineDisplay = get_default(this.get("line"), "display");
		var pointStyle = get_default(this.get("point"), "style", {});
		var lineStyle = get_default(this.get("line"), "style", {});
		var textStyle$1 = get_default(this.get("text"), "style", {});
		var direction$1 = this.get("direction");
		var lineLength = lineDisplay ? get_default(this.get("line"), "length", 0) : 0;
		var xFactor = 0, yFactor = 0;
		var textBaseline = "top", textAlign = "start";
		switch (direction$1) {
			case "upward":
				yFactor = -1;
				textBaseline = "bottom";
				break;
			case "downward":
				yFactor = 1;
				textBaseline = "top";
				break;
			case "leftward":
				xFactor = -1;
				textAlign = "end";
				break;
			case "rightward":
				xFactor = 1;
				textAlign = "start";
				break;
		}
		return {
			point: __assign({
				x: 0,
				y: 0
			}, pointStyle),
			line: __assign({ path: [[
				"M",
				0,
				0
			], [
				"L",
				lineLength * xFactor,
				lineLength * yFactor
			]] }, lineStyle),
			text: __assign({
				x: (lineLength + 2) * xFactor,
				y: (lineLength + 2) * yFactor,
				text: get_default(this.get("text"), "content", ""),
				textBaseline,
				textAlign
			}, textStyle$1)
		};
	};
	return DataMarkerAnnotation$1;
}(group_component_default);
var data_marker_default = DataMarkerAnnotation;

//#endregion
//#region node_modules/@antv/component/esm/annotation/data-region.js
var DataRegionAnnotation = function(_super) {
	__extends(DataRegionAnnotation$1, _super);
	function DataRegionAnnotation$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	/**
	* 默认的配置项
	* @returns {object} 默认的配置项
	*/
	DataRegionAnnotation$1.prototype.getDefaultCfg = function() {
		var cfg = _super.prototype.getDefaultCfg.call(this);
		return __assign(__assign({}, cfg), {
			name: "annotation",
			type: "dataRegion",
			locationType: "points",
			points: [],
			lineLength: 0,
			region: {},
			text: {},
			defaultCfg: {
				region: { style: {
					lineWidth: 0,
					fill: theme_default.regionColor,
					opacity: .4
				} },
				text: {
					content: "",
					style: {
						textAlign: "center",
						textBaseline: "bottom",
						fontSize: 12,
						fill: theme_default.textColor,
						fontFamily: theme_default.fontFamily
					}
				}
			}
		});
	};
	DataRegionAnnotation$1.prototype.renderInner = function(group$1) {
		var regionStyle = get_default(this.get("region"), "style", {});
		get_default(this.get("text"), "style", {});
		var lineLength = this.get("lineLength") || 0;
		var points = this.get("points");
		if (!points.length) return;
		var bbox = pointsToBBox(points);
		var path = [];
		path.push([
			"M",
			points[0].x,
			bbox.minY - lineLength
		]);
		points.forEach(function(point$1) {
			path.push([
				"L",
				point$1.x,
				point$1.y
			]);
		});
		path.push([
			"L",
			points[points.length - 1].x,
			points[points.length - 1].y - lineLength
		]);
		this.addShape(group$1, {
			type: "path",
			id: this.getElementId("region"),
			name: "annotation-region",
			attrs: __assign({ path }, regionStyle)
		});
		var textCfg = __assign({
			id: this.getElementId("text"),
			name: "annotation-text",
			x: (bbox.minX + bbox.maxX) / 2,
			y: bbox.minY - lineLength
		}, this.get("text"));
		renderTag$1(group$1, textCfg);
	};
	return DataRegionAnnotation$1;
}(group_component_default);
var data_region_default = DataRegionAnnotation;

//#endregion
//#region node_modules/@antv/component/esm/annotation/region-filter.js
var RegionFilterAnnotation = function(_super) {
	__extends(RegionFilterAnnotation$1, _super);
	function RegionFilterAnnotation$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	/**
	* 默认的配置项
	* @returns {object} 默认的配置项
	*/
	RegionFilterAnnotation$1.prototype.getDefaultCfg = function() {
		var cfg = _super.prototype.getDefaultCfg.call(this);
		return __assign(__assign({}, cfg), {
			name: "annotation",
			type: "regionFilter",
			locationType: "region",
			start: null,
			end: null,
			color: null,
			shape: []
		});
	};
	RegionFilterAnnotation$1.prototype.renderInner = function(group$1) {
		var _this = this;
		var start = this.get("start");
		var end = this.get("end");
		var layer = this.addGroup(group$1, {
			id: this.getElementId("region-filter"),
			capture: false
		});
		each_default(this.get("shapes"), function(shape, shapeIdx) {
			var type = shape.get("type");
			var attrs = clone_default(shape.attr());
			_this.adjustShapeAttrs(attrs);
			_this.addShape(layer, {
				id: _this.getElementId("shape-" + type + "-" + shapeIdx),
				capture: false,
				type,
				attrs
			});
		});
		var clipBBox = regionToBBox({
			start,
			end
		});
		layer.setClip({
			type: "rect",
			attrs: {
				x: clipBBox.minX,
				y: clipBBox.minY,
				width: clipBBox.width,
				height: clipBBox.height
			}
		});
	};
	RegionFilterAnnotation$1.prototype.adjustShapeAttrs = function(attr) {
		var color$2 = this.get("color");
		if (attr.fill) attr.fill = attr.fillStyle = color$2;
		attr.stroke = attr.strokeStyle = color$2;
	};
	return RegionFilterAnnotation$1;
}(group_component_default);
var region_filter_default = RegionFilterAnnotation;

//#endregion
//#region node_modules/@antv/component/esm/annotation/shape.js
var ShapeAnnotation = function(_super) {
	__extends(ShapeAnnotation$1, _super);
	function ShapeAnnotation$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	ShapeAnnotation$1.prototype.getDefaultCfg = function() {
		var cfg = _super.prototype.getDefaultCfg.call(this);
		return __assign(__assign({}, cfg), {
			name: "annotation",
			type: "shape",
			draw: noop_default
		});
	};
	ShapeAnnotation$1.prototype.renderInner = function(group$1) {
		var render = this.get("render");
		if (is_function_default(render)) render(group$1);
	};
	return ShapeAnnotation$1;
}(group_component_default);
var shape_default$1 = ShapeAnnotation;

//#endregion
//#region node_modules/@antv/component/esm/abstract/html-component.js
var HtmlComponent = function(_super) {
	__extends(HtmlComponent$1, _super);
	function HtmlComponent$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	HtmlComponent$1.prototype.getDefaultCfg = function() {
		var cfg = _super.prototype.getDefaultCfg.call(this);
		return __assign(__assign({}, cfg), {
			container: null,
			containerTpl: "<div></div>",
			updateAutoRender: true,
			containerClassName: "",
			parent: null
		});
	};
	HtmlComponent$1.prototype.getContainer = function() {
		return this.get("container");
	};
	/**
	* 显示组件
	*/
	HtmlComponent$1.prototype.show = function() {
		var container = this.get("container");
		container.style.display = "";
		this.set("visible", true);
	};
	/**
	* 隐藏组件
	*/
	HtmlComponent$1.prototype.hide = function() {
		var container = this.get("container");
		container.style.display = "none";
		this.set("visible", false);
	};
	/**
	* 是否允许捕捉事件
	* @param capture 事件捕捉
	*/
	HtmlComponent$1.prototype.setCapture = function(capture) {
		var container = this.getContainer();
		var value$1 = capture ? "auto" : "none";
		container.style.pointerEvents = value$1;
		this.set("capture", capture);
	};
	HtmlComponent$1.prototype.getBBox = function() {
		var container = this.getContainer();
		var x = parseFloat(container.style.left) || 0;
		var y = parseFloat(container.style.top) || 0;
		return createBBox(x, y, container.clientWidth, container.clientHeight);
	};
	HtmlComponent$1.prototype.clear = function() {
		var container = this.get("container");
		clearDom(container);
	};
	HtmlComponent$1.prototype.destroy = function() {
		this.removeEvent();
		this.removeDom();
		_super.prototype.destroy.call(this);
	};
	/**
	* 复写 init，主要是初始化 DOM 和事件
	*/
	HtmlComponent$1.prototype.init = function() {
		_super.prototype.init.call(this);
		this.initContainer();
		this.initDom();
		this.resetStyles();
		this.applyStyles();
		this.initEvent();
		this.initCapture();
		this.initVisible();
	};
	HtmlComponent$1.prototype.initCapture = function() {
		this.setCapture(this.get("capture"));
	};
	HtmlComponent$1.prototype.initVisible = function() {
		if (!this.get("visible")) this.hide();
		else this.show();
	};
	HtmlComponent$1.prototype.initDom = function() {};
	HtmlComponent$1.prototype.initContainer = function() {
		var container = this.get("container");
		if (is_nil_default(container)) {
			container = this.createDom();
			var parent_1 = this.get("parent");
			if (is_string_default(parent_1)) {
				parent_1 = document.getElementById(parent_1);
				this.set("parent", parent_1);
			}
			parent_1.appendChild(container);
			if (this.get("containerId")) container.setAttribute("id", this.get("containerId"));
			this.set("container", container);
		} else if (is_string_default(container)) {
			container = document.getElementById(container);
			this.set("container", container);
		}
		if (!this.get("parent")) this.set("parent", container.parentNode);
	};
	HtmlComponent$1.prototype.resetStyles = function() {
		var style = this.get("domStyles");
		var defaultStyles = this.get("defaultStyles");
		if (!style) style = defaultStyles;
		else style = deep_mix_default({}, defaultStyles, style);
		this.set("domStyles", style);
	};
	HtmlComponent$1.prototype.applyStyles = function() {
		var domStyles = this.get("domStyles");
		if (!domStyles) return;
		var container = this.getContainer();
		this.applyChildrenStyles(container, domStyles);
		var containerClassName = this.get("containerClassName");
		if (containerClassName && hasClass(container, containerClassName)) {
			var containerCss = domStyles[containerClassName];
			modifyCSS(container, containerCss);
		}
	};
	HtmlComponent$1.prototype.applyChildrenStyles = function(element, styles) {
		each_default(styles, function(style, name) {
			var elements = element.getElementsByClassName(name);
			each_default(elements, function(el) {
				modifyCSS(el, style);
			});
		});
	};
	HtmlComponent$1.prototype.applyStyle = function(cssName, dom) {
		var domStyles = this.get("domStyles");
		modifyCSS(dom, domStyles[cssName]);
	};
	/**
	* @protected
	*/
	HtmlComponent$1.prototype.createDom = function() {
		var containerTpl = this.get("containerTpl");
		return createDom$1(containerTpl);
	};
	/**
	* @protected
	* 初始化事件
	*/
	HtmlComponent$1.prototype.initEvent = function() {};
	/**
	* @protected
	* 清理 DOM
	*/
	HtmlComponent$1.prototype.removeDom = function() {
		var container = this.get("container");
		container && container.parentNode && container.parentNode.removeChild(container);
	};
	/**
	* @protected
	* 清理事件
	*/
	HtmlComponent$1.prototype.removeEvent = function() {};
	HtmlComponent$1.prototype.updateInner = function(cfg) {
		if (has_key_default(cfg, "domStyles")) {
			this.resetStyles();
			this.applyStyles();
		}
		this.resetPosition();
	};
	HtmlComponent$1.prototype.resetPosition = function() {};
	return HtmlComponent$1;
}(component_default);
var html_component_default = HtmlComponent;

//#endregion
//#region node_modules/@antv/component/esm/annotation/html.js
var HtmlAnnotation = function(_super) {
	__extends(HtmlAnnotation$1, _super);
	function HtmlAnnotation$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	HtmlAnnotation$1.prototype.getDefaultCfg = function() {
		var cfg = _super.prototype.getDefaultCfg.call(this);
		return __assign(__assign({}, cfg), {
			name: "annotation",
			type: "html",
			locationType: "point",
			x: 0,
			y: 0,
			containerTpl: "<div class=\"g2-html-annotation\" style=\"position:absolute\"></div>",
			alignX: "left",
			alignY: "top",
			html: "",
			zIndex: 7
		});
	};
	HtmlAnnotation$1.prototype.render = function() {
		var container = this.getContainer();
		var html = this.get("html");
		clearDom(container);
		var rst = is_function_default(html) ? html(container) : html;
		if (is_element_default(rst)) container.appendChild(rst);
		else if (is_string_default(rst) || is_number_default(rst)) {
			var dom = createDom$1("" + rst);
			if (dom) container.appendChild(dom);
		}
		this.resetPosition();
	};
	HtmlAnnotation$1.prototype.resetPosition = function() {
		var container = this.getContainer();
		var _a$5 = this.getLocation(), x = _a$5.x, y = _a$5.y;
		var alignX = this.get("alignX");
		var alignY = this.get("alignY");
		var offsetX = this.get("offsetX");
		var offsetY = this.get("offsetY");
		var domWidth = getOuterWidth(container);
		var domHeight = getOuterHeight(container);
		var position = {
			x,
			y
		};
		if (alignX === "middle") position.x -= Math.round(domWidth / 2);
		else if (alignX === "right") position.x -= Math.round(domWidth);
		if (alignY === "middle") position.y -= Math.round(domHeight / 2);
		else if (alignY === "bottom") position.y -= Math.round(domHeight);
		if (offsetX) position.x += offsetX;
		if (offsetY) position.y += offsetY;
		modifyCSS(container, {
			position: "absolute",
			left: position.x + "px",
			top: position.y + "px",
			zIndex: this.get("zIndex")
		});
	};
	return HtmlAnnotation$1;
}(html_component_default);
var html_default$2 = HtmlAnnotation;

//#endregion
//#region node_modules/@antv/component/esm/annotation/index.js
var annotation_exports = /* @__PURE__ */ __export({
	Arc: () => arc_default,
	DataMarker: () => data_marker_default,
	DataRegion: () => data_region_default,
	Html: () => html_default$2,
	Image: () => image_default$2,
	Line: () => line_default$7,
	Region: () => region_default,
	RegionFilter: () => region_filter_default,
	Shape: () => shape_default$1,
	Text: () => text_default$2
});

//#endregion
//#region node_modules/@antv/component/esm/util/state.js
function getStatesStyle(item, elementName, stateStyles) {
	var styleName = elementName + "Style";
	var styles = null;
	each_default(stateStyles, function(v, state$1) {
		if (item[state$1] && v[styleName]) {
			if (!styles) styles = {};
			mix(styles, v[styleName]);
		}
	});
	return styles;
}

//#endregion
//#region node_modules/@antv/component/esm/axis/base.js
var AxisBase = function(_super) {
	__extends(AxisBase$1, _super);
	function AxisBase$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	AxisBase$1.prototype.getDefaultCfg = function() {
		var cfg = _super.prototype.getDefaultCfg.call(this);
		return __assign(__assign({}, cfg), {
			name: "axis",
			ticks: [],
			line: {},
			tickLine: {},
			subTickLine: null,
			title: null,
			label: {},
			verticalFactor: 1,
			verticalLimitLength: null,
			overlapOrder: [
				"autoRotate",
				"autoEllipsis",
				"autoHide"
			],
			tickStates: {},
			optimize: {},
			defaultCfg: {
				line: { style: {
					lineWidth: 1,
					stroke: theme_default.lineColor
				} },
				tickLine: {
					style: {
						lineWidth: 1,
						stroke: theme_default.lineColor
					},
					alignTick: true,
					length: 5,
					displayWithLabel: true
				},
				subTickLine: {
					style: {
						lineWidth: 1,
						stroke: theme_default.lineColor
					},
					count: 4,
					length: 2
				},
				label: {
					autoRotate: true,
					autoHide: false,
					autoEllipsis: false,
					style: {
						fontSize: 12,
						fill: theme_default.textColor,
						fontFamily: theme_default.fontFamily,
						fontWeight: "normal"
					},
					offset: 10,
					offsetX: 0,
					offsetY: 0
				},
				title: {
					autoRotate: true,
					spacing: 5,
					position: "center",
					style: {
						fontSize: 12,
						fill: theme_default.textColor,
						textBaseline: "middle",
						fontFamily: theme_default.fontFamily,
						textAlign: "center"
					},
					iconStyle: {
						fill: theme_default.descriptionIconFill,
						stroke: theme_default.descriptionIconStroke
					},
					description: ""
				},
				tickStates: {
					active: {
						labelStyle: { fontWeight: 500 },
						tickLineStyle: { lineWidth: 2 }
					},
					inactive: { labelStyle: { fill: theme_default.uncheckedColor } }
				},
				optimize: {
					enable: true,
					threshold: 400
				}
			},
			theme: {}
		});
	};
	/**
	* 绘制组件
	*/
	AxisBase$1.prototype.renderInner = function(group$1) {
		if (this.get("line")) this.drawLine(group$1);
		this.drawTicks(group$1);
		if (this.get("title")) this.drawTitle(group$1);
	};
	AxisBase$1.prototype.isList = function() {
		return true;
	};
	/**
	* 获取图例项
	* @return {ListItem[]} 列表项集合
	*/
	AxisBase$1.prototype.getItems = function() {
		return this.get("ticks");
	};
	/**
	* 设置列表项
	* @param {ListItem[]} items 列表项集合
	*/
	AxisBase$1.prototype.setItems = function(items) {
		this.update({ ticks: items });
	};
	/**
	* 更新列表项
	* @param {ListItem} item 列表项
	* @param {object}   cfg  列表项
	*/
	AxisBase$1.prototype.updateItem = function(item, cfg) {
		mix(item, cfg);
		this.clear();
		this.render();
	};
	/**
	* 清空列表
	*/
	AxisBase$1.prototype.clearItems = function() {
		var itemGroup = this.getElementByLocalId("label-group");
		itemGroup && itemGroup.clear();
	};
	/**
	* 设置列表项的状态
	* @param {ListItem} item  列表项
	* @param {string}   state 状态名
	* @param {boolean}  value 状态值, true, false
	*/
	AxisBase$1.prototype.setItemState = function(item, state$1, value$1) {
		item[state$1] = value$1;
		this.updateTickStates(item);
	};
	/**
	* 是否存在指定的状态
	* @param {ListItem} item  列表项
	* @param {boolean} state 状态名
	*/
	AxisBase$1.prototype.hasState = function(item, state$1) {
		return !!item[state$1];
	};
	AxisBase$1.prototype.getItemStates = function(item) {
		var tickStates = this.get("tickStates");
		var rst = [];
		each_default(tickStates, function(v, k) {
			if (item[k]) rst.push(k);
		});
		return rst;
	};
	/**
	* 清楚所有列表项的状态
	* @param {string} state 状态值
	*/
	AxisBase$1.prototype.clearItemsState = function(state$1) {
		var _this = this;
		var items = this.getItemsByState(state$1);
		each_default(items, function(item) {
			_this.setItemState(item, state$1, false);
		});
	};
	/**
	* 根据状态获取图例项
	* @param  {string}     state [description]
	* @return {ListItem[]}       [description]
	*/
	AxisBase$1.prototype.getItemsByState = function(state$1) {
		var _this = this;
		var items = this.getItems();
		return filter_default(items, function(item) {
			return _this.hasState(item, state$1);
		});
	};
	AxisBase$1.prototype.getSidePoint = function(point$1, offset) {
		var vector = this.getSideVector(offset, point$1);
		return {
			x: point$1.x + vector[0],
			y: point$1.y + vector[1]
		};
	};
	AxisBase$1.prototype.getTextAnchor = function(vector) {
		var align;
		if (isNumberEqual(vector[0], 0)) align = "center";
		else if (vector[0] > 0) align = "start";
		else if (vector[0] < 0) align = "end";
		return align;
	};
	AxisBase$1.prototype.getTextBaseline = function(vector) {
		var base;
		if (isNumberEqual(vector[1], 0)) base = "middle";
		else if (vector[1] > 0) base = "top";
		else if (vector[1] < 0) base = "bottom";
		return base;
	};
	AxisBase$1.prototype.processOverlap = function(labelGroup) {};
	AxisBase$1.prototype.drawLine = function(group$1) {
		var path = this.getLinePath();
		var line$1 = this.get("line");
		this.addShape(group$1, {
			type: "path",
			id: this.getElementId("line"),
			name: "axis-line",
			attrs: mix({ path }, line$1.style)
		});
	};
	AxisBase$1.prototype.getTickLineItems = function(ticks) {
		var _this = this;
		var tickLineItems = [];
		var tickLine = this.get("tickLine");
		var alignTick = tickLine.alignTick;
		var tickLineLength = tickLine.length;
		var tickSegment = 1;
		if (ticks.length >= 2) tickSegment = ticks[1].value - ticks[0].value;
		each_default(ticks, function(tick) {
			var point$1 = tick.point;
			if (!alignTick) point$1 = _this.getTickPoint(tick.value - tickSegment / 2);
			var endPoint = _this.getSidePoint(point$1, tickLineLength);
			tickLineItems.push({
				startPoint: point$1,
				tickValue: tick.value,
				endPoint,
				tickId: tick.id,
				id: "tickline-" + tick.id
			});
		});
		return tickLineItems;
	};
	AxisBase$1.prototype.getSubTickLineItems = function(tickLineItems) {
		var subTickLineItems = [];
		var subTickLine = this.get("subTickLine");
		var subCount = subTickLine.count;
		var tickLineCount = tickLineItems.length;
		if (tickLineCount >= 2) for (var i = 0; i < tickLineCount - 1; i++) {
			var pre = tickLineItems[i];
			var next = tickLineItems[i + 1];
			for (var j = 0; j < subCount; j++) {
				var percent$1 = (j + 1) / (subCount + 1);
				var tickValue = (1 - percent$1) * pre.tickValue + percent$1 * next.tickValue;
				var point$1 = this.getTickPoint(tickValue);
				var endPoint = this.getSidePoint(point$1, subTickLine.length);
				subTickLineItems.push({
					startPoint: point$1,
					endPoint,
					tickValue,
					id: "sub-" + pre.id + "-" + j
				});
			}
		}
		return subTickLineItems;
	};
	AxisBase$1.prototype.getTickLineAttrs = function(tickItem, type, index, tickItems) {
		var style = this.get(type).style;
		var item = { points: [tickItem.startPoint, tickItem.endPoint] };
		var defaultTickLineStyle = get_default(this.get("theme"), ["tickLine", "style"], {});
		style = is_function_default(style) ? mix({}, defaultTickLineStyle, style(item, index, tickItems)) : style;
		var startPoint = tickItem.startPoint, endPoint = tickItem.endPoint;
		return __assign({
			x1: startPoint.x,
			y1: startPoint.y,
			x2: endPoint.x,
			y2: endPoint.y
		}, style);
	};
	AxisBase$1.prototype.drawTick = function(tickItem, tickLineGroup, type, index, tickItems) {
		this.addShape(tickLineGroup, {
			type: "line",
			id: this.getElementId(tickItem.id),
			name: "axis-" + type,
			attrs: this.getTickLineAttrs(tickItem, type, index, tickItems)
		});
	};
	AxisBase$1.prototype.drawTickLines = function(group$1) {
		var _this = this;
		var ticks = this.get("ticks");
		var subTickLine = this.get("subTickLine");
		var tickLineItems = this.getTickLineItems(ticks);
		var tickLineGroup = this.addGroup(group$1, {
			name: "axis-tickline-group",
			id: this.getElementId("tickline-group")
		});
		var tickCfg = this.get("tickLine");
		each_default(tickLineItems, function(item, index) {
			if (tickCfg.displayWithLabel) {
				var labelId = _this.getElementId("label-" + item.tickId);
				if (group$1.findById(labelId)) _this.drawTick(item, tickLineGroup, "tickLine", index, tickLineItems);
			} else _this.drawTick(item, tickLineGroup, "tickLine", index, tickLineItems);
		});
		if (subTickLine) {
			var subTickLineItems_1 = this.getSubTickLineItems(tickLineItems);
			each_default(subTickLineItems_1, function(item, index) {
				_this.drawTick(item, tickLineGroup, "subTickLine", index, subTickLineItems_1);
			});
		}
	};
	AxisBase$1.prototype.processTicks = function() {
		var _this = this;
		var ticks = this.get("ticks");
		each_default(ticks, function(tick) {
			tick.point = _this.getTickPoint(tick.value);
			if (is_nil_default(tick.id)) tick.id = tick.name;
		});
	};
	AxisBase$1.prototype.drawTicks = function(group$1) {
		var _this = this;
		this.optimizeTicks();
		this.processTicks();
		if (this.get("label")) this.drawLabels(group$1);
		if (this.get("tickLine")) this.drawTickLines(group$1);
		var ticks = this.get("ticks");
		each_default(ticks, function(tick) {
			_this.applyTickStates(tick, group$1);
		});
	};
	/**
	* 根据 optimize 配置对 ticks 进行抽样，对抽样过后的 ticks 才进行真实的渲染
	*/
	AxisBase$1.prototype.optimizeTicks = function() {
		var optimize = this.get("optimize");
		var ticks = this.get("ticks");
		if (optimize && optimize.enable && optimize.threshold > 0) {
			var len = size(ticks);
			if (len > optimize.threshold) {
				var page_1 = Math.ceil(len / optimize.threshold);
				var optimizedTicks = ticks.filter(function(tick, idx) {
					return idx % page_1 === 0;
				});
				this.set("ticks", optimizedTicks);
				this.set("originalTicks", ticks);
			}
		}
	};
	AxisBase$1.prototype.getLabelAttrs = function(tick, index, ticks) {
		var labelCfg = this.get("label");
		var offset = labelCfg.offset, offsetX = labelCfg.offsetX, offsetY = labelCfg.offsetY, rotate$2 = labelCfg.rotate, formatter = labelCfg.formatter;
		var point$1 = this.getSidePoint(tick.point, offset);
		var vector = this.getSideVector(offset, point$1);
		var text = formatter ? formatter(tick.name, tick, index) : tick.name;
		var style = labelCfg.style;
		style = is_function_default(style) ? get_default(this.get("theme"), ["label", "style"], {}) : style;
		var attrs = mix({
			x: point$1.x + offsetX,
			y: point$1.y + offsetY,
			text,
			textAlign: this.getTextAnchor(vector),
			textBaseline: this.getTextBaseline(vector)
		}, style);
		if (rotate$2) attrs.matrix = getMatrixByAngle(point$1, rotate$2);
		return attrs;
	};
	AxisBase$1.prototype.drawLabels = function(group$1) {
		var _this = this;
		var ticks = this.get("ticks");
		var labelGroup = this.addGroup(group$1, {
			name: "axis-label-group",
			id: this.getElementId("label-group")
		});
		each_default(ticks, function(tick, index) {
			_this.addShape(labelGroup, {
				type: "text",
				name: "axis-label",
				id: _this.getElementId("label-" + tick.id),
				attrs: _this.getLabelAttrs(tick, index, ticks),
				delegateObject: {
					tick,
					item: tick,
					index
				}
			});
		});
		this.processOverlap(labelGroup);
		var labels = labelGroup.getChildren();
		var defaultLabelStyle = get_default(this.get("theme"), ["label", "style"], {});
		var _a$5 = this.get("label"), style = _a$5.style, formatter = _a$5.formatter;
		if (is_function_default(style)) {
			var afterProcessTicks_1 = labels.map(function(label$16) {
				return get_default(label$16.get("delegateObject"), "tick");
			});
			each_default(labels, function(label$16, index) {
				var tick = label$16.get("delegateObject").tick;
				var text = formatter ? formatter(tick.name, tick, index) : tick.name;
				var newStyle = mix({}, defaultLabelStyle, style(text, index, afterProcessTicks_1));
				label$16.attr(newStyle);
			});
		}
	};
	AxisBase$1.prototype.getTitleAttrs = function() {
		var titleCfg = this.get("title");
		var style = titleCfg.style, position = titleCfg.position, offset = titleCfg.offset, _a$5 = titleCfg.spacing, spacing = _a$5 === void 0 ? 0 : _a$5, autoRotate = titleCfg.autoRotate;
		var titleHeight = style.fontSize;
		var percent$1 = .5;
		if (position === "start") percent$1 = 0;
		else if (position === "end") percent$1 = 1;
		var point$1 = this.getTickPoint(percent$1);
		var titlePoint = this.getSidePoint(point$1, offset || spacing + titleHeight / 2);
		var attrs = mix({
			x: titlePoint.x,
			y: titlePoint.y,
			text: titleCfg.text
		}, style);
		var rotate$2 = titleCfg.rotate;
		var angle$1 = rotate$2;
		if (is_nil_default(rotate$2) && autoRotate) {
			var vector = this.getAxisVector(point$1);
			angle$1 = angleTo(vector, [1, 0], true);
		}
		if (angle$1) attrs.matrix = getMatrixByAngle(titlePoint, angle$1);
		return attrs;
	};
	AxisBase$1.prototype.drawTitle = function(group$1) {
		var _a$5;
		var titleAttrs = this.getTitleAttrs();
		var titleShape = this.addShape(group$1, {
			type: "text",
			id: this.getElementId("title"),
			name: "axis-title",
			attrs: titleAttrs
		});
		if ((_a$5 = this.get("title")) === null || _a$5 === void 0 ? void 0 : _a$5.description) this.drawDescriptionIcon(group$1, titleShape, titleAttrs.matrix);
	};
	AxisBase$1.prototype.drawDescriptionIcon = function(group$1, titleShape, matrix) {
		var descriptionShape = this.addGroup(group$1, {
			name: "axis-description",
			id: this.getElementById("description")
		});
		var _a$5 = titleShape.getBBox(), maxX = _a$5.maxX, maxY$1 = _a$5.maxY, height = _a$5.height;
		var iconStyle = this.get("title").iconStyle;
		var spacing = 4;
		var r = height / 2;
		var lineWidth = r / 6;
		var startX = maxX + spacing;
		var startY = maxY$1 - height / 2;
		var _b = [startX + r, startY - r], x0 = _b[0], y0 = _b[1];
		var _c = [x0 + r, y0 + r], x1 = _c[0], y1 = _c[1];
		var _d = [x0, y1 + r], x2 = _d[0], y2 = _d[1];
		var _e = [startX, y0 + r], x3 = _e[0], y3 = _e[1];
		var _f = [startX + r, startY - height / 4], x4 = _f[0], y4 = _f[1];
		var _g = [x4, y4 + lineWidth], x5 = _g[0], y5 = _g[1];
		var _h = [x5, y5 + lineWidth], x6 = _h[0], y6 = _h[1];
		var _j = [x6, y6 + r * 3 / 4], x7 = _j[0], y7 = _j[1];
		this.addShape(descriptionShape, {
			type: "path",
			id: this.getElementId("title-description-icon"),
			name: "axis-title-description-icon",
			attrs: __assign({
				path: [
					[
						"M",
						x0,
						y0
					],
					[
						"A",
						r,
						r,
						0,
						0,
						1,
						x1,
						y1
					],
					[
						"A",
						r,
						r,
						0,
						0,
						1,
						x2,
						y2
					],
					[
						"A",
						r,
						r,
						0,
						0,
						1,
						x3,
						y3
					],
					[
						"A",
						r,
						r,
						0,
						0,
						1,
						x0,
						y0
					],
					[
						"M",
						x4,
						y4
					],
					[
						"L",
						x5,
						y5
					],
					[
						"M",
						x6,
						y6
					],
					[
						"L",
						x7,
						y7
					]
				],
				lineWidth,
				matrix
			}, iconStyle)
		});
		this.addShape(descriptionShape, {
			type: "rect",
			id: this.getElementId("title-description-rect"),
			name: "axis-title-description-rect",
			attrs: {
				x: startX,
				y: startY - height / 2,
				width: height,
				height,
				stroke: "#000",
				fill: "#000",
				opacity: 0,
				matrix,
				cursor: "pointer"
			}
		});
	};
	AxisBase$1.prototype.applyTickStates = function(tick, group$1) {
		if (this.getItemStates(tick).length) {
			var tickStates = this.get("tickStates");
			var labelId = this.getElementId("label-" + tick.id);
			var labelShape = group$1.findById(labelId);
			if (labelShape) {
				var labelStateStyle = getStatesStyle(tick, "label", tickStates);
				labelStateStyle && labelShape.attr(labelStateStyle);
			}
			var tickLineId = this.getElementId("tickline-" + tick.id);
			var tickLineShape = group$1.findById(tickLineId);
			if (tickLineShape) {
				var tickLineStateStyle = getStatesStyle(tick, "tickLine", tickStates);
				tickLineStateStyle && tickLineShape.attr(tickLineStateStyle);
			}
		}
	};
	AxisBase$1.prototype.updateTickStates = function(tick) {
		var states = this.getItemStates(tick);
		var tickStates = this.get("tickStates");
		var labelCfg = this.get("label");
		var labelShape = this.getElementByLocalId("label-" + tick.id);
		var tickLineCfg = this.get("tickLine");
		var tickLineShape = this.getElementByLocalId("tickline-" + tick.id);
		if (states.length) {
			if (labelShape) {
				var labelStateStyle = getStatesStyle(tick, "label", tickStates);
				labelStateStyle && labelShape.attr(labelStateStyle);
			}
			if (tickLineShape) {
				var tickLineStateStyle = getStatesStyle(tick, "tickLine", tickStates);
				tickLineStateStyle && tickLineShape.attr(tickLineStateStyle);
			}
		} else {
			if (labelShape) labelShape.attr(labelCfg.style);
			if (tickLineShape) tickLineShape.attr(tickLineCfg.style);
		}
	};
	return AxisBase$1;
}(group_component_default);
var base_default$14 = AxisBase;

//#endregion
//#region node_modules/@antv/component/esm/axis/overlap/auto-ellipsis.js
var auto_ellipsis_exports = /* @__PURE__ */ __export({
	ellipsisHead: () => ellipsisHead,
	ellipsisMiddle: () => ellipsisMiddle,
	ellipsisTail: () => ellipsisTail,
	getDefault: () => getDefault$2
});
function ellipseLabels(isVertical$1, labelGroup, limitLength, position) {
	var children = labelGroup.getChildren();
	var ellipsisFlag = false;
	each_default(children, function(label$16) {
		var rst = ellipsisLabel(isVertical$1, label$16, limitLength, position);
		ellipsisFlag = ellipsisFlag || rst;
	});
	return ellipsisFlag;
}
function getDefault$2() {
	return ellipsisTail;
}
function ellipsisHead(isVertical$1, labelGroup, limitLength) {
	return ellipseLabels(isVertical$1, labelGroup, limitLength, "head");
}
function ellipsisTail(isVertical$1, labelGroup, limitLength) {
	return ellipseLabels(isVertical$1, labelGroup, limitLength, "tail");
}
function ellipsisMiddle(isVertical$1, labelGroup, limitLength) {
	return ellipseLabels(isVertical$1, labelGroup, limitLength, "middle");
}

//#endregion
//#region node_modules/@antv/component/esm/axis/overlap/auto-hide.js
var auto_hide_exports = /* @__PURE__ */ __export({
	equidistance: () => equidistance,
	equidistanceWithReverseBoth: () => equidistanceWithReverseBoth,
	getDefault: () => getDefault$1,
	reserveBoth: () => reserveBoth,
	reserveFirst: () => reserveFirst,
	reserveLast: () => reserveLast
});
function isRotate(label$16) {
	var matrix = label$16.attr("matrix");
	return matrix && matrix[0] !== 1;
}
function getRotateAngle(label$16) {
	return (isRotate(label$16) ? getAngleByMatrix(label$16.attr("matrix")) : 0) % 360;
}
function isOverlap(isVertical$1, first, second, minGap) {
	var overlap$1 = false;
	var angle$1 = getRotateAngle(first);
	var distance$7 = isVertical$1 ? Math.abs(second.attr("y") - first.attr("y")) : Math.abs(second.attr("x") - first.attr("x"));
	var prevBBox = (isVertical$1 ? second.attr("y") > first.attr("y") : second.attr("x") > first.attr("x")) ? first.getBBox() : second.getBBox();
	if (isVertical$1) {
		var ratio = Math.abs(Math.cos(angle$1));
		if (near(ratio, 0, Math.PI / 180)) overlap$1 = prevBBox.width + minGap > distance$7;
		else overlap$1 = prevBBox.height / ratio + minGap > distance$7;
	} else {
		var ratio = Math.abs(Math.sin(angle$1));
		if (near(ratio, 0, Math.PI / 180)) overlap$1 = prevBBox.width + minGap > distance$7;
		else overlap$1 = prevBBox.height / ratio + minGap > distance$7;
	}
	return overlap$1;
}
function reserveOne(isVertical$1, labelsGroup, reversed, autoHideCfg) {
	var minGap = (autoHideCfg === null || autoHideCfg === void 0 ? void 0 : autoHideCfg.minGap) || 0;
	var labels = labelsGroup.getChildren().slice().filter(function(item) {
		return item.get("visible");
	});
	if (!labels.length) return false;
	var hasHide = false;
	if (reversed) labels.reverse();
	var count$1 = labels.length;
	var prev = labels[0];
	for (var i = 1; i < count$1; i++) {
		var label$16 = labels[i];
		label$16.getBBox();
		if (isOverlap(isVertical$1, prev, label$16, minGap)) {
			label$16.hide();
			hasHide = true;
		} else prev = label$16;
	}
	return hasHide;
}
function parityHide(isVertical$1, labelsGroup, autoHideCfg) {
	var minGap = (autoHideCfg === null || autoHideCfg === void 0 ? void 0 : autoHideCfg.minGap) || 0;
	var labels = labelsGroup.getChildren().slice();
	if (labels.length < 2) return false;
	var hasHide = false;
	var first = labels[0];
	var firstBBox = first.getBBox();
	var second = labels[1];
	var count$1 = labels.length;
	var angle$1 = getRotateAngle(first);
	var distance$7 = isVertical$1 ? Math.abs(second.attr("y") - first.attr("y")) : Math.abs(second.attr("x") - first.attr("x"));
	var interval$2 = 0;
	if (isVertical$1) {
		var ratio = Math.abs(Math.cos(angle$1));
		if (near(ratio, 0, Math.PI / 180)) {
			var maxWidth = getMaxLabelWidth(labels);
			interval$2 = (maxWidth + minGap) / distance$7;
		} else interval$2 = (firstBBox.height / ratio + minGap) / distance$7;
	} else {
		var ratio = Math.abs(Math.sin(angle$1));
		if (near(ratio, 0, Math.PI / 180)) {
			var maxWidth = getMaxLabelWidth(labels);
			interval$2 = (maxWidth + minGap) / distance$7;
		} else interval$2 = (firstBBox.height / ratio + minGap) / distance$7;
	}
	if (interval$2 > 1) {
		interval$2 = Math.ceil(interval$2);
		for (var i = 0; i < count$1; i++) if (i % interval$2 !== 0) {
			labels[i].hide();
			hasHide = true;
		}
	}
	return hasHide;
}
function getDefault$1() {
	return equidistance;
}
/**
* 保证首个 label 可见，即使超过 limitLength 也不隐藏
* @param {boolean} isVertical  是否垂直
* @param {IGroup}  labelsGroup label 的分组
* @param {number} limitLength 另一个方向的长度限制，autoHide 不关心
* @param {AxisLabelAutoHideCfg} autoHideCfg autoHide overlap 的可选配置参数
*/
function reserveFirst(isVertical$1, labelsGroup, limitLength, autoHideCfg) {
	return reserveOne(isVertical$1, labelsGroup, false, autoHideCfg);
}
/**
* 保证最后一个 label 可见，即使超过 limitLength 也不隐藏
* @param {boolean} isVertical  是否垂直
* @param {IGroup}  labelsGroup label 的分组
* @param {number} limitLength 另一个方向的长度限制，autoHide 不关心
* @param {AxisLabelAutoHideCfg} autoHideCfg autoHide overlap 的可选配置参数
*/
function reserveLast(isVertical$1, labelsGroup, limitLength, autoHideCfg) {
	return reserveOne(isVertical$1, labelsGroup, true, autoHideCfg);
}
/**
* 保证第一个最后一个 label 可见，即使超过 limitLength 也不隐藏
* @param {boolean} isVertical  是否垂直
* @param {IGroup}  labelsGroup label 的分组
* @param {number} limitLength 另一个方向的长度限制，autoHide 不关心
* @param {AxisLabelAutoHideCfg} autoHideCfg autoHide overlap 的可选配置参数
*/
function reserveBoth(isVertical$1, labelsGroup, limitLength, autoHideCfg) {
	var minGap = (autoHideCfg === null || autoHideCfg === void 0 ? void 0 : autoHideCfg.minGap) || 0;
	var labels = labelsGroup.getChildren().slice();
	if (labels.length <= 2) return false;
	var hasHide = false;
	var count$1 = labels.length;
	var first = labels[0];
	var last$1 = labels[count$1 - 1];
	var preLabel = first;
	for (var i = 1; i < count$1 - 1; i++) {
		var label$16 = labels[i];
		label$16.getBBox();
		if (isOverlap(isVertical$1, preLabel, label$16, minGap)) {
			label$16.hide();
			hasHide = true;
		} else preLabel = label$16;
	}
	if (isOverlap(isVertical$1, preLabel, last$1, minGap)) {
		preLabel.hide();
		hasHide = true;
	}
	return hasHide;
}
/**
* 保证 label 均匀显示 和 不出现重叠，主要解决文本层叠的问题，对于 limitLength 不处理
* @param {boolean} isVertical  是否垂直
* @param {IGroup}  labelsGroup label 的分组
* @param {number} limitLength 另一个方向的长度限制，autoHide 不关心
* @param {AxisLabelAutoHideCfg} autoHideCfg autoHide overlap 的可选配置参数
*/
function equidistance(isVertical$1, labelsGroup, limitLength, autoHideCfg) {
	var hasHide = parityHide(isVertical$1, labelsGroup, autoHideCfg);
	if (reserveOne(isVertical$1, labelsGroup, false)) hasHide = true;
	return hasHide;
}
/**
* 同 equidistance， 首先会保证 labels 均匀显示，然后会保留首尾
* @param isVertical
* @param labelsGroup
* @param {number} limitLength 另一个方向的长度限制，autoHide 不关心
* @param {AxisLabelAutoHideCfg} autoHideCfg autoHide overlap 的可选配置参数
*/
function equidistanceWithReverseBoth(isVertical$1, labelsGroup, limitLength, autoHideCfg) {
	var labels = labelsGroup.getChildren().slice();
	var hasHide = parityHide(isVertical$1, labelsGroup, autoHideCfg);
	if (labels.length > 2) {
		var first = labels[0];
		var last$1 = labels[labels.length - 1];
		if (!first.get("visible")) {
			first.show();
			if (reserveOne(isVertical$1, labelsGroup, false, autoHideCfg)) hasHide = true;
		}
		if (!last$1.get("visible")) {
			last$1.show();
			if (reserveOne(isVertical$1, labelsGroup, true, autoHideCfg)) hasHide = true;
		}
	}
	return hasHide;
}

//#endregion
//#region node_modules/@antv/component/esm/axis/overlap/auto-rotate.js
var auto_rotate_exports = /* @__PURE__ */ __export({
	fixedAngle: () => fixedAngle,
	getDefault: () => getDefault,
	unfixedAngle: () => unfixedAngle
});
function setLabelsAngle(labels, angle$1) {
	each_default(labels, function(label$16) {
		var x = label$16.attr("x");
		var y = label$16.attr("y");
		var matrix = getMatrixByAngle({
			x,
			y
		}, angle$1);
		label$16.attr("matrix", matrix);
	});
}
function labelRotate(isVertical$1, labelsGroup, limitLength, getAngle$3) {
	var labels = labelsGroup.getChildren();
	if (!labels.length) return false;
	if (!isVertical$1 && labels.length < 2) return false;
	var maxWidth = getMaxLabelWidth(labels);
	var isOverlap$1 = false;
	if (isVertical$1) isOverlap$1 = !!limitLength && maxWidth > limitLength;
	else {
		var tickWidth = Math.abs(labels[1].attr("x") - labels[0].attr("x"));
		isOverlap$1 = maxWidth > tickWidth;
	}
	if (isOverlap$1) {
		var angle$1 = getAngle$3(limitLength, maxWidth);
		setLabelsAngle(labels, angle$1);
	}
	return isOverlap$1;
}
function getDefault() {
	return fixedAngle;
}
/**
* 固定角度旋转文本
* @param  {boolean} isVertical  是否垂直方向
* @param  {IGroup}  labelsGroup 文本的 group
* @param  {number}  limitLength 限定长度
* @param  {number}  customRotate 自定义旋转角度
* @return {boolean}             是否发生了旋转
*/
function fixedAngle(isVertical$1, labelsGroup, limitLength, customRotate) {
	return labelRotate(isVertical$1, labelsGroup, limitLength, function() {
		if (is_number_default(customRotate)) return customRotate;
		return isVertical$1 ? theme_default.verticalAxisRotate : theme_default.horizontalAxisRotate;
	});
}
/**
* 非固定角度旋转文本
* @param  {boolean} isVertical  是否垂直方向
* @param  {IGroup}  labelsGroup 文本的 group
* @param  {number}  limitLength 限定长度
* @return {boolean}             是否发生了旋转
*/
function unfixedAngle(isVertical$1, labelsGroup, limitLength) {
	return labelRotate(isVertical$1, labelsGroup, limitLength, function(length$1, maxWidth) {
		if (!length$1) return isVertical$1 ? theme_default.verticalAxisRotate : theme_default.horizontalAxisRotate;
		if (isVertical$1) return -Math.acos(length$1 / maxWidth);
		else {
			var angle$1 = 0;
			if (length$1 > maxWidth) angle$1 = Math.PI / 4;
			else {
				angle$1 = Math.asin(length$1 / maxWidth);
				if (angle$1 > Math.PI / 4) angle$1 = Math.PI / 4;
			}
			return angle$1;
		}
	});
}

//#endregion
//#region node_modules/@antv/component/esm/axis/overlap/index.js
var overlap_exports = /* @__PURE__ */ __export({
	autoEllipsis: () => auto_ellipsis_exports,
	autoHide: () => auto_hide_exports,
	autoRotate: () => auto_rotate_exports
});

//#endregion
//#region node_modules/@antv/component/esm/axis/line.js
var Line$5 = function(_super) {
	__extends(Line$6, _super);
	function Line$6() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	Line$6.prototype.getDefaultCfg = function() {
		var cfg = _super.prototype.getDefaultCfg.call(this);
		return __assign(__assign({}, cfg), {
			type: "line",
			locationType: "region",
			start: null,
			end: null
		});
	};
	Line$6.prototype.getLinePath = function() {
		var start = this.get("start");
		var end = this.get("end");
		var path = [];
		path.push([
			"M",
			start.x,
			start.y
		]);
		path.push([
			"L",
			end.x,
			end.y
		]);
		return path;
	};
	Line$6.prototype.getInnerLayoutBBox = function() {
		var start = this.get("start");
		var end = this.get("end");
		var bbox = _super.prototype.getInnerLayoutBBox.call(this);
		var minX = Math.min(start.x, end.x, bbox.x);
		var minY = Math.min(start.y, end.y, bbox.y);
		var maxX = Math.max(start.x, end.x, bbox.maxX);
		var maxY$1 = Math.max(start.y, end.y, bbox.maxY);
		return {
			x: minX,
			y: minY,
			minX,
			minY,
			maxX,
			maxY: maxY$1,
			width: maxX - minX,
			height: maxY$1 - minY
		};
	};
	Line$6.prototype.isVertical = function() {
		var start = this.get("start");
		var end = this.get("end");
		return isNumberEqual(start.x, end.x);
	};
	Line$6.prototype.isHorizontal = function() {
		var start = this.get("start");
		var end = this.get("end");
		return isNumberEqual(start.y, end.y);
	};
	Line$6.prototype.getTickPoint = function(tickValue) {
		var self$3 = this;
		var start = self$3.get("start");
		var end = self$3.get("end");
		var regionX = end.x - start.x;
		var regionY = end.y - start.y;
		return {
			x: start.x + regionX * tickValue,
			y: start.y + regionY * tickValue
		};
	};
	Line$6.prototype.getSideVector = function(offset) {
		var axisVector = this.getAxisVector();
		var normal = normalize([0, 0], axisVector);
		var factor = this.get("verticalFactor");
		var verticalVector = [normal[1], normal[0] * -1];
		return scale$3([0, 0], verticalVector, offset * factor);
	};
	Line$6.prototype.getAxisVector = function() {
		var start = this.get("start");
		var end = this.get("end");
		return [end.x - start.x, end.y - start.y];
	};
	Line$6.prototype.processOverlap = function(labelGroup) {
		var _this = this;
		var isVertical$1 = this.isVertical();
		var isHorizontal$1 = this.isHorizontal();
		if (!isVertical$1 && !isHorizontal$1) return;
		var labelCfg = this.get("label");
		var titleCfg = this.get("title");
		var verticalLimitLength = this.get("verticalLimitLength");
		var labelOffset = labelCfg.offset;
		var limitLength = verticalLimitLength;
		var titleHeight = 0;
		var titleSpacing = 0;
		if (titleCfg) {
			titleHeight = titleCfg.style.fontSize;
			titleSpacing = titleCfg.spacing;
		}
		if (limitLength) limitLength = limitLength - labelOffset - titleSpacing - titleHeight;
		var overlapOrder = this.get("overlapOrder");
		each_default(overlapOrder, function(name) {
			if (labelCfg[name] && _this.canProcessOverlap(name)) _this.autoProcessOverlap(name, labelCfg[name], labelGroup, limitLength);
		});
		if (titleCfg) {
			if (is_nil_default(titleCfg.offset)) {
				var bbox = labelGroup.getCanvasBBox();
				var length_1 = isVertical$1 ? bbox.width : bbox.height;
				titleCfg.offset = labelOffset + length_1 + titleSpacing + titleHeight / 2;
			}
		}
	};
	/**
	* 是否可以执行某一 overlap
	* @param name
	*/
	Line$6.prototype.canProcessOverlap = function(name) {
		var labelCfg = this.get("label");
		if (name === "autoRotate") return is_nil_default(labelCfg.rotate);
		return true;
	};
	Line$6.prototype.autoProcessOverlap = function(name, value$1, labelGroup, limitLength) {
		var _this = this;
		var isVertical$1 = this.isVertical();
		var hasAdjusted = false;
		var util = overlap_exports[name];
		if (value$1 === true) {
			this.get("label");
			hasAdjusted = util.getDefault()(isVertical$1, labelGroup, limitLength);
		} else if (is_function_default(value$1)) hasAdjusted = value$1(isVertical$1, labelGroup, limitLength);
		else if (is_object_default(value$1)) {
			var overlapCfg = value$1;
			if (util[overlapCfg.type]) hasAdjusted = util[overlapCfg.type](isVertical$1, labelGroup, limitLength, overlapCfg.cfg);
		} else if (util[value$1]) hasAdjusted = util[value$1](isVertical$1, labelGroup, limitLength);
		if (name === "autoRotate") {
			if (hasAdjusted) {
				var labels = labelGroup.getChildren();
				var verticalFactor_1 = this.get("verticalFactor");
				each_default(labels, function(label$16) {
					if (label$16.attr("textAlign") === "center") {
						var newAlign = verticalFactor_1 > 0 ? "end" : "start";
						label$16.attr("textAlign", newAlign);
					}
				});
			}
		} else if (name === "autoHide") {
			var children = labelGroup.getChildren().slice(0);
			each_default(children, function(label$16) {
				if (!label$16.get("visible")) {
					if (_this.get("isRegister")) _this.unregisterElement(label$16);
					label$16.remove();
				}
			});
		}
	};
	return Line$6;
}(base_default$14);
var line_default$6 = Line$5;

//#endregion
//#region node_modules/@antv/component/esm/axis/circle.js
var Circle$4 = function(_super) {
	__extends(Circle$5, _super);
	function Circle$5() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	Circle$5.prototype.getDefaultCfg = function() {
		var cfg = _super.prototype.getDefaultCfg.call(this);
		return __assign(__assign({}, cfg), {
			type: "circle",
			locationType: "circle",
			center: null,
			radius: null,
			startAngle: -Math.PI / 2,
			endAngle: Math.PI * 3 / 2
		});
	};
	Circle$5.prototype.getLinePath = function() {
		var center$1 = this.get("center");
		var x = center$1.x;
		var y = center$1.y;
		var rx = this.get("radius");
		var ry = rx;
		var startAngle = this.get("startAngle");
		var endAngle = this.get("endAngle");
		var path = [];
		if (Math.abs(endAngle - startAngle) === Math.PI * 2) path = [
			[
				"M",
				x,
				y - ry
			],
			[
				"A",
				rx,
				ry,
				0,
				1,
				1,
				x,
				y + ry
			],
			[
				"A",
				rx,
				ry,
				0,
				1,
				1,
				x,
				y - ry
			],
			["Z"]
		];
		else {
			var startPoint = this.getCirclePoint(startAngle);
			var endPoint = this.getCirclePoint(endAngle);
			var large = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;
			var sweep = startAngle > endAngle ? 0 : 1;
			path = [
				[
					"M",
					x,
					y
				],
				[
					"L",
					startPoint.x,
					startPoint.y
				],
				[
					"A",
					rx,
					ry,
					0,
					large,
					sweep,
					endPoint.x,
					endPoint.y
				],
				[
					"L",
					x,
					y
				]
			];
		}
		return path;
	};
	Circle$5.prototype.getTickPoint = function(tickValue) {
		var startAngle = this.get("startAngle");
		var endAngle = this.get("endAngle");
		var angle$1 = startAngle + (endAngle - startAngle) * tickValue;
		return this.getCirclePoint(angle$1);
	};
	Circle$5.prototype.getSideVector = function(offset, point$1) {
		var center$1 = this.get("center");
		var vector = [point$1.x - center$1.x, point$1.y - center$1.y];
		var factor = this.get("verticalFactor");
		var vecLen = length(vector);
		scale$3(vector, vector, factor * offset / vecLen);
		return vector;
	};
	Circle$5.prototype.getAxisVector = function(point$1) {
		var center$1 = this.get("center");
		var vector = [point$1.x - center$1.x, point$1.y - center$1.y];
		return [vector[1], -1 * vector[0]];
	};
	Circle$5.prototype.getCirclePoint = function(angle$1, radius) {
		var center$1 = this.get("center");
		radius = radius || this.get("radius");
		return {
			x: center$1.x + Math.cos(angle$1) * radius,
			y: center$1.y + Math.sin(angle$1) * radius
		};
	};
	/**
	* 是否可以执行某一 overlap
	* @param name
	*/
	Circle$5.prototype.canProcessOverlap = function(name) {
		var labelCfg = this.get("label");
		if (name === "autoRotate") return is_nil_default(labelCfg.rotate);
		return true;
	};
	Circle$5.prototype.processOverlap = function(labelGroup) {
		var _this = this;
		var labelCfg = this.get("label");
		var titleCfg = this.get("title");
		var verticalLimitLength = this.get("verticalLimitLength");
		var labelOffset = labelCfg.offset;
		var limitLength = verticalLimitLength;
		var titleHeight = 0;
		var titleSpacing = 0;
		if (titleCfg) {
			titleHeight = titleCfg.style.fontSize;
			titleSpacing = titleCfg.spacing;
		}
		if (limitLength) limitLength = limitLength - labelOffset - titleSpacing - titleHeight;
		var overlapOrder = this.get("overlapOrder");
		each_default(overlapOrder, function(name) {
			if (labelCfg[name] && _this.canProcessOverlap(name)) _this.autoProcessOverlap(name, labelCfg[name], labelGroup, limitLength);
		});
		if (titleCfg) {
			if (is_nil_default(titleCfg.offset)) {
				var length_1 = labelGroup.getCanvasBBox().height;
				titleCfg.offset = labelOffset + length_1 + titleSpacing + titleHeight / 2;
			}
		}
	};
	Circle$5.prototype.autoProcessOverlap = function(name, value$1, labelGroup, limitLength) {
		var _this = this;
		var hasAdjusted = false;
		var util = overlap_exports[name];
		if (limitLength > 0) {
			if (value$1 === true) hasAdjusted = util.getDefault()(false, labelGroup, limitLength);
			else if (is_function_default(value$1)) hasAdjusted = value$1(false, labelGroup, limitLength);
			else if (is_object_default(value$1)) {
				var overlapCfg = value$1;
				if (util[overlapCfg.type]) hasAdjusted = util[overlapCfg.type](false, labelGroup, limitLength, overlapCfg.cfg);
			} else if (util[value$1]) hasAdjusted = util[value$1](false, labelGroup, limitLength);
		}
		if (name === "autoRotate") {
			if (hasAdjusted) {
				var labels = labelGroup.getChildren();
				var verticalFactor_1 = this.get("verticalFactor");
				each_default(labels, function(label$16) {
					if (label$16.attr("textAlign") === "center") {
						var newAlign = verticalFactor_1 > 0 ? "end" : "start";
						label$16.attr("textAlign", newAlign);
					}
				});
			}
		} else if (name === "autoHide") {
			var children = labelGroup.getChildren().slice(0);
			each_default(children, function(label$16) {
				if (!label$16.get("visible")) {
					if (_this.get("isRegister")) _this.unregisterElement(label$16);
					label$16.remove();
				}
			});
		}
	};
	return Circle$5;
}(base_default$14);
var circle_default$7 = Circle$4;

//#endregion
//#region node_modules/@antv/component/esm/crosshair/base.js
var CrosshairBase = function(_super) {
	__extends(CrosshairBase$1, _super);
	function CrosshairBase$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	CrosshairBase$1.prototype.getDefaultCfg = function() {
		var cfg = _super.prototype.getDefaultCfg.call(this);
		return __assign(__assign({}, cfg), {
			name: "crosshair",
			type: "base",
			line: {},
			text: null,
			textBackground: {},
			capture: false,
			defaultCfg: {
				line: { style: {
					lineWidth: 1,
					stroke: theme_default.lineColor
				} },
				text: {
					position: "start",
					offset: 10,
					autoRotate: false,
					content: null,
					style: {
						fill: theme_default.textColor,
						textAlign: "center",
						textBaseline: "middle",
						fontFamily: theme_default.fontFamily
					}
				},
				textBackground: {
					padding: 5,
					style: { stroke: theme_default.lineColor }
				}
			}
		});
	};
	CrosshairBase$1.prototype.renderInner = function(group$1) {
		if (this.get("line")) this.renderLine(group$1);
		if (this.get("text")) {
			this.renderText(group$1);
			this.renderBackground(group$1);
		}
	};
	CrosshairBase$1.prototype.renderText = function(group$1) {
		var text = this.get("text");
		var style = text.style, autoRotate = text.autoRotate, content = text.content;
		if (!is_nil_default(content)) {
			var textPoint = this.getTextPoint();
			var matrix = null;
			if (autoRotate) {
				var angle$1 = this.getRotateAngle();
				matrix = getMatrixByAngle(textPoint, angle$1);
			}
			this.addShape(group$1, {
				type: "text",
				name: "crosshair-text",
				id: this.getElementId("text"),
				attrs: __assign(__assign(__assign({}, textPoint), {
					text: content,
					matrix
				}), style)
			});
		}
	};
	CrosshairBase$1.prototype.renderLine = function(group$1) {
		var path = this.getLinePath();
		var style = this.get("line").style;
		this.addShape(group$1, {
			type: "path",
			name: "crosshair-line",
			id: this.getElementId("line"),
			attrs: __assign({ path }, style)
		});
	};
	CrosshairBase$1.prototype.renderBackground = function(group$1) {
		var textId = this.getElementId("text");
		var textShape = group$1.findById(textId);
		var textBackground = this.get("textBackground");
		if (textBackground && textShape) {
			var textBBox = textShape.getBBox();
			var padding$2 = formatPadding(textBackground.padding);
			var style = textBackground.style;
			this.addShape(group$1, {
				type: "rect",
				name: "crosshair-text-background",
				id: this.getElementId("text-background"),
				attrs: __assign({
					x: textBBox.x - padding$2[3],
					y: textBBox.y - padding$2[0],
					width: textBBox.width + padding$2[1] + padding$2[3],
					height: textBBox.height + padding$2[0] + padding$2[2],
					matrix: textShape.attr("matrix")
				}, style)
			}).toBack();
		}
	};
	return CrosshairBase$1;
}(group_component_default);
var base_default$13 = CrosshairBase;

//#endregion
//#region node_modules/@antv/component/esm/crosshair/line.js
var LineCrosshair$1 = function(_super) {
	__extends(LineCrosshair$2, _super);
	function LineCrosshair$2() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	LineCrosshair$2.prototype.getDefaultCfg = function() {
		var cfg = _super.prototype.getDefaultCfg.call(this);
		return __assign(__assign({}, cfg), {
			type: "line",
			locationType: "region",
			start: null,
			end: null
		});
	};
	LineCrosshair$2.prototype.getRotateAngle = function() {
		var _a$5 = this.getLocation(), start = _a$5.start, end = _a$5.end;
		var position = this.get("text").position;
		var angle$1 = Math.atan2(end.y - start.y, end.x - start.x);
		return position === "start" ? angle$1 - Math.PI / 2 : angle$1 + Math.PI / 2;
	};
	LineCrosshair$2.prototype.getTextPoint = function() {
		var _a$5 = this.getLocation(), start = _a$5.start, end = _a$5.end;
		var _b = this.get("text"), position = _b.position, offset = _b.offset;
		return getTextPoint(start, end, position, offset);
	};
	LineCrosshair$2.prototype.getLinePath = function() {
		var _a$5 = this.getLocation(), start = _a$5.start, end = _a$5.end;
		return [[
			"M",
			start.x,
			start.y
		], [
			"L",
			end.x,
			end.y
		]];
	};
	return LineCrosshair$2;
}(base_default$13);
var line_default$5 = LineCrosshair$1;

//#endregion
//#region node_modules/@antv/component/esm/crosshair/circle.js
var LineCrosshair = function(_super) {
	__extends(LineCrosshair$2, _super);
	function LineCrosshair$2() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	LineCrosshair$2.prototype.getDefaultCfg = function() {
		var cfg = _super.prototype.getDefaultCfg.call(this);
		return __assign(__assign({}, cfg), {
			type: "circle",
			locationType: "circle",
			center: null,
			radius: 100,
			startAngle: -Math.PI / 2,
			endAngle: Math.PI * 3 / 2
		});
	};
	LineCrosshair$2.prototype.getRotateAngle = function() {
		var _a$5 = this.getLocation(), startAngle = _a$5.startAngle, endAngle = _a$5.endAngle;
		return this.get("text").position === "start" ? startAngle + Math.PI / 2 : endAngle - Math.PI / 2;
	};
	LineCrosshair$2.prototype.getTextPoint = function() {
		var text = this.get("text");
		var position = text.position, offset = text.offset;
		var _a$5 = this.getLocation(), center$1 = _a$5.center, radius = _a$5.radius, startAngle = _a$5.startAngle, endAngle = _a$5.endAngle;
		var angle$1 = position === "start" ? startAngle : endAngle;
		var tangentAngle = this.getRotateAngle() - Math.PI;
		var point$1 = getCirclePoint(center$1, radius, angle$1);
		var offsetX = Math.cos(tangentAngle) * offset;
		var offsetY = Math.sin(tangentAngle) * offset;
		return {
			x: point$1.x + offsetX,
			y: point$1.y + offsetY
		};
	};
	LineCrosshair$2.prototype.getLinePath = function() {
		var _a$5 = this.getLocation(), center$1 = _a$5.center, radius = _a$5.radius, startAngle = _a$5.startAngle, endAngle = _a$5.endAngle;
		var path = null;
		if (endAngle - startAngle === Math.PI * 2) {
			var x = center$1.x, y = center$1.y;
			path = [
				[
					"M",
					x,
					y - radius
				],
				[
					"A",
					radius,
					radius,
					0,
					1,
					1,
					x,
					y + radius
				],
				[
					"A",
					radius,
					radius,
					0,
					1,
					1,
					x,
					y - radius
				],
				["Z"]
			];
		} else {
			var startPoint = getCirclePoint(center$1, radius, startAngle);
			var endPoint = getCirclePoint(center$1, radius, endAngle);
			var large = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;
			var sweep = startAngle > endAngle ? 0 : 1;
			path = [[
				"M",
				startPoint.x,
				startPoint.y
			], [
				"A",
				radius,
				radius,
				0,
				large,
				sweep,
				endPoint.x,
				endPoint.y
			]];
		}
		return path;
	};
	return LineCrosshair$2;
}(base_default$13);
var circle_default$6 = LineCrosshair;

//#endregion
//#region node_modules/@antv/component/esm/crosshair/css-const.js
var CONTAINER_CLASS$1 = "g2-crosshair";
var CROSSHAIR_LINE = CONTAINER_CLASS$1 + "-line";
var CROSSHAIR_TEXT = CONTAINER_CLASS$1 + "-text";

//#endregion
//#region node_modules/@antv/component/esm/crosshair/html-theme.js
var _a$4;
var html_theme_default$1 = (_a$4 = {}, _a$4["" + CONTAINER_CLASS$1] = { position: "relative" }, _a$4["" + CROSSHAIR_LINE] = {
	position: "absolute",
	backgroundColor: "rgba(0, 0, 0, 0.25)"
}, _a$4["" + CROSSHAIR_TEXT] = {
	position: "absolute",
	color: theme_default.textColor,
	fontFamily: theme_default.fontFamily
}, _a$4);

//#endregion
//#region node_modules/@antv/component/esm/crosshair/html.js
var HtmlCrosshair = function(_super) {
	__extends(HtmlCrosshair$1, _super);
	function HtmlCrosshair$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	HtmlCrosshair$1.prototype.getDefaultCfg = function() {
		var cfg = _super.prototype.getDefaultCfg.call(this);
		return __assign(__assign({}, cfg), {
			name: "crosshair",
			type: "html",
			locationType: "region",
			start: {
				x: 0,
				y: 0
			},
			end: {
				x: 0,
				y: 0
			},
			capture: false,
			text: null,
			containerTpl: "<div class=\"" + CONTAINER_CLASS$1 + "\"></div>",
			crosshairTpl: "<div class=\"" + CROSSHAIR_LINE + "\"></div>",
			textTpl: "<span class=\"" + CROSSHAIR_TEXT + "\">{content}</span>",
			domStyles: null,
			containerClassName: CONTAINER_CLASS$1,
			defaultStyles: html_theme_default$1,
			defaultCfg: { text: {
				position: "start",
				content: null,
				align: "center",
				offset: 10
			} }
		});
	};
	HtmlCrosshair$1.prototype.render = function() {
		this.resetText();
		this.resetPosition();
	};
	HtmlCrosshair$1.prototype.initCrossHair = function() {
		var container = this.getContainer();
		var crosshairTpl = this.get("crosshairTpl");
		var crosshairEl = createDom$1(crosshairTpl);
		container.appendChild(crosshairEl);
		this.applyStyle(CROSSHAIR_LINE, crosshairEl);
		this.set("crosshairEl", crosshairEl);
	};
	HtmlCrosshair$1.prototype.getTextPoint = function() {
		var _a$5 = this.getLocation(), start = _a$5.start, end = _a$5.end;
		var _b = this.get("text"), position = _b.position, offset = _b.offset;
		return getTextPoint(start, end, position, offset);
	};
	HtmlCrosshair$1.prototype.resetText = function() {
		var text = this.get("text");
		var textEl = this.get("textEl");
		if (text) {
			var content = text.content;
			if (!textEl) {
				var container = this.getContainer();
				var textTpl = substitute_default(this.get("textTpl"), text);
				textEl = createDom$1(textTpl);
				container.appendChild(textEl);
				this.applyStyle(CROSSHAIR_TEXT, textEl);
				this.set("textEl", textEl);
			}
			textEl.innerHTML = content;
		} else if (textEl) textEl.remove();
	};
	HtmlCrosshair$1.prototype.isVertical = function(start, end) {
		return start.x === end.x;
	};
	HtmlCrosshair$1.prototype.resetPosition = function() {
		var crosshairEl = this.get("crosshairEl");
		if (!crosshairEl) {
			this.initCrossHair();
			crosshairEl = this.get("crosshairEl");
		}
		var start = this.get("start");
		var end = this.get("end");
		var minX = Math.min(start.x, end.x);
		var minY = Math.min(start.y, end.y);
		if (this.isVertical(start, end)) modifyCSS(crosshairEl, {
			width: "1px",
			height: toPx(Math.abs(end.y - start.y))
		});
		else modifyCSS(crosshairEl, {
			height: "1px",
			width: toPx(Math.abs(end.x - start.x))
		});
		modifyCSS(crosshairEl, {
			top: toPx(minY),
			left: toPx(minX)
		});
		this.alignText();
	};
	HtmlCrosshair$1.prototype.alignText = function() {
		var textEl = this.get("textEl");
		if (textEl) {
			var align = this.get("text").align;
			var clientWidth = textEl.clientWidth;
			var point$1 = this.getTextPoint();
			switch (align) {
				case "center":
					point$1.x = point$1.x - clientWidth / 2;
					break;
				case "right": point$1.x = point$1.x - clientWidth;
				case "left": break;
			}
			modifyCSS(textEl, {
				top: toPx(point$1.y),
				left: toPx(point$1.x)
			});
		}
	};
	HtmlCrosshair$1.prototype.updateInner = function(cfg) {
		if (has_key_default(cfg, "text")) this.resetText();
		_super.prototype.updateInner.call(this, cfg);
	};
	return HtmlCrosshair$1;
}(html_component_default);
var html_default$1 = HtmlCrosshair;

//#endregion
//#region node_modules/@antv/component/esm/crosshair/index.js
var crosshair_exports = /* @__PURE__ */ __export({
	Base: () => base_default$13,
	Circle: () => circle_default$6,
	Html: () => html_default$1,
	Line: () => line_default$5
});

//#endregion
//#region node_modules/@antv/component/esm/grid/base.js
var GridBase = function(_super) {
	__extends(GridBase$1, _super);
	function GridBase$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	GridBase$1.prototype.getDefaultCfg = function() {
		var cfg = _super.prototype.getDefaultCfg.call(this);
		return __assign(__assign({}, cfg), {
			name: "grid",
			line: {},
			alternateColor: null,
			capture: false,
			items: [],
			closed: false,
			defaultCfg: { line: {
				type: "line",
				style: {
					lineWidth: 1,
					stroke: theme_default.lineColor
				}
			} }
		});
	};
	/**
	* 获取栅格线的类型
	* @return {string} 栅格线类型
	*/
	GridBase$1.prototype.getLineType = function() {
		return (this.get("line") || this.get("defaultCfg").line).type;
	};
	GridBase$1.prototype.renderInner = function(group$1) {
		this.drawGrid(group$1);
	};
	GridBase$1.prototype.getAlternatePath = function(prePoints, points) {
		var regionPath = this.getGridPath(prePoints);
		var reversePoints = points.slice(0).reverse();
		var nextPath = this.getGridPath(reversePoints, true);
		if (this.get("closed")) regionPath = regionPath.concat(nextPath);
		else {
			nextPath[0][0] = "L";
			regionPath = regionPath.concat(nextPath);
			regionPath.push(["Z"]);
		}
		return regionPath;
	};
	GridBase$1.prototype.getPathStyle = function() {
		return this.get("line").style;
	};
	GridBase$1.prototype.drawGrid = function(group$1) {
		var _this = this;
		var line$1 = this.get("line");
		var items = this.get("items");
		var alternateColor = this.get("alternateColor");
		var preItem = null;
		each_default(items, function(item, index) {
			var id$1 = item.id || index;
			if (line$1) {
				var style = _this.getPathStyle();
				style = is_function_default(style) ? style(item, index, items) : style;
				var lineId = _this.getElementId("line-" + id$1);
				var gridPath = _this.getGridPath(item.points);
				_this.addShape(group$1, {
					type: "path",
					name: "grid-line",
					id: lineId,
					attrs: mix({ path: gridPath }, style)
				});
			}
			if (alternateColor && index > 0) {
				var regionId = _this.getElementId("region-" + id$1);
				var isEven = index % 2 === 0;
				if (is_string_default(alternateColor)) {
					if (isEven) _this.drawAlternateRegion(regionId, group$1, preItem.points, item.points, alternateColor);
				} else {
					var color$2 = isEven ? alternateColor[1] : alternateColor[0];
					_this.drawAlternateRegion(regionId, group$1, preItem.points, item.points, color$2);
				}
			}
			preItem = item;
		});
	};
	GridBase$1.prototype.drawAlternateRegion = function(id$1, group$1, prePoints, points, color$2) {
		var regionPath = this.getAlternatePath(prePoints, points);
		this.addShape(group$1, {
			type: "path",
			id: id$1,
			name: "grid-region",
			attrs: {
				path: regionPath,
				fill: color$2
			}
		});
	};
	return GridBase$1;
}(group_component_default);
var base_default$12 = GridBase;

//#endregion
//#region node_modules/@antv/component/esm/grid/circle.js
function distance$3(x1, y1, x2, y2) {
	var dx = x2 - x1;
	var dy = y2 - y1;
	return Math.sqrt(dx * dx + dy * dy);
}
var Circle$3 = function(_super) {
	__extends(Circle$5, _super);
	function Circle$5() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	Circle$5.prototype.getDefaultCfg = function() {
		var cfg = _super.prototype.getDefaultCfg.call(this);
		return __assign(__assign({}, cfg), {
			type: "circle",
			center: null,
			closed: true
		});
	};
	Circle$5.prototype.getGridPath = function(points, reversed) {
		var lineType = this.getLineType();
		var closed = this.get("closed");
		var path = [];
		if (points.length) if (lineType === "circle") {
			var center$1 = this.get("center");
			var firstPoint = points[0];
			var radius_1 = distance$3(center$1.x, center$1.y, firstPoint.x, firstPoint.y);
			var sweepFlag_1 = reversed ? 0 : 1;
			if (closed) {
				path.push([
					"M",
					center$1.x,
					center$1.y - radius_1
				]);
				path.push([
					"A",
					radius_1,
					radius_1,
					0,
					0,
					sweepFlag_1,
					center$1.x,
					center$1.y + radius_1
				]);
				path.push([
					"A",
					radius_1,
					radius_1,
					0,
					0,
					sweepFlag_1,
					center$1.x,
					center$1.y - radius_1
				]);
				path.push(["Z"]);
			} else each_default(points, function(point$1, index) {
				if (index === 0) path.push([
					"M",
					point$1.x,
					point$1.y
				]);
				else path.push([
					"A",
					radius_1,
					radius_1,
					0,
					0,
					sweepFlag_1,
					point$1.x,
					point$1.y
				]);
			});
		} else {
			each_default(points, function(point$1, index) {
				if (index === 0) path.push([
					"M",
					point$1.x,
					point$1.y
				]);
				else path.push([
					"L",
					point$1.x,
					point$1.y
				]);
			});
			if (closed) path.push(["Z"]);
		}
		return path;
	};
	return Circle$5;
}(base_default$12);
var circle_default$5 = Circle$3;

//#endregion
//#region node_modules/@antv/component/esm/grid/line.js
var Line$4 = function(_super) {
	__extends(Line$6, _super);
	function Line$6() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	Line$6.prototype.getDefaultCfg = function() {
		var cfg = _super.prototype.getDefaultCfg.call(this);
		return __assign(__assign({}, cfg), { type: "line" });
	};
	Line$6.prototype.getGridPath = function(points) {
		var path = [];
		each_default(points, function(point$1, index) {
			if (index === 0) path.push([
				"M",
				point$1.x,
				point$1.y
			]);
			else path.push([
				"L",
				point$1.x,
				point$1.y
			]);
		});
		return path;
	};
	return Line$6;
}(base_default$12);
var line_default$4 = Line$4;

//#endregion
//#region node_modules/@antv/component/esm/legend/base.js
var LegendBase = function(_super) {
	__extends(LegendBase$1, _super);
	function LegendBase$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	LegendBase$1.prototype.getDefaultCfg = function() {
		var cfg = _super.prototype.getDefaultCfg.call(this);
		return __assign(__assign({}, cfg), {
			name: "legend",
			layout: "horizontal",
			locationType: "point",
			x: 0,
			y: 0,
			offsetX: 0,
			offsetY: 0,
			title: null,
			background: null
		});
	};
	LegendBase$1.prototype.getLayoutBBox = function() {
		var bbox = _super.prototype.getLayoutBBox.call(this);
		var maxWidth = this.get("maxWidth");
		var maxHeight = this.get("maxHeight");
		var width = bbox.width, height = bbox.height;
		if (maxWidth) width = Math.min(width, maxWidth);
		if (maxHeight) height = Math.min(height, maxHeight);
		return createBBox(bbox.minX, bbox.minY, width, height);
	};
	LegendBase$1.prototype.setLocation = function(cfg) {
		this.set("x", cfg.x);
		this.set("y", cfg.y);
		this.resetLocation();
	};
	LegendBase$1.prototype.resetLocation = function() {
		var x = this.get("x");
		var y = this.get("y");
		var offsetX = this.get("offsetX");
		var offsetY = this.get("offsetY");
		this.moveElementTo(this.get("group"), {
			x: x + offsetX,
			y: y + offsetY
		});
	};
	LegendBase$1.prototype.applyOffset = function() {
		this.resetLocation();
	};
	LegendBase$1.prototype.getDrawPoint = function() {
		return this.get("currentPoint");
	};
	LegendBase$1.prototype.setDrawPoint = function(point$1) {
		return this.set("currentPoint", point$1);
	};
	LegendBase$1.prototype.renderInner = function(group$1) {
		this.resetDraw();
		if (this.get("title")) this.drawTitle(group$1);
		this.drawLegendContent(group$1);
		if (this.get("background")) this.drawBackground(group$1);
	};
	LegendBase$1.prototype.drawBackground = function(group$1) {
		var background = this.get("background");
		var bbox = group$1.getBBox();
		var padding$2 = formatPadding(background.padding);
		var attrs = __assign({
			x: 0,
			y: 0,
			width: bbox.width + padding$2[1] + padding$2[3],
			height: bbox.height + padding$2[0] + padding$2[2]
		}, background.style);
		this.addShape(group$1, {
			type: "rect",
			id: this.getElementId("background"),
			name: "legend-background",
			attrs
		}).toBack();
	};
	LegendBase$1.prototype.drawTitle = function(group$1) {
		var currentPoint = this.get("currentPoint");
		var titleCfg = this.get("title");
		var spacing = titleCfg.spacing, style = titleCfg.style, text = titleCfg.text;
		var bbox = this.addShape(group$1, {
			type: "text",
			id: this.getElementId("title"),
			name: "legend-title",
			attrs: __assign({
				text,
				x: currentPoint.x,
				y: currentPoint.y
			}, style)
		}).getBBox();
		this.set("currentPoint", {
			x: currentPoint.x,
			y: bbox.maxY + spacing
		});
	};
	LegendBase$1.prototype.resetDraw = function() {
		var background = this.get("background");
		var currentPoint = {
			x: 0,
			y: 0
		};
		if (background) {
			var padding$2 = formatPadding(background.padding);
			currentPoint.x = padding$2[3];
			currentPoint.y = padding$2[0];
		}
		this.set("currentPoint", currentPoint);
	};
	return LegendBase$1;
}(group_component_default);
var base_default$11 = LegendBase;

//#endregion
//#region node_modules/@antv/component/esm/legend/category.js
/**
* 分页器 默认配置
*/
var DEFAULT_PAGE_NAVIGATOR = {
	marker: { style: {
		inactiveFill: "#000",
		inactiveOpacity: .45,
		fill: "#000",
		opacity: 1,
		size: 12
	} },
	text: { style: {
		fill: "#ccc",
		fontSize: 12
	} }
};
var textStyle = {
	fill: theme_default.textColor,
	fontSize: 12,
	textAlign: "start",
	textBaseline: "middle",
	fontFamily: theme_default.fontFamily,
	fontWeight: "normal",
	lineHeight: 12
};
var RIGHT_ARROW_NAME = "navigation-arrow-right";
var LEFT_ARROW_NAME = "navigation-arrow-left";
var ROTATE_MAP = {
	right: 90 * Math.PI / 180,
	left: 270 * Math.PI / 180,
	up: 0,
	down: 180 * Math.PI / 180
};
var Category = function(_super) {
	__extends(Category$2, _super);
	function Category$2() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.currentPageIndex = 1;
		_this.totalPagesCnt = 1;
		_this.pageWidth = 0;
		_this.pageHeight = 0;
		_this.startX = 0;
		_this.startY = 0;
		_this.onNavigationBack = function() {
			var itemGroup = _this.getElementByLocalId("item-group");
			if (_this.currentPageIndex > 1) {
				_this.currentPageIndex -= 1;
				_this.updateNavigation();
				var matrix = _this.getCurrentNavigationMatrix();
				if (_this.get("animate")) itemGroup.animate({ matrix }, 100);
				else itemGroup.attr({ matrix });
			}
		};
		_this.onNavigationAfter = function() {
			var itemGroup = _this.getElementByLocalId("item-group");
			if (_this.currentPageIndex < _this.totalPagesCnt) {
				_this.currentPageIndex += 1;
				_this.updateNavigation();
				var matrix = _this.getCurrentNavigationMatrix();
				if (_this.get("animate")) itemGroup.animate({ matrix }, 100);
				else itemGroup.attr({ matrix });
			}
		};
		return _this;
	}
	Category$2.prototype.getDefaultCfg = function() {
		var cfg = _super.prototype.getDefaultCfg.call(this);
		return __assign(__assign({}, cfg), {
			name: "legend",
			type: "category",
			itemSpacing: 24,
			itemMarginBottom: 8,
			maxItemWidth: null,
			itemWidth: null,
			itemHeight: null,
			itemName: {},
			itemValue: null,
			maxWidth: null,
			maxHeight: null,
			marker: {},
			radio: null,
			items: [],
			itemStates: {},
			itemBackground: {},
			pageNavigator: {},
			defaultCfg: {
				title: {
					spacing: 5,
					style: {
						fill: theme_default.textColor,
						fontSize: 12,
						textAlign: "start",
						textBaseline: "top"
					}
				},
				background: {
					padding: 5,
					style: { stroke: theme_default.lineColor }
				},
				itemBackground: { style: {
					opacity: 0,
					fill: "#fff"
				} },
				pageNavigator: DEFAULT_PAGE_NAVIGATOR,
				itemName: {
					spacing: 16,
					style: textStyle
				},
				marker: {
					spacing: 8,
					style: {
						r: 6,
						symbol: "circle"
					}
				},
				itemValue: {
					alignRight: false,
					formatter: null,
					style: textStyle,
					spacing: 6
				},
				itemStates: {
					active: { nameStyle: { opacity: .8 } },
					unchecked: {
						nameStyle: { fill: theme_default.uncheckedColor },
						markerStyle: {
							fill: theme_default.uncheckedColor,
							stroke: theme_default.uncheckedColor
						}
					},
					inactive: {
						nameStyle: { fill: theme_default.uncheckedColor },
						markerStyle: { opacity: .2 }
					}
				}
			}
		});
	};
	Category$2.prototype.isList = function() {
		return true;
	};
	/**
	* 获取图例项
	* @return {ListItem[]} 列表项集合
	*/
	Category$2.prototype.getItems = function() {
		return this.get("items");
	};
	/**
	* 设置列表项
	* @param {ListItem[]} items 列表项集合
	*/
	Category$2.prototype.setItems = function(items) {
		this.update({ items });
	};
	/**
	* 更新列表项
	* @param {ListItem} item 列表项
	* @param {object}   cfg  列表项
	*/
	Category$2.prototype.updateItem = function(item, cfg) {
		mix(item, cfg);
		this.clear();
		this.render();
	};
	/**
	* 清空列表
	*/
	Category$2.prototype.clearItems = function() {
		var itemGroup = this.getElementByLocalId("item-group");
		itemGroup && itemGroup.clear();
	};
	/**
	* 设置列表项的状态
	* @param {ListItem} item  列表项
	* @param {string}   state 状态名
	* @param {boolean}  value 状态值, true, false
	*/
	Category$2.prototype.setItemState = function(item, state$1, value$1) {
		item[state$1] = value$1;
		var itemElement = this.getElementByLocalId("item-" + item.id);
		if (itemElement) {
			var index = this.getItems().indexOf(item);
			var offsetGroup = this.createOffScreenGroup();
			var newElement = this.drawItem(item, index, this.getItemHeight(), offsetGroup);
			this.updateElements(newElement, itemElement);
			this.clearUpdateStatus(itemElement);
		}
	};
	/**
	* 是否存在指定的状态
	* @param {ListItem} item  列表项
	* @param {boolean} state 状态名
	*/
	Category$2.prototype.hasState = function(item, state$1) {
		return !!item[state$1];
	};
	Category$2.prototype.getItemStates = function(item) {
		var itemStates = this.get("itemStates");
		var rst = [];
		each_default(itemStates, function(v, k) {
			if (item[k]) rst.push(k);
		});
		return rst;
	};
	/**
	* 清楚所有列表项的状态
	* @param {string} state 状态值
	*/
	Category$2.prototype.clearItemsState = function(state$1) {
		var _this = this;
		var items = this.getItemsByState(state$1);
		each_default(items, function(item) {
			_this.setItemState(item, state$1, false);
		});
	};
	/**
	* 根据状态获取图例项
	* @param  {string}     state [description]
	* @return {ListItem[]}       [description]
	*/
	Category$2.prototype.getItemsByState = function(state$1) {
		var _this = this;
		var items = this.getItems();
		return filter_default(items, function(item) {
			return _this.hasState(item, state$1);
		});
	};
	Category$2.prototype.drawLegendContent = function(group$1) {
		this.processItems();
		this.drawItems(group$1);
	};
	Category$2.prototype.processItems = function() {
		var items = this.get("items");
		each_default(items, function(item) {
			if (!item.id) item.id = item.name;
		});
	};
	Category$2.prototype.drawItems = function(group$1) {
		var _this = this;
		var itemContainerGroup = this.addGroup(group$1, {
			id: this.getElementId("item-container-group"),
			name: "legend-item-container-group"
		});
		var itemGroup = this.addGroup(itemContainerGroup, {
			id: this.getElementId("item-group"),
			name: "legend-item-group"
		});
		var itemHeight = this.getItemHeight();
		var itemWidth = this.get("itemWidth");
		var itemSpacing = this.get("itemSpacing");
		var itemMarginBottom = this.get("itemMarginBottom");
		var currentPoint = this.get("currentPoint");
		var startX = currentPoint.x;
		var startY = currentPoint.y;
		var layout$1 = this.get("layout");
		var items = this.get("items");
		var wrapped = false;
		var pageWidth = 0;
		var maxWidth = this.get("maxWidth");
		var maxHeight = this.get("maxHeight");
		each_default(items, function(item, index) {
			var subGroup = _this.drawItem(item, index, itemHeight, itemGroup);
			var bbox = subGroup.getBBox();
			var width = itemWidth || bbox.width;
			if (width > pageWidth) pageWidth = width;
			if (layout$1 === "horizontal") {
				if (maxWidth && maxWidth < currentPoint.x + width - startX) {
					wrapped = true;
					currentPoint.x = startX;
					currentPoint.y += itemHeight + itemMarginBottom;
				}
				_this.moveElementTo(subGroup, currentPoint);
				currentPoint.x += width + itemSpacing;
			} else {
				if (maxHeight && maxHeight < currentPoint.y + itemHeight + itemMarginBottom - startY) {
					wrapped = true;
					currentPoint.x += pageWidth + itemSpacing;
					currentPoint.y = startY;
					pageWidth = 0;
				}
				_this.moveElementTo(subGroup, currentPoint);
				currentPoint.y += itemHeight + itemMarginBottom;
			}
		});
		if (wrapped && this.get("flipPage")) {
			this.pageHeight = 0;
			this.pageWidth = 0;
			this.totalPagesCnt = 1;
			this.startX = startX;
			this.startY = startY;
			this.adjustNavigation(group$1, itemGroup);
		}
	};
	Category$2.prototype.getItemHeight = function() {
		var itemHeight = this.get("itemHeight");
		if (!itemHeight) {
			var style_1 = (this.get("itemName") || {}).style;
			if (is_function_default(style_1)) {
				var items_1 = this.getItems();
				items_1.forEach(function(item, index) {
					var fontSize = __assign(__assign({}, textStyle), style_1(item, index, items_1)).fontSize;
					if (itemHeight < fontSize) itemHeight = fontSize;
				});
			} else if (style_1) itemHeight = style_1.fontSize;
		}
		return itemHeight;
	};
	Category$2.prototype.drawMarker = function(container, markerCfg, item, itemHeight) {
		var markerAttrs = __assign(__assign(__assign({
			x: 0,
			y: itemHeight / 2
		}, markerCfg.style), { symbol: get_default(item.marker, "symbol", "circle") }), get_default(item.marker, "style", {}));
		var shape = this.addShape(container, {
			type: "marker",
			id: this.getElementId("item-" + item.id + "-marker"),
			name: "legend-item-marker",
			attrs: markerAttrs
		});
		var bbox = shape.getBBox();
		shape.attr("x", bbox.width / 2);
		var _a$5 = shape.attr(), stroke = _a$5.stroke, fill = _a$5.fill;
		if (stroke) shape.set("isStroke", true);
		if (fill) shape.set("isFill", true);
		return shape;
	};
	Category$2.prototype.drawItemText = function(container, textName, cfg, item, itemHeight, xPosition, index) {
		var formatter = cfg.formatter;
		var style = cfg.style;
		var attrs = __assign(__assign({
			x: xPosition,
			y: itemHeight / 2,
			text: formatter ? formatter(item[textName], item, index) : item[textName]
		}, textStyle), is_function_default(style) ? style(item, index, this.getItems()) : style);
		return this.addShape(container, {
			type: "text",
			id: this.getElementId("item-" + item.id + "-" + textName),
			name: "legend-item-" + textName,
			attrs
		});
	};
	Category$2.prototype.drawRadio = function(container, radioCfg, item, itemHeight, x) {
		var _a$5, _b;
		var style = radioCfg.style || {};
		var r = (_a$5 = style.r) !== null && _a$5 !== void 0 ? _a$5 : itemHeight / 2;
		var lineWidth = r * 3.6 / 8;
		var _c = [x + r, itemHeight / 2 - r], x0 = _c[0], y0 = _c[1];
		var _d = [x0 + r, y0 + r], x1 = _d[0], y1 = _d[1];
		var _e = [x0, y1 + r], x2 = _e[0], y2 = _e[1];
		var _f = [x, y0 + r], x3 = _f[0], y3 = _f[1];
		var showRadio = item.showRadio;
		var attrs = __assign(__assign({
			path: [
				[
					"M",
					x0,
					y0
				],
				[
					"A",
					r,
					r,
					0,
					0,
					1,
					x1,
					y1
				],
				[
					"L",
					x1 - lineWidth,
					y1
				],
				[
					"L",
					x1,
					y1
				],
				[
					"A",
					r,
					r,
					0,
					0,
					1,
					x2,
					y2
				],
				[
					"L",
					x2,
					y2 - lineWidth
				],
				[
					"L",
					x2,
					y2
				],
				[
					"A",
					r,
					r,
					0,
					0,
					1,
					x3,
					y3
				],
				[
					"L",
					x3 + lineWidth,
					y3
				],
				[
					"L",
					x3,
					y3
				],
				[
					"A",
					r,
					r,
					0,
					0,
					1,
					x0,
					y0
				],
				[
					"L",
					x0,
					y0 + lineWidth
				]
			],
			stroke: "#000000",
			fill: "#ffffff"
		}, style), { opacity: showRadio ? (_b = style === null || style === void 0 ? void 0 : style.opacity) !== null && _b !== void 0 ? _b : .45 : 0 });
		var radioShape = this.addShape(container, {
			type: "path",
			id: this.getElementId("item-" + item.id + "-radio"),
			name: "legend-item-radio",
			attrs
		});
		radioShape.set("tip", radioCfg.tip);
		return radioShape;
	};
	Category$2.prototype.drawItem = function(item, index, itemHeight, itemGroup) {
		var groupId = "item-" + item.id;
		var subContainer = this.addGroup(itemGroup, {
			name: "legend-item-container",
			id: this.getElementId("item-container-" + groupId),
			delegateObject: {
				item,
				index
			}
		});
		var subGroup = this.addGroup(subContainer, {
			name: "legend-item",
			id: this.getElementId(groupId),
			delegateObject: {
				item,
				index
			}
		});
		var marker = this.get("marker");
		var itemName = this.get("itemName");
		var itemValue = this.get("itemValue");
		var itemBackground = this.get("itemBackground");
		var radio = this.get("radio");
		var itemWidth = this.getLimitItemWidth();
		var curX = 0;
		if (marker) {
			var markerShape = this.drawMarker(subGroup, marker, item, itemHeight);
			var spacing = marker.spacing;
			var itemMarkerSpacing = get_default(item, ["marker", "spacing"]);
			if (is_number_default(itemMarkerSpacing)) spacing = itemMarkerSpacing;
			curX = markerShape.getBBox().maxX + spacing;
		}
		if (itemName) {
			var nameShape = this.drawItemText(subGroup, "name", itemName, item, itemHeight, curX, index);
			if (itemWidth) ellipsisLabel(true, nameShape, clamp_default(itemWidth - curX, 0, itemWidth));
			curX = nameShape.getBBox().maxX + itemName.spacing;
		}
		if (itemValue) {
			var valueShape = this.drawItemText(subGroup, "value", itemValue, item, itemHeight, curX, index);
			if (itemWidth) if (itemValue.alignRight) {
				valueShape.attr({
					textAlign: "right",
					x: itemWidth
				});
				ellipsisLabel(true, valueShape, clamp_default(itemWidth - curX, 0, itemWidth), "head");
			} else ellipsisLabel(true, valueShape, clamp_default(itemWidth - curX, 0, itemWidth));
			curX = valueShape.getBBox().maxX + itemValue.spacing;
		}
		if (radio) this.drawRadio(subGroup, radio, item, itemHeight, curX);
		if (itemBackground) {
			var bbox = subGroup.getBBox();
			this.addShape(subGroup, {
				type: "rect",
				name: "legend-item-background",
				id: this.getElementId(groupId + "-background"),
				attrs: __assign({
					x: 0,
					y: 0,
					width: bbox.width,
					height: itemHeight
				}, itemBackground.style)
			}).toBack();
		}
		this.applyItemStates(item, subGroup);
		return subGroup;
	};
	Category$2.prototype.adjustNavigation = function(container, itemGroup) {
		var _this = this;
		var startX = this.startX;
		var startY = this.startY;
		var layout$1 = this.get("layout");
		var subGroups = itemGroup.findAll(function(item) {
			return item.get("name") === "legend-item";
		});
		var maxWidth = this.get("maxWidth");
		var maxHeight = this.get("maxHeight");
		var itemWidth = this.get("itemWidth");
		var itemSpacing = this.get("itemSpacing");
		var itemHeight = this.getItemHeight();
		var pageNavigator = deep_mix_default({}, DEFAULT_PAGE_NAVIGATOR, this.get("pageNavigator"));
		var navigation = this.drawNavigation(container, layout$1, "00/00", pageNavigator);
		var navigationBBox = navigation.getBBox();
		var currentPoint = {
			x: startX,
			y: startY
		};
		var pages = 1;
		var widthLimit = 0;
		var pageWidth = 0;
		var maxItemWidth = 0;
		var itemMarginBottom = this.get("itemMarginBottom");
		/**  判断当前 item 是否溢出当前页。是的话，需要换行 */
		function shouldWrap(item, currentPoint$1) {
			var bbox = item.getBBox();
			var width = itemWidth || bbox.width;
			return currentPoint$1.x + width + itemSpacing + navigationBBox.width > maxWidth;
		}
		if (layout$1 === "horizontal") {
			var maxRow = this.get("maxRow") || 1;
			var maxRowHeight_1 = itemHeight + (maxRow === 1 ? 0 : itemMarginBottom);
			var navigationX_1 = maxWidth - itemSpacing - navigationBBox.width - navigationBBox.minX;
			this.pageHeight = maxRowHeight_1 * maxRow;
			this.pageWidth = navigationX_1;
			each_default(subGroups, function(item) {
				var bbox = item.getBBox();
				var width = itemWidth || bbox.width;
				if (widthLimit && widthLimit < currentPoint.x + width + itemSpacing || shouldWrap(item, currentPoint)) {
					if (pages === 1) {
						widthLimit = currentPoint.x + itemSpacing;
						_this.moveElementTo(navigation, {
							x: navigationX_1,
							y: currentPoint.y + itemHeight / 2 - navigationBBox.height / 2 - navigationBBox.minY
						});
					}
					pages += 1;
					currentPoint.x = startX;
					currentPoint.y += maxRowHeight_1;
				}
				_this.moveElementTo(item, currentPoint);
				item.getParent().setClip({
					type: "rect",
					attrs: {
						x: currentPoint.x,
						y: currentPoint.y,
						width: width + itemSpacing,
						height: itemHeight
					}
				});
				currentPoint.x += width + itemSpacing;
			});
		} else {
			each_default(subGroups, function(item) {
				var bbox = item.getBBox();
				if (bbox.width > pageWidth) pageWidth = bbox.width;
			});
			maxItemWidth = pageWidth;
			pageWidth += itemSpacing;
			if (maxWidth) {
				pageWidth = Math.min(maxWidth, pageWidth);
				maxItemWidth = Math.min(maxWidth, maxItemWidth);
			}
			this.pageWidth = pageWidth;
			this.pageHeight = maxHeight - Math.max(navigationBBox.height, itemHeight + itemMarginBottom);
			var cntPerPage_1 = Math.floor(this.pageHeight / (itemHeight + itemMarginBottom));
			each_default(subGroups, function(item, index) {
				if (index !== 0 && index % cntPerPage_1 === 0) {
					pages += 1;
					currentPoint.x += pageWidth;
					currentPoint.y = startY;
				}
				_this.moveElementTo(item, currentPoint);
				item.getParent().setClip({
					type: "rect",
					attrs: {
						x: currentPoint.x,
						y: currentPoint.y,
						width: pageWidth,
						height: itemHeight
					}
				});
				currentPoint.y += itemHeight + itemMarginBottom;
			});
			this.totalPagesCnt = pages;
			this.moveElementTo(navigation, {
				x: startX + maxItemWidth / 2 - navigationBBox.width / 2 - navigationBBox.minX,
				y: maxHeight - navigationBBox.height - navigationBBox.minY
			});
		}
		if (this.pageHeight && this.pageWidth) itemGroup.getParent().setClip({
			type: "rect",
			attrs: {
				x: this.startX,
				y: this.startY,
				width: this.pageWidth,
				height: this.pageHeight
			}
		});
		if (layout$1 === "horizontal" && this.get("maxRow")) this.totalPagesCnt = Math.ceil(pages / this.get("maxRow"));
		else this.totalPagesCnt = pages;
		if (this.currentPageIndex > this.totalPagesCnt) this.currentPageIndex = 1;
		this.updateNavigation(navigation);
		itemGroup.attr("matrix", this.getCurrentNavigationMatrix());
	};
	/**
	* 绘制分页器
	*/
	Category$2.prototype.drawNavigation = function(group$1, layout$1, text, styleCfg) {
		var currentPoint = {
			x: 0,
			y: 0
		};
		var subGroup = this.addGroup(group$1, {
			id: this.getElementId("navigation-group"),
			name: "legend-navigation"
		});
		var _a$5 = get_default(styleCfg.marker, "style", {}), _b = _a$5.size, size$1 = _b === void 0 ? 12 : _b, arrowStyle = __rest(_a$5, ["size"]);
		var leftArrow = this.drawArrow(subGroup, currentPoint, LEFT_ARROW_NAME, layout$1 === "horizontal" ? "up" : "left", size$1, arrowStyle);
		leftArrow.on("click", this.onNavigationBack);
		var leftArrowBBox = leftArrow.getBBox();
		currentPoint.x += leftArrowBBox.width + 2;
		var textBBox = this.addShape(subGroup, {
			type: "text",
			id: this.getElementId("navigation-text"),
			name: "navigation-text",
			attrs: __assign({
				x: currentPoint.x,
				y: currentPoint.y + size$1 / 2,
				text,
				textBaseline: "middle"
			}, get_default(styleCfg.text, "style"))
		}).getBBox();
		currentPoint.x += textBBox.width + 2;
		this.drawArrow(subGroup, currentPoint, RIGHT_ARROW_NAME, layout$1 === "horizontal" ? "down" : "right", size$1, arrowStyle).on("click", this.onNavigationAfter);
		return subGroup;
	};
	Category$2.prototype.updateNavigation = function(navigation) {
		var _a$5 = deep_mix_default({}, DEFAULT_PAGE_NAVIGATOR, this.get("pageNavigator")).marker.style, fill = _a$5.fill, opacity = _a$5.opacity, inactiveFill = _a$5.inactiveFill, inactiveOpacity = _a$5.inactiveOpacity;
		var text = this.currentPageIndex + "/" + this.totalPagesCnt;
		var textShape = navigation ? navigation.getChildren()[1] : this.getElementByLocalId("navigation-text");
		var leftArrow = navigation ? navigation.findById(this.getElementId(LEFT_ARROW_NAME)) : this.getElementByLocalId(LEFT_ARROW_NAME);
		var rightArrow = navigation ? navigation.findById(this.getElementId(RIGHT_ARROW_NAME)) : this.getElementByLocalId(RIGHT_ARROW_NAME);
		textShape.attr("text", text);
		leftArrow.attr("opacity", this.currentPageIndex === 1 ? inactiveOpacity : opacity);
		leftArrow.attr("fill", this.currentPageIndex === 1 ? inactiveFill : fill);
		leftArrow.attr("cursor", this.currentPageIndex === 1 ? "not-allowed" : "pointer");
		rightArrow.attr("opacity", this.currentPageIndex === this.totalPagesCnt ? inactiveOpacity : opacity);
		rightArrow.attr("fill", this.currentPageIndex === this.totalPagesCnt ? inactiveFill : fill);
		rightArrow.attr("cursor", this.currentPageIndex === this.totalPagesCnt ? "not-allowed" : "pointer");
		var cursorX = leftArrow.getBBox().maxX + 2;
		textShape.attr("x", cursorX);
		cursorX += textShape.getBBox().width + 2;
		this.updateArrowPath(rightArrow, {
			x: cursorX,
			y: 0
		});
	};
	Category$2.prototype.drawArrow = function(group$1, currentPoint, name, direction$1, size$1, style) {
		var x = currentPoint.x, y = currentPoint.y;
		var shape = this.addShape(group$1, {
			type: "path",
			id: this.getElementId(name),
			name,
			attrs: __assign({
				size: size$1,
				direction: direction$1,
				path: [
					[
						"M",
						x + size$1 / 2,
						y
					],
					[
						"L",
						x,
						y + size$1
					],
					[
						"L",
						x + size$1,
						y + size$1
					],
					["Z"]
				],
				cursor: "pointer"
			}, style)
		});
		shape.attr("matrix", getMatrixByAngle({
			x: x + size$1 / 2,
			y: y + size$1 / 2
		}, ROTATE_MAP[direction$1]));
		return shape;
	};
	/**
	* 更新分页器 arrow 组件
	*/
	Category$2.prototype.updateArrowPath = function(arrow, point$1) {
		var x = point$1.x, y = point$1.y;
		var _a$5 = arrow.attr(), size$1 = _a$5.size, direction$1 = _a$5.direction;
		var matrix = getMatrixByAngle({
			x: x + size$1 / 2,
			y: y + size$1 / 2
		}, ROTATE_MAP[direction$1]);
		arrow.attr("path", [
			[
				"M",
				x + size$1 / 2,
				y
			],
			[
				"L",
				x,
				y + size$1
			],
			[
				"L",
				x + size$1,
				y + size$1
			],
			["Z"]
		]);
		arrow.attr("matrix", matrix);
	};
	Category$2.prototype.getCurrentNavigationMatrix = function() {
		var _a$5 = this, currentPageIndex = _a$5.currentPageIndex, pageWidth = _a$5.pageWidth, pageHeight = _a$5.pageHeight;
		var translate$1 = this.get("layout") === "horizontal" ? {
			x: 0,
			y: pageHeight * (1 - currentPageIndex)
		} : {
			x: pageWidth * (1 - currentPageIndex),
			y: 0
		};
		return getMatrixByTranslate(translate$1);
	};
	Category$2.prototype.applyItemStates = function(item, subGroup) {
		if (this.getItemStates(item).length > 0) {
			var children = subGroup.getChildren();
			var itemStates_1 = this.get("itemStates");
			each_default(children, function(element) {
				var elName = element.get("name").split("-")[2];
				var statesStyle = getStatesStyle(item, elName, itemStates_1);
				if (statesStyle) {
					element.attr(statesStyle);
					if (elName === "marker" && !(element.get("isStroke") && element.get("isFill"))) {
						if (element.get("isStroke")) element.attr("fill", null);
						if (element.get("isFill")) element.attr("stroke", null);
					}
				}
			});
		}
	};
	Category$2.prototype.getLimitItemWidth = function() {
		var itemWidth = this.get("itemWidth");
		var maxItemWidth = this.get("maxItemWidth");
		if (maxItemWidth) {
			if (itemWidth) maxItemWidth = itemWidth <= maxItemWidth ? itemWidth : maxItemWidth;
		} else if (itemWidth) maxItemWidth = itemWidth;
		return maxItemWidth;
	};
	return Category$2;
}(base_default$11);
var category_default = Category;

//#endregion
//#region node_modules/@antv/component/esm/legend/continuous.js
var HANDLER_HEIGHT_RATIO = 1.4;
var HANDLER_TRIANGLE_RATIO = .4;
var ContinueLegend = function(_super) {
	__extends(ContinueLegend$1, _super);
	function ContinueLegend$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	ContinueLegend$1.prototype.getDefaultCfg = function() {
		var cfg = _super.prototype.getDefaultCfg.call(this);
		return __assign(__assign({}, cfg), {
			type: "continue",
			min: 0,
			max: 100,
			value: null,
			colors: [],
			track: {},
			rail: {},
			label: {},
			handler: {},
			slidable: true,
			tip: null,
			step: null,
			maxWidth: null,
			maxHeight: null,
			defaultCfg: {
				label: {
					align: "rail",
					spacing: 5,
					formatter: null,
					style: {
						fontSize: 12,
						fill: theme_default.textColor,
						textBaseline: "middle",
						fontFamily: theme_default.fontFamily
					}
				},
				handler: {
					size: 10,
					style: {
						fill: "#fff",
						stroke: "#333"
					}
				},
				track: {},
				rail: {
					type: "color",
					size: 20,
					defaultLength: 100,
					style: { fill: "#DCDEE2" }
				},
				title: {
					spacing: 5,
					style: {
						fill: theme_default.textColor,
						fontSize: 12,
						textAlign: "start",
						textBaseline: "top"
					}
				}
			}
		});
	};
	ContinueLegend$1.prototype.isSlider = function() {
		return true;
	};
	ContinueLegend$1.prototype.getValue = function() {
		return this.getCurrentValue();
	};
	ContinueLegend$1.prototype.getRange = function() {
		return {
			min: this.get("min"),
			max: this.get("max")
		};
	};
	ContinueLegend$1.prototype.setRange = function(min$2, max$2) {
		this.update({
			min: min$2,
			max: max$2
		});
	};
	ContinueLegend$1.prototype.setValue = function(value$1) {
		var originValue = this.getValue();
		this.set("value", value$1);
		var group$1 = this.get("group");
		this.resetTrackClip();
		if (this.get("slidable")) this.resetHandlers(group$1);
		this.delegateEmit("valuechanged", {
			originValue,
			value: value$1
		});
	};
	ContinueLegend$1.prototype.initEvent = function() {
		var group$1 = this.get("group");
		this.bindSliderEvent(group$1);
		this.bindRailEvent(group$1);
		this.bindTrackEvent(group$1);
	};
	ContinueLegend$1.prototype.drawLegendContent = function(group$1) {
		this.drawRail(group$1);
		this.drawLabels(group$1);
		this.fixedElements(group$1);
		this.resetTrack(group$1);
		this.resetTrackClip(group$1);
		if (this.get("slidable")) this.resetHandlers(group$1);
	};
	ContinueLegend$1.prototype.bindSliderEvent = function(group$1) {
		this.bindHandlersEvent(group$1);
	};
	ContinueLegend$1.prototype.bindHandlersEvent = function(group$1) {
		var _this = this;
		group$1.on("legend-handler-min:drag", function(ev) {
			var minValue = _this.getValueByCanvasPoint(ev.x, ev.y);
			var maxValue = _this.getCurrentValue()[1];
			if (maxValue < minValue) maxValue = minValue;
			_this.setValue([minValue, maxValue]);
		});
		group$1.on("legend-handler-max:drag", function(ev) {
			var maxValue = _this.getValueByCanvasPoint(ev.x, ev.y);
			var minValue = _this.getCurrentValue()[0];
			if (minValue > maxValue) minValue = maxValue;
			_this.setValue([minValue, maxValue]);
		});
	};
	ContinueLegend$1.prototype.bindRailEvent = function(group$1) {};
	ContinueLegend$1.prototype.bindTrackEvent = function(group$1) {
		var _this = this;
		var prePoint = null;
		group$1.on("legend-track:dragstart", function(ev) {
			prePoint = {
				x: ev.x,
				y: ev.y
			};
		});
		group$1.on("legend-track:drag", function(ev) {
			if (!prePoint) return;
			var preValue = _this.getValueByCanvasPoint(prePoint.x, prePoint.y);
			var curValue = _this.getValueByCanvasPoint(ev.x, ev.y);
			var currentValue = _this.getCurrentValue();
			var curDiff = currentValue[1] - currentValue[0];
			var range = _this.getRange();
			var dValue = curValue - preValue;
			if (dValue < 0) if (currentValue[0] + dValue > range.min) _this.setValue([currentValue[0] + dValue, currentValue[1] + dValue]);
			else _this.setValue([range.min, range.min + curDiff]);
			else if (dValue > 0) if (dValue > 0 && currentValue[1] + dValue < range.max) _this.setValue([currentValue[0] + dValue, currentValue[1] + dValue]);
			else _this.setValue([range.max - curDiff, range.max]);
			prePoint = {
				x: ev.x,
				y: ev.y
			};
		});
		group$1.on("legend-track:dragend", function(ev) {
			prePoint = null;
		});
	};
	ContinueLegend$1.prototype.drawLabels = function(group$1) {
		this.drawLabel("min", group$1);
		this.drawLabel("max", group$1);
	};
	ContinueLegend$1.prototype.drawLabel = function(name, group$1) {
		var labelCfg = this.get("label");
		var style = labelCfg.style;
		var labelAlign = labelCfg.align;
		var labelFormatter = labelCfg.formatter;
		var value$1 = this.get(name);
		var alignAttrs = this.getLabelAlignAttrs(name, labelAlign);
		var localId = "label-" + name;
		this.addShape(group$1, {
			type: "text",
			id: this.getElementId(localId),
			name: "legend-label-" + name,
			attrs: __assign(__assign({
				x: 0,
				y: 0,
				text: is_function_default(labelFormatter) ? labelFormatter(value$1) : value$1
			}, style), alignAttrs)
		});
	};
	ContinueLegend$1.prototype.getLabelAlignAttrs = function(name, align) {
		var isVertical$1 = this.isVertical();
		var textAlign = "center";
		var textBaseline = "middle";
		if (isVertical$1) {
			textAlign = "start";
			if (align !== "rail") if (name === "min") textBaseline = "top";
			else textBaseline = "bottom";
			else textBaseline = "top";
		} else if (align !== "rail") {
			textBaseline = "top";
			if (name === "min") textAlign = "start";
			else textAlign = "end";
		} else {
			textAlign = "start";
			textBaseline = "middle";
		}
		return {
			textAlign,
			textBaseline
		};
	};
	ContinueLegend$1.prototype.getRailPath = function(x, y, w, h) {
		var railCfg = this.get("rail");
		var size$1 = railCfg.size, defaultLength = railCfg.defaultLength, type = railCfg.type;
		var isVertical$1 = this.isVertical();
		var length$1 = defaultLength;
		var width = w;
		var height = h;
		if (!width) width = isVertical$1 ? size$1 : length$1;
		if (!height) height = isVertical$1 ? length$1 : size$1;
		var path = [];
		if (type === "color") {
			path.push([
				"M",
				x,
				y
			]);
			path.push([
				"L",
				x + width,
				y
			]);
			path.push([
				"L",
				x + width,
				y + height
			]);
			path.push([
				"L",
				x,
				y + height
			]);
			path.push(["Z"]);
		} else {
			path.push([
				"M",
				x + width,
				y
			]);
			path.push([
				"L",
				x + width,
				y + height
			]);
			path.push([
				"L",
				x,
				y + height
			]);
			path.push(["Z"]);
		}
		return path;
	};
	ContinueLegend$1.prototype.drawRail = function(group$1) {
		var style = this.get("rail").style;
		this.addShape(group$1, {
			type: "path",
			id: this.getElementId("rail"),
			name: "legend-rail",
			attrs: __assign({ path: this.getRailPath(0, 0) }, style)
		});
	};
	ContinueLegend$1.prototype.getTrackColor = function(colors) {
		var count$1 = colors.length;
		if (!count$1) return null;
		if (count$1 === 1) return colors[0];
		var color$2;
		if (this.isVertical()) color$2 = "l(90)";
		else color$2 = "l(0)";
		for (var i = 0; i < count$1; i++) {
			var percent$1 = i / (count$1 - 1);
			color$2 += " " + percent$1 + ":" + colors[i];
		}
		return color$2;
	};
	ContinueLegend$1.prototype.getTrackPath = function(group$1) {
		var path = this.getRailShape(group$1).attr("path");
		return clone_default(path);
	};
	ContinueLegend$1.prototype.getClipTrackAttrs = function(group$1) {
		var value$1 = this.getCurrentValue();
		var min$2 = value$1[0], max$2 = value$1[1];
		var railBBox = this.getRailBBox(group$1);
		var startPoint = this.getPointByValue(min$2, group$1);
		var endPoint = this.getPointByValue(max$2, group$1);
		var isVertical$1 = this.isVertical();
		var x;
		var y;
		var width;
		var height;
		if (isVertical$1) {
			x = railBBox.minX;
			y = startPoint.y;
			width = railBBox.width;
			height = endPoint.y - startPoint.y;
		} else {
			x = startPoint.x;
			y = railBBox.minY;
			width = endPoint.x - startPoint.x;
			height = railBBox.height;
		}
		return {
			x,
			y,
			width,
			height
		};
	};
	ContinueLegend$1.prototype.getTrackAttrs = function(group$1) {
		var trackCfg = this.get("track");
		var colors = this.get("colors");
		var path = this.getTrackPath(group$1);
		return mix({
			path,
			fill: this.getTrackColor(colors)
		}, trackCfg.style);
	};
	ContinueLegend$1.prototype.resetTrackClip = function(group$1) {
		var container = group$1 || this.get("group");
		var trackId = this.getElementId("track");
		var trackShape = container.findById(trackId);
		var clipShape = trackShape.getClip();
		var attrs = this.getClipTrackAttrs(group$1);
		if (!clipShape) trackShape.setClip({
			type: "rect",
			attrs
		});
		else clipShape.attr(attrs);
	};
	ContinueLegend$1.prototype.resetTrack = function(group$1) {
		var trackId = this.getElementId("track");
		var trackShape = group$1.findById(trackId);
		var trackAttrs = this.getTrackAttrs(group$1);
		if (trackShape) trackShape.attr(trackAttrs);
		else this.addShape(group$1, {
			type: "path",
			id: trackId,
			draggable: this.get("slidable"),
			name: "legend-track",
			attrs: trackAttrs
		});
	};
	ContinueLegend$1.prototype.getPointByValue = function(value$1, group$1) {
		var _a$5 = this.getRange(), min$2 = _a$5.min, max$2 = _a$5.max;
		var percent$1 = (value$1 - min$2) / (max$2 - min$2);
		var bbox = this.getRailBBox(group$1);
		var isVertcal = this.isVertical();
		var point$1 = {
			x: 0,
			y: 0
		};
		if (isVertcal) {
			point$1.x = bbox.minX + bbox.width / 2;
			point$1.y = getValueByPercent(bbox.minY, bbox.maxY, percent$1);
		} else {
			point$1.x = getValueByPercent(bbox.minX, bbox.maxX, percent$1);
			point$1.y = bbox.minY + bbox.height / 2;
		}
		return point$1;
	};
	ContinueLegend$1.prototype.getRailShape = function(group$1) {
		return (group$1 || this.get("group")).findById(this.getElementId("rail"));
	};
	ContinueLegend$1.prototype.getRailBBox = function(group$1) {
		return this.getRailShape(group$1).getBBox();
	};
	ContinueLegend$1.prototype.getRailCanvasBBox = function() {
		return this.get("group").findById(this.getElementId("rail")).getCanvasBBox();
	};
	ContinueLegend$1.prototype.isVertical = function() {
		return this.get("layout") === "vertical";
	};
	ContinueLegend$1.prototype.getValueByCanvasPoint = function(x, y) {
		var _a$5 = this.getRange(), min$2 = _a$5.min, max$2 = _a$5.max;
		var bbox = this.getRailCanvasBBox();
		var isVertcal = this.isVertical();
		var step = this.get("step");
		var percent$1;
		if (isVertcal) percent$1 = (y - bbox.minY) / bbox.height;
		else percent$1 = (x - bbox.minX) / bbox.width;
		var value$1 = getValueByPercent(min$2, max$2, percent$1);
		if (step) {
			var count$1 = Math.round((value$1 - min$2) / step);
			value$1 = min$2 + count$1 * step;
		}
		if (value$1 > max$2) value$1 = max$2;
		if (value$1 < min$2) value$1 = min$2;
		return value$1;
	};
	ContinueLegend$1.prototype.getCurrentValue = function() {
		var value$1 = this.get("value");
		if (!value$1) {
			var values$1 = this.get("values");
			if (!values$1) return [this.get("min"), this.get("max")];
			return [Math.max(Math.min.apply(Math, __spreadArrays(values$1, [this.get("max")])), this.get("min")), Math.min(Math.max.apply(Math, __spreadArrays(values$1, [this.get("min")])), this.get("max"))];
		}
		return value$1;
	};
	ContinueLegend$1.prototype.resetHandlers = function(group$1) {
		var currentValue = this.getCurrentValue();
		var min$2 = currentValue[0], max$2 = currentValue[1];
		this.resetHandler(group$1, "min", min$2);
		this.resetHandler(group$1, "max", max$2);
	};
	ContinueLegend$1.prototype.getHandlerPath = function(handlerCfg, point$1) {
		var isVertical$1 = this.isVertical();
		var path = [];
		var width = handlerCfg.size;
		var x = point$1.x, y = point$1.y;
		var height = width * HANDLER_HEIGHT_RATIO;
		var halfWidth = width / 2;
		var oneSixthWidth = width / 6;
		if (isVertical$1) {
			/**
			* 竖直情况下的滑块 handler，左侧顶点是 x,y
			*  /----|
			*    -- |
			*    -- |
			*  \----|
			*/
			var triangleX = x + height * HANDLER_TRIANGLE_RATIO;
			path.push([
				"M",
				x,
				y
			]);
			path.push([
				"L",
				triangleX,
				y + halfWidth
			]);
			path.push([
				"L",
				x + height,
				y + halfWidth
			]);
			path.push([
				"L",
				x + height,
				y - halfWidth
			]);
			path.push([
				"L",
				triangleX,
				y - halfWidth
			]);
			path.push(["Z"]);
			path.push([
				"M",
				triangleX,
				y + oneSixthWidth
			]);
			path.push([
				"L",
				x + height - 2,
				y + oneSixthWidth
			]);
			path.push([
				"M",
				triangleX,
				y - oneSixthWidth
			]);
			path.push([
				"L",
				x + height - 2,
				y - oneSixthWidth
			]);
		} else {
			/**
			* 水平情况下的滑块，上面顶点处是 x,y
			*  /   \
			* | | | |
			* | | | |
			*  -----
			*/
			var triangleY = y + height * HANDLER_TRIANGLE_RATIO;
			path.push([
				"M",
				x,
				y
			]);
			path.push([
				"L",
				x - halfWidth,
				triangleY
			]);
			path.push([
				"L",
				x - halfWidth,
				y + height
			]);
			path.push([
				"L",
				x + halfWidth,
				y + height
			]);
			path.push([
				"L",
				x + halfWidth,
				triangleY
			]);
			path.push(["Z"]);
			path.push([
				"M",
				x - oneSixthWidth,
				triangleY
			]);
			path.push([
				"L",
				x - oneSixthWidth,
				y + height - 2
			]);
			path.push([
				"M",
				x + oneSixthWidth,
				triangleY
			]);
			path.push([
				"L",
				x + oneSixthWidth,
				y + height - 2
			]);
		}
		return path;
	};
	ContinueLegend$1.prototype.resetHandler = function(group$1, name, value$1) {
		var point$1 = this.getPointByValue(value$1, group$1);
		var handlerCfg = this.get("handler");
		var path = this.getHandlerPath(handlerCfg, point$1);
		var id$1 = this.getElementId("handler-" + name);
		var handlerShape = group$1.findById(id$1);
		var isVertical$1 = this.isVertical();
		if (handlerShape) handlerShape.attr("path", path);
		else this.addShape(group$1, {
			type: "path",
			name: "legend-handler-" + name,
			draggable: true,
			id: id$1,
			attrs: __assign(__assign({ path }, handlerCfg.style), { cursor: isVertical$1 ? "ns-resize" : "ew-resize" })
		});
	};
	ContinueLegend$1.prototype.fixedElements = function(group$1) {
		var railShape = group$1.findById(this.getElementId("rail"));
		var minLabel = group$1.findById(this.getElementId("label-min"));
		var maxLabel = group$1.findById(this.getElementId("label-max"));
		var startPoint = this.getDrawPoint();
		if (this.isVertical()) this.fixedVertail(minLabel, maxLabel, railShape, startPoint);
		else this.fixedHorizontal(minLabel, maxLabel, railShape, startPoint);
	};
	ContinueLegend$1.prototype.fitRailLength = function(minLabelBBox, maxLabelBBox, railBBox, railShape) {
		var lengthField = this.isVertical() ? "height" : "width";
		var labelCfg = this.get("label");
		var labelAlign = labelCfg.align;
		var spacing = labelCfg.spacing;
		var maxLength = this.get("max" + upper_first_default(lengthField));
		if (maxLength) {
			var diff$1 = (labelAlign === "rail" ? railBBox[lengthField] + minLabelBBox[lengthField] + maxLabelBBox[lengthField] + spacing * 2 : railBBox[lengthField]) - maxLength;
			if (diff$1 > 0) this.changeRailLength(railShape, lengthField, railBBox[lengthField] - diff$1);
		}
	};
	ContinueLegend$1.prototype.changeRailLength = function(railShape, lengthField, length$1) {
		var bbox = railShape.getBBox();
		var path;
		if (lengthField === "height") path = this.getRailPath(bbox.x, bbox.y, bbox.width, length$1);
		else path = this.getRailPath(bbox.x, bbox.y, length$1, bbox.height);
		railShape.attr("path", path);
	};
	ContinueLegend$1.prototype.changeRailPosition = function(railShape, x, y) {
		var bbox = railShape.getBBox();
		var path = this.getRailPath(x, y, bbox.width, bbox.height);
		railShape.attr("path", path);
	};
	ContinueLegend$1.prototype.fixedHorizontal = function(minLabel, maxLabel, railShape, startPoint) {
		var labelCfg = this.get("label");
		var labelAlign = labelCfg.align;
		var spacing = labelCfg.spacing;
		var railBBox = railShape.getBBox();
		var minLabelBBox = minLabel.getBBox();
		var maxLabelBBox = maxLabel.getBBox();
		var railHeight = railBBox.height;
		this.fitRailLength(minLabelBBox, maxLabelBBox, railBBox, railShape);
		railBBox = railShape.getBBox();
		if (labelAlign === "rail") {
			minLabel.attr({
				x: startPoint.x,
				y: startPoint.y + railHeight / 2
			});
			this.changeRailPosition(railShape, startPoint.x + minLabelBBox.width + spacing, startPoint.y);
			maxLabel.attr({
				x: startPoint.x + minLabelBBox.width + railBBox.width + spacing * 2,
				y: startPoint.y + railHeight / 2
			});
		} else if (labelAlign === "top") {
			minLabel.attr({
				x: startPoint.x,
				y: startPoint.y
			});
			maxLabel.attr({
				x: startPoint.x + railBBox.width,
				y: startPoint.y
			});
			this.changeRailPosition(railShape, startPoint.x, startPoint.y + minLabelBBox.height + spacing);
		} else {
			this.changeRailPosition(railShape, startPoint.x, startPoint.y);
			minLabel.attr({
				x: startPoint.x,
				y: startPoint.y + railBBox.height + spacing
			});
			maxLabel.attr({
				x: startPoint.x + railBBox.width,
				y: startPoint.y + railBBox.height + spacing
			});
		}
	};
	ContinueLegend$1.prototype.fixedVertail = function(minLabel, maxLabel, railShape, startPoint) {
		var labelCfg = this.get("label");
		var labelAlign = labelCfg.align;
		var spacing = labelCfg.spacing;
		var railBBox = railShape.getBBox();
		var minLabelBBox = minLabel.getBBox();
		var maxLabelBBox = maxLabel.getBBox();
		this.fitRailLength(minLabelBBox, maxLabelBBox, railBBox, railShape);
		railBBox = railShape.getBBox();
		if (labelAlign === "rail") {
			minLabel.attr({
				x: startPoint.x,
				y: startPoint.y
			});
			this.changeRailPosition(railShape, startPoint.x, startPoint.y + minLabelBBox.height + spacing);
			maxLabel.attr({
				x: startPoint.x,
				y: startPoint.y + minLabelBBox.height + railBBox.height + spacing * 2
			});
		} else if (labelAlign === "right") {
			minLabel.attr({
				x: startPoint.x + railBBox.width + spacing,
				y: startPoint.y
			});
			this.changeRailPosition(railShape, startPoint.x, startPoint.y);
			maxLabel.attr({
				x: startPoint.x + railBBox.width + spacing,
				y: startPoint.y + railBBox.height
			});
		} else {
			var maxLabelWidth = Math.max(minLabelBBox.width, maxLabelBBox.width);
			minLabel.attr({
				x: startPoint.x,
				y: startPoint.y
			});
			this.changeRailPosition(railShape, startPoint.x + maxLabelWidth + spacing, startPoint.y);
			maxLabel.attr({
				x: startPoint.x,
				y: startPoint.y + railBBox.height
			});
		}
	};
	return ContinueLegend$1;
}(base_default$11);
var continuous_default = ContinueLegend;

//#endregion
//#region node_modules/@antv/component/esm/tooltip/css-const.js
var css_const_exports = /* @__PURE__ */ __export({
	CONTAINER_CLASS: () => CONTAINER_CLASS,
	CROSSHAIR_X: () => CROSSHAIR_X,
	CROSSHAIR_Y: () => CROSSHAIR_Y,
	LIST_CLASS: () => LIST_CLASS,
	LIST_ITEM_CLASS: () => LIST_ITEM_CLASS,
	MARKER_CLASS: () => MARKER_CLASS,
	NAME_CLASS: () => NAME_CLASS,
	TITLE_CLASS: () => TITLE_CLASS,
	VALUE_CLASS: () => VALUE_CLASS
});
var CONTAINER_CLASS = "g2-tooltip";
var TITLE_CLASS = "g2-tooltip-title";
var LIST_CLASS = "g2-tooltip-list";
var LIST_ITEM_CLASS = "g2-tooltip-list-item";
var MARKER_CLASS = "g2-tooltip-marker";
var VALUE_CLASS = "g2-tooltip-value";
var NAME_CLASS = "g2-tooltip-name";
var CROSSHAIR_X = "g2-tooltip-crosshair-x";
var CROSSHAIR_Y = "g2-tooltip-crosshair-y";

//#endregion
//#region node_modules/@antv/component/esm/tooltip/html-theme.js
var _a$3;
var html_theme_default = (_a$3 = {}, _a$3["" + CONTAINER_CLASS] = {
	position: "absolute",
	visibility: "visible",
	zIndex: 8,
	transition: "visibility 0.2s cubic-bezier(0.23, 1, 0.32, 1), left 0.4s cubic-bezier(0.23, 1, 0.32, 1), top 0.4s cubic-bezier(0.23, 1, 0.32, 1)",
	backgroundColor: "rgba(255, 255, 255, 0.9)",
	boxShadow: "0px 0px 10px #aeaeae",
	borderRadius: "3px",
	color: "rgb(87, 87, 87)",
	fontSize: "12px",
	fontFamily: theme_default.fontFamily,
	lineHeight: "20px",
	padding: "10px 10px 6px 10px"
}, _a$3["" + TITLE_CLASS] = { marginBottom: "4px" }, _a$3["" + LIST_CLASS] = {
	margin: "0px",
	listStyleType: "none",
	padding: "0px"
}, _a$3["" + LIST_ITEM_CLASS] = {
	listStyleType: "none",
	marginBottom: "4px"
}, _a$3["" + MARKER_CLASS] = {
	width: "8px",
	height: "8px",
	borderRadius: "50%",
	display: "inline-block",
	marginRight: "8px"
}, _a$3["" + VALUE_CLASS] = {
	display: "inline-block",
	float: "right",
	marginLeft: "30px"
}, _a$3["" + CROSSHAIR_X] = {
	position: "absolute",
	width: "1px",
	backgroundColor: "rgba(0, 0, 0, 0.25)"
}, _a$3["" + CROSSHAIR_Y] = {
	position: "absolute",
	height: "1px",
	backgroundColor: "rgba(0, 0, 0, 0.25)"
}, _a$3);

//#endregion
//#region node_modules/@antv/component/esm/util/align.js
function getOutSides(x, y, width, height, limitBox) {
	return {
		left: x < limitBox.x,
		right: x + width > limitBox.x + limitBox.width,
		top: y < limitBox.y,
		bottom: y + height > limitBox.y + limitBox.height
	};
}
function getPointByPosition(x, y, offset, width, height, position) {
	var px = x;
	var py = y;
	switch (position) {
		case "left":
			px = x - width - offset;
			py = y - height / 2;
			break;
		case "right":
			px = x + offset;
			py = y - height / 2;
			break;
		case "top":
			px = x - width / 2;
			py = y - height - offset;
			break;
		case "bottom":
			px = x - width / 2;
			py = y + offset;
			break;
		default:
			px = x + offset;
			py = y - height - offset;
			break;
	}
	return {
		x: px,
		y: py
	};
}
function getAlignPoint(x, y, offset, width, height, position, limitBox) {
	var point$1 = getPointByPosition(x, y, offset, width, height, position);
	if (limitBox) {
		var outSides = getOutSides(point$1.x, point$1.y, width, height, limitBox);
		if (position === "auto") {
			if (outSides.right) point$1.x = Math.max(0, x - width - offset);
			if (outSides.top) point$1.y = Math.max(0, y - height - offset);
		} else if (position === "top" || position === "bottom") {
			if (outSides.left) point$1.x = limitBox.x;
			if (outSides.right) point$1.x = limitBox.x + limitBox.width - width;
			if (position === "top" && outSides.top) point$1.y = y + offset;
			if (position === "bottom" && outSides.bottom) point$1.y = y - height - offset;
		} else {
			if (outSides.top) point$1.y = limitBox.y;
			if (outSides.bottom) point$1.y = limitBox.y + limitBox.height - height;
			if (position === "left" && outSides.left) point$1.x = x + offset;
			if (position === "right" && outSides.right) point$1.x = x - width - offset;
		}
	}
	return point$1;
}

//#endregion
//#region node_modules/@antv/component/esm/tooltip/html.js
function hasOneKey(obj, keys$1) {
	var result = false;
	each_default(keys$1, function(key) {
		if (has_key_default(obj, key)) {
			result = true;
			return false;
		}
	});
	return result;
}
var Tooltip$1 = function(_super) {
	__extends(Tooltip$2, _super);
	function Tooltip$2() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	Tooltip$2.prototype.getDefaultCfg = function() {
		var cfg = _super.prototype.getDefaultCfg.call(this);
		return __assign(__assign({}, cfg), {
			name: "tooltip",
			type: "html",
			x: 0,
			y: 0,
			items: [],
			customContent: null,
			containerTpl: "<div class=\"" + CONTAINER_CLASS + "\"><div class=\"" + TITLE_CLASS + "\"></div><ul class=\"" + LIST_CLASS + "\"></ul></div>",
			itemTpl: "<li class=\"" + LIST_ITEM_CLASS + "\" data-index={index}>\n          <span class=\"" + MARKER_CLASS + "\" style=\"background:{color}\"></span>\n          <span class=\"" + NAME_CLASS + "\">{name}</span>:\n          <span class=\"" + VALUE_CLASS + "\">{value}</span>\n        </li>",
			xCrosshairTpl: "<div class=\"" + CROSSHAIR_X + "\"></div>",
			yCrosshairTpl: "<div class=\"" + CROSSHAIR_Y + "\"></div>",
			title: null,
			showTitle: true,
			region: null,
			crosshairsRegion: null,
			containerClassName: CONTAINER_CLASS,
			crosshairs: null,
			offset: 10,
			position: "right",
			domStyles: null,
			defaultStyles: html_theme_default
		});
	};
	Tooltip$2.prototype.render = function() {
		if (this.get("customContent")) this.renderCustomContent();
		else {
			this.resetTitle();
			this.renderItems();
		}
		this.resetPosition();
	};
	Tooltip$2.prototype.clear = function() {
		this.clearCrosshairs();
		this.setTitle("");
		this.clearItemDoms();
	};
	Tooltip$2.prototype.show = function() {
		var container = this.getContainer();
		if (!container || this.destroyed) return;
		this.set("visible", true);
		modifyCSS(container, { visibility: "visible" });
		this.setCrossHairsVisible(true);
	};
	Tooltip$2.prototype.hide = function() {
		var container = this.getContainer();
		if (!container || this.destroyed) return;
		this.set("visible", false);
		modifyCSS(container, { visibility: "hidden" });
		this.setCrossHairsVisible(false);
	};
	Tooltip$2.prototype.getLocation = function() {
		return {
			x: this.get("x"),
			y: this.get("y")
		};
	};
	Tooltip$2.prototype.setLocation = function(point$1) {
		this.set("x", point$1.x);
		this.set("y", point$1.y);
		this.resetPosition();
	};
	Tooltip$2.prototype.setCrossHairsVisible = function(visible) {
		var display = visible ? "" : "none";
		var xCrosshairDom = this.get("xCrosshairDom");
		var yCrosshairDom = this.get("yCrosshairDom");
		xCrosshairDom && modifyCSS(xCrosshairDom, { display });
		yCrosshairDom && modifyCSS(yCrosshairDom, { display });
	};
	Tooltip$2.prototype.initContainer = function() {
		_super.prototype.initContainer.call(this);
		if (this.get("customContent")) {
			if (this.get("container")) this.get("container").remove();
			var container = this.getHtmlContentNode();
			this.get("parent").appendChild(container);
			this.set("container", container);
			this.resetStyles();
			this.applyStyles();
		}
	};
	Tooltip$2.prototype.updateInner = function(cfg) {
		if (this.get("customContent")) this.renderCustomContent();
		else {
			if (hasOneKey(cfg, ["title", "showTitle"])) this.resetTitle();
			if (has_key_default(cfg, "items")) this.renderItems();
		}
		_super.prototype.updateInner.call(this, cfg);
	};
	Tooltip$2.prototype.initDom = function() {
		this.cacheDoms();
	};
	Tooltip$2.prototype.removeDom = function() {
		_super.prototype.removeDom.call(this);
		this.clearCrosshairs();
	};
	Tooltip$2.prototype.resetPosition = function() {
		var x = this.get("x");
		var y = this.get("y");
		var offset = this.get("offset");
		var _a$5 = this.getOffset(), offsetX = _a$5.offsetX, offsetY = _a$5.offsetY;
		var position = this.get("position");
		var region = this.get("region");
		var container = this.getContainer();
		var bbox = this.getBBox();
		var width = bbox.width, height = bbox.height;
		var limitBox;
		if (region) limitBox = regionToBBox(region);
		var point$1 = getAlignPoint(x, y, offset, width, height, position, limitBox);
		modifyCSS(container, {
			left: toPx(point$1.x + offsetX),
			top: toPx(point$1.y + offsetY)
		});
		this.resetCrosshairs();
	};
	Tooltip$2.prototype.renderCustomContent = function() {
		var node = this.getHtmlContentNode();
		var parent = this.get("parent");
		var curContainer = this.get("container");
		if (curContainer && curContainer.parentNode === parent) parent.replaceChild(node, curContainer);
		else parent.appendChild(node);
		this.set("container", node);
		this.resetStyles();
		this.applyStyles();
	};
	Tooltip$2.prototype.getHtmlContentNode = function() {
		var node;
		var customContent = this.get("customContent");
		if (customContent) {
			var elem = customContent(this.get("title"), this.get("items"));
			if (is_element_default(elem)) node = elem;
			else node = createDom$1(elem);
		}
		return node;
	};
	Tooltip$2.prototype.cacheDoms = function() {
		var container = this.getContainer();
		var titleDom = container.getElementsByClassName(TITLE_CLASS)[0];
		var listDom = container.getElementsByClassName(LIST_CLASS)[0];
		this.set("titleDom", titleDom);
		this.set("listDom", listDom);
	};
	Tooltip$2.prototype.resetTitle = function() {
		var title = this.get("title");
		if (this.get("showTitle") && title) this.setTitle(title);
		else this.setTitle("");
	};
	Tooltip$2.prototype.setTitle = function(text) {
		var titleDom = this.get("titleDom");
		if (titleDom) titleDom.innerText = text;
	};
	Tooltip$2.prototype.resetCrosshairs = function() {
		var crosshairsRegion = this.get("crosshairsRegion");
		var crosshairs = this.get("crosshairs");
		if (!crosshairsRegion || !crosshairs) this.clearCrosshairs();
		else {
			var crosshairBox = regionToBBox(crosshairsRegion);
			var xCrosshairDom = this.get("xCrosshairDom");
			var yCrosshairDom = this.get("yCrosshairDom");
			if (crosshairs === "x") {
				this.resetCrosshair("x", crosshairBox);
				if (yCrosshairDom) {
					yCrosshairDom.remove();
					this.set("yCrosshairDom", null);
				}
			} else if (crosshairs === "y") {
				this.resetCrosshair("y", crosshairBox);
				if (xCrosshairDom) {
					xCrosshairDom.remove();
					this.set("xCrosshairDom", null);
				}
			} else {
				this.resetCrosshair("x", crosshairBox);
				this.resetCrosshair("y", crosshairBox);
			}
			this.setCrossHairsVisible(this.get("visible"));
		}
	};
	Tooltip$2.prototype.resetCrosshair = function(name, bbox) {
		var croshairDom = this.checkCrosshair(name);
		var value$1 = this.get(name);
		if (name === "x") modifyCSS(croshairDom, {
			left: toPx(value$1),
			top: toPx(bbox.y),
			height: toPx(bbox.height)
		});
		else modifyCSS(croshairDom, {
			top: toPx(value$1),
			left: toPx(bbox.x),
			width: toPx(bbox.width)
		});
	};
	Tooltip$2.prototype.checkCrosshair = function(name) {
		var domName = name + "CrosshairDom";
		var tplName = name + "CrosshairTpl";
		var constName = "CROSSHAIR_" + name.toUpperCase();
		var styleName = css_const_exports[constName];
		var croshairDom = this.get(domName);
		var parent = this.get("parent");
		if (!croshairDom) {
			croshairDom = createDom$1(this.get(tplName));
			this.applyStyle(styleName, croshairDom);
			parent.appendChild(croshairDom);
			this.set(domName, croshairDom);
		}
		return croshairDom;
	};
	Tooltip$2.prototype.renderItems = function() {
		this.clearItemDoms();
		var items = this.get("items");
		var itemTpl = this.get("itemTpl");
		var listDom = this.get("listDom");
		if (listDom) {
			each_default(items, function(item) {
				var color$2 = esm_default.toCSSGradient(item.color);
				var substituteObj = __assign(__assign({}, item), { color: color$2 });
				var domStr = substitute_default(itemTpl, substituteObj);
				var itemDom = createDom$1(domStr);
				listDom.appendChild(itemDom);
			});
			this.applyChildrenStyles(listDom, this.get("domStyles"));
		}
	};
	Tooltip$2.prototype.clearItemDoms = function() {
		if (this.get("listDom")) clearDom(this.get("listDom"));
	};
	Tooltip$2.prototype.clearCrosshairs = function() {
		var xCrosshairDom = this.get("xCrosshairDom");
		var yCrosshairDom = this.get("yCrosshairDom");
		xCrosshairDom && xCrosshairDom.remove();
		yCrosshairDom && yCrosshairDom.remove();
		this.set("xCrosshairDom", null);
		this.set("yCrosshairDom", null);
	};
	return Tooltip$2;
}(html_component_default);
var html_default = Tooltip$1;

//#endregion
//#region node_modules/@antv/component/esm/trend/constant.js
var BACKGROUND_STYLE$1 = { opacity: 0 };
var LINE_STYLE = {
	stroke: "#C5C5C5",
	strokeOpacity: .85
};
var AREA_STYLE = {
	fill: "#CACED4",
	opacity: .85
};

//#endregion
//#region node_modules/@antv/component/node_modules/@antv/path-util/esm/catmull-rom-2-bezier.js
function smoothBezier$2(points, smooth, isLoop, constraint) {
	var cps = [];
	var hasConstraint = !!constraint;
	var prevPoint;
	var nextPoint;
	var min$2;
	var max$2;
	var nextCp0;
	var cp1;
	var cp0;
	if (hasConstraint) {
		min$2 = constraint[0], max$2 = constraint[1];
		for (var i = 0, l = points.length; i < l; i += 1) {
			var point$1 = points[i];
			min$2 = min$1([0, 0], min$2, point$1);
			max$2 = max$1([0, 0], max$2, point$1);
		}
	}
	for (var i = 0, len = points.length; i < len; i += 1) {
		var point$1 = points[i];
		if (i === 0 && !isLoop) cp0 = point$1;
		else if (i === len - 1 && !isLoop) {
			cp1 = point$1;
			cps.push(cp0);
			cps.push(cp1);
		} else {
			var prevIdx = [i ? i - 1 : len - 1, i - 1][isLoop ? 0 : 1];
			prevPoint = points[prevIdx];
			nextPoint = points[isLoop ? (i + 1) % len : i + 1];
			var v = [0, 0];
			v = sub(v, nextPoint, prevPoint);
			v = scale$3(v, v, smooth);
			var d0 = distance$6(point$1, prevPoint);
			var d1 = distance$6(point$1, nextPoint);
			var sum = d0 + d1;
			if (sum !== 0) {
				d0 /= sum;
				d1 /= sum;
			}
			var v1 = scale$3([0, 0], v, -d0);
			var v2 = scale$3([0, 0], v, d1);
			cp1 = add([0, 0], point$1, v1);
			nextCp0 = add([0, 0], point$1, v2);
			nextCp0 = min$1([0, 0], nextCp0, max$1([0, 0], nextPoint, point$1));
			nextCp0 = max$1([0, 0], nextCp0, min$1([0, 0], nextPoint, point$1));
			v1 = sub([0, 0], nextCp0, point$1);
			v1 = scale$3([0, 0], v1, -d0 / d1);
			cp1 = add([0, 0], point$1, v1);
			cp1 = min$1([0, 0], cp1, max$1([0, 0], prevPoint, point$1));
			cp1 = max$1([0, 0], cp1, min$1([0, 0], prevPoint, point$1));
			v2 = sub([0, 0], point$1, cp1);
			v2 = scale$3([0, 0], v2, d1 / d0);
			nextCp0 = add([0, 0], point$1, v2);
			if (hasConstraint) {
				cp1 = max$1([0, 0], cp1, min$2);
				cp1 = min$1([0, 0], cp1, max$2);
				nextCp0 = max$1([0, 0], nextCp0, min$2);
				nextCp0 = min$1([0, 0], nextCp0, max$2);
			}
			cps.push(cp0);
			cps.push(cp1);
			cp0 = nextCp0;
		}
	}
	if (isLoop) cps.push(cps.shift());
	return cps;
}
/**
* create bezier spline from catmull rom spline
* @param {Array} crp Catmull Rom Points
* @param {boolean} z Spline is loop
* @param {Array} constraint Constraint
*/
function catmullRom2Bezier(crp, z, constraint) {
	if (z === void 0) z = false;
	if (constraint === void 0) constraint = [[0, 0], [1, 1]];
	var isLoop = !!z;
	var pointList = [];
	for (var i = 0, l = crp.length; i < l; i += 2) pointList.push([crp[i], crp[i + 1]]);
	var controlPointList = smoothBezier$2(pointList, .4, isLoop, constraint);
	var len = pointList.length;
	var d1 = [];
	var cp1;
	var cp2;
	var p;
	for (var i = 0; i < len - 1; i += 1) {
		cp1 = controlPointList[i * 2];
		cp2 = controlPointList[i * 2 + 1];
		p = pointList[i + 1];
		d1.push([
			"C",
			cp1[0],
			cp1[1],
			cp2[0],
			cp2[1],
			p[0],
			p[1]
		]);
	}
	if (isLoop) {
		cp1 = controlPointList[len];
		cp2 = controlPointList[len + 1];
		p = pointList[0];
		d1.push([
			"C",
			cp1[0],
			cp1[1],
			cp2[0],
			cp2[1],
			p[0],
			p[1]
		]);
	}
	return d1;
}
var catmull_rom_2_bezier_default = catmullRom2Bezier;

//#endregion
//#region node_modules/@antv/component/node_modules/@antv/path-util/esm/parse-path-string.js
var SPACES$3 = "	\n\v\f\r \xA0 ᠎             　\u2028\u2029";
var PATH_COMMAND$3 = new RegExp("([a-z])[" + SPACES$3 + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + SPACES$3 + "]*,?[" + SPACES$3 + "]*)+)", "ig");
var PATH_VALUES$3 = new RegExp("(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[" + SPACES$3 + "]*,?[" + SPACES$3 + "]*", "ig");

//#endregion
//#region node_modules/@antv/component/node_modules/@antv/path-util/esm/process/arc-2-cubic.js
var TAU$3 = Math.PI * 2;

//#endregion
//#region node_modules/@antv/component/esm/trend/path.js
/**
* 点数组转 path
* @param points
*/
function pointsToPath(points) {
	return map_default(points, function(p, idx) {
		var command = idx === 0 ? "M" : "L";
		var x = p[0], y = p[1];
		return [
			command,
			x,
			y
		];
	});
}
/**
* 将点连接成路径 path
* @param points
*/
function getLinePath$1(points) {
	return pointsToPath(points);
}
/**
* 将点连成平滑的曲线
* @param points
*/
function getSmoothLinePath(points) {
	if (points.length <= 2) return getLinePath$1(points);
	var data$2 = [];
	each_default(points, function(p) {
		if (!is_equal_default(p, data$2.slice(data$2.length - 2))) data$2.push(p[0], p[1]);
	});
	var path = catmull_rom_2_bezier_default(data$2, false);
	var _a$5 = head(points), x = _a$5[0], y = _a$5[1];
	path.unshift([
		"M",
		x,
		y
	]);
	return path;
}
/**
* 将数据转成 path，利用 scale 的归一化能力
* @param data
* @param width
* @param height
* @param smooth
*/
function dataToPath(data$2, width, height, smooth) {
	if (smooth === void 0) smooth = true;
	var y = new linear_default({ values: data$2 });
	var x = new base_default$10({ values: map_default(data$2, function(v, idx) {
		return idx;
	}) });
	var points = map_default(data$2, function(v, idx) {
		return [x.scale(idx) * width, height - y.scale(v) * height];
	});
	return smooth ? getSmoothLinePath(points) : getLinePath$1(points);
}
/**
* 获得 area 面积的横向连接线的 px 位置
* @param data
* @param width
* @param height
*/
function getAreaLineY(data$2, height) {
	var y = new linear_default({ values: data$2 });
	var lineY = y.max < 0 ? y.max : Math.max(0, y.min);
	return height - y.scale(lineY) * height;
}
/**
* 线 path 转 area path
* @param path
* @param width
* @param height
*/
function linePathToAreaPath(path, width, height, data$2) {
	var areaPath = __spreadArrays(path);
	var lineYPx = getAreaLineY(data$2, height);
	areaPath.push([
		"L",
		width,
		lineYPx
	]);
	areaPath.push([
		"L",
		0,
		lineYPx
	]);
	areaPath.push(["Z"]);
	return areaPath;
}

//#endregion
//#region node_modules/@antv/component/esm/trend/trend.js
var Trend = function(_super) {
	__extends(Trend$1, _super);
	function Trend$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	Trend$1.prototype.getDefaultCfg = function() {
		var cfg = _super.prototype.getDefaultCfg.call(this);
		return __assign(__assign({}, cfg), {
			name: "trend",
			x: 0,
			y: 0,
			width: 200,
			height: 16,
			smooth: true,
			isArea: false,
			data: [],
			backgroundStyle: BACKGROUND_STYLE$1,
			lineStyle: LINE_STYLE,
			areaStyle: AREA_STYLE
		});
	};
	Trend$1.prototype.renderInner = function(group$1) {
		var _a$5 = this.cfg, width = _a$5.width, height = _a$5.height, data$2 = _a$5.data, smooth = _a$5.smooth, isArea = _a$5.isArea, backgroundStyle = _a$5.backgroundStyle, lineStyle = _a$5.lineStyle, areaStyle = _a$5.areaStyle;
		this.addShape(group$1, {
			id: this.getElementId("background"),
			type: "rect",
			attrs: __assign({
				x: 0,
				y: 0,
				width,
				height
			}, backgroundStyle)
		});
		var path = dataToPath(data$2, width, height, smooth);
		this.addShape(group$1, {
			id: this.getElementId("line"),
			type: "path",
			attrs: __assign({ path }, lineStyle)
		});
		if (isArea) {
			var areaPath = linePathToAreaPath(path, width, height, data$2);
			this.addShape(group$1, {
				id: this.getElementId("area"),
				type: "path",
				attrs: __assign({ path: areaPath }, areaStyle)
			});
		}
	};
	Trend$1.prototype.applyOffset = function() {
		var _a$5 = this.cfg, x = _a$5.x, y = _a$5.y;
		this.moveElementTo(this.get("group"), {
			x,
			y
		});
	};
	return Trend$1;
}(group_component_default);

//#endregion
//#region node_modules/@antv/component/esm/slider/handler.js
var DEFAULT_HANDLER_STYLE = {
	fill: "#F7F7F7",
	stroke: "#BFBFBF",
	radius: 2,
	opacity: 1,
	cursor: "ew-resize",
	highLightFill: "#FFF"
};
var Handler = function(_super) {
	__extends(Handler$1, _super);
	function Handler$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	Handler$1.prototype.getDefaultCfg = function() {
		var cfg = _super.prototype.getDefaultCfg.call(this);
		return __assign(__assign({}, cfg), {
			name: "handler",
			x: 0,
			y: 0,
			width: 10,
			height: 24,
			style: DEFAULT_HANDLER_STYLE
		});
	};
	Handler$1.prototype.renderInner = function(group$1) {
		var _a$5 = this.cfg, width = _a$5.width, height = _a$5.height, style = _a$5.style;
		var fill = style.fill, stroke = style.stroke, radius = style.radius, opacity = style.opacity, cursor = style.cursor;
		this.addShape(group$1, {
			type: "rect",
			id: this.getElementId("background"),
			attrs: {
				x: 0,
				y: 0,
				width,
				height,
				fill,
				stroke,
				radius,
				opacity,
				cursor
			}
		});
		var x1 = 1 / 3 * width;
		var x2 = 2 / 3 * width;
		var y1 = 1 / 4 * height;
		var y2 = 3 / 4 * height;
		this.addShape(group$1, {
			id: this.getElementId("line-left"),
			type: "line",
			attrs: {
				x1,
				y1,
				x2: x1,
				y2,
				stroke,
				cursor
			}
		});
		this.addShape(group$1, {
			id: this.getElementId("line-right"),
			type: "line",
			attrs: {
				x1: x2,
				y1,
				x2,
				y2,
				stroke,
				cursor
			}
		});
	};
	Handler$1.prototype.applyOffset = function() {
		this.moveElementTo(this.get("group"), {
			x: this.get("x"),
			y: this.get("y")
		});
	};
	Handler$1.prototype.initEvent = function() {
		this.bindEvents();
	};
	Handler$1.prototype.bindEvents = function() {
		var _this = this;
		this.get("group").on("mouseenter", function() {
			var highLightFill = _this.get("style").highLightFill;
			_this.getElementByLocalId("background").attr("fill", highLightFill);
			_this.draw();
		});
		this.get("group").on("mouseleave", function() {
			var fill = _this.get("style").fill;
			_this.getElementByLocalId("background").attr("fill", fill);
			_this.draw();
		});
	};
	Handler$1.prototype.draw = function() {
		var canvas = this.get("container").get("canvas");
		if (canvas) canvas.draw();
	};
	return Handler$1;
}(group_component_default);

//#endregion
//#region node_modules/@antv/component/esm/slider/constant.js
/**
* 一些默认的样式配置
*/
var BACKGROUND_STYLE = {
	fill: "#416180",
	opacity: .05
};
var FOREGROUND_STYLE = {
	fill: "#5B8FF9",
	opacity: .15,
	cursor: "move"
};
var DEFAULT_HANDLER_WIDTH = 10;
var HANDLER_STYLE = {
	width: DEFAULT_HANDLER_WIDTH,
	height: 24
};
var TEXT_STYLE = {
	textBaseline: "middle",
	fill: "#000",
	opacity: .45
};
var SLIDER_CHANGE = "sliderchange";

//#endregion
//#region node_modules/@antv/component/esm/slider/slider.js
var Slider = function(_super) {
	__extends(Slider$2, _super);
	function Slider$2() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.onMouseDown = function(target) {
			return function(e) {
				_this.currentTarget = target;
				var event = e.originalEvent;
				event.stopPropagation();
				event.preventDefault();
				_this.prevX = get_default(event, "touches.0.pageX", event.pageX);
				_this.prevY = get_default(event, "touches.0.pageY", event.pageY);
				var containerDOM = _this.getContainerDOM();
				containerDOM.addEventListener("mousemove", _this.onMouseMove);
				containerDOM.addEventListener("mouseup", _this.onMouseUp);
				containerDOM.addEventListener("mouseleave", _this.onMouseUp);
				containerDOM.addEventListener("touchmove", _this.onMouseMove);
				containerDOM.addEventListener("touchend", _this.onMouseUp);
				containerDOM.addEventListener("touchcancel", _this.onMouseUp);
			};
		};
		_this.onMouseMove = function(event) {
			var width = _this.cfg.width;
			var originValue = [_this.get("start"), _this.get("end")];
			event.stopPropagation();
			event.preventDefault();
			var x = get_default(event, "touches.0.pageX", event.pageX);
			var y = get_default(event, "touches.0.pageY", event.pageY);
			var offsetX = x - _this.prevX;
			var offsetXRange = _this.adjustOffsetRange(offsetX / width);
			_this.updateStartEnd(offsetXRange);
			_this.updateUI(_this.getElementByLocalId("foreground"), _this.getElementByLocalId("minText"), _this.getElementByLocalId("maxText"));
			_this.prevX = x;
			_this.prevY = y;
			_this.draw();
			_this.emit(SLIDER_CHANGE, [_this.get("start"), _this.get("end")].sort());
			_this.delegateEmit("valuechanged", {
				originValue,
				value: [_this.get("start"), _this.get("end")]
			});
		};
		_this.onMouseUp = function() {
			if (_this.currentTarget) _this.currentTarget = void 0;
			var containerDOM = _this.getContainerDOM();
			if (containerDOM) {
				containerDOM.removeEventListener("mousemove", _this.onMouseMove);
				containerDOM.removeEventListener("mouseup", _this.onMouseUp);
				containerDOM.removeEventListener("mouseleave", _this.onMouseUp);
				containerDOM.removeEventListener("touchmove", _this.onMouseMove);
				containerDOM.removeEventListener("touchend", _this.onMouseUp);
				containerDOM.removeEventListener("touchcancel", _this.onMouseUp);
			}
		};
		return _this;
	}
	Slider$2.prototype.setRange = function(min$2, max$2) {
		this.set("minLimit", min$2);
		this.set("maxLimit", max$2);
		var oldStart = this.get("start");
		var oldEnd = this.get("end");
		var newStart = clamp_default(oldStart, min$2, max$2);
		var newEnd = clamp_default(oldEnd, min$2, max$2);
		if (!this.get("isInit") && (oldStart !== newStart || oldEnd !== newEnd)) this.setValue([newStart, newEnd]);
	};
	Slider$2.prototype.getRange = function() {
		return {
			min: this.get("minLimit") || 0,
			max: this.get("maxLimit") || 1
		};
	};
	Slider$2.prototype.setValue = function(value$1) {
		var range = this.getRange();
		if (is_array_default(value$1) && value$1.length === 2) {
			var originValue = [this.get("start"), this.get("end")];
			this.update({
				start: clamp_default(value$1[0], range.min, range.max),
				end: clamp_default(value$1[1], range.min, range.max)
			});
			if (!this.get("updateAutoRender")) this.render();
			this.delegateEmit("valuechanged", {
				originValue,
				value: value$1
			});
		}
	};
	Slider$2.prototype.getValue = function() {
		return [this.get("start"), this.get("end")];
	};
	Slider$2.prototype.getDefaultCfg = function() {
		var cfg = _super.prototype.getDefaultCfg.call(this);
		return __assign(__assign({}, cfg), {
			name: "slider",
			x: 0,
			y: 0,
			width: 100,
			height: 16,
			backgroundStyle: {},
			foregroundStyle: {},
			handlerStyle: {},
			textStyle: {},
			defaultCfg: {
				backgroundStyle: BACKGROUND_STYLE,
				foregroundStyle: FOREGROUND_STYLE,
				handlerStyle: HANDLER_STYLE,
				textStyle: TEXT_STYLE
			}
		});
	};
	Slider$2.prototype.update = function(cfg) {
		var start = cfg.start, end = cfg.end;
		var validCfg = __assign({}, cfg);
		if (!is_nil_default(start)) validCfg.start = clamp_default(start, 0, 1);
		if (!is_nil_default(end)) validCfg.end = clamp_default(end, 0, 1);
		_super.prototype.update.call(this, validCfg);
		this.minHandler = this.getChildComponentById(this.getElementId("minHandler"));
		this.maxHandler = this.getChildComponentById(this.getElementId("maxHandler"));
		this.trend = this.getChildComponentById(this.getElementId("trend"));
	};
	Slider$2.prototype.init = function() {
		this.set("start", clamp_default(this.get("start"), 0, 1));
		this.set("end", clamp_default(this.get("end"), 0, 1));
		_super.prototype.init.call(this);
	};
	Slider$2.prototype.render = function() {
		_super.prototype.render.call(this);
		this.updateUI(this.getElementByLocalId("foreground"), this.getElementByLocalId("minText"), this.getElementByLocalId("maxText"));
	};
	Slider$2.prototype.renderInner = function(group$1) {
		var _a$5 = this.cfg, start = _a$5.start, end = _a$5.end, width = _a$5.width, height = _a$5.height, _b = _a$5.trendCfg, trendCfg = _b === void 0 ? {} : _b, minText = _a$5.minText, maxText = _a$5.maxText, _c = _a$5.backgroundStyle, backgroundStyle = _c === void 0 ? {} : _c, _d = _a$5.foregroundStyle, foregroundStyle = _d === void 0 ? {} : _d, _e = _a$5.textStyle, textStyle$1 = _e === void 0 ? {} : _e;
		var handlerStyle = deep_mix_default({}, DEFAULT_HANDLER_STYLE, this.cfg.handlerStyle);
		start * width;
		end * width;
		if (size(get_default(trendCfg, "data"))) this.trend = this.addComponent(group$1, __assign({
			component: Trend,
			id: this.getElementId("trend"),
			x: 0,
			y: 0,
			width,
			height
		}, trendCfg));
		this.addShape(group$1, {
			id: this.getElementId("background"),
			type: "rect",
			attrs: __assign({
				x: 0,
				y: 0,
				width,
				height
			}, backgroundStyle)
		});
		this.addShape(group$1, {
			id: this.getElementId("minText"),
			type: "text",
			attrs: __assign({
				y: height / 2,
				textAlign: "right",
				text: minText,
				silent: false
			}, textStyle$1)
		});
		this.addShape(group$1, {
			id: this.getElementId("maxText"),
			type: "text",
			attrs: __assign({
				y: height / 2,
				textAlign: "left",
				text: maxText,
				silent: false
			}, textStyle$1)
		});
		this.addShape(group$1, {
			id: this.getElementId("foreground"),
			name: "foreground",
			type: "rect",
			attrs: __assign({
				y: 0,
				height
			}, foregroundStyle)
		});
		var handlerWidth = get_default(handlerStyle, "width", DEFAULT_HANDLER_WIDTH);
		var handlerHeight = get_default(handlerStyle, "height", 24);
		this.minHandler = this.addComponent(group$1, {
			component: Handler,
			id: this.getElementId("minHandler"),
			name: "handler-min",
			x: 0,
			y: (height - handlerHeight) / 2,
			width: handlerWidth,
			height: handlerHeight,
			cursor: "ew-resize",
			style: handlerStyle
		});
		this.maxHandler = this.addComponent(group$1, {
			component: Handler,
			id: this.getElementId("maxHandler"),
			name: "handler-max",
			x: 0,
			y: (height - handlerHeight) / 2,
			width: handlerWidth,
			height: handlerHeight,
			cursor: "ew-resize",
			style: handlerStyle
		});
	};
	Slider$2.prototype.applyOffset = function() {
		this.moveElementTo(this.get("group"), {
			x: this.get("x"),
			y: this.get("y")
		});
	};
	Slider$2.prototype.initEvent = function() {
		this.bindEvents();
	};
	Slider$2.prototype.updateUI = function(foregroundShape, minTextShape, maxTextShape) {
		var _a$5 = this.cfg, start = _a$5.start, end = _a$5.end, width = _a$5.width, minText = _a$5.minText, maxText = _a$5.maxText, handlerStyle = _a$5.handlerStyle, height = _a$5.height;
		var min$2 = start * width;
		var max$2 = end * width;
		if (this.trend) {
			this.trend.update({
				width,
				height
			});
			if (!this.get("updateAutoRender")) this.trend.render();
		}
		foregroundShape.attr("x", min$2);
		foregroundShape.attr("width", max$2 - min$2);
		var handlerWidth = get_default(handlerStyle, "width", DEFAULT_HANDLER_WIDTH);
		minTextShape.attr("text", minText);
		maxTextShape.attr("text", maxText);
		var _b = this._dodgeText([min$2, max$2], minTextShape, maxTextShape), minAttrs = _b[0], maxAttrs = _b[1];
		if (this.minHandler) {
			this.minHandler.update({ x: min$2 - handlerWidth / 2 });
			if (!this.get("updateAutoRender")) this.minHandler.render();
		}
		each_default(minAttrs, function(v, k) {
			return minTextShape.attr(k, v);
		});
		if (this.maxHandler) {
			this.maxHandler.update({ x: max$2 - handlerWidth / 2 });
			if (!this.get("updateAutoRender")) this.maxHandler.render();
		}
		each_default(maxAttrs, function(v, k) {
			return maxTextShape.attr(k, v);
		});
	};
	Slider$2.prototype.bindEvents = function() {
		var group$1 = this.get("group");
		group$1.on("handler-min:mousedown", this.onMouseDown("minHandler"));
		group$1.on("handler-min:touchstart", this.onMouseDown("minHandler"));
		group$1.on("handler-max:mousedown", this.onMouseDown("maxHandler"));
		group$1.on("handler-max:touchstart", this.onMouseDown("maxHandler"));
		var foreground = group$1.findById(this.getElementId("foreground"));
		foreground.on("mousedown", this.onMouseDown("foreground"));
		foreground.on("touchstart", this.onMouseDown("foreground"));
	};
	/**
	* 调整 offsetRange，因为一些范围的限制
	* @param offsetRange
	*/
	Slider$2.prototype.adjustOffsetRange = function(offsetRange) {
		var _a$5 = this.cfg, start = _a$5.start, end = _a$5.end;
		switch (this.currentTarget) {
			case "minHandler":
				var min$2 = 0 - start;
				var max$2 = 1 - start;
				return Math.min(max$2, Math.max(min$2, offsetRange));
			case "maxHandler":
				var min$2 = 0 - end;
				var max$2 = 1 - end;
				return Math.min(max$2, Math.max(min$2, offsetRange));
			case "foreground":
				var min$2 = 0 - start;
				var max$2 = 1 - end;
				return Math.min(max$2, Math.max(min$2, offsetRange));
		}
	};
	Slider$2.prototype.updateStartEnd = function(offsetRange) {
		var _a$5 = this.cfg, start = _a$5.start, end = _a$5.end;
		switch (this.currentTarget) {
			case "minHandler":
				start += offsetRange;
				break;
			case "maxHandler":
				end += offsetRange;
				break;
			case "foreground":
				start += offsetRange;
				end += offsetRange;
				break;
		}
		this.set("start", start);
		this.set("end", end);
	};
	/**
	* 调整 text 的位置，自动躲避
	* 根据位置，调整返回新的位置
	* @param range
	*/
	Slider$2.prototype._dodgeText = function(range, minTextShape, maxTextShape) {
		var _a$5, _b;
		var _c = this.cfg, handlerStyle = _c.handlerStyle, width = _c.width;
		var PADDING$1 = 2;
		var handlerWidth = get_default(handlerStyle, "width", DEFAULT_HANDLER_WIDTH);
		var min$2 = range[0], max$2 = range[1];
		var sorted = false;
		if (min$2 > max$2) {
			_a$5 = [max$2, min$2], min$2 = _a$5[0], max$2 = _a$5[1];
			_b = [maxTextShape, minTextShape], minTextShape = _b[0], maxTextShape = _b[1];
			sorted = true;
		}
		var minBBox = minTextShape.getBBox();
		var maxBBox = maxTextShape.getBBox();
		var minAttrs = minBBox.width > min$2 - PADDING$1 ? {
			x: min$2 + handlerWidth / 2 + PADDING$1,
			textAlign: "left"
		} : {
			x: min$2 - handlerWidth / 2 - PADDING$1,
			textAlign: "right"
		};
		var maxAttrs = maxBBox.width > width - max$2 - PADDING$1 ? {
			x: max$2 - handlerWidth / 2 - PADDING$1,
			textAlign: "right"
		} : {
			x: max$2 + handlerWidth / 2 + PADDING$1,
			textAlign: "left"
		};
		return !sorted ? [minAttrs, maxAttrs] : [maxAttrs, minAttrs];
	};
	Slider$2.prototype.draw = function() {
		var container = this.get("container");
		var canvas = container && container.get("canvas");
		if (canvas) canvas.draw();
	};
	Slider$2.prototype.getContainerDOM = function() {
		var container = this.get("container");
		var canvas = container && container.get("canvas");
		return canvas && canvas.get("container");
	};
	return Slider$2;
}(group_component_default);

//#endregion
//#region node_modules/@antv/component/esm/scrollbar/scrollbar.js
var DEFAULT_STYLE = {
	trackColor: "rgba(0,0,0,0)",
	thumbColor: "rgba(0,0,0,0.15)",
	size: 8,
	lineCap: "round"
};
var DEFAULT_THEME = {
	default: DEFAULT_STYLE,
	hover: { thumbColor: "rgba(0,0,0,0.2)" }
};
var Scrollbar = function(_super) {
	__extends(Scrollbar$2, _super);
	function Scrollbar$2() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.clearEvents = noop_default;
		_this.onStartEvent = function(isMobile) {
			return function(e) {
				_this.isMobile = isMobile;
				e.originalEvent.preventDefault();
				var clientX = isMobile ? get_default(e.originalEvent, "touches.0.clientX") : e.clientX;
				var clientY = isMobile ? get_default(e.originalEvent, "touches.0.clientY") : e.clientY;
				_this.startPos = _this.cfg.isHorizontal ? clientX : clientY;
				_this.bindLaterEvent();
			};
		};
		_this.bindLaterEvent = function() {
			var containerDOM = _this.getContainerDOM();
			var events = [];
			if (_this.isMobile) events = [
				addEventListener(containerDOM, "touchmove", _this.onMouseMove),
				addEventListener(containerDOM, "touchend", _this.onMouseUp),
				addEventListener(containerDOM, "touchcancel", _this.onMouseUp)
			];
			else events = [
				addEventListener(containerDOM, "mousemove", _this.onMouseMove),
				addEventListener(containerDOM, "mouseup", _this.onMouseUp),
				addEventListener(containerDOM, "mouseleave", _this.onMouseUp)
			];
			_this.clearEvents = function() {
				events.forEach(function(e) {
					e.remove();
				});
			};
		};
		_this.onMouseMove = function(e) {
			var _a$5 = _this.cfg, isHorizontal$1 = _a$5.isHorizontal, thumbOffset = _a$5.thumbOffset;
			e.preventDefault();
			var clientX = _this.isMobile ? get_default(e, "touches.0.clientX") : e.clientX;
			var clientY = _this.isMobile ? get_default(e, "touches.0.clientY") : e.clientY;
			var endPos = isHorizontal$1 ? clientX : clientY;
			var diff$1 = endPos - _this.startPos;
			_this.startPos = endPos;
			_this.updateThumbOffset(thumbOffset + diff$1);
		};
		_this.onMouseUp = function(e) {
			e.preventDefault();
			_this.clearEvents();
		};
		_this.onTrackClick = function(e) {
			var _a$5 = _this.cfg, isHorizontal$1 = _a$5.isHorizontal, x = _a$5.x, y = _a$5.y, thumbLen = _a$5.thumbLen;
			var rect$1 = _this.getContainerDOM().getBoundingClientRect();
			var clientX = e.clientX, clientY = e.clientY;
			var offset = isHorizontal$1 ? clientX - rect$1.left - x - thumbLen / 2 : clientY - rect$1.top - y - thumbLen / 2;
			var newOffset = _this.validateRange(offset);
			_this.updateThumbOffset(newOffset);
		};
		_this.onThumbMouseOver = function() {
			var thumbColor = _this.cfg.theme.hover.thumbColor;
			_this.getElementByLocalId("thumb").attr("stroke", thumbColor);
			_this.draw();
		};
		_this.onThumbMouseOut = function() {
			var thumbColor = _this.cfg.theme.default.thumbColor;
			_this.getElementByLocalId("thumb").attr("stroke", thumbColor);
			_this.draw();
		};
		return _this;
	}
	Scrollbar$2.prototype.setRange = function(min$2, max$2) {
		this.set("minLimit", min$2);
		this.set("maxLimit", max$2);
		var curValue = this.getValue();
		var newValue = clamp_default(curValue, min$2, max$2);
		if (curValue !== newValue && !this.get("isInit")) this.setValue(newValue);
	};
	Scrollbar$2.prototype.getRange = function() {
		var min$2 = this.get("minLimit") || 0;
		var max$2 = this.get("maxLimit") || 1;
		return {
			min: min$2,
			max: max$2
		};
	};
	Scrollbar$2.prototype.setValue = function(value$1) {
		var range = this.getRange();
		var originalValue = this.getValue();
		this.update({ thumbOffset: (this.get("trackLen") - this.get("thumbLen")) * clamp_default(value$1, range.min, range.max) });
		this.delegateEmit("valuechange", {
			originalValue,
			value: this.getValue()
		});
	};
	Scrollbar$2.prototype.getValue = function() {
		return clamp_default(this.get("thumbOffset") / (this.get("trackLen") - this.get("thumbLen")), 0, 1);
	};
	Scrollbar$2.prototype.getDefaultCfg = function() {
		var cfg = _super.prototype.getDefaultCfg.call(this);
		return __assign(__assign({}, cfg), {
			name: "scrollbar",
			isHorizontal: true,
			minThumbLen: 20,
			thumbOffset: 0,
			theme: DEFAULT_THEME
		});
	};
	Scrollbar$2.prototype.renderInner = function(group$1) {
		this.renderTrackShape(group$1);
		this.renderThumbShape(group$1);
	};
	Scrollbar$2.prototype.applyOffset = function() {
		this.moveElementTo(this.get("group"), {
			x: this.get("x"),
			y: this.get("y")
		});
	};
	Scrollbar$2.prototype.initEvent = function() {
		this.bindEvents();
	};
	Scrollbar$2.prototype.renderTrackShape = function(group$1) {
		var _a$5 = this.cfg, trackLen = _a$5.trackLen, _b = _a$5.theme;
		var _c = deep_mix_default({}, DEFAULT_THEME, _b === void 0 ? { default: {} } : _b).default, lineCap = _c.lineCap, trackColor = _c.trackColor, themeSize = _c.size;
		var size$1 = get_default(this.cfg, "size", themeSize);
		var attrs = this.get("isHorizontal") ? {
			x1: 0 + size$1 / 2,
			y1: size$1 / 2,
			x2: trackLen - size$1 / 2,
			y2: size$1 / 2,
			lineWidth: size$1,
			stroke: trackColor,
			lineCap
		} : {
			x1: size$1 / 2,
			y1: 0 + size$1 / 2,
			x2: size$1 / 2,
			y2: trackLen - size$1 / 2,
			lineWidth: size$1,
			stroke: trackColor,
			lineCap
		};
		return this.addShape(group$1, {
			id: this.getElementId("track"),
			name: "track",
			type: "line",
			attrs
		});
	};
	Scrollbar$2.prototype.renderThumbShape = function(group$1) {
		var _a$5 = this.cfg, thumbOffset = _a$5.thumbOffset, thumbLen = _a$5.thumbLen, theme$3 = _a$5.theme;
		var _b = deep_mix_default({}, DEFAULT_THEME, theme$3).default, themeSize = _b.size, lineCap = _b.lineCap, thumbColor = _b.thumbColor;
		var size$1 = get_default(this.cfg, "size", themeSize);
		var attrs = this.get("isHorizontal") ? {
			x1: thumbOffset + size$1 / 2,
			y1: size$1 / 2,
			x2: thumbOffset + thumbLen - size$1 / 2,
			y2: size$1 / 2,
			lineWidth: size$1,
			stroke: thumbColor,
			lineCap,
			cursor: "default"
		} : {
			x1: size$1 / 2,
			y1: thumbOffset + size$1 / 2,
			x2: size$1 / 2,
			y2: thumbOffset + thumbLen - size$1 / 2,
			lineWidth: size$1,
			stroke: thumbColor,
			lineCap,
			cursor: "default"
		};
		return this.addShape(group$1, {
			id: this.getElementId("thumb"),
			name: "thumb",
			type: "line",
			attrs
		});
	};
	Scrollbar$2.prototype.bindEvents = function() {
		var group$1 = this.get("group");
		group$1.on("mousedown", this.onStartEvent(false));
		group$1.on("mouseup", this.onMouseUp);
		group$1.on("touchstart", this.onStartEvent(true));
		group$1.on("touchend", this.onMouseUp);
		group$1.findById(this.getElementId("track")).on("click", this.onTrackClick);
		var thumbShape = group$1.findById(this.getElementId("thumb"));
		thumbShape.on("mouseover", this.onThumbMouseOver);
		thumbShape.on("mouseout", this.onThumbMouseOut);
	};
	Scrollbar$2.prototype.getContainerDOM = function() {
		var container = this.get("container");
		var canvas = container && container.get("canvas");
		return canvas && canvas.get("container");
	};
	Scrollbar$2.prototype.validateRange = function(offset) {
		var _a$5 = this.cfg, thumbLen = _a$5.thumbLen, trackLen = _a$5.trackLen;
		var newOffset = offset;
		if (offset + thumbLen > trackLen) newOffset = trackLen - thumbLen;
		else if (offset + thumbLen < thumbLen) newOffset = 0;
		return newOffset;
	};
	Scrollbar$2.prototype.draw = function() {
		var container = this.get("container");
		var canvas = container && container.get("canvas");
		if (canvas) canvas.draw();
	};
	Scrollbar$2.prototype.updateThumbOffset = function(offset) {
		var _a$5 = this.cfg, thumbOffset = _a$5.thumbOffset, isHorizontal$1 = _a$5.isHorizontal, thumbLen = _a$5.thumbLen, size$1 = _a$5.size;
		var newOffset = this.validateRange(offset);
		if (newOffset === thumbOffset) return;
		var thumbShape = this.getElementByLocalId("thumb");
		if (isHorizontal$1) thumbShape.attr({
			x1: newOffset + size$1 / 2,
			x2: newOffset + thumbLen - size$1 / 2
		});
		else thumbShape.attr({
			y1: newOffset + size$1 / 2,
			y2: newOffset + thumbLen - size$1 / 2
		});
		this.emitOffsetChange(newOffset);
	};
	Scrollbar$2.prototype.emitOffsetChange = function(offset) {
		var _a$5 = this.cfg, originalValue = _a$5.thumbOffset, trackLen = _a$5.trackLen, thumbLen = _a$5.thumbLen;
		this.cfg.thumbOffset = offset;
		this.emit("scrollchange", {
			thumbOffset: offset,
			ratio: clamp_default(offset / (trackLen - thumbLen), 0, 1)
		});
		this.delegateEmit("valuechange", {
			originalValue,
			value: offset
		});
	};
	return Scrollbar$2;
}(group_component_default);

//#endregion
//#region node_modules/@antv/g2/esm/dependents.js
var LineAxis = line_default$6, CircleAxis = circle_default$7;
var LineGrid = line_default$4, CircleGrid = circle_default$5;
var CategoryLegend = category_default, ContinuousLegend = continuous_default;
var HtmlTooltip = html_default;

//#endregion
//#region node_modules/@antv/g2/esm/util/graphics.js
function getPointsBox(points) {
	if (is_empty_default(points)) return null;
	var minX = points[0].x;
	var maxX = points[0].x;
	var minY = points[0].y;
	var maxY$1 = points[0].y;
	each_default(points, function(point$1) {
		minX = minX > point$1.x ? point$1.x : minX;
		maxX = maxX < point$1.x ? point$1.x : maxX;
		minY = minY > point$1.y ? point$1.y : minY;
		maxY$1 = maxY$1 < point$1.y ? point$1.y : maxY$1;
	});
	return {
		minX,
		maxX,
		minY,
		maxY: maxY$1,
		centerX: (minX + maxX) / 2,
		centerY: (minY + maxY$1) / 2
	};
}
function uniqueValues(array) {
	return Array.from(new Set(array)).length === 1;
}
function mid(array) {
	return (min_default(array) + max_default(array)) / 2;
}
/**
* @ignore
* 根据弧度计算极坐标系下的坐标点
* @param centerX
* @param centerY
* @param radius
* @param angleInRadian
* @returns
*/
function polarToCartesian(centerX, centerY, radius, angleInRadian) {
	return {
		x: centerX + radius * Math.cos(angleInRadian),
		y: centerY + radius * Math.sin(angleInRadian)
	};
}
/**
* @ignore
* 根据起始角度计算绘制扇形的 path
* @param centerX
* @param centerY
* @param radius
* @param startAngleInRadian
* @param endAngleInRadian
* @returns
*/
function getSectorPath(centerX, centerY, radius, startAngleInRadian, endAngleInRadian, innerRadius) {
	if (innerRadius === void 0) innerRadius = 0;
	var start = polarToCartesian(centerX, centerY, radius, startAngleInRadian);
	var end = polarToCartesian(centerX, centerY, radius, endAngleInRadian);
	var innerStart = polarToCartesian(centerX, centerY, innerRadius, startAngleInRadian);
	var innerEnd = polarToCartesian(centerX, centerY, innerRadius, endAngleInRadian);
	if (endAngleInRadian - startAngleInRadian === Math.PI * 2) {
		var middlePoint = polarToCartesian(centerX, centerY, radius, startAngleInRadian + Math.PI);
		var innerMiddlePoint = polarToCartesian(centerX, centerY, innerRadius, startAngleInRadian + Math.PI);
		var circlePathCommands = [
			[
				"M",
				start.x,
				start.y
			],
			[
				"A",
				radius,
				radius,
				0,
				1,
				1,
				middlePoint.x,
				middlePoint.y
			],
			[
				"A",
				radius,
				radius,
				0,
				1,
				1,
				end.x,
				end.y
			],
			[
				"M",
				innerStart.x,
				innerStart.y
			]
		];
		if (innerRadius) {
			circlePathCommands.push([
				"A",
				innerRadius,
				innerRadius,
				0,
				1,
				0,
				innerMiddlePoint.x,
				innerMiddlePoint.y
			]);
			circlePathCommands.push([
				"A",
				innerRadius,
				innerRadius,
				0,
				1,
				0,
				innerEnd.x,
				innerEnd.y
			]);
		}
		circlePathCommands.push([
			"M",
			start.x,
			start.y
		]);
		circlePathCommands.push(["Z"]);
		return circlePathCommands;
	}
	var arcSweep = endAngleInRadian - startAngleInRadian <= Math.PI ? 0 : 1;
	var sectorPathCommands = [
		[
			"M",
			start.x,
			start.y
		],
		[
			"A",
			radius,
			radius,
			0,
			arcSweep,
			1,
			end.x,
			end.y
		],
		[
			"L",
			innerEnd.x,
			innerEnd.y
		]
	];
	if (innerRadius) sectorPathCommands.push([
		"A",
		innerRadius,
		innerRadius,
		0,
		arcSweep,
		0,
		innerStart.x,
		innerStart.y
	]);
	sectorPathCommands.push([
		"L",
		start.x,
		start.y
	]);
	sectorPathCommands.push(["Z"]);
	return sectorPathCommands;
}
/**
* @ignore
* Gets arc path
* @param centerX
* @param centerY
* @param radius
* @param startAngleInRadian
* @param endAngleInRadian
* @returns
*/
function getArcPath(centerX, centerY, radius, startAngleInRadian, endAngleInRadian) {
	var start = polarToCartesian(centerX, centerY, radius, startAngleInRadian);
	var end = polarToCartesian(centerX, centerY, radius, endAngleInRadian);
	if (isNumberEqual(endAngleInRadian - startAngleInRadian, Math.PI * 2)) {
		var middlePoint = polarToCartesian(centerX, centerY, radius, startAngleInRadian + Math.PI);
		return [
			[
				"M",
				start.x,
				start.y
			],
			[
				"A",
				radius,
				radius,
				0,
				1,
				1,
				middlePoint.x,
				middlePoint.y
			],
			[
				"A",
				radius,
				radius,
				0,
				1,
				1,
				start.x,
				start.y
			],
			[
				"A",
				radius,
				radius,
				0,
				1,
				0,
				middlePoint.x,
				middlePoint.y
			],
			[
				"A",
				radius,
				radius,
				0,
				1,
				0,
				start.x,
				start.y
			],
			["Z"]
		];
	}
	var arcSweep = endAngleInRadian - startAngleInRadian <= Math.PI ? 0 : 1;
	return [[
		"M",
		start.x,
		start.y
	], [
		"A",
		radius,
		radius,
		0,
		arcSweep,
		1,
		end.x,
		end.y
	]];
}
/**
* @ignore
* 从数据模型中的 points 换算角度
* @param shapeModel
* @param coordinate
* @returns
*/
function getAngle(shapeModel, coordinate$10) {
	var points = shapeModel.points;
	var box$1 = getPointsBox(points);
	var endAngle;
	var startAngle;
	var coordStartAngle = coordinate$10.startAngle;
	var diffAngle = coordinate$10.endAngle - coordStartAngle;
	if (coordinate$10.isTransposed) {
		endAngle = box$1.maxY * diffAngle;
		startAngle = box$1.minY * diffAngle;
	} else {
		endAngle = box$1.maxX * diffAngle;
		startAngle = box$1.minX * diffAngle;
	}
	endAngle += coordStartAngle;
	startAngle += coordStartAngle;
	return {
		startAngle,
		endAngle
	};
}
/**
* @ignore
* 计算多边形重心: https://en.wikipedia.org/wiki/Centroid#Of_a_polygon
*/
function getPolygonCentroid(xs, ys) {
	if (is_number_default(xs) && is_number_default(ys)) return [xs, ys];
	xs = xs;
	ys = ys;
	if (uniqueValues(xs) || uniqueValues(ys)) return [mid(xs), mid(ys)];
	var i = -1;
	var x = 0;
	var y = 0;
	var former;
	var current = xs.length - 1;
	var diff$1;
	var k = 0;
	while (++i < xs.length) {
		former = current;
		current = i;
		k += diff$1 = xs[former] * ys[current] - xs[current] * ys[former];
		x += (xs[former] + xs[current]) * diff$1;
		y += (ys[former] + ys[current]) * diff$1;
	}
	k *= 3;
	return [x / k, y / k];
}
/**
* @ignore
* 获取需要替换的属性，如果原先图形元素存在，而新图形不存在，则设置 undefined
*/
function getReplaceAttrs(sourceShape, targetShape) {
	var originAttrs = sourceShape.attr();
	var newAttrs = targetShape.attr();
	each_default(originAttrs, function(v, k) {
		if (newAttrs[k] === void 0) newAttrs[k] = void 0;
	});
	return newAttrs;
}

//#endregion
//#region node_modules/@antv/g2/esm/util/helper.js
/**
* @ignore
* Determines whether between is
* @param value
* @param start
* @param end
* @returns true if between
*/
function isBetween$1(value$1, start, end) {
	return value$1 >= Math.min(start, end) && value$1 <= Math.max(start, end);
}
/**
* @ignore
* pads the current string/array with a given value (repeated, if needed) so that the resulting reaches a given length.
* The padding is applied from the end of the current value.
*
* @param source
* @param targetLength
* @param padValue
* @returns
*/
function padEnd(source, targetLength, padValue) {
	if (is_string_default(source)) return source.padEnd(targetLength, padValue);
	else if (is_array_default(source)) {
		var sourceLength = source.length;
		if (sourceLength < targetLength) {
			var diff$1 = targetLength - sourceLength;
			for (var i = 0; i < diff$1; i++) source.push(padValue);
		}
	}
	return source;
}
/**
* @ignore
* omit keys of an object.
* @param obj
* @param keys
*/
function omit(obj, keys$1) {
	if (typeof obj === "object") keys$1.forEach(function(key) {
		delete obj[key];
	});
	return obj;
}
/**
* @ignore
* @param sourceArray
* @param targetArray
* @param map
*/
function uniq$1(sourceArray, targetArray, map$3) {
	var e_1, _a$5;
	if (targetArray === void 0) targetArray = [];
	if (map$3 === void 0) map$3 = /* @__PURE__ */ new Map();
	try {
		for (var sourceArray_1 = __values(sourceArray), sourceArray_1_1 = sourceArray_1.next(); !sourceArray_1_1.done; sourceArray_1_1 = sourceArray_1.next()) {
			var source = sourceArray_1_1.value;
			if (!map$3.has(source)) {
				targetArray.push(source);
				map$3.set(source, true);
			}
		}
	} catch (e_1_1) {
		e_1 = { error: e_1_1 };
	} finally {
		try {
			if (sourceArray_1_1 && !sourceArray_1_1.done && (_a$5 = sourceArray_1.return)) _a$5.call(sourceArray_1);
		} finally {
			if (e_1) throw e_1.error;
		}
	}
	return targetArray;
}

//#endregion
//#region node_modules/@antv/g2/esm/util/bbox.js
/**
* 用于包围盒计算。
*/
var BBox = function() {
	function BBox$1(x, y, width, height) {
		if (x === void 0) x = 0;
		if (y === void 0) y = 0;
		if (width === void 0) width = 0;
		if (height === void 0) height = 0;
		this.x = x;
		this.y = y;
		this.height = height;
		this.width = width;
	}
	BBox$1.fromRange = function(minX, minY, maxX, maxY$1) {
		return new BBox$1(minX, minY, maxX - minX, maxY$1 - minY);
	};
	BBox$1.fromObject = function(bbox) {
		return new BBox$1(bbox.minX, bbox.minY, bbox.width, bbox.height);
	};
	Object.defineProperty(BBox$1.prototype, "minX", {
		get: function() {
			return this.x;
		},
		enumerable: false,
		configurable: true
	});
	Object.defineProperty(BBox$1.prototype, "maxX", {
		get: function() {
			return this.x + this.width;
		},
		enumerable: false,
		configurable: true
	});
	Object.defineProperty(BBox$1.prototype, "minY", {
		get: function() {
			return this.y;
		},
		enumerable: false,
		configurable: true
	});
	Object.defineProperty(BBox$1.prototype, "maxY", {
		get: function() {
			return this.y + this.height;
		},
		enumerable: false,
		configurable: true
	});
	Object.defineProperty(BBox$1.prototype, "tl", {
		get: function() {
			return {
				x: this.x,
				y: this.y
			};
		},
		enumerable: false,
		configurable: true
	});
	Object.defineProperty(BBox$1.prototype, "tr", {
		get: function() {
			return {
				x: this.maxX,
				y: this.y
			};
		},
		enumerable: false,
		configurable: true
	});
	Object.defineProperty(BBox$1.prototype, "bl", {
		get: function() {
			return {
				x: this.x,
				y: this.maxY
			};
		},
		enumerable: false,
		configurable: true
	});
	Object.defineProperty(BBox$1.prototype, "br", {
		get: function() {
			return {
				x: this.maxX,
				y: this.maxY
			};
		},
		enumerable: false,
		configurable: true
	});
	Object.defineProperty(BBox$1.prototype, "top", {
		get: function() {
			return {
				x: this.x + this.width / 2,
				y: this.minY
			};
		},
		enumerable: false,
		configurable: true
	});
	Object.defineProperty(BBox$1.prototype, "right", {
		get: function() {
			return {
				x: this.maxX,
				y: this.y + this.height / 2
			};
		},
		enumerable: false,
		configurable: true
	});
	Object.defineProperty(BBox$1.prototype, "bottom", {
		get: function() {
			return {
				x: this.x + this.width / 2,
				y: this.maxY
			};
		},
		enumerable: false,
		configurable: true
	});
	Object.defineProperty(BBox$1.prototype, "left", {
		get: function() {
			return {
				x: this.minX,
				y: this.y + this.height / 2
			};
		},
		enumerable: false,
		configurable: true
	});
	/**
	* 包围盒是否相等
	* @param {BBox} bbox 包围盒
	* @returns      包围盒是否相等
	*/
	BBox$1.prototype.isEqual = function(bbox) {
		return this.x === bbox.x && this.y === bbox.y && this.width === bbox.width && this.height === bbox.height;
	};
	/**
	* 是否包含了另一个包围盒
	* @param child
	*/
	BBox$1.prototype.contains = function(child) {
		return child.minX >= this.minX && child.maxX <= this.maxX && child.minY >= this.minY && child.maxY <= this.maxY;
	};
	/**
	* 克隆包围盒
	* @returns 包围盒
	*/
	BBox$1.prototype.clone = function() {
		return new BBox$1(this.x, this.y, this.width, this.height);
	};
	/**
	* 取并集
	* @param subBBox
	*/
	BBox$1.prototype.add = function() {
		var subBBox = [];
		for (var _i = 0; _i < arguments.length; _i++) subBBox[_i] = arguments[_i];
		var bbox = this.clone();
		each_default(subBBox, function(b) {
			bbox.x = Math.min(b.x, bbox.x);
			bbox.y = Math.min(b.y, bbox.y);
			bbox.width = Math.max(b.maxX, bbox.maxX) - bbox.x;
			bbox.height = Math.max(b.maxY, bbox.maxY) - bbox.y;
		});
		return bbox;
	};
	/**
	* 取交集
	* @param subBBox
	*/
	BBox$1.prototype.merge = function() {
		var subBBox = [];
		for (var _i = 0; _i < arguments.length; _i++) subBBox[_i] = arguments[_i];
		var bbox = this.clone();
		each_default(subBBox, function(b) {
			bbox.x = Math.max(b.x, bbox.x);
			bbox.y = Math.max(b.y, bbox.y);
			bbox.width = Math.min(b.maxX, bbox.maxX) - bbox.x;
			bbox.height = Math.min(b.maxY, bbox.maxY) - bbox.y;
		});
		return bbox;
	};
	/**
	* bbox 剪裁
	* @param subBBox
	* @param direction
	*/
	BBox$1.prototype.cut = function(subBBox, direction$1) {
		var width = subBBox.width;
		var height = subBBox.height;
		switch (direction$1) {
			case DIRECTION.TOP:
			case DIRECTION.TOP_LEFT:
			case DIRECTION.TOP_RIGHT: return BBox$1.fromRange(this.minX, this.minY + height, this.maxX, this.maxY);
			case DIRECTION.RIGHT:
			case DIRECTION.RIGHT_TOP:
			case DIRECTION.RIGHT_BOTTOM: return BBox$1.fromRange(this.minX, this.minY, this.maxX - width, this.maxY);
			case DIRECTION.BOTTOM:
			case DIRECTION.BOTTOM_LEFT:
			case DIRECTION.BOTTOM_RIGHT: return BBox$1.fromRange(this.minX, this.minY, this.maxX, this.maxY - height);
			case DIRECTION.LEFT:
			case DIRECTION.LEFT_TOP:
			case DIRECTION.LEFT_BOTTOM: return BBox$1.fromRange(this.minX + width, this.minY, this.maxX, this.maxY);
			default: return this;
		}
	};
	/**
	* 收缩形成新的
	* @param gap
	*/
	BBox$1.prototype.shrink = function(gap) {
		var _a$5 = __read(gap, 4), top = _a$5[0], right$1 = _a$5[1], bottom = _a$5[2], left$1 = _a$5[3];
		return new BBox$1(this.x + left$1, this.y + top, this.width - left$1 - right$1, this.height - top - bottom);
	};
	/**
	* 扩张形成新的
	* @param gap
	*/
	BBox$1.prototype.expand = function(gap) {
		var _a$5 = __read(gap, 4), top = _a$5[0], right$1 = _a$5[1], bottom = _a$5[2], left$1 = _a$5[3];
		return new BBox$1(this.x - left$1, this.y - top, this.width + left$1 + right$1, this.height + top + bottom);
	};
	/**
	* get the gap of two bbox, if not exceed, then 0
	* @param bbox
	* @returns [top, right, bottom, left]
	*/
	BBox$1.prototype.exceed = function(bbox) {
		return [
			Math.max(-this.minY + bbox.minY, 0),
			Math.max(this.maxX - bbox.maxX, 0),
			Math.max(this.maxY - bbox.maxY, 0),
			Math.max(-this.minX + bbox.minX, 0)
		];
	};
	/**
	* 是否碰撞
	* @param bbox
	*/
	BBox$1.prototype.collide = function(bbox) {
		return this.minX < bbox.maxX && this.maxX > bbox.minX && this.minY < bbox.maxY && this.maxY > bbox.minY;
	};
	/**
	* 获取包围盒大小
	* @returns 包围盒大小
	*/
	BBox$1.prototype.size = function() {
		return this.width * this.height;
	};
	/**
	* 点是否在 bbox 中
	* @param p
	*/
	BBox$1.prototype.isPointIn = function(p) {
		return p.x >= this.minX && p.x <= this.maxX && p.y >= this.minY && p.y <= this.maxY;
	};
	return BBox$1;
}();
/**
* 将 bbox 转换成 points
* @param bbox
*/
function toPoints(bbox) {
	return [
		[bbox.minX, bbox.minY],
		[bbox.maxX, bbox.minY],
		[bbox.maxX, bbox.maxY],
		[bbox.minX, bbox.maxY]
	];
}

//#endregion
//#region node_modules/@antv/g2/esm/util/coordinate.js
/**
* @ignore
* Gets x dimension length
* @param coordinate
* @returns x dimension length
*/
function getXDimensionLength(coordinate$10) {
	if (coordinate$10.isPolar && !coordinate$10.isTransposed) return (coordinate$10.endAngle - coordinate$10.startAngle) * coordinate$10.getRadius();
	var start = coordinate$10.convert({
		x: 0,
		y: 0
	});
	var end = coordinate$10.convert({
		x: 1,
		y: 0
	});
	return Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));
}
/**
* @ignore
* Determines whether full circle is
* @param coordinate
* @returns true if full circle
*/
function isFullCircle(coordinate$10) {
	if (coordinate$10.isPolar) {
		var startAngle = coordinate$10.startAngle;
		return coordinate$10.endAngle - startAngle === Math.PI * 2;
	}
	return false;
}
/**
* @ignore
* 获取当前点到坐标系圆心的距离
* @param coordinate 坐标系
* @param point 当前点
* @returns distance to center
*/
function getDistanceToCenter(coordinate$10, point$1) {
	var center$1 = coordinate$10.getCenter();
	return Math.sqrt(Math.pow(point$1.x - center$1.x, 2) + Math.pow(point$1.y - center$1.y, 2));
}
/**
* @ignore
* 坐标点是否在坐标系中
* @param coordinate
* @param point
*/
function isPointInCoordinate(coordinate$10, point$1) {
	var result = false;
	if (coordinate$10) if (coordinate$10.type === "theta") {
		var start = coordinate$10.start, end = coordinate$10.end;
		result = isBetween$1(point$1.x, start.x, end.x) && isBetween$1(point$1.y, start.y, end.y);
	} else {
		var invertPoint = coordinate$10.invert(point$1);
		result = isBetween$1(invertPoint.x, 0, 1) && isBetween$1(invertPoint.y, 0, 1);
	}
	return result;
}
/**
* @ignore
* 获取点到圆心的连线与水平方向的夹角
*/
function getAngleByPoint(coordinate$10, point$1) {
	var center$1 = coordinate$10.getCenter();
	return Math.atan2(point$1.y - center$1.y, point$1.x - center$1.x);
}
/**
* @ignore
* 获取同坐标系范围相同的剪切区域
* @param coordinate
* @returns
*/
function getCoordinateClipCfg(coordinate$10, margin) {
	if (margin === void 0) margin = 0;
	var start = coordinate$10.start, end = coordinate$10.end;
	var width = coordinate$10.getWidth();
	var height = coordinate$10.getHeight();
	if (coordinate$10.isPolar) {
		var startAngle_1 = coordinate$10.startAngle, endAngle_1 = coordinate$10.endAngle;
		var center_1 = coordinate$10.getCenter();
		var radius_1 = coordinate$10.getRadius();
		return {
			type: "path",
			startState: { path: getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, startAngle_1) },
			endState: function(ratio) {
				var diff$1 = (endAngle_1 - startAngle_1) * ratio + startAngle_1;
				return { path: getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, diff$1) };
			},
			attrs: { path: getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, endAngle_1) }
		};
	}
	var endState;
	if (coordinate$10.isTransposed) endState = { height: height + margin * 2 };
	else endState = { width: width + margin * 2 };
	return {
		type: "rect",
		startState: {
			x: start.x - margin,
			y: end.y - margin,
			width: coordinate$10.isTransposed ? width + margin * 2 : 0,
			height: coordinate$10.isTransposed ? 0 : height + margin * 2
		},
		endState,
		attrs: {
			x: start.x - margin,
			y: end.y - margin,
			width: width + margin * 2,
			height: height + margin * 2
		}
	};
}
/**
* 获取坐标系范围的 BBox
* @param coordinate
* @param margin
*/
function getCoordinateBBox(coordinate$10, margin) {
	if (margin === void 0) margin = 0;
	var start = coordinate$10.start, end = coordinate$10.end;
	var width = coordinate$10.getWidth();
	var height = coordinate$10.getHeight();
	var minX = Math.min(start.x, end.x);
	var minY = Math.min(start.y, end.y);
	return BBox.fromRange(minX - margin, minY - margin, minX + width + margin, minY + height + margin);
}

//#endregion
//#region node_modules/@antv/g2/esm/util/scale.js
var dateRegex = /^(?:(?!0000)[0-9]{4}([-/.]+)(?:(?:0?[1-9]|1[0-2])\1(?:0?[1-9]|1[0-9]|2[0-8])|(?:0?[13-9]|1[0-2])\1(?:29|30)|(?:0?[13578]|1[02])\1(?:31))|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)([-/.]+)0?2\2(?:29))(\s+([01]|([01][0-9]|2[0-3])):([0-9]|[0-5][0-9]):([0-9]|[0-5][0-9]))?$/;
/**
* 获取字段对应数据的类型
* @param field 数据字段名
* @param data 数据源
* @returns default type 返回对应的数据类型
*/
function getDefaultType(value$1) {
	var type = "linear";
	if (dateRegex.test(value$1)) type = "timeCat";
	else if (is_string_default(value$1)) type = "cat";
	return type;
}
/**
* using the scale type if user specified, otherwise infer the type
*/
function inferScaleType(scale$4, scaleDef, attrType, geometryType) {
	if (scaleDef === void 0) scaleDef = {};
	if (scaleDef.type) return scaleDef.type;
	if (scale$4.type !== "identity" && GROUP_ATTRS.includes(attrType) && ["interval"].includes(geometryType)) return "cat";
	return scale$4.isCategory ? "cat" : scale$4.type;
}
/**
* @ignore
* 为指定的 `field` 字段数据创建 scale
* @param field 字段名
* @param [data] 数据集，可为空
* @param [scaleDef] 列定义，可为空
* @returns scale 返回创建的 Scale 实例
*/
function createScaleByField(field$5, data$2, scaleDef) {
	var validData = data$2 || [];
	if (is_number_default(field$5) || is_nil_default(first_value_default(validData, field$5)) && is_empty_default(scaleDef)) return new (getClass("identity"))({
		field: field$5.toString(),
		values: [field$5]
	});
	var values$1 = values_of_key_default(validData, field$5);
	var type = get_default(scaleDef, "type", getDefaultType(values$1[0]));
	return new (getClass(type))(__assign({
		field: field$5,
		values: values$1
	}, scaleDef));
}
/**
* @ignore
* 同步 scale
* @todo 是否可以通过 scale.update() 方法进行更新
* @param scale 需要同步的 scale 实例
* @param newScale 同步源 Scale
*/
function syncScale(scale$4, newScale) {
	if (scale$4.type !== "identity" && newScale.type !== "identity") {
		var obj = {};
		for (var k in newScale) if (Object.prototype.hasOwnProperty.call(newScale, k)) obj[k] = newScale[k];
		scale$4.change(obj);
	}
}
/**
* @ignore
* get the scale name, if alias exist, return alias, or else field
* @param scale
* @returns the name of field
*/
function getName(scale$4) {
	return scale$4.alias || scale$4.field;
}
/**
* 根据 scale values 和 coordinate 获取分类默认 range
* @param scale 需要获取的 scale 实例
* @param coordinate coordinate 实例
* @param theme theme
*/
function getDefaultCategoryScaleRange(scale$4, coordinate$10, theme$3) {
	var count$1 = scale$4.values.length;
	var range;
	if (count$1 === 1) range = [.5, 1];
	else {
		var widthRatio = 1;
		var offset = 0;
		if (isFullCircle(coordinate$10)) if (!coordinate$10.isTransposed) range = [0, 1 - 1 / count$1];
		else {
			widthRatio = get_default(theme$3, "widthRatio.multiplePie", 1 / 1.3);
			offset = 1 / count$1 * widthRatio;
			range = [offset / 2, 1 - offset / 2];
		}
		else {
			offset = 1 / count$1 / 2;
			range = [offset, 1 - offset];
		}
	}
	return range;
}
/**
* @function y轴scale的max
* @param {yScale}
*/
function getMaxScale(scale$4) {
	var values$1 = scale$4.values.filter(function(item) {
		return !is_nil_default(item) && !isNaN(item);
	});
	return Math.max.apply(Math, __spreadArray(__spreadArray([], __read(values$1), false), [is_nil_default(scale$4.max) ? -Infinity : scale$4.max], false));
}

//#endregion
//#region node_modules/@antv/g2/esm/util/axis.js
/**
* @ignore
* get axis relative region ( 0 ~ 1) by direction when coordinate is rect
* @param direction
* @returns axis coordinate region
*/
function getLineAxisRelativeRegion(direction$1) {
	var start;
	var end;
	switch (direction$1) {
		case DIRECTION.TOP:
			start = {
				x: 0,
				y: 1
			};
			end = {
				x: 1,
				y: 1
			};
			break;
		case DIRECTION.RIGHT:
			start = {
				x: 1,
				y: 0
			};
			end = {
				x: 1,
				y: 1
			};
			break;
		case DIRECTION.BOTTOM:
			start = {
				x: 0,
				y: 0
			};
			end = {
				x: 1,
				y: 0
			};
			break;
		case DIRECTION.LEFT:
			start = {
				x: 0,
				y: 0
			};
			end = {
				x: 0,
				y: 1
			};
			break;
		default: start = end = {
			x: 0,
			y: 0
		};
	}
	return {
		start,
		end
	};
}
/**
* @ignore
* get axis relative region ( 0 ~ 1) by direction when coordinate is polar
* @param coordinate
* @returns axis coordinate region
*/
function getCircleAxisRelativeRegion(coordinate$10) {
	var start;
	var end;
	if (coordinate$10.isTransposed) {
		start = {
			x: 0,
			y: 0
		};
		end = {
			x: 1,
			y: 0
		};
	} else {
		start = {
			x: 0,
			y: 0
		};
		end = {
			x: 0,
			y: 1
		};
	}
	return {
		start,
		end
	};
}
/**
* @ignore
* get the axis region from coordinate
* @param coordinate
* @param direction
* @returns the axis region (start point, end point)
*/
function getAxisRegion(coordinate$10, direction$1) {
	var region = {
		start: {
			x: 0,
			y: 0
		},
		end: {
			x: 0,
			y: 0
		}
	};
	if (coordinate$10.isRect) region = getLineAxisRelativeRegion(direction$1);
	else if (coordinate$10.isPolar) region = getCircleAxisRelativeRegion(coordinate$10);
	var start = region.start, end = region.end;
	return {
		start: coordinate$10.convert(start),
		end: coordinate$10.convert(end)
	};
}
/**
* @ignore
* whether the axis isVertical
* @param region
* @returns isVertical
*/
function isVertical(region) {
	var start = region.start, end = region.end;
	return start.x === end.x;
}
/**
* @ignore
* get factor by region (real position)
* @param region
* @param center
* @returns factor
*/
function getAxisFactorByRegion(region, center$1) {
	var start = region.start, end = region.end;
	if (isVertical(region)) if ((start.y - end.y) * (center$1.x - start.x) > 0) return 1;
	else return -1;
	else if ((end.x - start.x) * (start.y - center$1.y) > 0) return -1;
	else return 1;
}
/**
* @ignore
* get the axis cfg from theme, will mix the common cfg of legend theme
*
* @param theme view theme object
* @param direction axis direction
* @returns axis theme cfg
*/
function getAxisThemeCfg(theme$3, direction$1) {
	var axisTheme = get_default(theme$3, ["components", "axis"], {});
	return deep_mix_default({}, get_default(axisTheme, ["common"], {}), deep_mix_default({}, get_default(axisTheme, [direction$1], {})));
}
/**
* get the options of axis title，mix the cfg from theme, avoid common themeCfg not work
* @param theme
* @param direction
* @param axisOptions
* @returns axis title options
*/
function getAxisTitleOptions(theme$3, direction$1, axisOptions) {
	var axisTheme = get_default(theme$3, ["components", "axis"], {});
	return deep_mix_default({}, get_default(axisTheme, ["common", "title"], {}), deep_mix_default({}, get_default(axisTheme, [direction$1, "title"], {})), axisOptions);
}
/**
* @ignore
* get circle axis center and radius
* @param coordinate
*/
function getCircleAxisCenterRadius(coordinate$10) {
	var x = coordinate$10.x, y = coordinate$10.y, center$1 = coordinate$10.circleCenter;
	var isReflectY = y.start > y.end;
	var start = coordinate$10.isTransposed ? coordinate$10.convert({
		x: isReflectY ? 0 : 1,
		y: 0
	}) : coordinate$10.convert({
		x: 0,
		y: isReflectY ? 0 : 1
	});
	var startVector = [start.x - center$1.x, start.y - center$1.y];
	var normalVector = [1, 0];
	var startAngle = start.y > center$1.y ? angle(startVector, normalVector) : angle(startVector, normalVector) * -1;
	var endAngle = startAngle + (x.end - x.start);
	var radius = Math.sqrt(Math.pow(start.x - center$1.x, 2) + Math.pow(start.y - center$1.y, 2));
	return {
		center: center$1,
		radius,
		startAngle,
		endAngle
	};
}
/**
* @ignore
* 从配置中获取单个字段的 axis 配置
* @param axes
* @param field
* @returns the axis option of field
*/
function getAxisOption(axes, field$5) {
	if (is_boolean_default(axes)) return axes === false ? false : {};
	return get_default(axes, [field$5]);
}
/**
* @ignore
* 如果配置了 position，则使用配置
* @param axisOption
* @param def
*/
function getAxisDirection(axisOption, def) {
	return get_default(axisOption, "position", def);
}
/**
* 获取 axis 的 title 文本
* @param scale
* @param axisOption
*/
function getAxisTitleText(scale$4, axisOption) {
	return get_default(axisOption, ["title", "text"], getName(scale$4));
}

//#endregion
//#region node_modules/@antv/g2/esm/facet/facet.js
/**
* facet 基类
*  - 定义生命周期，方便自定义 facet
*  - 提供基础的生命流程方法
*
* 生命周期：
*
* 初始化 init
* 1. 初始化容器
* 2. 数据分面，生成分面布局信息
*
* 渲染阶段 render
* 1. view 创建
* 2. title
* 3. axis
*
* 清除阶段 clear
* 1. 清除 view
*
* 销毁阶段 destroy
* 1. clear
* 2. 清除事件
* 3. 清除 group
*/
var Facet$1 = function() {
	function Facet$2(view, cfg) {
		/** 是否销毁 */
		this.destroyed = false;
		/** 分面之后的所有分面数据结构 */
		this.facets = [];
		this.view = view;
		this.cfg = deep_mix_default({}, this.getDefaultCfg(), cfg);
	}
	/**
	* 初始化过程
	*/
	Facet$2.prototype.init = function() {
		if (!this.container) this.container = this.createContainer();
		var data$2 = this.view.getData();
		this.facets = this.generateFacets(data$2);
	};
	/**
	* 渲染分面，由上层 view 调用。包括：
	*  - 分面 view
	*  - 轴
	*  - title
	*
	*  子类可以复写，添加一些其他组件，比如滚动条等
	*/
	Facet$2.prototype.render = function() {
		this.renderViews();
	};
	/**
	* 更新 facet
	*/
	Facet$2.prototype.update = function() {};
	/**
	* 清空，clear 之后如果还需要使用，需要重新调用 init 初始化过程
	* 一般在数据有变更的时候调用，重新进行数据的分面逻辑
	*/
	Facet$2.prototype.clear = function() {
		this.clearFacetViews();
	};
	/**
	* 销毁
	*/
	Facet$2.prototype.destroy = function() {
		this.clear();
		if (this.container) {
			this.container.remove(true);
			this.container = void 0;
		}
		this.destroyed = true;
		this.view = void 0;
		this.facets = [];
	};
	/**
	* 根据 facet 生成 view，可以给上层自定义使用
	* @param facet
	*/
	Facet$2.prototype.facetToView = function(facet) {
		var region = facet.region, data$2 = facet.data, _a$5 = facet.padding, padding$2 = _a$5 === void 0 ? this.cfg.padding : _a$5;
		var view = this.view.createView({
			region,
			padding: padding$2
		});
		view.data(data$2 || []);
		facet.view = view;
		this.beforeEachView(view, facet);
		var eachView = this.cfg.eachView;
		if (eachView) eachView(view, facet);
		this.afterEachView(view, facet);
		return view;
	};
	Facet$2.prototype.createContainer = function() {
		return this.view.getLayer(LAYER.FORE).addGroup();
	};
	/**
	* 初始化 view
	*/
	Facet$2.prototype.renderViews = function() {
		this.createFacetViews();
	};
	/**
	* 创建 分面 view
	*/
	Facet$2.prototype.createFacetViews = function() {
		var _this = this;
		return this.facets.map(function(facet) {
			return _this.facetToView(facet);
		});
	};
	/**
	* 从 view 中清除 facetView
	*/
	Facet$2.prototype.clearFacetViews = function() {
		var _this = this;
		each_default(this.facets, function(facet) {
			if (facet.view) {
				_this.view.removeView(facet.view);
				facet.view = void 0;
			}
		});
	};
	/**
	* 解析 spacing
	*/
	Facet$2.prototype.parseSpacing = function() {
		/**
		* @example
		*
		* // 仅使用百分比或像素值
		* // 横向间隔为 10%，纵向间隔为 10%
		* ['10%', '10%']
		* // 横向间隔为 10px，纵向间隔为 10px
		* [10, 10]
		*
		* // 同时使用百分比和像素值
		* ['10%', 10]
		* // 横向间隔为 10%，纵向间隔为 10px
		*/
		var _a$5 = this.view.viewBBox, width = _a$5.width, height = _a$5.height;
		return this.cfg.spacing.map(function(s, idx) {
			if (is_number_default(s)) return s / (idx === 0 ? width : height);
			else return parseFloat(s) / 100;
		});
	};
	/**
	* 获取这个字段对应的所有值，数组
	* @protected
	* @param data 数据
	* @param field 字段名
	* @return 字段对应的值
	*/
	Facet$2.prototype.getFieldValues = function(data$2, field$5) {
		var rst = [];
		var cache$2 = {};
		each_default(data$2, function(d) {
			var value$1 = d[field$5];
			if (!is_nil_default(value$1) && !cache$2[value$1]) {
				rst.push(value$1);
				cache$2[value$1] = true;
			}
		});
		return rst;
	};
	/**
	* 获得每个分面的 region，平分区域
	* @param rows row 总数
	* @param cols col 总数
	* @param xIndex x 方向 index
	* @param yIndex y 方向 index
	*/
	Facet$2.prototype.getRegion = function(rows, cols, xIndex, yIndex) {
		var _a$5 = __read(this.parseSpacing(), 2), xSpacing = _a$5[0], ySpacing = _a$5[1];
		/**
		* ratio * num + spacing * (num - 1) = 1
		* => ratio = (1 - (spacing * (num - 1))) / num
		*          = (1 + spacing) / num - spacing
		*
		* num 对应 cols/rows
		* spacing 对应 xSpacing/ySpacing
		*/
		var xRatio = (1 + xSpacing) / (cols === 0 ? 1 : cols) - xSpacing;
		var yRatio = (1 + ySpacing) / (rows === 0 ? 1 : rows) - ySpacing;
		var start = {
			x: (xRatio + xSpacing) * xIndex,
			y: (yRatio + ySpacing) * yIndex
		};
		var end = {
			x: start.x + xRatio,
			y: start.y + yRatio
		};
		return {
			start,
			end
		};
	};
	Facet$2.prototype.getDefaultCfg = function() {
		return {
			eachView: void 0,
			showTitle: true,
			spacing: [0, 0],
			padding: 10,
			fields: []
		};
	};
	/**
	* 默认的 title 样式，因为有的分面是 title，有的分面配置是 columnTitle、rowTitle
	*/
	Facet$2.prototype.getDefaultTitleCfg = function() {
		return { style: {
			fontSize: 14,
			fill: "#666",
			fontFamily: this.view.getTheme().fontFamily
		} };
	};
	/**
	* 处理 axis 的默认配置
	* @param view
	* @param facet
	*/
	Facet$2.prototype.processAxis = function(view, facet) {
		var options = view.getOptions();
		var coordinateOption = options.coordinate;
		var geometries = view.geometries;
		if (get_default(coordinateOption, "type", "rect") === "rect" && geometries.length) {
			if (is_nil_default(options.axes)) options.axes = {};
			var axes = options.axes;
			var _a$5 = __read(geometries[0].getXYFields(), 2), x = _a$5[0], y = _a$5[1];
			var xOption = getAxisOption(axes, x);
			var yOption = getAxisOption(axes, y);
			if (xOption !== false) options.axes[x] = this.getXAxisOption(x, axes, xOption, facet);
			if (yOption !== false) options.axes[y] = this.getYAxisOption(y, axes, yOption, facet);
		}
	};
	/**
	* 获取分面数据
	* @param conditions
	*/
	Facet$2.prototype.getFacetDataFilter = function(conditions) {
		return function(datum) {
			return every_default(conditions, function(condition) {
				var field$5 = condition.field, value$1 = condition.value;
				if (!is_nil_default(value$1) && field$5) return datum[field$5] === value$1;
				return true;
			});
		};
	};
	return Facet$2;
}();

//#endregion
//#region node_modules/@antv/g2/esm/facet/index.js
/**
* 所有的 Facet 类
*/
var Facets = {};
/**
* 根据 type 获取 facet 类
* @param type 分面类型
*/
var getFacet = function(type) {
	return Facets[lower_case_default(type)];
};
/**
* 注册一个 Facet 类
* @param type 分面类型
* @param ctor 分面类
*/
var registerFacet = function(type, ctor) {
	Facets[lower_case_default(type)] = ctor;
};

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/base.js
/**
* Action 的基类
*/
var Action = function() {
	function Action$1(context, cfg) {
		this.context = context;
		this.cfg = cfg;
		context.addAction(this);
	}
	/**
	* 设置配置项传入的值
	* @param cfg
	*/
	Action$1.prototype.applyCfg = function(cfg) {
		mix(this, cfg);
	};
	/**
	* Inits action，提供给子类用于继承
	*/
	Action$1.prototype.init = function() {
		this.applyCfg(this.cfg);
	};
	/**
	* Destroys action
	*/
	Action$1.prototype.destroy = function() {
		this.context.removeAction(this);
		this.context = null;
	};
	return Action$1;
}();
var base_default$1 = Action;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/callback.js
/** 回调函数构建的 Action */
var CallbackAction = function(_super) {
	__extends(CallbackAction$1, _super);
	function CallbackAction$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	/**
	* 执行
	*/
	CallbackAction$1.prototype.execute = function() {
		if (this.callback) this.callback(this.context);
	};
	/**
	* 销毁
	*/
	CallbackAction$1.prototype.destroy = function() {
		_super.prototype.destroy.call(this);
		this.callback = null;
	};
	return CallbackAction$1;
}(base_default$1);
var callback_default = CallbackAction;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/register.js
var ActionCache = {};
/**
* 根据名称获取 Action 实例
* @param actionName - action 的名称
* @param context 上下文
* @returns Action 实例
*/
function createAction(actionName, context) {
	var actionOption = ActionCache[actionName];
	var action = null;
	if (actionOption) {
		var ActionClass = actionOption.ActionClass, cfg = actionOption.cfg;
		action = new ActionClass(context, cfg);
		action.name = actionName;
		action.init();
	}
	return action;
}
/**
* 根据 action 的 name 获取定义的类
* @param actionName action 的 name
*/
function getActionClass(actionName) {
	var actionOption = ActionCache[actionName];
	return get_default(actionOption, "ActionClass");
}
/**
* 注册 Action
* @param actionName - action 的名称
* @param ActionClass - 继承自 action 的类
*/
function registerAction(actionName, ActionClass, cfg) {
	ActionCache[actionName] = {
		ActionClass,
		cfg
	};
}
/**
* 根据回调函数获取 Action 实例
* @param callback - action 的回调函数
* @param context 上下文
* @returns Action 实例
*/
function createCallbackAction(callback, context) {
	var action = new callback_default(context);
	action.callback = callback;
	action.name = "callback";
	return action;
}

//#endregion
//#region node_modules/@antv/g2/esm/geometry/shape/util/path.js
function _points2path(points, isInCircle) {
	var path = [];
	if (points.length) {
		path.push([
			"M",
			points[0].x,
			points[0].y
		]);
		for (var i = 1, length_1 = points.length; i < length_1; i += 1) {
			var item = points[i];
			path.push([
				"L",
				item.x,
				item.y
			]);
		}
		if (isInCircle) path.push(["Z"]);
	}
	return path;
}
function _convertArr(arr, coord$1) {
	var tmp = [arr[0]];
	for (var i = 1, len = arr.length; i < len; i = i + 2) {
		var point$1 = coord$1.convert({
			x: arr[i],
			y: arr[i + 1]
		});
		tmp.push(point$1.x, point$1.y);
	}
	return tmp;
}
function _convertArcPath(path, coord$1) {
	var isTransposed = coord$1.isTransposed;
	var r = path[1];
	var x = path[6];
	var y = path[7];
	var point$1 = coord$1.convert({
		x,
		y
	});
	return [
		"A",
		r,
		r,
		0,
		0,
		isTransposed ? 0 : 1,
		point$1.x,
		point$1.y
	];
}
function _convertPolarPath(pre, cur, coord$1) {
	var isTransposed = coord$1.isTransposed, startAngle = coord$1.startAngle, endAngle = coord$1.endAngle;
	var prePoint = pre[0].toLowerCase() === "a" ? {
		x: pre[6],
		y: pre[7]
	} : {
		x: pre[1],
		y: pre[2]
	};
	var curPoint = {
		x: cur[1],
		y: cur[2]
	};
	var rst = [];
	var xDim = isTransposed ? "y" : "x";
	var angleRange = Math.abs(curPoint[xDim] - prePoint[xDim]) * (endAngle - startAngle);
	var direction$1 = curPoint[xDim] >= prePoint[xDim] ? 1 : 0;
	var flag = angleRange > Math.PI ? 1 : 0;
	var convertPoint = coord$1.convert(curPoint);
	var r = getDistanceToCenter(coord$1, convertPoint);
	if (r >= .5) if (angleRange === Math.PI * 2) {
		var middlePoint = {
			x: (curPoint.x + prePoint.x) / 2,
			y: (curPoint.y + prePoint.y) / 2
		};
		var middleConvertPoint = coord$1.convert(middlePoint);
		rst.push([
			"A",
			r,
			r,
			0,
			flag,
			direction$1,
			middleConvertPoint.x,
			middleConvertPoint.y
		]);
		rst.push([
			"A",
			r,
			r,
			0,
			flag,
			direction$1,
			convertPoint.x,
			convertPoint.y
		]);
	} else rst.push([
		"A",
		r,
		r,
		0,
		flag,
		direction$1,
		convertPoint.x,
		convertPoint.y
	]);
	return rst;
}
function _filterFullCirleLine(path) {
	each_default(path, function(subPath, index) {
		if (subPath[0].toLowerCase() === "a") {
			var pre = path[index - 1];
			var next = path[index + 1];
			if (next && next[0].toLowerCase() === "a") {
				if (pre && pre[0].toLowerCase() === "l") pre[0] = "M";
			} else if (pre && pre[0].toLowerCase() === "a") {
				if (next && next[0].toLowerCase() === "l") next[0] = "M";
			}
		}
	});
}
/**
* @ignore
* 计算光滑的贝塞尔曲线
*/
var smoothBezier$1 = function(points, smooth, isLoop, constraint) {
	var _a$5;
	var cps = [];
	var hasConstraint = !!constraint;
	var prevPoint;
	var nextPoint;
	var min$2;
	var max$2;
	var nextCp0;
	var cp1;
	var cp0;
	if (hasConstraint) {
		_a$5 = __read(constraint, 2), min$2 = _a$5[0], max$2 = _a$5[1];
		for (var i = 0, l = points.length; i < l; i++) {
			var point$1 = points[i];
			min$2 = min$1([0, 0], min$2, point$1);
			max$2 = max$1([0, 0], max$2, point$1);
		}
	}
	for (var i = 0, len = points.length; i < len; i++) {
		var point$1 = points[i];
		if (i === 0 && !isLoop) cp0 = point$1;
		else if (i === len - 1 && !isLoop) {
			cp1 = point$1;
			cps.push(cp0);
			cps.push(cp1);
		} else {
			prevPoint = points[isLoop ? i ? i - 1 : len - 1 : i - 1];
			nextPoint = points[isLoop ? (i + 1) % len : i + 1];
			var v = [0, 0];
			v = sub(v, nextPoint, prevPoint);
			v = scale$3(v, v, smooth);
			var d0 = distance$6(point$1, prevPoint);
			var d1 = distance$6(point$1, nextPoint);
			var sum = d0 + d1;
			if (sum !== 0) {
				d0 /= sum;
				d1 /= sum;
			}
			var v1 = scale$3([0, 0], v, -d0);
			var v2 = scale$3([0, 0], v, d1);
			cp1 = add([0, 0], point$1, v1);
			nextCp0 = add([0, 0], point$1, v2);
			nextCp0 = min$1([0, 0], nextCp0, max$1([0, 0], nextPoint, point$1));
			nextCp0 = max$1([0, 0], nextCp0, min$1([0, 0], nextPoint, point$1));
			v1 = sub([0, 0], nextCp0, point$1);
			v1 = scale$3([0, 0], v1, -d0 / d1);
			cp1 = add([0, 0], point$1, v1);
			cp1 = min$1([0, 0], cp1, max$1([0, 0], prevPoint, point$1));
			cp1 = max$1([0, 0], cp1, min$1([0, 0], prevPoint, point$1));
			v2 = sub([0, 0], point$1, cp1);
			v2 = scale$3([0, 0], v2, d1 / d0);
			nextCp0 = add([0, 0], point$1, v2);
			if (hasConstraint) {
				cp1 = max$1([0, 0], cp1, min$2);
				cp1 = min$1([0, 0], cp1, max$2);
				nextCp0 = max$1([0, 0], nextCp0, min$2);
				nextCp0 = min$1([0, 0], nextCp0, max$2);
			}
			cps.push(cp0);
			cps.push(cp1);
			cp0 = nextCp0;
		}
	}
	if (isLoop) cps.push(cps.shift());
	return cps;
};
/**
* @ignore
* 贝塞尔曲线
*/
function catmullRom2bezier$1(crp, z, constraint) {
	var isLoop = !!z;
	var pointList = [];
	for (var i = 0, l = crp.length; i < l; i += 2) pointList.push([crp[i], crp[i + 1]]);
	var controlPointList = smoothBezier$1(pointList, .4, isLoop, constraint);
	var len = pointList.length;
	var d1 = [];
	var cp1;
	var cp2;
	var p;
	for (var i = 0; i < len - 1; i++) {
		cp1 = controlPointList[i * 2];
		cp2 = controlPointList[i * 2 + 1];
		p = pointList[i + 1];
		d1.push([
			"C",
			cp1[0],
			cp1[1],
			cp2[0],
			cp2[1],
			p[0],
			p[1]
		]);
	}
	if (isLoop) {
		cp1 = controlPointList[len];
		cp2 = controlPointList[len + 1];
		p = pointList[0];
		d1.push([
			"C",
			cp1[0],
			cp1[1],
			cp2[0],
			cp2[1],
			p[0],
			p[1]
		]);
	}
	return d1;
}
/**
* @ignore
* 将点连接成路径 path
*/
function getLinePath(points, isInCircle) {
	return _points2path(points, isInCircle);
}
/**
* @ignore
* 根据关键点获取限定了范围的平滑线
*/
function getSplinePath$1(points, isInCircle, constaint) {
	var data$2 = [];
	var first = points[0];
	var prePoint = null;
	if (points.length <= 2) return getLinePath(points, isInCircle);
	for (var i = 0, len = points.length; i < len; i++) {
		var point$1 = points[i];
		if (!prePoint || !(prePoint.x === point$1.x && prePoint.y === point$1.y)) {
			data$2.push(point$1.x);
			data$2.push(point$1.y);
			prePoint = point$1;
		}
	}
	var splinePath$1 = catmullRom2bezier$1(data$2, isInCircle, constaint || [[0, 0], [1, 1]]);
	splinePath$1.unshift([
		"M",
		first.x,
		first.y
	]);
	return splinePath$1;
}
/**
* @ignore
* 将归一化后的路径数据转换成坐标
*/
function convertNormalPath(coord$1, path) {
	var tmp = [];
	each_default(path, function(subPath) {
		switch (subPath[0].toLowerCase()) {
			case "m":
			case "l":
			case "c":
				tmp.push(_convertArr(subPath, coord$1));
				break;
			case "a":
				tmp.push(_convertArcPath(subPath, coord$1));
				break;
			case "z":
			default:
				tmp.push(subPath);
				break;
		}
	});
	return tmp;
}
/**
* @ignore
* 将路径转换为极坐标下的真实路径
*/
function convertPolarPath(coord$1, path) {
	var tmp = [];
	var pre;
	var cur;
	var transposed;
	var equals;
	each_default(path, function(subPath, index) {
		switch (subPath[0].toLowerCase()) {
			case "m":
			case "c":
			case "q":
				tmp.push(_convertArr(subPath, coord$1));
				break;
			case "l":
				pre = path[index - 1];
				cur = subPath;
				transposed = coord$1.isTransposed;
				equals = transposed ? pre[pre.length - 2] === cur[1] : pre[pre.length - 1] === cur[2];
				if (equals) tmp = tmp.concat(_convertPolarPath(pre, cur, coord$1));
				else tmp.push(_convertArr(subPath, coord$1));
				break;
			case "a":
				tmp.push(_convertArcPath(subPath, coord$1));
				break;
			case "z":
			default:
				tmp.push(subPath);
				break;
		}
	});
	_filterFullCirleLine(tmp);
	return tmp;
}

//#endregion
//#region node_modules/@antv/g2/node_modules/@antv/path-util/esm/parse-path-string.js
var SPACES$2 = "	\n\v\f\r \xA0 ᠎             　\u2028\u2029";
var PATH_COMMAND$2 = new RegExp("([a-z])[" + SPACES$2 + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + SPACES$2 + "]*,?[" + SPACES$2 + "]*)+)", "ig");
var PATH_VALUES$2 = new RegExp("(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[" + SPACES$2 + "]*,?[" + SPACES$2 + "]*", "ig");
function parsePathString$2(pathString) {
	if (!pathString) return null;
	if (is_array_default(pathString)) return pathString;
	var paramCounts = {
		a: 7,
		c: 6,
		o: 2,
		h: 1,
		l: 2,
		m: 2,
		r: 4,
		q: 4,
		s: 4,
		t: 2,
		v: 1,
		u: 3,
		z: 0
	};
	var data$2 = [];
	String(pathString).replace(PATH_COMMAND$2, function(a, b, c) {
		var params = [];
		var name = b.toLowerCase();
		c.replace(PATH_VALUES$2, function(a$1, b$1) {
			b$1 && params.push(+b$1);
		});
		if (name === "m" && params.length > 2) {
			data$2.push([b].concat(params.splice(0, 2)));
			name = "l";
			b = b === "m" ? "l" : "L";
		}
		if (name === "o" && params.length === 1) data$2.push([b, params[0]]);
		if (name === "r") data$2.push([b].concat(params));
		else while (params.length >= paramCounts[name]) {
			data$2.push([b].concat(params.splice(0, paramCounts[name])));
			if (!paramCounts[name]) break;
		}
		return "";
	});
	return data$2;
}

//#endregion
//#region node_modules/@antv/g2/node_modules/@antv/path-util/esm/process/arc-2-cubic.js
var TAU$2 = Math.PI * 2;

//#endregion
//#region node_modules/@antv/g2/node_modules/@antv/path-util/esm/get-line-intersect.js
var isBetween$2 = function(value$1, min$2, max$2) {
	return value$1 >= min$2 && value$1 <= max$2;
};
function getLineIntersect(p0, p1, p2, p3) {
	var tolerance$2 = .001;
	var E = {
		x: p2.x - p0.x,
		y: p2.y - p0.y
	};
	var D0 = {
		x: p1.x - p0.x,
		y: p1.y - p0.y
	};
	var D1 = {
		x: p3.x - p2.x,
		y: p3.y - p2.y
	};
	var kross = D0.x * D1.y - D0.y * D1.x;
	var sqrKross = kross * kross;
	var sqrLen0 = D0.x * D0.x + D0.y * D0.y;
	var sqrLen1 = D1.x * D1.x + D1.y * D1.y;
	var point$1 = null;
	if (sqrKross > tolerance$2 * sqrLen0 * sqrLen1) {
		var s = (E.x * D1.y - E.y * D1.x) / kross;
		var t = (E.x * D0.y - E.y * D0.x) / kross;
		if (isBetween$2(s, 0, 1) && isBetween$2(t, 0, 1)) point$1 = {
			x: p0.x + s * D0.x,
			y: p0.y + s * D0.y
		};
	}
	return point$1;
}

//#endregion
//#region node_modules/@antv/g2/node_modules/@antv/path-util/esm/point-in-polygon.js
/**
* @fileoverview 判断点是否在多边形内
* @author dxq613@gmail.com
*/
var tolerance$1 = 1e-6;
function dcmp$1(x) {
	if (Math.abs(x) < tolerance$1) return 0;
	return x < 0 ? -1 : 1;
}
function onSegment$1(p1, p2, q) {
	if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q[0] && q[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q[1] && q[1] <= Math.max(p1[1], p2[1])) return true;
	return false;
}
function isInPolygon$1(points, x, y) {
	var isHit = false;
	var n = points.length;
	if (n <= 2) return false;
	for (var i = 0; i < n; i++) {
		var p1 = points[i];
		var p2 = points[(i + 1) % n];
		if (onSegment$1(p1, p2, [x, y])) return true;
		if (dcmp$1(p1[1] - y) > 0 !== dcmp$1(p2[1] - y) > 0 && dcmp$1(x - (y - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) isHit = !isHit;
	}
	return isHit;
}

//#endregion
//#region node_modules/@antv/g2/node_modules/@antv/path-util/esm/is-polygons-intersect.js
function parseToLines(points) {
	var lines = [];
	var count$1 = points.length;
	for (var i = 0; i < count$1 - 1; i++) {
		var point$1 = points[i];
		var next = points[i + 1];
		lines.push({
			from: {
				x: point$1[0],
				y: point$1[1]
			},
			to: {
				x: next[0],
				y: next[1]
			}
		});
	}
	if (lines.length > 1) {
		var first = points[0];
		var last$1 = points[count$1 - 1];
		lines.push({
			from: {
				x: last$1[0],
				y: last$1[1]
			},
			to: {
				x: first[0],
				y: first[1]
			}
		});
	}
	return lines;
}
function lineIntersectPolygon(lines, line$1) {
	var isIntersect = false;
	each_default(lines, function(l) {
		if (getLineIntersect(l.from, l.to, line$1.from, line$1.to)) {
			isIntersect = true;
			return false;
		}
	});
	return isIntersect;
}
function getBBox(points) {
	var xArr = points.map(function(p) {
		return p[0];
	});
	var yArr = points.map(function(p) {
		return p[1];
	});
	return {
		minX: Math.min.apply(null, xArr),
		maxX: Math.max.apply(null, xArr),
		minY: Math.min.apply(null, yArr),
		maxY: Math.max.apply(null, yArr)
	};
}
function intersectBBox(box1, box2) {
	return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
}
function isPolygonsIntersect(points1, points2) {
	if (points1.length < 2 || points2.length < 2) return false;
	var bbox1 = getBBox(points1);
	var bbox2 = getBBox(points2);
	if (!intersectBBox(bbox1, bbox2)) return false;
	var isIn = false;
	each_default(points2, function(point$1) {
		if (isInPolygon$1(points1, point$1[0], point$1[1])) {
			isIn = true;
			return false;
		}
	});
	if (isIn) return true;
	each_default(points1, function(point$1) {
		if (isInPolygon$1(points2, point$1[0], point$1[1])) {
			isIn = true;
			return false;
		}
	});
	if (isIn) return true;
	var lines1 = parseToLines(points1);
	var lines2 = parseToLines(points2);
	var isIntersect = false;
	each_default(lines2, function(line$1) {
		if (lineIntersectPolygon(lines1, line$1)) {
			isIntersect = true;
			return false;
		}
	});
	return isIntersect;
}

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/util.js
function getMaskBBox(context, tolerance$2) {
	var maskShape = context.event.target;
	return getMaskBBoxByShape(maskShape, tolerance$2);
}
/**
* 如果 mask BBox 过小则不返回
*/
function isValidMaskBBox(maskShape, tolerance$2) {
	var maskBBox = maskShape.getCanvasBBox();
	var width = maskBBox.width, height = maskBBox.height;
	return width > 0 && height > 0 && (width >= tolerance$2 || height >= tolerance$2);
}
/**
* 通过 maskShape 获取 mask 的 canvasBBox
* @param maskShape
* @param tolerance
* @returns
*/
function getMaskBBoxByShape(maskShape, tolerance$2) {
	var maskBBox = maskShape.getCanvasBBox();
	return isValidMaskBBox(maskShape, tolerance$2) ? maskBBox : null;
}
/**
* 获取 multiple 模式下 mask 的 canvasBBox 数组
* @param context 上下文
* @param tolerance box 宽高小于则不返回
* @returns
*/
function getMultiMaskBBoxList(context, tolerance$2) {
	return context.event.maskShapes.map(function(maskShape) {
		return getMaskBBoxByShape(maskShape, tolerance$2);
	}).filter(function(bBox) {
		return !!bBox;
	});
}
function getMaskPath$2(context, tolerance$2) {
	var maskShape = context.event.target;
	return getMaskPathByMaskShape(maskShape, tolerance$2);
}
/**
* 通过 maskShape 获取 mask path
* @param maskShape
* @param tolerance box 宽高小于则不返回
* @returns
*/
function getMaskPathByMaskShape(maskShape, tolerance$2) {
	return isValidMaskBBox(maskShape, tolerance$2) ? maskShape.attr("path") : null;
}
/**
* 获取 multiple 模式下 mask path 数组
* @param context 上下文
* @param tolerance box 宽高小于则不返回
* @returns
*/
function getMultiMaskPathList(context, tolerance$2) {
	return context.event.maskShapes.map(function(maskShape) {
		return getMaskPathByMaskShape(maskShape, tolerance$2);
	});
}
/**
* 获取当前事件相关的图表元素
* @param context 交互的上下文
* @ignore
*/
function getCurrentElement$1(context) {
	var event = context.event;
	var element;
	var target = event.target;
	if (target) element = target.get("element");
	return element;
}
/**
* 获取委托对象
* @param context 上下文
* @ignore
*/
function getDelegationObject(context) {
	var target = context.event.target;
	var delegateObject;
	if (target) delegateObject = target.get("delegateObject");
	return delegateObject;
}
function isElementChange(context) {
	var event = context.event.gEvent;
	if (event && event.fromShape && event.toShape && event.fromShape.get("element") === event.toShape.get("element")) return false;
	return true;
}
/**
* 是否是列表组件
* @param delegateObject 委托对象
* @ignore
*/
function isList(delegateObject) {
	return delegateObject && delegateObject.component && delegateObject.component.isList();
}
/**
* 是否是滑块组件
* @param delegateObject 委托对象
* @ignore
*/
function isSlider(delegateObject) {
	return delegateObject && delegateObject.component && delegateObject.component.isSlider();
}
/**
* 是否由 mask 触发
* @param context 上下文
* @ignore
*/
function isMask(context) {
	var target = context.event.target;
	return target && (target === null || target === void 0 ? void 0 : target.get("name")) === "mask" || isMultipleMask(context);
}
/**
* 是否由 multiple mask 触发
* @param context
* @returns
*/
function isMultipleMask(context) {
	var _a$5;
	return ((_a$5 = context.event.target) === null || _a$5 === void 0 ? void 0 : _a$5.get("name")) === "multi-mask";
}
/**
* 获取被遮挡的 elements
* @param context 上下文
* @ignore
*/
function getMaskedElements(context, tolerance$2) {
	var target = context.event.target;
	if (isMultipleMask(context)) return getMultiMaskedElements(context, tolerance$2);
	if (target.get("type") === "path") {
		var maskPath = getMaskPath$2(context, tolerance$2);
		if (!maskPath) return;
		return getElementsByPath(context.view, maskPath);
	}
	var maskBBox = getMaskBBox(context, tolerance$2);
	if (!maskBBox) return null;
	return getIntersectElements(context.view, maskBBox);
}
/**
* 获取 multiple 模式下被 mask 遮挡的 elements
* @param context 上下文
* @returns
*/
function getMultiMaskedElements(context, tolerance$2) {
	if (context.event.target.get("type") === "path") {
		var maskPathList = getMultiMaskPathList(context, tolerance$2);
		if (maskPathList.length > 0) return maskPathList.flatMap(function(maskPath) {
			return getElementsByPath(context.view, maskPath);
		});
		return null;
	}
	var maskBBoxList = getMultiMaskBBoxList(context, tolerance$2);
	if (maskBBoxList.length > 0) return maskBBoxList.flatMap(function(maskBBox) {
		return getIntersectElements(context.view, maskBBox);
	});
	return null;
}
/**
* @ignore
*/
function getSiblingMaskElements(context, sibling, tolerance$2) {
	if (isMultipleMask(context)) return getSiblingMultiMaskedElements(context, sibling, tolerance$2);
	var maskBBox = getMaskBBox(context, tolerance$2);
	if (!maskBBox) return null;
	return getSiblingMaskElementsByBBox(maskBBox, context, sibling);
}
/**
* 通过 mashBBox 获取 sibling 模式下被 mask 遮挡的 elements
* @param maskBBox
* @param context 上下文
* @param sibling sibling view
* @returns
*/
function getSiblingMaskElementsByBBox(maskBBox, context, sibling) {
	var view = context.view;
	var start = getSiblingPoint(view, sibling, {
		x: maskBBox.x,
		y: maskBBox.y
	});
	var end = getSiblingPoint(view, sibling, {
		x: maskBBox.maxX,
		y: maskBBox.maxY
	});
	var box$1 = {
		minX: start.x,
		minY: start.y,
		maxX: end.x,
		maxY: end.y
	};
	return getIntersectElements(sibling, box$1);
}
/**
* 获取 sibling 模式下被 multiple mask 遮挡的 elements
* @param context 上下文
* @param sibling sibling view
* @param tolerance box 宽高小于则不返回
* @returns
*/
function getSiblingMultiMaskedElements(context, sibling, tolerance$2) {
	var maskBBoxList = getMultiMaskBBoxList(context, tolerance$2);
	if (maskBBoxList.length > 0) return maskBBoxList.flatMap(function(maskBBox) {
		return getSiblingMaskElementsByBBox(maskBBox, context, sibling);
	});
	return null;
}
/**
* 获取所有的图表元素
* @param view View/Chart
* @ignore
*/
function getElements(view) {
	var geometries = view.geometries;
	var rst = [];
	each_default(geometries, function(geom) {
		var elements = geom.elements;
		rst = rst.concat(elements);
	});
	if (view.views && view.views.length) each_default(view.views, function(subView) {
		rst = rst.concat(getElements(subView));
	});
	return rst;
}
/**
* 获取所有的图表元素
* @param view View/Chart
* @param field 字段名
* @param value 字段值
* @ignore
*/
function getElementsByField(view, field$5, value$1) {
	return getElements(view).filter(function(el) {
		return getElementValue$1(el, field$5) === value$1;
	});
}
/**
* 根据状态名获取图表元素
* @param view View/Chart
* @param stateName 状态名
* @ignore
*/
function getElementsByState(view, stateName) {
	var geometries = view.geometries;
	var rst = [];
	each_default(geometries, function(geom) {
		var elements = geom.getElementsBy(function(el) {
			return el.hasState(stateName);
		});
		rst = rst.concat(elements);
	});
	if (view.views && view.views.length) each_default(view.views, function(subView) {
		rst.push.apply(rst, __spreadArray([], __read(getElementsByState(subView, stateName)), false));
	});
	return rst;
}
/**
* 获取图表元素对应字段的值
* @param element 图表元素
* @param field 字段名
* @ignore
*/
function getElementValue$1(element, field$5) {
	var record = element.getModel().data;
	var value$1;
	if (is_array_default(record)) value$1 = record[0][field$5];
	else value$1 = record[field$5];
	return value$1;
}
/**
* 两个包围盒是否相交
* @param box1 包围盒1
* @param box2 包围盒2
* @ignore
*/
function intersectRect$1(box1, box2) {
	return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
}
/**
* 获取包围盒内的图表元素
* @param view View/Chart
* @param box 包围盒
* @ignore
*/
function getIntersectElements(view, box$1) {
	var elements = getElements(view);
	var rst = [];
	each_default(elements, function(el) {
		var shapeBBox = el.shape.getCanvasBBox();
		if (intersectRect$1(box$1, shapeBBox)) rst.push(el);
	});
	return rst;
}
function pathToPoints(path) {
	var points = [];
	each_default(path, function(seg) {
		if (seg[0] !== "A") for (var i = 1; i < seg.length; i = i + 2) points.push([seg[i], seg[i + 1]]);
		else {
			var length_1 = seg.length;
			points.push([seg[length_1 - 2], seg[length_1 - 1]]);
		}
	});
	return points;
}
/**
* 获取包围盒内的图表元素
* @param view View/Chart
* @param path 路径
* @ignore
*/
function getElementsByPath(view, path) {
	var elements = getElements(view);
	var points = pathToPoints(path);
	return elements.filter(function(el) {
		var shape = el.shape;
		var shapePoints;
		if (shape.get("type") === "path") shapePoints = pathToPoints(shape.attr("path"));
		else {
			var shapeBBox = shape.getCanvasBBox();
			shapePoints = toPoints(shapeBBox);
		}
		return isPolygonsIntersect(points, shapePoints);
	});
}
/**
* 获取当前 View 的所有组件
* @param view View/Chart
* @ignore
*/
function getComponents(view) {
	return view.getComponents().map(function(co) {
		return co.component;
	});
}
/** @ignore */
function distance$1(p1, p2) {
	var dx = p2.x - p1.x;
	var dy = p2.y - p1.y;
	return Math.sqrt(dx * dx + dy * dy);
}
/** @ignore */
function getSpline(points, z) {
	if (points.length <= 2) return getLinePath(points, false);
	var first = points[0];
	var arr = [];
	each_default(points, function(point$1) {
		arr.push(point$1.x);
		arr.push(point$1.y);
	});
	var path = catmullRom2bezier$1(arr, z, null);
	path.unshift([
		"M",
		first.x,
		first.y
	]);
	return path;
}
/**
* 检测点是否在包围盒内
* @param box 包围盒
* @param point 点
* @ignore
*/
function isInBox(box$1, point$1) {
	return box$1.x <= point$1.x && box$1.maxX >= point$1.x && box$1.y <= point$1.y && box$1.maxY > point$1.y;
}
/**
* 获取同 view 同一级的 views
* @param view 当前 view
* @returns 同一级的 views
* @ignore
*/
function getSilbings(view) {
	var parent = view.parent;
	var siblings = null;
	if (parent) siblings = parent.views.filter(function(sub$1) {
		return sub$1 !== view;
	});
	return siblings;
}
function point2Normalize(view, point$1) {
	return view.getCoordinate().invert(point$1);
}
/**
* 将 view 上的一点转换成另一个 view 的点
* @param view 当前的 view
* @param sibling 同一层级的 view
* @param point 指定点
* @ignore
*/
function getSiblingPoint(view, sibling, point$1) {
	var normalPoint = point2Normalize(view, point$1);
	return sibling.getCoordinate().convert(normalPoint);
}
/**
* 是否在记录中，临时因为所有的 view 中的数据不是引用，而使用的方法
* 不同 view 上对数据的引用不相等，导致无法直接用 includes
* 假设 x, y 值相等时是同一条数据，这个假设不完全正确，而改成 isEqual 则成本太高
* 后面改成同一个引用时可以修改回来
* @param records
* @param record
* @param xFiled
* @param yField
* @returns
* @ignore
*/
function isInRecords(records, record, xFiled, yField) {
	var isIn = false;
	each_default(records, function(r) {
		if (r[xFiled] === record[xFiled] && r[yField] === record[yField]) {
			isIn = true;
			return false;
		}
	});
	return isIn;
}
function getScaleByField(view, field$5) {
	var scale$4 = view.getScaleByField(field$5);
	if (!scale$4 && view.views) each_default(view.views, function(subView) {
		scale$4 = getScaleByField(subView, field$5);
		if (scale$4) return false;
	});
	return scale$4;
}

//#endregion
//#region node_modules/@antv/g2/esm/interaction/context.js
/**
* 交互的上下文
*/
var Context = function() {
	function Context$1(view) {
		/** 当前所有的 Action */
		this.actions = [];
		/** 当前事件对象 */
		this.event = null;
		this.cacheMap = {};
		this.view = view;
	}
	/**
	* 缓存信息
	* @param params 缓存的字段
	*  - 如果一个字段则获取缓存
	*  - 两个字段则设置缓存
	*/
	Context$1.prototype.cache = function() {
		var params = [];
		for (var _i = 0; _i < arguments.length; _i++) params[_i] = arguments[_i];
		if (params.length === 1) return this.cacheMap[params[0]];
		else if (params.length === 2) this.cacheMap[params[0]] = params[1];
	};
	/**
	* 获取 Action
	* @param name Action 的名称
	*/
	Context$1.prototype.getAction = function(name) {
		return this.actions.find(function(action) {
			return action.name === name;
		});
	};
	/**
	* 获取 Action
	* @param action Action 对象
	*/
	Context$1.prototype.addAction = function(action) {
		this.actions.push(action);
	};
	/**
	* 移除 Action
	* @param action Action 对象
	*/
	Context$1.prototype.removeAction = function(action) {
		var actions = this.actions;
		var index = this.actions.indexOf(action);
		if (index >= 0) actions.splice(index, 1);
	};
	/**
	* 获取当前的点
	*/
	Context$1.prototype.getCurrentPoint = function() {
		var event = this.event;
		if (event) if (event.target instanceof HTMLElement) return this.view.getCanvas().getPointByClient(event.clientX, event.clientY);
		else return {
			x: event.x,
			y: event.y
		};
		return null;
	};
	/**
	* 获取当前 shape
	* @returns current shape
	*/
	Context$1.prototype.getCurrentShape = function() {
		return get_default(this.event, ["gEvent", "shape"]);
	};
	/**
	* 当前的触发是否在 View 内
	*/
	Context$1.prototype.isInPlot = function() {
		var point$1 = this.getCurrentPoint();
		if (point$1) return this.view.isPointInPlot(point$1);
		return false;
	};
	/**
	* 是否在指定的图形内
	* @param name shape 的 name
	*/
	Context$1.prototype.isInShape = function(name) {
		var shape = this.getCurrentShape();
		if (shape) return shape.get("name") === name;
		return false;
	};
	/**
	* 当前的触发是组件内部
	* @param name 组件名，可以为空
	*/
	Context$1.prototype.isInComponent = function(name) {
		var components = getComponents(this.view);
		var point$1 = this.getCurrentPoint();
		if (point$1) return !!components.find(function(component$1) {
			var bbox = component$1.getBBox();
			if (name) return component$1.get("name") === name && isInBox(bbox, point$1);
			else return isInBox(bbox, point$1);
		});
		return false;
	};
	/**
	* 销毁
	*/
	Context$1.prototype.destroy = function() {
		each_default(this.actions.slice(), function(action) {
			action.destroy();
		});
		this.view = null;
		this.event = null;
		this.actions = null;
		this.cacheMap = null;
	};
	return Context$1;
}();
var context_default = Context;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/interaction.js
/**
* 交互的基类。
*/
var Interaction = function() {
	function Interaction$1(view, cfg) {
		this.view = view;
		this.cfg = cfg;
	}
	/**
	* 初始化。
	*/
	Interaction$1.prototype.init = function() {
		this.initEvents();
	};
	/**
	* 绑定事件
	*/
	Interaction$1.prototype.initEvents = function() {};
	/**
	* 销毁事件
	*/
	Interaction$1.prototype.clearEvents = function() {};
	/**
	* 销毁。
	*/
	Interaction$1.prototype.destroy = function() {
		this.clearEvents();
	};
	return Interaction$1;
}();
var interaction_default = Interaction;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/grammar-interaction.js
function parseAction(actionStr, context, arg) {
	var arr = actionStr.split(":");
	var actionName = arr[0];
	var action = context.getAction(actionName) || createAction(actionName, context);
	if (!action) throw new Error("There is no action named ".concat(actionName));
	var methodName = arr[1];
	return {
		action,
		methodName,
		arg
	};
}
function executeAction(actionObject) {
	var action = actionObject.action, methodName = actionObject.methodName, arg = actionObject.arg;
	if (action[methodName]) action[methodName](arg);
	else throw new Error("Action(".concat(action.name, ") doesn't have a method called ").concat(methodName));
}
var STEP_NAMES = {
	START: "start",
	SHOW_ENABLE: "showEnable",
	END: "end",
	ROLLBACK: "rollback",
	PROCESSING: "processing"
};
/**
* 支持语法的交互类
*/
var GrammarInteraction = function(_super) {
	__extends(GrammarInteraction$1, _super);
	function GrammarInteraction$1(view, steps) {
		var _this = _super.call(this, view, steps) || this;
		_this.callbackCaches = {};
		_this.emitCaches = {};
		_this.steps = steps;
		return _this;
	}
	/**
	* 初始化
	*/
	GrammarInteraction$1.prototype.init = function() {
		this.initContext();
		_super.prototype.init.call(this);
	};
	/**
	* 清理资源
	*/
	GrammarInteraction$1.prototype.destroy = function() {
		_super.prototype.destroy.call(this);
		this.steps = null;
		if (this.context) {
			this.context.destroy();
			this.context = null;
		}
		this.callbackCaches = null;
		this.view = null;
	};
	/**
	* 绑定事件
	*/
	GrammarInteraction$1.prototype.initEvents = function() {
		var _this = this;
		each_default(this.steps, function(stepArr, stepName) {
			each_default(stepArr, function(step) {
				var callback = _this.getActionCallback(stepName, step);
				if (callback) _this.bindEvent(step.trigger, callback);
			});
		});
	};
	/**
	* 清理绑定的事件
	*/
	GrammarInteraction$1.prototype.clearEvents = function() {
		var _this = this;
		each_default(this.steps, function(stepArr, stepName) {
			each_default(stepArr, function(step) {
				var callback = _this.getActionCallback(stepName, step);
				if (callback) _this.offEvent(step.trigger, callback);
			});
		});
	};
	GrammarInteraction$1.prototype.initContext = function() {
		var view = this.view;
		var context = new context_default(view);
		this.context = context;
		var steps = this.steps;
		each_default(steps, function(subSteps) {
			each_default(subSteps, function(step) {
				if (is_function_default(step.action)) step.actionObject = {
					action: createCallbackAction(step.action, context),
					methodName: "execute"
				};
				else if (is_string_default(step.action)) step.actionObject = parseAction(step.action, context, step.arg);
				else if (is_array_default(step.action)) {
					var actionArr = step.action;
					var argArr_1 = is_array_default(step.arg) ? step.arg : [step.arg];
					step.actionObject = [];
					each_default(actionArr, function(actionStr, idx) {
						step.actionObject.push(parseAction(actionStr, context, argArr_1[idx]));
					});
				}
			});
		});
	};
	GrammarInteraction$1.prototype.isAllowStep = function(stepName) {
		var currentStepName = this.currentStepName;
		var steps = this.steps;
		if (currentStepName === stepName) return true;
		if (stepName === STEP_NAMES.SHOW_ENABLE) return true;
		if (stepName === STEP_NAMES.PROCESSING) return currentStepName === STEP_NAMES.START;
		if (stepName === STEP_NAMES.START) return currentStepName !== STEP_NAMES.PROCESSING;
		if (stepName === STEP_NAMES.END) return currentStepName === STEP_NAMES.PROCESSING || currentStepName === STEP_NAMES.START;
		if (stepName === STEP_NAMES.ROLLBACK) {
			if (steps[STEP_NAMES.END]) return currentStepName === STEP_NAMES.END;
			else if (currentStepName === STEP_NAMES.START) return true;
		}
		return false;
	};
	GrammarInteraction$1.prototype.isAllowExecute = function(stepName, step) {
		if (this.isAllowStep(stepName)) {
			var key = this.getKey(stepName, step);
			if (step.once && this.emitCaches[key]) return false;
			if (step.isEnable) return step.isEnable(this.context);
			return true;
		}
		return false;
	};
	GrammarInteraction$1.prototype.enterStep = function(stepName) {
		this.currentStepName = stepName;
		this.emitCaches = {};
	};
	GrammarInteraction$1.prototype.afterExecute = function(stepName, step) {
		if (stepName !== STEP_NAMES.SHOW_ENABLE && this.currentStepName !== stepName) this.enterStep(stepName);
		var key = this.getKey(stepName, step);
		this.emitCaches[key] = true;
	};
	GrammarInteraction$1.prototype.getKey = function(stepName, step) {
		return stepName + step.trigger + step.action;
	};
	GrammarInteraction$1.prototype.getActionCallback = function(stepName, step) {
		var _this = this;
		var context = this.context;
		var callbackCaches = this.callbackCaches;
		var actionObject = step.actionObject;
		if (step.action && actionObject) {
			var key = this.getKey(stepName, step);
			if (!callbackCaches[key]) {
				var actionCallback = function(event) {
					context.event = event;
					if (_this.isAllowExecute(stepName, step)) {
						if (is_array_default(actionObject)) each_default(actionObject, function(obj) {
							context.event = event;
							executeAction(obj);
						});
						else {
							context.event = event;
							executeAction(actionObject);
						}
						_this.afterExecute(stepName, step);
						if (step.callback) {
							context.event = event;
							step.callback(context);
						}
					} else context.event = null;
				};
				if (step.debounce) callbackCaches[key] = debounce_default(actionCallback, step.debounce.wait, step.debounce.immediate);
				else if (step.throttle) callbackCaches[key] = throttle_default(actionCallback, step.throttle.wait, {
					leading: step.throttle.leading,
					trailing: step.throttle.trailing
				});
				else callbackCaches[key] = actionCallback;
			}
			return callbackCaches[key];
		}
		return null;
	};
	GrammarInteraction$1.prototype.bindEvent = function(eventName, callback) {
		var nameArr = eventName.split(":");
		if (nameArr[0] === "window") window.addEventListener(nameArr[1], callback);
		else if (nameArr[0] === "document") document.addEventListener(nameArr[1], callback);
		else this.view.on(eventName, callback);
	};
	GrammarInteraction$1.prototype.offEvent = function(eventName, callback) {
		var nameArr = eventName.split(":");
		if (nameArr[0] === "window") window.removeEventListener(nameArr[1], callback);
		else if (nameArr[0] === "document") document.removeEventListener(nameArr[1], callback);
		else this.view.off(eventName, callback);
	};
	return GrammarInteraction$1;
}(interaction_default);
var grammar_interaction_default = GrammarInteraction;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/index.js
var Interactions = {};
/**
* 根据交互行为名字获取对应的交互类
* @param name 交互名字
* @returns 交互类
*/
function getInteraction(name) {
	return Interactions[lower_case_default(name)];
}
/**
* 注册交互行为
* @param name 交互行为名字
* @param interaction 交互类
*/
function registerInteraction(name, interaction$9) {
	Interactions[lower_case_default(name)] = interaction$9;
}
/**
* 创建交互实例
* @param name 交互名
* @param view 交互应用的 View 实例
* @param cfg 交互行为配置
*/
function createInteraction(name, view, cfg) {
	var interaciton = getInteraction(name);
	if (!interaciton) return null;
	if (is_plain_object_default(interaciton)) {
		var steps = mix(clone_default(interaciton), cfg);
		return new grammar_interaction_default(view, steps);
	} else return new interaciton(view, cfg);
}

//#endregion
//#region node_modules/@antv/g2/esm/theme/util/create-by-style-sheet.js
/**
* 根据样式表创建 axis 组件主题样式
* @param styleSheet
*/
function createAxisStyles(styleSheet) {
	return {
		title: {
			autoRotate: true,
			position: "center",
			spacing: styleSheet.axisTitleSpacing,
			style: {
				fill: styleSheet.axisTitleTextFillColor,
				fontSize: styleSheet.axisTitleTextFontSize,
				lineHeight: styleSheet.axisTitleTextLineHeight,
				textBaseline: "middle",
				fontFamily: styleSheet.fontFamily
			},
			iconStyle: { fill: styleSheet.axisDescriptionIconFillColor }
		},
		label: {
			autoRotate: false,
			autoEllipsis: false,
			autoHide: {
				type: "equidistance",
				cfg: { minGap: 6 }
			},
			offset: styleSheet.axisLabelOffset,
			style: {
				fill: styleSheet.axisLabelFillColor,
				fontSize: styleSheet.axisLabelFontSize,
				lineHeight: styleSheet.axisLabelLineHeight,
				fontFamily: styleSheet.fontFamily
			}
		},
		line: { style: {
			lineWidth: styleSheet.axisLineBorder,
			stroke: styleSheet.axisLineBorderColor
		} },
		grid: {
			line: {
				type: "line",
				style: {
					stroke: styleSheet.axisGridBorderColor,
					lineWidth: styleSheet.axisGridBorder,
					lineDash: styleSheet.axisGridLineDash
				}
			},
			alignTick: true,
			animate: true
		},
		tickLine: {
			style: {
				lineWidth: styleSheet.axisTickLineBorder,
				stroke: styleSheet.axisTickLineBorderColor
			},
			alignTick: true,
			length: styleSheet.axisTickLineLength
		},
		subTickLine: null,
		animate: true
	};
}
/**
*
* @param styleSheet
*/
/**
* 根据样式表创建 legend 组件主题样式
* @param styleSheet
*/
function createLegendStyles(styleSheet) {
	return {
		title: null,
		marker: {
			symbol: "circle",
			spacing: styleSheet.legendMarkerSpacing,
			style: {
				r: styleSheet.legendCircleMarkerSize,
				fill: styleSheet.legendMarkerColor
			}
		},
		itemName: {
			spacing: 5,
			style: {
				fill: styleSheet.legendItemNameFillColor,
				fontFamily: styleSheet.fontFamily,
				fontSize: styleSheet.legendItemNameFontSize,
				lineHeight: styleSheet.legendItemNameLineHeight,
				fontWeight: styleSheet.legendItemNameFontWeight,
				textAlign: "start",
				textBaseline: "middle"
			}
		},
		itemStates: {
			active: { nameStyle: { opacity: .8 } },
			unchecked: {
				nameStyle: { fill: "#D8D8D8" },
				markerStyle: {
					fill: "#D8D8D8",
					stroke: "#D8D8D8"
				}
			},
			inactive: {
				nameStyle: { fill: "#D8D8D8" },
				markerStyle: { opacity: .2 }
			}
		},
		flipPage: true,
		pageNavigator: {
			marker: { style: {
				size: styleSheet.legendPageNavigatorMarkerSize,
				inactiveFill: styleSheet.legendPageNavigatorMarkerInactiveFillColor,
				inactiveOpacity: styleSheet.legendPageNavigatorMarkerInactiveFillOpacity,
				fill: styleSheet.legendPageNavigatorMarkerFillColor,
				opacity: styleSheet.legendPageNavigatorMarkerFillOpacity
			} },
			text: { style: {
				fill: styleSheet.legendPageNavigatorTextFillColor,
				fontSize: styleSheet.legendPageNavigatorTextFontSize
			} }
		},
		animate: false,
		maxItemWidth: 200,
		itemSpacing: styleSheet.legendItemSpacing,
		itemMarginBottom: styleSheet.legendItemMarginBottom,
		padding: styleSheet.legendPadding
	};
}
/**
* 根据主题样式表生成主题结构
* @param styleSheet 主题样式表
*/
function createThemeByStyleSheet(styleSheet) {
	var _a$5;
	var shapeStyles = {
		point: {
			default: {
				fill: styleSheet.pointFillColor,
				r: styleSheet.pointSize,
				stroke: styleSheet.pointBorderColor,
				lineWidth: styleSheet.pointBorder,
				fillOpacity: styleSheet.pointFillOpacity
			},
			active: {
				stroke: styleSheet.pointActiveBorderColor,
				lineWidth: styleSheet.pointActiveBorder
			},
			selected: {
				stroke: styleSheet.pointSelectedBorderColor,
				lineWidth: styleSheet.pointSelectedBorder
			},
			inactive: {
				fillOpacity: styleSheet.pointInactiveFillOpacity,
				strokeOpacity: styleSheet.pointInactiveBorderOpacity
			}
		},
		hollowPoint: {
			default: {
				fill: styleSheet.hollowPointFillColor,
				lineWidth: styleSheet.hollowPointBorder,
				stroke: styleSheet.hollowPointBorderColor,
				strokeOpacity: styleSheet.hollowPointBorderOpacity,
				r: styleSheet.hollowPointSize
			},
			active: {
				stroke: styleSheet.hollowPointActiveBorderColor,
				strokeOpacity: styleSheet.hollowPointActiveBorderOpacity
			},
			selected: {
				lineWidth: styleSheet.hollowPointSelectedBorder,
				stroke: styleSheet.hollowPointSelectedBorderColor,
				strokeOpacity: styleSheet.hollowPointSelectedBorderOpacity
			},
			inactive: { strokeOpacity: styleSheet.hollowPointInactiveBorderOpacity }
		},
		area: {
			default: {
				fill: styleSheet.areaFillColor,
				fillOpacity: styleSheet.areaFillOpacity,
				stroke: null
			},
			active: { fillOpacity: styleSheet.areaActiveFillOpacity },
			selected: { fillOpacity: styleSheet.areaSelectedFillOpacity },
			inactive: { fillOpacity: styleSheet.areaInactiveFillOpacity }
		},
		hollowArea: {
			default: {
				fill: null,
				stroke: styleSheet.hollowAreaBorderColor,
				lineWidth: styleSheet.hollowAreaBorder,
				strokeOpacity: styleSheet.hollowAreaBorderOpacity
			},
			active: {
				fill: null,
				lineWidth: styleSheet.hollowAreaActiveBorder
			},
			selected: {
				fill: null,
				lineWidth: styleSheet.hollowAreaSelectedBorder
			},
			inactive: { strokeOpacity: styleSheet.hollowAreaInactiveBorderOpacity }
		},
		interval: {
			default: {
				fill: styleSheet.intervalFillColor,
				fillOpacity: styleSheet.intervalFillOpacity
			},
			active: {
				stroke: styleSheet.intervalActiveBorderColor,
				lineWidth: styleSheet.intervalActiveBorder
			},
			selected: {
				stroke: styleSheet.intervalSelectedBorderColor,
				lineWidth: styleSheet.intervalSelectedBorder
			},
			inactive: {
				fillOpacity: styleSheet.intervalInactiveFillOpacity,
				strokeOpacity: styleSheet.intervalInactiveBorderOpacity
			}
		},
		hollowInterval: {
			default: {
				fill: styleSheet.hollowIntervalFillColor,
				stroke: styleSheet.hollowIntervalBorderColor,
				lineWidth: styleSheet.hollowIntervalBorder,
				strokeOpacity: styleSheet.hollowIntervalBorderOpacity
			},
			active: {
				stroke: styleSheet.hollowIntervalActiveBorderColor,
				lineWidth: styleSheet.hollowIntervalActiveBorder,
				strokeOpacity: styleSheet.hollowIntervalActiveBorderOpacity
			},
			selected: {
				stroke: styleSheet.hollowIntervalSelectedBorderColor,
				lineWidth: styleSheet.hollowIntervalSelectedBorder,
				strokeOpacity: styleSheet.hollowIntervalSelectedBorderOpacity
			},
			inactive: {
				stroke: styleSheet.hollowIntervalInactiveBorderColor,
				lineWidth: styleSheet.hollowIntervalInactiveBorder,
				strokeOpacity: styleSheet.hollowIntervalInactiveBorderOpacity
			}
		},
		line: {
			default: {
				stroke: styleSheet.lineBorderColor,
				lineWidth: styleSheet.lineBorder,
				strokeOpacity: styleSheet.lineBorderOpacity,
				fill: null,
				lineAppendWidth: 10,
				lineCap: "round",
				lineJoin: "round"
			},
			active: { lineWidth: styleSheet.lineActiveBorder },
			selected: { lineWidth: styleSheet.lineSelectedBorder },
			inactive: { strokeOpacity: styleSheet.lineInactiveBorderOpacity }
		}
	};
	var axisStyles = createAxisStyles(styleSheet);
	var legendStyles = createLegendStyles(styleSheet);
	return {
		background: styleSheet.backgroundColor,
		defaultColor: styleSheet.brandColor,
		subColor: styleSheet.subColor,
		semanticRed: styleSheet.paletteSemanticRed,
		semanticGreen: styleSheet.paletteSemanticGreen,
		padding: "auto",
		fontFamily: styleSheet.fontFamily,
		columnWidthRatio: 1 / 2,
		maxColumnWidth: null,
		minColumnWidth: null,
		roseWidthRatio: .9999999,
		multiplePieWidthRatio: 1 / 1.3,
		colors10: styleSheet.paletteQualitative10,
		colors20: styleSheet.paletteQualitative20,
		sequenceColors: styleSheet.paletteSequence,
		shapes: {
			point: [
				"hollow-circle",
				"hollow-square",
				"hollow-bowtie",
				"hollow-diamond",
				"hollow-hexagon",
				"hollow-triangle",
				"hollow-triangle-down",
				"circle",
				"square",
				"bowtie",
				"diamond",
				"hexagon",
				"triangle",
				"triangle-down",
				"cross",
				"tick",
				"plus",
				"hyphen",
				"line"
			],
			line: [
				"line",
				"dash",
				"dot",
				"smooth"
			],
			area: [
				"area",
				"smooth",
				"line",
				"smooth-line"
			],
			interval: [
				"rect",
				"hollow-rect",
				"line",
				"tick"
			]
		},
		sizes: [1, 10],
		geometries: {
			interval: {
				rect: {
					default: { style: shapeStyles.interval.default },
					active: { style: shapeStyles.interval.active },
					inactive: { style: shapeStyles.interval.inactive },
					selected: { style: function(element) {
						var coordinate$10 = element.geometry.coordinate;
						if (coordinate$10.isPolar && coordinate$10.isTransposed) {
							var _a$6 = getAngle(element.getModel(), coordinate$10), startAngle = _a$6.startAngle, endAngle = _a$6.endAngle;
							var middleAngle = (startAngle + endAngle) / 2;
							var r = 7.5;
							var x = r * Math.cos(middleAngle);
							var y = r * Math.sin(middleAngle);
							return { matrix: transform$6(null, [[
								"t",
								x,
								y
							]]) };
						}
						return shapeStyles.interval.selected;
					} }
				},
				"hollow-rect": {
					default: { style: shapeStyles.hollowInterval.default },
					active: { style: shapeStyles.hollowInterval.active },
					inactive: { style: shapeStyles.hollowInterval.inactive },
					selected: { style: shapeStyles.hollowInterval.selected }
				},
				line: {
					default: { style: shapeStyles.hollowInterval.default },
					active: { style: shapeStyles.hollowInterval.active },
					inactive: { style: shapeStyles.hollowInterval.inactive },
					selected: { style: shapeStyles.hollowInterval.selected }
				},
				tick: {
					default: { style: shapeStyles.hollowInterval.default },
					active: { style: shapeStyles.hollowInterval.active },
					inactive: { style: shapeStyles.hollowInterval.inactive },
					selected: { style: shapeStyles.hollowInterval.selected }
				},
				funnel: {
					default: { style: shapeStyles.interval.default },
					active: { style: shapeStyles.interval.active },
					inactive: { style: shapeStyles.interval.inactive },
					selected: { style: shapeStyles.interval.selected }
				},
				pyramid: {
					default: { style: shapeStyles.interval.default },
					active: { style: shapeStyles.interval.active },
					inactive: { style: shapeStyles.interval.inactive },
					selected: { style: shapeStyles.interval.selected }
				}
			},
			line: {
				line: {
					default: { style: shapeStyles.line.default },
					active: { style: shapeStyles.line.active },
					inactive: { style: shapeStyles.line.inactive },
					selected: { style: shapeStyles.line.selected }
				},
				dot: {
					default: { style: __assign(__assign({}, shapeStyles.line.default), {
						lineCap: null,
						lineDash: [1, 1]
					}) },
					active: { style: __assign(__assign({}, shapeStyles.line.active), {
						lineCap: null,
						lineDash: [1, 1]
					}) },
					inactive: { style: __assign(__assign({}, shapeStyles.line.inactive), {
						lineCap: null,
						lineDash: [1, 1]
					}) },
					selected: { style: __assign(__assign({}, shapeStyles.line.selected), {
						lineCap: null,
						lineDash: [1, 1]
					}) }
				},
				dash: {
					default: { style: __assign(__assign({}, shapeStyles.line.default), {
						lineCap: null,
						lineDash: [5.5, 1]
					}) },
					active: { style: __assign(__assign({}, shapeStyles.line.active), {
						lineCap: null,
						lineDash: [5.5, 1]
					}) },
					inactive: { style: __assign(__assign({}, shapeStyles.line.inactive), {
						lineCap: null,
						lineDash: [5.5, 1]
					}) },
					selected: { style: __assign(__assign({}, shapeStyles.line.selected), {
						lineCap: null,
						lineDash: [5.5, 1]
					}) }
				},
				smooth: {
					default: { style: shapeStyles.line.default },
					active: { style: shapeStyles.line.active },
					inactive: { style: shapeStyles.line.inactive },
					selected: { style: shapeStyles.line.selected }
				},
				hv: {
					default: { style: shapeStyles.line.default },
					active: { style: shapeStyles.line.active },
					inactive: { style: shapeStyles.line.inactive },
					selected: { style: shapeStyles.line.selected }
				},
				vh: {
					default: { style: shapeStyles.line.default },
					active: { style: shapeStyles.line.active },
					inactive: { style: shapeStyles.line.inactive },
					selected: { style: shapeStyles.line.selected }
				},
				hvh: {
					default: { style: shapeStyles.line.default },
					active: { style: shapeStyles.line.active },
					inactive: { style: shapeStyles.line.inactive },
					selected: { style: shapeStyles.line.selected }
				},
				vhv: {
					default: { style: shapeStyles.line.default },
					active: { style: shapeStyles.line.active },
					inactive: { style: shapeStyles.line.inactive },
					selected: { style: shapeStyles.line.selected }
				}
			},
			polygon: { polygon: {
				default: { style: shapeStyles.interval.default },
				active: { style: shapeStyles.interval.active },
				inactive: { style: shapeStyles.interval.inactive },
				selected: { style: shapeStyles.interval.selected }
			} },
			point: {
				circle: {
					default: { style: shapeStyles.point.default },
					active: { style: shapeStyles.point.active },
					inactive: { style: shapeStyles.point.inactive },
					selected: { style: shapeStyles.point.selected }
				},
				square: {
					default: { style: shapeStyles.point.default },
					active: { style: shapeStyles.point.active },
					inactive: { style: shapeStyles.point.inactive },
					selected: { style: shapeStyles.point.selected }
				},
				bowtie: {
					default: { style: shapeStyles.point.default },
					active: { style: shapeStyles.point.active },
					inactive: { style: shapeStyles.point.inactive },
					selected: { style: shapeStyles.point.selected }
				},
				diamond: {
					default: { style: shapeStyles.point.default },
					active: { style: shapeStyles.point.active },
					inactive: { style: shapeStyles.point.inactive },
					selected: { style: shapeStyles.point.selected }
				},
				hexagon: {
					default: { style: shapeStyles.point.default },
					active: { style: shapeStyles.point.active },
					inactive: { style: shapeStyles.point.inactive },
					selected: { style: shapeStyles.point.selected }
				},
				triangle: {
					default: { style: shapeStyles.point.default },
					active: { style: shapeStyles.point.active },
					inactive: { style: shapeStyles.point.inactive },
					selected: { style: shapeStyles.point.selected }
				},
				"triangle-down": {
					default: { style: shapeStyles.point.default },
					active: { style: shapeStyles.point.active },
					inactive: { style: shapeStyles.point.inactive },
					selected: { style: shapeStyles.point.selected }
				},
				"hollow-circle": {
					default: { style: shapeStyles.hollowPoint.default },
					active: { style: shapeStyles.hollowPoint.active },
					inactive: { style: shapeStyles.hollowPoint.inactive },
					selected: { style: shapeStyles.hollowPoint.selected }
				},
				"hollow-square": {
					default: { style: shapeStyles.hollowPoint.default },
					active: { style: shapeStyles.hollowPoint.active },
					inactive: { style: shapeStyles.hollowPoint.inactive },
					selected: { style: shapeStyles.hollowPoint.selected }
				},
				"hollow-bowtie": {
					default: { style: shapeStyles.hollowPoint.default },
					active: { style: shapeStyles.hollowPoint.active },
					inactive: { style: shapeStyles.hollowPoint.inactive },
					selected: { style: shapeStyles.hollowPoint.selected }
				},
				"hollow-diamond": {
					default: { style: shapeStyles.hollowPoint.default },
					active: { style: shapeStyles.hollowPoint.active },
					inactive: { style: shapeStyles.hollowPoint.inactive },
					selected: { style: shapeStyles.hollowPoint.selected }
				},
				"hollow-hexagon": {
					default: { style: shapeStyles.hollowPoint.default },
					active: { style: shapeStyles.hollowPoint.active },
					inactive: { style: shapeStyles.hollowPoint.inactive },
					selected: { style: shapeStyles.hollowPoint.selected }
				},
				"hollow-triangle": {
					default: { style: shapeStyles.hollowPoint.default },
					active: { style: shapeStyles.hollowPoint.active },
					inactive: { style: shapeStyles.hollowPoint.inactive },
					selected: { style: shapeStyles.hollowPoint.selected }
				},
				"hollow-triangle-down": {
					default: { style: shapeStyles.hollowPoint.default },
					active: { style: shapeStyles.hollowPoint.active },
					inactive: { style: shapeStyles.hollowPoint.inactive },
					selected: { style: shapeStyles.hollowPoint.selected }
				},
				cross: {
					default: { style: shapeStyles.hollowPoint.default },
					active: { style: shapeStyles.hollowPoint.active },
					inactive: { style: shapeStyles.hollowPoint.inactive },
					selected: { style: shapeStyles.hollowPoint.selected }
				},
				tick: {
					default: { style: shapeStyles.hollowPoint.default },
					active: { style: shapeStyles.hollowPoint.active },
					inactive: { style: shapeStyles.hollowPoint.inactive },
					selected: { style: shapeStyles.hollowPoint.selected }
				},
				plus: {
					default: { style: shapeStyles.hollowPoint.default },
					active: { style: shapeStyles.hollowPoint.active },
					inactive: { style: shapeStyles.hollowPoint.inactive },
					selected: { style: shapeStyles.hollowPoint.selected }
				},
				hyphen: {
					default: { style: shapeStyles.hollowPoint.default },
					active: { style: shapeStyles.hollowPoint.active },
					inactive: { style: shapeStyles.hollowPoint.inactive },
					selected: { style: shapeStyles.hollowPoint.selected }
				},
				line: {
					default: { style: shapeStyles.hollowPoint.default },
					active: { style: shapeStyles.hollowPoint.active },
					inactive: { style: shapeStyles.hollowPoint.inactive },
					selected: { style: shapeStyles.hollowPoint.selected }
				}
			},
			area: {
				area: {
					default: { style: shapeStyles.area.default },
					active: { style: shapeStyles.area.active },
					inactive: { style: shapeStyles.area.inactive },
					selected: { style: shapeStyles.area.selected }
				},
				smooth: {
					default: { style: shapeStyles.area.default },
					active: { style: shapeStyles.area.active },
					inactive: { style: shapeStyles.area.inactive },
					selected: { style: shapeStyles.area.selected }
				},
				line: {
					default: { style: shapeStyles.hollowArea.default },
					active: { style: shapeStyles.hollowArea.active },
					inactive: { style: shapeStyles.hollowArea.inactive },
					selected: { style: shapeStyles.hollowArea.selected }
				},
				"smooth-line": {
					default: { style: shapeStyles.hollowArea.default },
					active: { style: shapeStyles.hollowArea.active },
					inactive: { style: shapeStyles.hollowArea.inactive },
					selected: { style: shapeStyles.hollowArea.selected }
				}
			},
			schema: {
				candle: {
					default: { style: shapeStyles.hollowInterval.default },
					active: { style: shapeStyles.hollowInterval.active },
					inactive: { style: shapeStyles.hollowInterval.inactive },
					selected: { style: shapeStyles.hollowInterval.selected }
				},
				box: {
					default: { style: shapeStyles.hollowInterval.default },
					active: { style: shapeStyles.hollowInterval.active },
					inactive: { style: shapeStyles.hollowInterval.inactive },
					selected: { style: shapeStyles.hollowInterval.selected }
				}
			},
			edge: {
				line: {
					default: { style: shapeStyles.line.default },
					active: { style: shapeStyles.line.active },
					inactive: { style: shapeStyles.line.inactive },
					selected: { style: shapeStyles.line.selected }
				},
				vhv: {
					default: { style: shapeStyles.line.default },
					active: { style: shapeStyles.line.active },
					inactive: { style: shapeStyles.line.inactive },
					selected: { style: shapeStyles.line.selected }
				},
				smooth: {
					default: { style: shapeStyles.line.default },
					active: { style: shapeStyles.line.active },
					inactive: { style: shapeStyles.line.inactive },
					selected: { style: shapeStyles.line.selected }
				},
				arc: {
					default: { style: shapeStyles.line.default },
					active: { style: shapeStyles.line.active },
					inactive: { style: shapeStyles.line.inactive },
					selected: { style: shapeStyles.line.selected }
				}
			},
			violin: {
				violin: {
					default: { style: shapeStyles.line.default },
					active: { style: shapeStyles.line.active },
					inactive: { style: shapeStyles.line.inactive },
					selected: { style: shapeStyles.line.selected }
				},
				smooth: {
					default: { style: shapeStyles.line.default },
					active: { style: shapeStyles.line.active },
					inactive: { style: shapeStyles.line.inactive },
					selected: { style: shapeStyles.line.selected }
				},
				hollow: {
					default: { style: shapeStyles.hollowArea.default },
					active: { style: shapeStyles.hollowArea.active },
					inactive: { style: shapeStyles.hollowArea.inactive },
					selected: { style: shapeStyles.hollowArea.selected }
				},
				"hollow-smooth": {
					default: { style: shapeStyles.hollowArea.default },
					active: { style: shapeStyles.hollowArea.active },
					inactive: { style: shapeStyles.hollowArea.inactive },
					selected: { style: shapeStyles.hollowArea.selected }
				}
			}
		},
		components: {
			axis: {
				common: axisStyles,
				top: {
					position: "top",
					grid: null,
					title: null,
					verticalLimitLength: 1 / 2
				},
				bottom: {
					position: "bottom",
					grid: null,
					title: null,
					verticalLimitLength: 1 / 2
				},
				left: {
					position: "left",
					title: null,
					line: null,
					tickLine: null,
					verticalLimitLength: 1 / 3
				},
				right: {
					position: "right",
					title: null,
					line: null,
					tickLine: null,
					verticalLimitLength: 1 / 3
				},
				circle: {
					title: null,
					grid: deep_mix_default({}, axisStyles.grid, { line: { type: "line" } })
				},
				radius: {
					title: null,
					grid: deep_mix_default({}, axisStyles.grid, { line: { type: "circle" } })
				}
			},
			legend: {
				common: legendStyles,
				right: {
					layout: "vertical",
					padding: styleSheet.legendVerticalPadding
				},
				left: {
					layout: "vertical",
					padding: styleSheet.legendVerticalPadding
				},
				top: {
					layout: "horizontal",
					padding: styleSheet.legendHorizontalPadding
				},
				bottom: {
					layout: "horizontal",
					padding: styleSheet.legendHorizontalPadding
				},
				continuous: {
					title: null,
					background: null,
					track: {},
					rail: {
						type: "color",
						size: styleSheet.sliderRailHeight,
						defaultLength: styleSheet.sliderRailWidth,
						style: {
							fill: styleSheet.sliderRailFillColor,
							stroke: styleSheet.sliderRailBorderColor,
							lineWidth: styleSheet.sliderRailBorder
						}
					},
					label: {
						align: "rail",
						spacing: 4,
						formatter: null,
						style: {
							fill: styleSheet.sliderLabelTextFillColor,
							fontSize: styleSheet.sliderLabelTextFontSize,
							lineHeight: styleSheet.sliderLabelTextLineHeight,
							textBaseline: "middle",
							fontFamily: styleSheet.fontFamily
						}
					},
					handler: {
						size: styleSheet.sliderHandlerWidth,
						style: {
							fill: styleSheet.sliderHandlerFillColor,
							stroke: styleSheet.sliderHandlerBorderColor
						}
					},
					slidable: true,
					padding: legendStyles.padding
				}
			},
			tooltip: {
				showContent: true,
				follow: true,
				showCrosshairs: false,
				showMarkers: true,
				shared: false,
				enterable: false,
				position: "auto",
				marker: {
					symbol: "circle",
					stroke: "#fff",
					shadowBlur: 10,
					shadowOffsetX: 0,
					shadowOffsetY: 0,
					shadowColor: "rgba(0,0,0,0.09)",
					lineWidth: 2,
					r: 4
				},
				crosshairs: {
					line: { style: {
						stroke: styleSheet.tooltipCrosshairsBorderColor,
						lineWidth: styleSheet.tooltipCrosshairsBorder
					} },
					text: null,
					textBackground: {
						padding: 2,
						style: {
							fill: "rgba(0, 0, 0, 0.25)",
							lineWidth: 0,
							stroke: null
						}
					},
					follow: false
				},
				domStyles: (_a$5 = {}, _a$5["".concat(CONTAINER_CLASS)] = {
					position: "absolute",
					visibility: "hidden",
					zIndex: 8,
					transition: "left 0.4s cubic-bezier(0.23, 1, 0.32, 1) 0s, top 0.4s cubic-bezier(0.23, 1, 0.32, 1) 0s",
					backgroundColor: styleSheet.tooltipContainerFillColor,
					opacity: styleSheet.tooltipContainerFillOpacity,
					boxShadow: styleSheet.tooltipContainerShadow,
					borderRadius: "".concat(styleSheet.tooltipContainerBorderRadius, "px"),
					color: styleSheet.tooltipTextFillColor,
					fontSize: "".concat(styleSheet.tooltipTextFontSize, "px"),
					fontFamily: styleSheet.fontFamily,
					lineHeight: "".concat(styleSheet.tooltipTextLineHeight, "px"),
					padding: "0 12px 0 12px"
				}, _a$5["".concat(TITLE_CLASS)] = {
					marginBottom: "12px",
					marginTop: "12px"
				}, _a$5["".concat(LIST_CLASS)] = {
					margin: 0,
					listStyleType: "none",
					padding: 0
				}, _a$5["".concat(LIST_ITEM_CLASS)] = {
					listStyleType: "none",
					padding: 0,
					marginBottom: "12px",
					marginTop: "12px",
					marginLeft: 0,
					marginRight: 0
				}, _a$5["".concat(MARKER_CLASS)] = {
					width: "8px",
					height: "8px",
					borderRadius: "50%",
					display: "inline-block",
					marginRight: "8px"
				}, _a$5["".concat(VALUE_CLASS)] = {
					display: "inline-block",
					float: "right",
					marginLeft: "30px"
				}, _a$5)
			},
			annotation: {
				arc: {
					style: {
						stroke: styleSheet.annotationArcBorderColor,
						lineWidth: styleSheet.annotationArcBorder
					},
					animate: true
				},
				line: {
					style: {
						stroke: styleSheet.annotationLineBorderColor,
						lineDash: styleSheet.annotationLineDash,
						lineWidth: styleSheet.annotationLineBorder
					},
					text: {
						position: "start",
						autoRotate: true,
						style: {
							fill: styleSheet.annotationTextFillColor,
							stroke: styleSheet.annotationTextBorderColor,
							lineWidth: styleSheet.annotationTextBorder,
							fontSize: styleSheet.annotationTextFontSize,
							textAlign: "start",
							fontFamily: styleSheet.fontFamily,
							textBaseline: "bottom"
						}
					},
					animate: true
				},
				text: {
					style: {
						fill: styleSheet.annotationTextFillColor,
						stroke: styleSheet.annotationTextBorderColor,
						lineWidth: styleSheet.annotationTextBorder,
						fontSize: styleSheet.annotationTextFontSize,
						textBaseline: "middle",
						textAlign: "start",
						fontFamily: styleSheet.fontFamily
					},
					animate: true
				},
				region: {
					top: false,
					style: {
						lineWidth: styleSheet.annotationRegionBorder,
						stroke: styleSheet.annotationRegionBorderColor,
						fill: styleSheet.annotationRegionFillColor,
						fillOpacity: styleSheet.annotationRegionFillOpacity
					},
					animate: true
				},
				image: {
					top: false,
					animate: true
				},
				dataMarker: {
					top: true,
					point: { style: {
						r: 3,
						stroke: styleSheet.brandColor,
						lineWidth: 2
					} },
					line: {
						style: {
							stroke: styleSheet.annotationLineBorderColor,
							lineWidth: styleSheet.annotationLineBorder
						},
						length: styleSheet.annotationDataMarkerLineLength
					},
					text: { style: {
						textAlign: "start",
						fill: styleSheet.annotationTextFillColor,
						stroke: styleSheet.annotationTextBorderColor,
						lineWidth: styleSheet.annotationTextBorder,
						fontSize: styleSheet.annotationTextFontSize,
						fontFamily: styleSheet.fontFamily
					} },
					direction: "upward",
					autoAdjust: true,
					animate: true
				},
				dataRegion: {
					style: {
						region: {
							fill: styleSheet.annotationRegionFillColor,
							fillOpacity: styleSheet.annotationRegionFillOpacity
						},
						text: {
							textAlign: "center",
							textBaseline: "bottom",
							fill: styleSheet.annotationTextFillColor,
							stroke: styleSheet.annotationTextBorderColor,
							lineWidth: styleSheet.annotationTextBorder,
							fontSize: styleSheet.annotationTextFontSize,
							fontFamily: styleSheet.fontFamily
						}
					},
					animate: true
				}
			},
			slider: { common: {
				padding: [
					8,
					8,
					8,
					8
				],
				backgroundStyle: {
					fill: styleSheet.cSliderBackgroundFillColor,
					opacity: styleSheet.cSliderBackgroundFillOpacity
				},
				foregroundStyle: {
					fill: styleSheet.cSliderForegroundFillColor,
					opacity: styleSheet.cSliderForegroundFillOpacity
				},
				handlerStyle: {
					width: styleSheet.cSliderHandlerWidth,
					height: styleSheet.cSliderHandlerHeight,
					fill: styleSheet.cSliderHandlerFillColor,
					opacity: styleSheet.cSliderHandlerFillOpacity,
					stroke: styleSheet.cSliderHandlerBorderColor,
					lineWidth: styleSheet.cSliderHandlerBorder,
					radius: styleSheet.cSliderHandlerBorderRadius,
					highLightFill: styleSheet.cSliderHandlerHighlightFillColor
				},
				textStyle: {
					fill: styleSheet.cSliderTextFillColor,
					opacity: styleSheet.cSliderTextFillOpacity,
					fontSize: styleSheet.cSliderTextFontSize,
					lineHeight: styleSheet.cSliderTextLineHeight,
					fontWeight: styleSheet.cSliderTextFontWeight,
					stroke: styleSheet.cSliderTextBorderColor,
					lineWidth: styleSheet.cSliderTextBorder
				}
			} },
			scrollbar: {
				common: { padding: [
					8,
					8,
					8,
					8
				] },
				default: { style: {
					trackColor: styleSheet.scrollbarTrackFillColor,
					thumbColor: styleSheet.scrollbarThumbFillColor
				} },
				hover: { style: { thumbColor: styleSheet.scrollbarThumbHighlightFillColor } }
			}
		},
		labels: {
			offset: 12,
			style: {
				fill: styleSheet.labelFillColor,
				fontSize: styleSheet.labelFontSize,
				fontFamily: styleSheet.fontFamily,
				stroke: styleSheet.labelBorderColor,
				lineWidth: styleSheet.labelBorder
			},
			fillColorDark: styleSheet.labelFillColorDark,
			fillColorLight: styleSheet.labelFillColorLight,
			autoRotate: true
		},
		innerLabels: {
			style: {
				fill: styleSheet.innerLabelFillColor,
				fontSize: styleSheet.innerLabelFontSize,
				fontFamily: styleSheet.fontFamily,
				stroke: styleSheet.innerLabelBorderColor,
				lineWidth: styleSheet.innerLabelBorder
			},
			autoRotate: true
		},
		overflowLabels: { style: {
			fill: styleSheet.overflowLabelFillColor,
			fontSize: styleSheet.overflowLabelFontSize,
			fontFamily: styleSheet.fontFamily,
			stroke: styleSheet.overflowLabelBorderColor,
			lineWidth: styleSheet.overflowLabelBorder
		} },
		pieLabels: {
			labelHeight: 14,
			offset: 10,
			labelLine: { style: { lineWidth: styleSheet.labelLineBorder } },
			autoRotate: true
		}
	};
}

//#endregion
//#region node_modules/@antv/g2/esm/theme/style-sheet/light.js
var BLACK_COLORS$1 = {
	100: "#000",
	95: "#0D0D0D",
	85: "#262626",
	65: "#595959",
	45: "#8C8C8C",
	25: "#BFBFBF",
	15: "#D9D9D9",
	6: "#F0F0F0"
};
var WHITE_COLORS$1 = {
	100: "#FFFFFF",
	95: "#F2F2F2",
	85: "#D9D9D9",
	65: "#A6A6A6",
	45: "#737373",
	25: "#404040",
	15: "#262626",
	6: "#0F0F0F"
};
var QUALITATIVE_10$1 = [
	"#5B8FF9",
	"#5AD8A6",
	"#5D7092",
	"#F6BD16",
	"#6F5EF9",
	"#6DC8EC",
	"#945FB9",
	"#FF9845",
	"#1E9493",
	"#FF99C3"
];
var QUALITATIVE_20$1 = [
	"#5B8FF9",
	"#CDDDFD",
	"#5AD8A6",
	"#CDF3E4",
	"#5D7092",
	"#CED4DE",
	"#F6BD16",
	"#FCEBB9",
	"#6F5EF9",
	"#D3CEFD",
	"#6DC8EC",
	"#D3EEF9",
	"#945FB9",
	"#DECFEA",
	"#FF9845",
	"#FFE0C7",
	"#1E9493",
	"#BBDEDE",
	"#FF99C3",
	"#FFE0ED"
];
/** 单色顺序色板 */
var SINGLE_SEQUENCE$1 = [
	"#B8E1FF",
	"#9AC5FF",
	"#7DAAFF",
	"#5B8FF9",
	"#3D76DD",
	"#085EC0",
	"#0047A5",
	"#00318A",
	"#001D70"
];
var createLightStyleSheet = function(cfg) {
	if (cfg === void 0) cfg = {};
	var _a$5 = cfg.paletteQualitative10, paletteQualitative10 = _a$5 === void 0 ? QUALITATIVE_10$1 : _a$5, _b = cfg.paletteQualitative20, paletteQualitative20 = _b === void 0 ? QUALITATIVE_20$1 : _b;
	var _c = cfg.brandColor, brandColor = _c === void 0 ? paletteQualitative10[0] : _c;
	var token$1 = {
		backgroundColor: "transparent",
		brandColor,
		subColor: "rgba(0,0,0,0.05)",
		paletteQualitative10,
		paletteQualitative20,
		paletteSemanticRed: "#F4664A",
		paletteSemanticGreen: "#30BF78",
		paletteSemanticYellow: "#FAAD14",
		paletteSequence: SINGLE_SEQUENCE$1,
		fontFamily: "\"Segoe UI\", Roboto, \"Helvetica Neue\", Arial,\n    \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\",\n    \"Noto Color Emoji\"",
		axisLineBorderColor: BLACK_COLORS$1[25],
		axisLineBorder: 1,
		axisLineDash: null,
		axisTitleTextFillColor: BLACK_COLORS$1[65],
		axisTitleTextFontSize: 12,
		axisTitleTextLineHeight: 12,
		axisTitleTextFontWeight: "normal",
		axisTitleSpacing: 12,
		axisDescriptionIconFillColor: WHITE_COLORS$1[85],
		axisTickLineBorderColor: BLACK_COLORS$1[25],
		axisTickLineLength: 4,
		axisTickLineBorder: 1,
		axisSubTickLineBorderColor: BLACK_COLORS$1[15],
		axisSubTickLineLength: 2,
		axisSubTickLineBorder: 1,
		axisLabelFillColor: BLACK_COLORS$1[45],
		axisLabelFontSize: 12,
		axisLabelLineHeight: 12,
		axisLabelFontWeight: "normal",
		axisLabelOffset: 8,
		axisGridBorderColor: BLACK_COLORS$1[15],
		axisGridBorder: 1,
		axisGridLineDash: null,
		legendTitleTextFillColor: BLACK_COLORS$1[45],
		legendTitleTextFontSize: 12,
		legendTitleTextLineHeight: 21,
		legendTitleTextFontWeight: "normal",
		legendMarkerColor: brandColor,
		legendMarkerSpacing: 8,
		legendMarkerSize: 4,
		legendCircleMarkerSize: 4,
		legendSquareMarkerSize: 4,
		legendLineMarkerSize: 5,
		legendItemNameFillColor: BLACK_COLORS$1[65],
		legendItemNameFontSize: 12,
		legendItemNameLineHeight: 12,
		legendItemNameFontWeight: "normal",
		legendItemSpacing: 24,
		legendItemMarginBottom: 12,
		legendPadding: [
			8,
			8,
			8,
			8
		],
		legendHorizontalPadding: [
			8,
			0,
			8,
			0
		],
		legendVerticalPadding: [
			0,
			8,
			0,
			8
		],
		legendPageNavigatorMarkerSize: 12,
		legendPageNavigatorMarkerInactiveFillColor: BLACK_COLORS$1[100],
		legendPageNavigatorMarkerInactiveFillOpacity: .45,
		legendPageNavigatorMarkerFillColor: BLACK_COLORS$1[100],
		legendPageNavigatorMarkerFillOpacity: 1,
		legendPageNavigatorTextFillColor: BLACK_COLORS$1[45],
		legendPageNavigatorTextFontSize: 12,
		sliderRailFillColor: BLACK_COLORS$1[15],
		sliderRailBorder: 0,
		sliderRailBorderColor: null,
		sliderRailWidth: 100,
		sliderRailHeight: 12,
		sliderLabelTextFillColor: BLACK_COLORS$1[45],
		sliderLabelTextFontSize: 12,
		sliderLabelTextLineHeight: 12,
		sliderLabelTextFontWeight: "normal",
		sliderHandlerFillColor: BLACK_COLORS$1[6],
		sliderHandlerWidth: 10,
		sliderHandlerHeight: 14,
		sliderHandlerBorder: 1,
		sliderHandlerBorderColor: BLACK_COLORS$1[25],
		annotationArcBorderColor: BLACK_COLORS$1[15],
		annotationArcBorder: 1,
		annotationLineBorderColor: BLACK_COLORS$1[25],
		annotationLineBorder: 1,
		annotationLineDash: null,
		annotationTextFillColor: BLACK_COLORS$1[65],
		annotationTextFontSize: 12,
		annotationTextLineHeight: 12,
		annotationTextFontWeight: "normal",
		annotationTextBorderColor: null,
		annotationTextBorder: 0,
		annotationRegionFillColor: BLACK_COLORS$1[100],
		annotationRegionFillOpacity: .06,
		annotationRegionBorder: 0,
		annotationRegionBorderColor: null,
		annotationDataMarkerLineLength: 16,
		tooltipCrosshairsBorderColor: BLACK_COLORS$1[25],
		tooltipCrosshairsBorder: 1,
		tooltipCrosshairsLineDash: null,
		tooltipContainerFillColor: "rgb(255, 255, 255)",
		tooltipContainerFillOpacity: .95,
		tooltipContainerShadow: "0px 0px 10px #aeaeae",
		tooltipContainerBorderRadius: 3,
		tooltipTextFillColor: BLACK_COLORS$1[65],
		tooltipTextFontSize: 12,
		tooltipTextLineHeight: 12,
		tooltipTextFontWeight: "bold",
		labelFillColor: BLACK_COLORS$1[65],
		labelFillColorDark: "#2c3542",
		labelFillColorLight: "#ffffff",
		labelFontSize: 12,
		labelLineHeight: 12,
		labelFontWeight: "normal",
		labelBorderColor: null,
		labelBorder: 0,
		innerLabelFillColor: WHITE_COLORS$1[100],
		innerLabelFontSize: 12,
		innerLabelLineHeight: 12,
		innerLabelFontWeight: "normal",
		innerLabelBorderColor: null,
		innerLabelBorder: 0,
		overflowLabelFillColor: BLACK_COLORS$1[65],
		overflowLabelFontSize: 12,
		overflowLabelLineHeight: 12,
		overflowLabelFontWeight: "normal",
		overflowLabelBorderColor: WHITE_COLORS$1[100],
		overflowLabelBorder: 1,
		labelLineBorder: 1,
		labelLineBorderColor: BLACK_COLORS$1[25],
		cSliderRailHieght: 16,
		cSliderBackgroundFillColor: "#416180",
		cSliderBackgroundFillOpacity: .05,
		cSliderForegroundFillColor: "#5B8FF9",
		cSliderForegroundFillOpacity: .15,
		cSliderHandlerHeight: 24,
		cSliderHandlerWidth: 10,
		cSliderHandlerFillColor: "#F7F7F7",
		cSliderHandlerFillOpacity: 1,
		cSliderHandlerHighlightFillColor: "#FFF",
		cSliderHandlerBorderColor: "#BFBFBF",
		cSliderHandlerBorder: 1,
		cSliderHandlerBorderRadius: 2,
		cSliderTextFillColor: "#000",
		cSliderTextFillOpacity: .45,
		cSliderTextFontSize: 12,
		cSliderTextLineHeight: 12,
		cSliderTextFontWeight: "normal",
		cSliderTextBorderColor: null,
		cSliderTextBorder: 0,
		scrollbarTrackFillColor: "rgba(0,0,0,0)",
		scrollbarThumbFillColor: "rgba(0,0,0,0.15)",
		scrollbarThumbHighlightFillColor: "rgba(0,0,0,0.2)",
		pointFillColor: brandColor,
		pointFillOpacity: .95,
		pointSize: 4,
		pointBorder: 1,
		pointBorderColor: WHITE_COLORS$1[100],
		pointBorderOpacity: 1,
		pointActiveBorderColor: BLACK_COLORS$1[100],
		pointSelectedBorder: 2,
		pointSelectedBorderColor: BLACK_COLORS$1[100],
		pointInactiveFillOpacity: .3,
		pointInactiveBorderOpacity: .3,
		hollowPointSize: 4,
		hollowPointBorder: 1,
		hollowPointBorderColor: brandColor,
		hollowPointBorderOpacity: .95,
		hollowPointFillColor: WHITE_COLORS$1[100],
		hollowPointActiveBorder: 1,
		hollowPointActiveBorderColor: BLACK_COLORS$1[100],
		hollowPointActiveBorderOpacity: 1,
		hollowPointSelectedBorder: 2,
		hollowPointSelectedBorderColor: BLACK_COLORS$1[100],
		hollowPointSelectedBorderOpacity: 1,
		hollowPointInactiveBorderOpacity: .3,
		lineBorder: 2,
		lineBorderColor: brandColor,
		lineBorderOpacity: 1,
		lineActiveBorder: 3,
		lineSelectedBorder: 3,
		lineInactiveBorderOpacity: .3,
		areaFillColor: brandColor,
		areaFillOpacity: .25,
		areaActiveFillColor: brandColor,
		areaActiveFillOpacity: .5,
		areaSelectedFillColor: brandColor,
		areaSelectedFillOpacity: .5,
		areaInactiveFillOpacity: .3,
		hollowAreaBorderColor: brandColor,
		hollowAreaBorder: 2,
		hollowAreaBorderOpacity: 1,
		hollowAreaActiveBorder: 3,
		hollowAreaActiveBorderColor: BLACK_COLORS$1[100],
		hollowAreaSelectedBorder: 3,
		hollowAreaSelectedBorderColor: BLACK_COLORS$1[100],
		hollowAreaInactiveBorderOpacity: .3,
		intervalFillColor: brandColor,
		intervalFillOpacity: .95,
		intervalActiveBorder: 1,
		intervalActiveBorderColor: BLACK_COLORS$1[100],
		intervalActiveBorderOpacity: 1,
		intervalSelectedBorder: 2,
		intervalSelectedBorderColor: BLACK_COLORS$1[100],
		intervalSelectedBorderOpacity: 1,
		intervalInactiveBorderOpacity: .3,
		intervalInactiveFillOpacity: .3,
		hollowIntervalBorder: 2,
		hollowIntervalBorderColor: brandColor,
		hollowIntervalBorderOpacity: 1,
		hollowIntervalFillColor: WHITE_COLORS$1[100],
		hollowIntervalActiveBorder: 2,
		hollowIntervalActiveBorderColor: BLACK_COLORS$1[100],
		hollowIntervalSelectedBorder: 3,
		hollowIntervalSelectedBorderColor: BLACK_COLORS$1[100],
		hollowIntervalSelectedBorderOpacity: 1,
		hollowIntervalInactiveBorderOpacity: .3
	};
	return __assign(__assign({}, token$1), cfg);
};
var antvLight = createLightStyleSheet();

//#endregion
//#region node_modules/@antv/g2/esm/theme/util/create-theme.js
function createTheme(themeCfg) {
	var _a$5 = themeCfg.styleSheet, styleSheetCfg = _a$5 === void 0 ? {} : _a$5, themeObject = __rest(themeCfg, ["styleSheet"]);
	var styleSheet = createLightStyleSheet(styleSheetCfg);
	return deep_mix_default({}, createThemeByStyleSheet(styleSheet), themeObject);
}

//#endregion
//#region node_modules/@antv/g2/esm/theme/index.js
var Themes = { default: createTheme({}) };
/**
* 获取主题配置信息。
* @param theme 主题名
*/
function getTheme(theme$3) {
	return get_default(Themes, lower_case_default(theme$3), Themes.default);
}
/**
* 注册新的主题配置信息。
* @param theme 主题名。
* @param value 具体的主题配置。
*/
function registerTheme(theme$3, value$1) {
	Themes[lower_case_default(theme$3)] = createTheme(value$1);
}

//#endregion
//#region node_modules/@antv/g2/esm/util/tooltip.js
function snapEqual(v1, v2, scale$4) {
	var value1 = scale$4.translate(v1);
	var value2 = scale$4.translate(v2);
	return isNumberEqual(value1, value2);
}
function getXValueByPoint(point$1, geometry$34) {
	var coordinate$10 = geometry$34.coordinate;
	var xScale = geometry$34.getXScale();
	var range = xScale.range;
	var rangeMax = range[range.length - 1];
	var rangeMin = range[0];
	var xValue = coordinate$10.invert(point$1).x;
	if (coordinate$10.isPolar && xValue > (1 + rangeMax) / 2) xValue = rangeMin;
	return xScale.translate(xScale.invert(xValue));
}
function filterYValue(data$2, point$1, geometry$34) {
	var coordinate$10 = geometry$34.coordinate;
	var yScale = geometry$34.getYScale();
	var yField = yScale.field;
	var invertPoint = coordinate$10.invert(point$1);
	var yValue = yScale.invert(invertPoint.y);
	return find_default(data$2, function(obj) {
		var originData = obj[FIELD_ORIGIN];
		return originData[yField][0] <= yValue && originData[yField][1] >= yValue;
	}) || data$2[data$2.length - 1];
}
var getXDistance = memoize_default(function(scale$4) {
	if (scale$4.isCategory) return 1;
	var scaleValues = scale$4.values;
	var length$1 = scaleValues.length;
	var min$2 = scale$4.translate(scaleValues[0]);
	var max$2 = min$2;
	for (var index = 0; index < length$1; index++) {
		var value$1 = scaleValues[index];
		var numericValue = scale$4.translate(value$1);
		if (numericValue < min$2) min$2 = numericValue;
		if (numericValue > max$2) max$2 = numericValue;
	}
	return (max$2 - min$2) / (length$1 - 1);
});
/**
* 获得 tooltip 的 title
* @param originData
* @param geometry
* @param title
*/
function getTooltipTitle(originData, geometry$34, title) {
	var fields = geometry$34.getAttribute("position").getFields();
	var scales = geometry$34.scales;
	var titleField = is_function_default(title) || !title ? fields[0] : title;
	var titleScale = scales[titleField];
	var tooltipTitle = titleScale ? titleScale.getText(originData[titleField]) : originData[titleField] || titleField;
	return is_function_default(title) ? title(tooltipTitle, originData) : tooltipTitle;
}
function getAttributesForLegend(geometry$34) {
	var attributes = values_default(geometry$34.attributes);
	return filter_default(attributes, function(attribute) {
		return contains_default(GROUP_ATTRS, attribute.type);
	});
}
function getTooltipValueScale(geometry$34) {
	var e_1, _a$5;
	var attributes = getAttributesForLegend(geometry$34);
	var scale$4;
	try {
		for (var attributes_1 = __values(attributes), attributes_1_1 = attributes_1.next(); !attributes_1_1.done; attributes_1_1 = attributes_1.next()) {
			var attribute = attributes_1_1.value;
			var tmpScale = attribute.getScale(attribute.type);
			if (tmpScale && tmpScale.isLinear) {
				var tmpScaleDef = get_default(geometry$34.scaleDefs, tmpScale.field);
				if (inferScaleType(tmpScale, tmpScaleDef, attribute.type, geometry$34.type) !== "cat") {
					scale$4 = tmpScale;
					break;
				}
			}
		}
	} catch (e_1_1) {
		e_1 = { error: e_1_1 };
	} finally {
		try {
			if (attributes_1_1 && !attributes_1_1.done && (_a$5 = attributes_1.return)) _a$5.call(attributes_1);
		} finally {
			if (e_1) throw e_1.error;
		}
	}
	var xScale = geometry$34.getXScale();
	var yScale = geometry$34.getYScale();
	return scale$4 || yScale || xScale;
}
function getTooltipValue(originData, valueScale) {
	var field$5 = valueScale.field;
	var value$1 = originData[field$5];
	if (is_array_default(value$1)) return value$1.map(function(eachValue) {
		return valueScale.getText(eachValue);
	}).join("-");
	return valueScale.getText(value$1);
}
function getTooltipName(originData, geometry$34) {
	var nameScale;
	var groupScales = geometry$34.getGroupScales();
	if (groupScales.length) nameScale = groupScales[0];
	if (nameScale) {
		var field$5 = nameScale.field;
		return nameScale.getText(originData[field$5]);
	}
	var valueScale = getTooltipValueScale(geometry$34);
	return getName(valueScale);
}
/**
* @ignore
* Finds data from geometry by point
* @param point canvas point
* @param data an item of geometry.dataArray
* @param geometry
* @returns
*/
function findDataByPoint(point$1, data$2, geometry$34) {
	if (data$2.length === 0) return null;
	var geometryType = geometry$34.type;
	var xScale = geometry$34.getXScale();
	var yScale = geometry$34.getYScale();
	var xField = xScale.field;
	var yField = yScale.field;
	var rst = null;
	if (geometryType === "heatmap" || geometryType === "point") {
		var invertPoint = geometry$34.coordinate.invert(point$1);
		var x = xScale.invert(invertPoint.x);
		var y = yScale.invert(invertPoint.y);
		var min$2 = Infinity;
		for (var index = 0; index < data$2.length; index++) {
			var obj = data$2[index];
			var originData = obj[FIELD_ORIGIN];
			var range = Math.pow(originData[xField] - x, 2) + Math.pow(originData[yField] - y, 2);
			if (range < min$2) {
				min$2 = range;
				rst = obj;
			}
		}
		return rst;
	}
	var first = data$2[0];
	var last$1 = data$2[data$2.length - 1];
	var xValue = getXValueByPoint(point$1, geometry$34);
	var firstXValue = first[FIELD_ORIGIN][xField];
	var firstYValue = first[FIELD_ORIGIN][yField];
	var lastXValue = last$1[FIELD_ORIGIN][xField];
	var isYArray = yScale.isLinear && is_array_default(firstYValue);
	if (is_array_default(firstXValue)) {
		for (var index = 0; index < data$2.length; index++) {
			var record = data$2[index];
			var originData = record[FIELD_ORIGIN];
			if (xScale.translate(originData[xField][0]) <= xValue && xScale.translate(originData[xField][1]) >= xValue) if (isYArray) {
				if (!is_array_default(rst)) rst = [];
				rst.push(record);
			} else {
				rst = record;
				break;
			}
		}
		if (is_array_default(rst)) rst = filterYValue(rst, point$1, geometry$34);
	} else {
		var next = void 0;
		if (!xScale.isLinear && xScale.type !== "timeCat") {
			for (var index = 0; index < data$2.length; index++) {
				var record = data$2[index];
				var originData = record[FIELD_ORIGIN];
				if (snapEqual(originData[xField], xValue, xScale)) if (isYArray) {
					if (!is_array_default(rst)) rst = [];
					rst.push(record);
				} else {
					rst = record;
					break;
				}
				else if (xScale.translate(originData[xField]) <= xValue) {
					last$1 = record;
					next = data$2[index + 1];
				}
			}
			if (is_array_default(rst)) rst = filterYValue(rst, point$1, geometry$34);
		} else {
			if ((xValue > xScale.translate(lastXValue) || xValue < xScale.translate(firstXValue)) && (xValue > xScale.max || xValue < xScale.min)) return null;
			var firstIdx = 0;
			var lastIdx = data$2.length - 1;
			var middleIdx = void 0;
			while (firstIdx <= lastIdx) {
				middleIdx = Math.floor((firstIdx + lastIdx) / 2);
				var item = data$2[middleIdx][FIELD_ORIGIN][xField];
				if (snapEqual(item, xValue, xScale)) return data$2[middleIdx];
				if (xScale.translate(item) <= xScale.translate(xValue)) {
					firstIdx = middleIdx + 1;
					last$1 = data$2[middleIdx];
					next = data$2[middleIdx + 1];
				} else {
					if (lastIdx === 0) last$1 = data$2[0];
					lastIdx = middleIdx - 1;
				}
			}
		}
		if (last$1 && next) {
			if (Math.abs(xScale.translate(last$1[FIELD_ORIGIN][xField]) - xValue) > Math.abs(xScale.translate(next[FIELD_ORIGIN][xField]) - xValue)) last$1 = next;
		}
	}
	var distance$7 = getXDistance(geometry$34.getXScale());
	if (!rst && Math.abs(xScale.translate(last$1[FIELD_ORIGIN][xField]) - xValue) <= distance$7 / 2) rst = last$1;
	return rst;
}
/**
* @ignore
* Gets tooltip items
* @param data
* @param geometry
* @param [title]
* @returns
*/
function getTooltipItems(data$2, geometry$34, title, showNil) {
	var e_2, _a$5;
	if (title === void 0) title = "";
	if (showNil === void 0) showNil = false;
	var originData = data$2[FIELD_ORIGIN];
	var tooltipTitle = getTooltipTitle(originData, geometry$34, title);
	var tooltipOption = geometry$34.tooltipOption;
	var defaultColor = geometry$34.theme.defaultColor;
	var items = [];
	var name;
	var value$1;
	function addItem(itemName, itemValue) {
		if (showNil || !is_nil_default(itemValue) && itemValue !== "") {
			var item = {
				title: tooltipTitle,
				data: originData,
				mappingData: data$2,
				name: itemName,
				value: itemValue,
				color: data$2.color || defaultColor,
				marker: true
			};
			items.push(item);
		}
	}
	if (is_object_default(tooltipOption)) {
		var fields = tooltipOption.fields, callback = tooltipOption.callback;
		if (callback) {
			var callbackParams = fields.map(function(field$6) {
				return data$2[FIELD_ORIGIN][field$6];
			});
			var cfg = callback.apply(void 0, __spreadArray([], __read(callbackParams), false));
			var itemCfg = __assign({
				data: data$2[FIELD_ORIGIN],
				mappingData: data$2,
				title: tooltipTitle,
				color: data$2.color || defaultColor,
				marker: true
			}, cfg);
			items.push(itemCfg);
		} else {
			var scales = geometry$34.scales;
			try {
				for (var fields_1 = __values(fields), fields_1_1 = fields_1.next(); !fields_1_1.done; fields_1_1 = fields_1.next()) {
					var field$5 = fields_1_1.value;
					if (!is_nil_default(originData[field$5])) {
						var scale$4 = scales[field$5];
						name = getName(scale$4);
						value$1 = scale$4.getText(originData[field$5]);
						addItem(name, value$1);
					}
				}
			} catch (e_2_1) {
				e_2 = { error: e_2_1 };
			} finally {
				try {
					if (fields_1_1 && !fields_1_1.done && (_a$5 = fields_1.return)) _a$5.call(fields_1);
				} finally {
					if (e_2) throw e_2.error;
				}
			}
		}
	} else {
		var valueScale = getTooltipValueScale(geometry$34);
		value$1 = getTooltipValue(originData, valueScale);
		name = getTooltipName(originData, geometry$34);
		addItem(name, value$1);
	}
	return items;
}
function getTooltipItemsByFindData(geometry$34, point$1, title, tooltipCfg) {
	var e_3, _a$5;
	var showNil = tooltipCfg.showNil;
	var result = [];
	var dataArray = geometry$34.dataArray;
	if (!is_empty_default(dataArray)) {
		geometry$34.sort(dataArray);
		try {
			for (var dataArray_1 = __values(dataArray), dataArray_1_1 = dataArray_1.next(); !dataArray_1_1.done; dataArray_1_1 = dataArray_1.next()) {
				var data$2 = dataArray_1_1.value;
				var record = findDataByPoint(point$1, data$2, geometry$34);
				if (record) {
					var elementId = geometry$34.getElementId(record);
					var element = geometry$34.elementsMap[elementId];
					if (geometry$34.type === "heatmap" || element.visible) {
						var items = getTooltipItems(record, geometry$34, title, showNil);
						if (items.length) result.push(items);
					}
				}
			}
		} catch (e_3_1) {
			e_3 = { error: e_3_1 };
		} finally {
			try {
				if (dataArray_1_1 && !dataArray_1_1.done && (_a$5 = dataArray_1.return)) _a$5.call(dataArray_1);
			} finally {
				if (e_3) throw e_3.error;
			}
		}
	}
	return result;
}
function getTooltipItemsByHitShape(geometry$34, point$1, title, tooltipCfg) {
	var showNil = tooltipCfg.showNil;
	var result = [];
	var shape = geometry$34.container.getShape(point$1.x, point$1.y);
	if (shape && shape.get("visible") && shape.get("origin")) {
		var mappingData = shape.get("origin").mappingData;
		var items = getTooltipItems(mappingData, geometry$34, title, showNil);
		if (items.length) result.push(items);
	}
	return result;
}
/**
* 不进行递归查找
*/
function findItemsFromView(view, point$1, tooltipCfg) {
	var e_4, _a$5;
	var result = [];
	var geometries = view.geometries;
	var shared = tooltipCfg.shared, title = tooltipCfg.title, reversed = tooltipCfg.reversed;
	try {
		for (var geometries_1 = __values(geometries), geometries_1_1 = geometries_1.next(); !geometries_1_1.done; geometries_1_1 = geometries_1.next()) {
			var geometry$34 = geometries_1_1.value;
			if (geometry$34.visible && geometry$34.tooltipOption !== false) {
				var geometryType = geometry$34.type;
				var tooltipItems = void 0;
				if ([
					"point",
					"edge",
					"polygon"
				].includes(geometryType)) tooltipItems = getTooltipItemsByHitShape(geometry$34, point$1, title, tooltipCfg);
				else if ([
					"area",
					"line",
					"path",
					"heatmap"
				].includes(geometryType)) tooltipItems = getTooltipItemsByFindData(geometry$34, point$1, title, tooltipCfg);
				else if (shared !== false) tooltipItems = getTooltipItemsByFindData(geometry$34, point$1, title, tooltipCfg);
				else tooltipItems = getTooltipItemsByHitShape(geometry$34, point$1, title, tooltipCfg);
				if (tooltipItems.length) {
					if (reversed) tooltipItems.reverse();
					result.push(tooltipItems);
				}
			}
		}
	} catch (e_4_1) {
		e_4 = { error: e_4_1 };
	} finally {
		try {
			if (geometries_1_1 && !geometries_1_1.done && (_a$5 = geometries_1.return)) _a$5.call(geometries_1);
		} finally {
			if (e_4) throw e_4.error;
		}
	}
	return result;
}
function findItemsFromViewRecurisive(view, point$1, tooltipCfg) {
	var e_5, _a$5;
	var result = findItemsFromView(view, point$1, tooltipCfg);
	try {
		for (var _b = __values(view.views), _c = _b.next(); !_c.done; _c = _b.next()) {
			var childView = _c.value;
			result = result.concat(findItemsFromView(childView, point$1, tooltipCfg));
		}
	} catch (e_5_1) {
		e_5 = { error: e_5_1 };
	} finally {
		try {
			if (_c && !_c.done && (_a$5 = _b.return)) _a$5.call(_b);
		} finally {
			if (e_5) throw e_5.error;
		}
	}
	return result;
}

//#endregion
//#region node_modules/@antv/g2/esm/util/padding.js
/**
* @ignore
* 是否是自动 padding
* @param padding
*/
function isAutoPadding(padding$2) {
	return !is_number_default(padding$2) && !is_array_default(padding$2);
}
/**
* @ignore
* padding 的解析逻辑
* @param padding
* @return [ top, right, bottom, left ]
*/
function parsePadding(padding$2) {
	if (padding$2 === void 0) padding$2 = 0;
	var paddingArray = is_array_default(padding$2) ? padding$2 : [padding$2];
	switch (paddingArray.length) {
		case 0:
			paddingArray = [
				0,
				0,
				0,
				0
			];
			break;
		case 1:
			paddingArray = new Array(4).fill(paddingArray[0]);
			break;
		case 2:
			paddingArray = __spreadArray(__spreadArray([], __read(paddingArray), false), __read(paddingArray), false);
			break;
		case 3:
			paddingArray = __spreadArray(__spreadArray([], __read(paddingArray), false), [paddingArray[1]], false);
			break;
		default:
			paddingArray = paddingArray.slice(0, 4);
			break;
	}
	return paddingArray;
}

//#endregion
//#region node_modules/@antv/g2/esm/chart/controller/index.js
var LOAD_COMPONENT_CONTROLLERS = {};
/**
* 全局注册组件。
* @param name 组件名称
* @param plugin 注册的组件类
* @returns void
*/
function registerComponentController(name, plugin) {
	LOAD_COMPONENT_CONTROLLERS[name] = plugin;
}
/**
* 获取以注册的组件名。
* @returns string[] 返回已注册的组件名称
*/
function getComponentControllerNames() {
	return Object.keys(LOAD_COMPONENT_CONTROLLERS);
}
/**
* 根据组件名获取组件类。
* @param name 组件名
* @returns 返回组件类
*/
function getComponentController(name) {
	return LOAD_COMPONENT_CONTROLLERS[name];
}

//#endregion
//#region node_modules/@antv/g2/esm/chart/controller/coordinate.js
/**
* coordinate controller，职责：
* 1. 创建实例
* 2. 暂存配置
*/
var CoordinateController = function() {
	function CoordinateController$1(option) {
		this.option = this.wrapperOption(option);
	}
	/**
	* 更新配置
	* @param option
	*/
	CoordinateController$1.prototype.update = function(option) {
		this.option = this.wrapperOption(option);
		return this;
	};
	/**
	* 是否存在某一个 action
	* @param actionName
	*/
	CoordinateController$1.prototype.hasAction = function(actionName) {
		var actions = this.option.actions;
		return some_default(actions, function(action) {
			return action[0] === actionName;
		});
	};
	/**
	* 创建坐标系对象
	* @param start 起始位置
	* @param end   结束位置
	* @return 坐标系实例
	*/
	CoordinateController$1.prototype.create = function(start, end) {
		var _a$5 = this.option, type = _a$5.type, cfg = _a$5.cfg;
		var isTheta = type === "theta";
		var props = __assign({
			start,
			end
		}, cfg);
		this.coordinate = new (getCoordinate(isTheta ? "polar" : type))(props);
		this.coordinate.type = type;
		if (isTheta) {
			if (!this.hasAction("transpose")) this.transpose();
		}
		this.execActions();
		return this.coordinate;
	};
	/**
	* 更新坐标系对象
	* @param start 起始位置
	* @param end   结束位置
	* @return 坐标系实例
	*/
	CoordinateController$1.prototype.adjust = function(start, end) {
		this.coordinate.update({
			start,
			end
		});
		this.coordinate.resetMatrix();
		this.execActions([
			"scale",
			"rotate",
			"translate"
		]);
		return this.coordinate;
	};
	/**
	* 旋转弧度
	* @param angle
	*/
	CoordinateController$1.prototype.rotate = function(angle$1) {
		this.option.actions.push(["rotate", angle$1]);
		return this;
	};
	/**
	* 镜像
	* @param dim
	*/
	CoordinateController$1.prototype.reflect = function(dim) {
		this.option.actions.push(["reflect", dim]);
		return this;
	};
	/**
	* scale
	* @param sx
	* @param sy
	*/
	CoordinateController$1.prototype.scale = function(sx, sy) {
		this.option.actions.push([
			"scale",
			sx,
			sy
		]);
		return this;
	};
	/**
	* 对角变换
	*/
	CoordinateController$1.prototype.transpose = function() {
		this.option.actions.push(["transpose"]);
		return this;
	};
	/**
	* 获取配置
	*/
	CoordinateController$1.prototype.getOption = function() {
		return this.option;
	};
	/**
	* 获得 coordinate 实例
	*/
	CoordinateController$1.prototype.getCoordinate = function() {
		return this.coordinate;
	};
	/**
	* 包装配置的默认值
	* @param option
	*/
	CoordinateController$1.prototype.wrapperOption = function(option) {
		return __assign({
			type: "rect",
			actions: [],
			cfg: {}
		}, option);
	};
	/**
	* coordinate 实例执行 actions
	* @params includeActions 如果没有指定，则执行全部，否则，执行指定的 action
	*/
	CoordinateController$1.prototype.execActions = function(includeActions) {
		var _this = this;
		var actions = this.option.actions;
		each_default(actions, function(action) {
			var _a$5;
			var _b = __read(action), actionName = _b[0], args = _b.slice(1);
			if (is_nil_default(includeActions) ? true : includeActions.includes(actionName)) (_a$5 = _this.coordinate)[actionName].apply(_a$5, __spreadArray([], __read(args), false));
		});
	};
	return CoordinateController$1;
}();
var coordinate_default = CoordinateController;

//#endregion
//#region node_modules/@antv/g2/esm/chart/event.js
/**
* @todo Whether it can(or necessary to) keep consistent with the structure of G.Event or directly use the structure of G.Event
* G2 事件的事件包装类，基于 G.Event
*/
var Event = function() {
	function Event$1(view, gEvent, data$2) {
		this.view = view;
		this.gEvent = gEvent;
		this.data = data$2;
		this.type = gEvent.type;
	}
	/**
	* 非交互产生的事件
	* @param view
	* @param type
	* @param data
	*/
	Event$1.fromData = function(view, type, data$2) {
		return new Event$1(view, new graph_event_default(type, {}), data$2);
	};
	Object.defineProperty(Event$1.prototype, "target", {
		get: function() {
			return this.gEvent.target;
		},
		enumerable: false,
		configurable: true
	});
	Object.defineProperty(Event$1.prototype, "event", {
		get: function() {
			return this.gEvent.originalEvent;
		},
		enumerable: false,
		configurable: true
	});
	Object.defineProperty(Event$1.prototype, "x", {
		get: function() {
			return this.gEvent.x;
		},
		enumerable: false,
		configurable: true
	});
	Object.defineProperty(Event$1.prototype, "y", {
		get: function() {
			return this.gEvent.y;
		},
		enumerable: false,
		configurable: true
	});
	Object.defineProperty(Event$1.prototype, "clientX", {
		get: function() {
			return this.gEvent.clientX;
		},
		enumerable: false,
		configurable: true
	});
	Object.defineProperty(Event$1.prototype, "clientY", {
		get: function() {
			return this.gEvent.clientY;
		},
		enumerable: false,
		configurable: true
	});
	/**
	* event string
	* @returns string
	*/
	Event$1.prototype.toString = function() {
		return "[Event (type=".concat(this.type, ")]");
	};
	/**
	* clone a new event with same attributes
	* @returns [[Event]]
	*/
	Event$1.prototype.clone = function() {
		return new Event$1(this.view, this.gEvent, this.data);
	};
	return Event$1;
}();
var event_default = Event;

//#endregion
//#region node_modules/@antv/g2/esm/chart/layout/index.js
/**
* @ignore
* G2 默认提供的 layout 函数
* 内置布局函数处理的逻辑：
*
* 1. 如果 padding = 'auto'，那么自动根据组件的 direction 来计算 padding 数组
* 2. 根据 padding 和 direction 去分配对应方向的 padding 数值
* 3. 移动组件位置
*
* 前面 1，2 步骤在 view 中已经做掉了。对于组件响应式布局，可以尝试使用约束布局的方式去求解位置信息。
* @param view
*/
function defaultLayout(view) {
	var axis$21 = view.getController("axis");
	var legend$17 = view.getController("legend");
	var annotation$3 = view.getController("annotation");
	var slider$3 = view.getController("slider");
	var scrollbar$1 = view.getController("scrollbar");
	[
		axis$21,
		slider$3,
		scrollbar$1,
		legend$17,
		annotation$3
	].forEach(function(controller) {
		if (controller) controller.layout();
	});
}

//#endregion
//#region node_modules/@antv/g2/esm/chart/util/scale-pool.js
/** @ignore */
var ScalePool = function() {
	function ScalePool$1() {
		/** 所有的 scales */
		this.scales = /* @__PURE__ */ new Map();
		/** 需要同步的 scale 分组， key: scaleKeyArray */
		this.syncScales = /* @__PURE__ */ new Map();
	}
	/**
	* 创建 scale
	* @param field
	* @param data
	* @param scaleDef
	* @param key
	*/
	ScalePool$1.prototype.createScale = function(field$5, data$2, scaleDef, key) {
		var finalScaleDef = scaleDef;
		var cacheScaleMeta = this.getScaleMeta(key);
		if (data$2.length === 0 && cacheScaleMeta) {
			var cacheScale = cacheScaleMeta.scale;
			var cacheScaleDef = { type: cacheScale.type };
			if (cacheScale.isCategory) cacheScaleDef.values = cacheScale.values;
			finalScaleDef = deep_mix_default(cacheScaleDef, cacheScaleMeta.scaleDef, scaleDef);
		}
		var scale$4 = createScaleByField(field$5, data$2, finalScaleDef);
		this.cacheScale(scale$4, scaleDef, key);
		return scale$4;
	};
	/**
	* 同步 scale
	*/
	ScalePool$1.prototype.sync = function(coordinate$10, theme$3) {
		var _this = this;
		this.syncScales.forEach(function(scaleKeys, syncKey) {
			var min$2 = Number.MAX_SAFE_INTEGER;
			var max$2 = Number.MIN_SAFE_INTEGER;
			var values$1 = [];
			each_default(scaleKeys, function(key) {
				var scale$4 = _this.getScale(key);
				max$2 = is_number_default(scale$4.max) ? Math.max(max$2, scale$4.max) : max$2;
				min$2 = is_number_default(scale$4.min) ? Math.min(min$2, scale$4.min) : min$2;
				each_default(scale$4.values, function(v) {
					if (!values$1.includes(v)) values$1.push(v);
				});
			});
			each_default(scaleKeys, function(key) {
				var scale$4 = _this.getScale(key);
				if (scale$4.isContinuous) scale$4.change({
					min: min$2,
					max: max$2,
					values: values$1
				});
				else if (scale$4.isCategory) {
					var range = scale$4.range;
					var cacheScaleMeta = _this.getScaleMeta(key);
					if (values$1 && !get_default(cacheScaleMeta, ["scaleDef", "range"])) range = getDefaultCategoryScaleRange(deep_mix_default({}, scale$4, { values: values$1 }), coordinate$10, theme$3);
					scale$4.change({
						values: values$1,
						range
					});
				}
			});
		});
	};
	/**
	* 缓存一个 scale
	* @param scale
	* @param scaleDef
	* @param key
	*/
	ScalePool$1.prototype.cacheScale = function(scale$4, scaleDef, key) {
		var sm = this.getScaleMeta(key);
		if (sm && sm.scale.type === scale$4.type) {
			syncScale(sm.scale, scale$4);
			sm.scaleDef = scaleDef;
		} else {
			sm = {
				key,
				scale: scale$4,
				scaleDef
			};
			this.scales.set(key, sm);
		}
		var syncKey = this.getSyncKey(sm);
		sm.syncKey = syncKey;
		this.removeFromSyncScales(key);
		if (syncKey) {
			var scaleKeys = this.syncScales.get(syncKey);
			if (!scaleKeys) {
				scaleKeys = [];
				this.syncScales.set(syncKey, scaleKeys);
			}
			scaleKeys.push(key);
		}
	};
	/**
	* 通过 key 获取 scale
	* @param key
	*/
	ScalePool$1.prototype.getScale = function(key) {
		var scaleMeta = this.getScaleMeta(key);
		if (!scaleMeta) {
			var field$5 = last(key.split("-"));
			var scaleKeys = this.syncScales.get(field$5);
			if (scaleKeys && scaleKeys.length) scaleMeta = this.getScaleMeta(scaleKeys[0]);
		}
		return scaleMeta && scaleMeta.scale;
	};
	/**
	* 在 view 销毁的时候，删除 scale 实例，防止内存泄露
	* @param key
	*/
	ScalePool$1.prototype.deleteScale = function(key) {
		var scaleMeta = this.getScaleMeta(key);
		if (scaleMeta) {
			var syncKey = scaleMeta.syncKey;
			var scaleKeys = this.syncScales.get(syncKey);
			if (scaleKeys && scaleKeys.length) {
				var idx = scaleKeys.indexOf(key);
				if (idx !== -1) scaleKeys.splice(idx, 1);
			}
		}
		this.scales.delete(key);
	};
	/**
	* 清空
	*/
	ScalePool$1.prototype.clear = function() {
		this.scales.clear();
		this.syncScales.clear();
	};
	/**
	* 删除 sync scale 引用
	* @param key
	*/
	ScalePool$1.prototype.removeFromSyncScales = function(key) {
		var _this = this;
		this.syncScales.forEach(function(scaleKeys, syncKey) {
			var idx = scaleKeys.indexOf(key);
			if (idx !== -1) {
				scaleKeys.splice(idx, 1);
				if (scaleKeys.length === 0) _this.syncScales.delete(syncKey);
				return false;
			}
		});
	};
	/**
	* get sync key
	* @param sm
	*/
	ScalePool$1.prototype.getSyncKey = function(sm) {
		var scale$4 = sm.scale, scaleDef = sm.scaleDef;
		var field$5 = scale$4.field;
		var sync = get_default(scaleDef, ["sync"]);
		return sync === true ? field$5 : sync === false ? void 0 : sync;
	};
	/**
	* 通过 key 获取 scale
	* @param key
	*/
	ScalePool$1.prototype.getScaleMeta = function(key) {
		return this.scales.get(key);
	};
	return ScalePool$1;
}();

//#endregion
//#region node_modules/@antv/g2/esm/chart/layout/padding-cal.js
/** @ignore */
var PaddingCal = function() {
	/**
	* 初始的 padding 数据
	* @param top
	* @param right
	* @param bottom
	* @param left
	*/
	function PaddingCal$1(top, right$1, bottom, left$1) {
		if (top === void 0) top = 0;
		if (right$1 === void 0) right$1 = 0;
		if (bottom === void 0) bottom = 0;
		if (left$1 === void 0) left$1 = 0;
		this.top = top;
		this.right = right$1;
		this.bottom = bottom;
		this.left = left$1;
	}
	/**
	* 使用静态方法创建一个
	* @param top
	* @param right
	* @param bottom
	* @param left
	*/
	PaddingCal$1.instance = function(top, right$1, bottom, left$1) {
		if (top === void 0) top = 0;
		if (right$1 === void 0) right$1 = 0;
		if (bottom === void 0) bottom = 0;
		if (left$1 === void 0) left$1 = 0;
		return new PaddingCal$1(top, right$1, bottom, left$1);
	};
	/**
	* 取最大区间
	* @param padding
	*/
	PaddingCal$1.prototype.max = function(padding$2) {
		var _a$5 = __read(padding$2, 4), top = _a$5[0], right$1 = _a$5[1], bottom = _a$5[2], left$1 = _a$5[3];
		this.top = Math.max(this.top, top);
		this.right = Math.max(this.right, right$1);
		this.bottom = Math.max(this.bottom, bottom);
		this.left = Math.max(this.left, left$1);
		return this;
	};
	/**
	* 四周增加 padding
	* @param padding
	*/
	PaddingCal$1.prototype.shrink = function(padding$2) {
		var _a$5 = __read(padding$2, 4), top = _a$5[0], right$1 = _a$5[1], bottom = _a$5[2], left$1 = _a$5[3];
		this.top += top;
		this.right += right$1;
		this.bottom += bottom;
		this.left += left$1;
		return this;
	};
	/**
	* 在某一个方向增加 padding
	* @param bbox
	* @param direction
	*/
	PaddingCal$1.prototype.inc = function(bbox, direction$1) {
		var width = bbox.width, height = bbox.height;
		switch (direction$1) {
			case DIRECTION.TOP:
			case DIRECTION.TOP_LEFT:
			case DIRECTION.TOP_RIGHT:
				this.top += height;
				break;
			case DIRECTION.RIGHT:
			case DIRECTION.RIGHT_TOP:
			case DIRECTION.RIGHT_BOTTOM:
				this.right += width;
				break;
			case DIRECTION.BOTTOM:
			case DIRECTION.BOTTOM_LEFT:
			case DIRECTION.BOTTOM_RIGHT:
				this.bottom += height;
				break;
			case DIRECTION.LEFT:
			case DIRECTION.LEFT_TOP:
			case DIRECTION.LEFT_BOTTOM:
				this.left += width;
				break;
			default: break;
		}
		return this;
	};
	/**
	* 获得最终的 padding
	*/
	PaddingCal$1.prototype.getPadding = function() {
		return [
			this.top,
			this.right,
			this.bottom,
			this.left
		];
	};
	/**
	* clone 一个 padding cal
	*/
	PaddingCal$1.prototype.clone = function() {
		return new (PaddingCal$1.bind.apply(PaddingCal$1, __spreadArray([void 0], __read(this.getPadding()), false)))();
	};
	return PaddingCal$1;
}();

//#endregion
//#region node_modules/@antv/g2/esm/chart/layout/auto.js
/**
* @ignore
* 根据 view 中的组件，计算实际的 padding 数值
* @param view
*/
function calculatePadding(view) {
	var padding$2 = view.padding;
	if (!isAutoPadding(padding$2)) return new (PaddingCal.bind.apply(PaddingCal, __spreadArray([void 0], __read(parsePadding(padding$2)), false)))();
	var viewBBox = view.viewBBox;
	var paddingCal = new PaddingCal();
	var axisComponents = [];
	var paddingComponents = [];
	var otherComponents = [];
	each_default(view.getComponents(), function(co) {
		var type = co.type;
		if (type === COMPONENT_TYPE.AXIS) axisComponents.push(co);
		else if ([
			COMPONENT_TYPE.LEGEND,
			COMPONENT_TYPE.SLIDER,
			COMPONENT_TYPE.SCROLLBAR
		].includes(type)) paddingComponents.push(co);
		else if (type !== COMPONENT_TYPE.GRID && type !== COMPONENT_TYPE.TOOLTIP) otherComponents.push(co);
	});
	each_default(axisComponents, function(co) {
		var bboxObject = co.component.getLayoutBBox();
		var exceed = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height).exceed(viewBBox);
		paddingCal.max(exceed);
	});
	each_default(paddingComponents, function(co) {
		var component$1 = co.component, direction$1 = co.direction;
		var bboxObject = component$1.getLayoutBBox();
		var componentPadding = component$1.get("padding");
		var componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height).expand(componentPadding);
		paddingCal.inc(componentBBox, direction$1);
	});
	each_default(otherComponents, function(co) {
		var component$1 = co.component, direction$1 = co.direction;
		var bboxObject = component$1.getLayoutBBox();
		var componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height);
		paddingCal.inc(componentBBox, direction$1);
	});
	return paddingCal;
}

//#endregion
//#region node_modules/@antv/g2/esm/chart/util/sync-view-padding.js
/**
* 默认的 syncViewPadding 逻辑
* @param chart
* @param views
* @param PC: PaddingCalCtor
*/
function defaultSyncViewPadding(chart, views, PC) {
	var syncPadding = PC.instance();
	views.forEach(function(v) {
		v.autoPadding = syncPadding.max(v.autoPadding.getPadding());
	});
}

//#endregion
//#region node_modules/@antv/g2/esm/chart/view.js
/**
* G2 视图 View 类
*/
var View = function(_super) {
	__extends(View$1, _super);
	function View$1(props) {
		var _this = _super.call(this, { visible: props.visible }) || this;
		/** 所有的子 view。 */
		_this.views = [];
		/** 所有的 geometry 实例。 */
		_this.geometries = [];
		/** 所有的组件 controllers。 */
		_this.controllers = [];
		/** 所有的 Interaction 实例。 */
		_this.interactions = {};
		/** 是否对超出坐标系范围的 Geometry 进行剪切 */
		_this.limitInPlot = false;
		_this.options = {
			data: [],
			animate: true
		};
		/** 配置开启的组件插件，默认为全局配置的组件。 */
		_this.usedControllers = getComponentControllerNames();
		/** 所有的 scales */
		_this.scalePool = new ScalePool();
		/** 布局函数 */
		_this.layoutFunc = defaultLayout;
		/** 当前鼠标是否在 plot 内（CoordinateBBox） */
		_this.isPreMouseInPlot = false;
		/** 默认标识位，用于判定数据是否更新 */
		_this.isDataChanged = false;
		/** 用于判断坐标系范围是否发生变化的标志位 */
		_this.isCoordinateChanged = false;
		/** 从当前这个 view 创建的 scale key */
		_this.createdScaleKeys = /* @__PURE__ */ new Map();
		_this.onCanvasEvent = function(evt) {
			var name = evt.name;
			if (!name.includes(":")) {
				var e = _this.createViewEvent(evt);
				_this.doPlotEvent(e);
				_this.emit(name, e);
			}
		};
		/**
		* 触发事件之后
		* @param evt
		*/
		_this.onDelegateEvents = function(evt) {
			var name = evt.name;
			if (!name.includes(":")) return;
			var e = _this.createViewEvent(evt);
			_this.emit(name, e);
		};
		var _a$5 = props.id, id$1 = _a$5 === void 0 ? unique_id_default("view") : _a$5, parent = props.parent, canvas = props.canvas, backgroundGroup = props.backgroundGroup, middleGroup = props.middleGroup, foregroundGroup = props.foregroundGroup, _b = props.region, region = _b === void 0 ? {
			start: {
				x: 0,
				y: 0
			},
			end: {
				x: 1,
				y: 1
			}
		} : _b, padding$2 = props.padding, appendPadding = props.appendPadding, theme$3 = props.theme, options = props.options, limitInPlot$4 = props.limitInPlot, syncViewPadding$1 = props.syncViewPadding;
		_this.parent = parent;
		_this.canvas = canvas;
		_this.backgroundGroup = backgroundGroup;
		_this.middleGroup = middleGroup;
		_this.foregroundGroup = foregroundGroup;
		_this.region = region;
		_this.padding = padding$2;
		_this.appendPadding = appendPadding;
		_this.options = __assign(__assign({}, _this.options), options);
		_this.limitInPlot = limitInPlot$4;
		_this.id = id$1;
		_this.syncViewPadding = syncViewPadding$1;
		_this.themeObject = is_object_default(theme$3) ? deep_mix_default({}, getTheme("default"), createTheme(theme$3)) : getTheme(theme$3);
		_this.init();
		return _this;
	}
	/**
	* 设置 layout 布局函数
	* @param layout 布局函数
	* @returns void
	*/
	View$1.prototype.setLayout = function(layout$1) {
		this.layoutFunc = layout$1;
	};
	/**
	* 生命周期：初始化
	* @returns voids
	*/
	View$1.prototype.init = function() {
		this.calculateViewBBox();
		this.initEvents();
		this.initComponentController();
		this.initOptions();
	};
	/**
	* 生命周期：渲染流程，渲染过程需要处理数据更新的情况。
	* render 函数仅仅会处理 view 和子 view。
	* @param isUpdate 是否触发更新流程。
	* @param params render 事件参数
	*/
	View$1.prototype.render = function(isUpdate, payload) {
		if (isUpdate === void 0) isUpdate = false;
		this.emit(VIEW_LIFE_CIRCLE.BEFORE_RENDER, event_default.fromData(this, VIEW_LIFE_CIRCLE.BEFORE_RENDER, payload));
		this.paint(isUpdate);
		this.emit(VIEW_LIFE_CIRCLE.AFTER_RENDER, event_default.fromData(this, VIEW_LIFE_CIRCLE.AFTER_RENDER, payload));
		if (this.visible === false) this.changeVisible(false);
	};
	/**
	* 生命周期：清空图表上所有的绘制内容，但是不销毁图表，chart 仍可使用。
	* @returns void
	*/
	View$1.prototype.clear = function() {
		var _this = this;
		this.emit(VIEW_LIFE_CIRCLE.BEFORE_CLEAR);
		this.filteredData = [];
		this.coordinateInstance = void 0;
		this.isDataChanged = false;
		this.isCoordinateChanged = false;
		var geometries = this.geometries;
		for (var i = 0; i < geometries.length; i++) {
			geometries[i].clear();
			geometries[i].container.remove(true);
			geometries[i].labelsContainer.remove(true);
		}
		this.geometries = [];
		var controllers = this.controllers;
		for (var i = 0; i < controllers.length; i++) if (controllers[i].name === "annotation") controllers[i].clear(true);
		else controllers[i].clear();
		this.createdScaleKeys.forEach(function(v, k) {
			_this.getRootView().scalePool.deleteScale(k);
		});
		this.createdScaleKeys.clear();
		var views = this.views;
		for (var i = 0; i < views.length; i++) views[i].clear();
		this.emit(VIEW_LIFE_CIRCLE.AFTER_CLEAR);
	};
	/**
	* 生命周期：销毁，完全无法使用。
	* @returns void
	*/
	View$1.prototype.destroy = function() {
		this.emit(VIEW_LIFE_CIRCLE.BEFORE_DESTROY);
		var interactions = this.interactions;
		each_default(interactions, function(interaction$9) {
			if (interaction$9) interaction$9.destroy();
		});
		this.clear();
		var controllers = this.controllers;
		for (var i = 0, len = controllers.length; i < len; i++) controllers[i].destroy();
		this.backgroundGroup.remove(true);
		this.middleGroup.remove(true);
		this.foregroundGroup.remove(true);
		_super.prototype.destroy.call(this);
	};
	/**
	* 显示或者隐藏整个 view。
	* @param visible 是否可见
	* @returns View
	*/
	View$1.prototype.changeVisible = function(visible) {
		_super.prototype.changeVisible.call(this, visible);
		var geometries = this.geometries;
		for (var i = 0, len = geometries.length; i < len; i++) geometries[i].changeVisible(visible);
		var controllers = this.controllers;
		for (var i = 0, len = controllers.length; i < len; i++) controllers[i].changeVisible(visible);
		this.foregroundGroup.set("visible", visible);
		this.middleGroup.set("visible", visible);
		this.backgroundGroup.set("visible", visible);
		this.getCanvas().draw();
		return this;
	};
	/**
	* 装载数据源。
	*
	* ```ts
	* view.data([{ city: '杭州', sale: 100 }, { city: '上海', sale: 110 } ]);
	* ```
	*
	* @param data 数据源，json 数组。
	* @returns View
	*/
	View$1.prototype.data = function(data$2) {
		set_default(this.options, "data", data$2);
		this.isDataChanged = true;
		return this;
	};
	/**
	* @deprecated
	* This method will be removed at G2 V4.1. Replaced by {@link #data(data)}
	*/
	View$1.prototype.source = function(data$2) {
		console.warn("This method will be removed at G2 V4.1. Please use chart.data() instead.");
		return this.data(data$2);
	};
	/**
	* 设置数据筛选规则。
	*
	* ```ts
	* view.filter('city', (value: any, datum: Datum) => value !== '杭州');
	*
	* // 删除 'city' 字段对应的筛选规则。
	* view.filter('city', null);
	* ```
	*
	* @param field 数据字段
	* @param condition 筛选规则
	* @returns View
	*/
	View$1.prototype.filter = function(field$5, condition) {
		if (is_function_default(condition)) {
			set_default(this.options, ["filters", field$5], condition);
			return this;
		}
		if (!condition && get_default(this.options, ["filters", field$5])) delete this.options.filters[field$5];
		return this;
	};
	View$1.prototype.axis = function(field$5, axisOption) {
		if (is_boolean_default(field$5)) set_default(this.options, ["axes"], field$5);
		else set_default(this.options, ["axes", field$5], axisOption);
		return this;
	};
	View$1.prototype.legend = function(field$5, legendOption) {
		if (is_boolean_default(field$5)) set_default(this.options, ["legends"], field$5);
		else if (is_string_default(field$5)) {
			set_default(this.options, ["legends", field$5], legendOption);
			if (is_plain_object_default(legendOption) && (legendOption === null || legendOption === void 0 ? void 0 : legendOption.selected)) set_default(this.options, ["filters", field$5], function(name) {
				var _a$5;
				return (_a$5 = legendOption === null || legendOption === void 0 ? void 0 : legendOption.selected[name]) !== null && _a$5 !== void 0 ? _a$5 : true;
			});
		} else set_default(this.options, ["legends"], field$5);
		return this;
	};
	View$1.prototype.scale = function(field$5, scaleOption) {
		var _this = this;
		if (is_string_default(field$5)) set_default(this.options, ["scales", field$5], scaleOption);
		else if (is_object_default(field$5)) each_default(field$5, function(v, k) {
			set_default(_this.options, ["scales", k], v);
		});
		return this;
	};
	/**
	* tooltip 提示信息配置。
	*
	* ```ts
	* view.tooltip(false); // 关闭 tooltip
	*
	* view.tooltip({
	*   shared: true
	* });
	* ```
	*
	* @param cfg Tooltip 配置，更详细的配置项参考：https://github.com/antvis/component#tooltip
	* @returns View
	*/
	View$1.prototype.tooltip = function(cfg) {
		set_default(this.options, "tooltip", cfg);
		return this;
	};
	/**
	* 辅助标记配置。
	*
	* ```ts
	* view.annotation().line({
	*   start: ['min', 85],
	*   end: ['max', 85],
	*   style: {
	*     stroke: '#595959',
	*     lineWidth: 1,
	*     lineDash: [3, 3],
	*   },
	* });
	* ```
	* 更详细的配置项：https://github.com/antvis/component#annotation
	* @returns [[Annotation]]
	*/
	View$1.prototype.annotation = function() {
		return this.getController("annotation");
	};
	/**
	* @deprecated
	* This method will be removed at G2 V4.1. Replaced by {@link #guide()}
	*/
	View$1.prototype.guide = function() {
		console.warn("This method will be removed at G2 V4.1. Please use chart.annotation() instead.");
		return this.annotation();
	};
	View$1.prototype.coordinate = function(type, coordinateCfg) {
		if (is_string_default(type)) set_default(this.options, "coordinate", {
			type,
			cfg: coordinateCfg
		});
		else set_default(this.options, "coordinate", type);
		this.coordinateController.update(this.options.coordinate);
		return this.coordinateController;
	};
	/**
	* @deprecated
	* This method will be removed at G2 V4.1. Replaced by {@link #coordinate()}
	*/
	View$1.prototype.coord = function(type, coordinateCfg) {
		console.warn("This method will be removed at G2 V4.1. Please use chart.coordinate() instead.");
		return this.coordinate(type, coordinateCfg);
	};
	/**
	* view 分面绘制。
	*
	* ```ts
	* view.facet('rect', {
	*   rowField: 'province',
	*   columnField: 'category',
	*   eachView: (innerView: View, facet?: FacetData) => {
	*     innerView.line().position('city*sale');
	*   },
	* });
	* ```
	*
	* @param type 分面类型
	* @param cfg 分面配置， [[FacetCfgMap]]
	* @returns View
	*/
	View$1.prototype.facet = function(type, cfg) {
		if (this.facetInstance) this.facetInstance.destroy();
		var Ctor = getFacet(type);
		if (!Ctor) throw new Error("facet '".concat(type, "' is not exist!"));
		this.facetInstance = new Ctor(this, __assign(__assign({}, cfg), { type }));
		return this;
	};
	View$1.prototype.animate = function(status) {
		set_default(this.options, "animate", status);
		return this;
	};
	/**
	* 更新配置项，用于配置项式声明。
	* @param options 配置项
	*/
	View$1.prototype.updateOptions = function(options) {
		this.clear();
		mix(this.options, options);
		this.views.forEach(function(view) {
			return view.destroy();
		});
		this.views = [];
		this.initOptions();
		this.coordinateBBox = this.viewBBox;
		return this;
	};
	/**
	* 往 `view.options` 属性中存储配置项。
	* @param name 属性名称
	* @param opt 属性值
	* @returns view
	*/
	View$1.prototype.option = function(name, opt) {
		if (View$1.prototype[name]) throw new Error("Can't use built in variable name \"".concat(name, "\", please change another one."));
		set_default(this.options, name, opt);
		return this;
	};
	/**
	* 设置主题。
	*
	* ```ts
	* view.theme('dark'); // 'dark' 需要事先通过 `registerTheme()` 接口注册完成
	*
	* view.theme({ defaultColor: 'red' });
	* ```
	*
	* @param theme 主题名或者主题配置
	* @returns View
	*/
	View$1.prototype.theme = function(theme$3) {
		this.themeObject = is_object_default(theme$3) ? deep_mix_default({}, this.themeObject, createTheme(theme$3)) : getTheme(theme$3);
		return this;
	};
	/**
	* Call the interaction based on the interaction name
	*
	* ```ts
	* view.interaction('my-interaction', { extra: 'hello world' });
	* ```
	* 详细文档可以参考：https://g2.antv.vision/zh/docs/api/general/interaction
	* @param name interaction name
	* @param cfg interaction config
	* @returns
	*/
	View$1.prototype.interaction = function(name, cfg) {
		var existInteraction = this.interactions[name];
		if (existInteraction) existInteraction.destroy();
		var interaction$9 = createInteraction(name, this, cfg);
		if (interaction$9) {
			interaction$9.init();
			this.interactions[name] = interaction$9;
		}
		return this;
	};
	/**
	* 移除当前 View 的 interaction
	* ```ts
	* view.removeInteraction('my-interaction');
	* ```
	* @param name interaction name
	*/
	View$1.prototype.removeInteraction = function(name) {
		var existInteraction = this.interactions[name];
		if (existInteraction) {
			existInteraction.destroy();
			this.interactions[name] = void 0;
		}
	};
	/**
	* 修改数据，数据更新逻辑，数据更新仅仅影响当前这一层的 view
	*
	* ```ts
	* view.changeData([{ city: '北京', sale: '200' }]);
	* ```
	*
	* @param data
	* @returns void
	*/
	View$1.prototype.changeData = function(data$2) {
		this.isDataChanged = true;
		this.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, event_default.fromData(this, VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
		this.data(data$2);
		this.paint(true);
		var views = this.views;
		for (var i = 0, len = views.length; i < len; i++) views[i].changeData(data$2);
		this.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, event_default.fromData(this, VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
	};
	/**
	* 创建子 view
	*
	* ```ts
	* const innerView = view.createView({
	*   start: { x: 0, y: 0 },
	*   end: { x: 0.5, y: 0.5 },
	*   padding: 8,
	* });
	* ```
	*
	* @param cfg
	* @returns View
	*/
	View$1.prototype.createView = function(cfg) {
		if (this.parent && this.parent.parent) console.warn("The view nesting recursive feature will be removed at G2 V4.1. Please avoid to use it.");
		var sharedOptions = {
			data: this.options.data,
			scales: clone_default(this.options.scales),
			axes: clone_default(this.options.axes),
			coordinate: clone_default(this.coordinateController.getOption()),
			tooltip: clone_default(this.options.tooltip),
			legends: clone_default(this.options.legends),
			animate: this.options.animate,
			visible: this.visible
		};
		var v = new View$1(__assign(__assign({
			parent: this,
			canvas: this.canvas,
			backgroundGroup: this.backgroundGroup.addGroup({ zIndex: GROUP_Z_INDEX.BG }),
			middleGroup: this.middleGroup.addGroup({ zIndex: GROUP_Z_INDEX.MID }),
			foregroundGroup: this.foregroundGroup.addGroup({ zIndex: GROUP_Z_INDEX.FORE }),
			theme: this.themeObject,
			padding: this.padding
		}, cfg), { options: __assign(__assign({}, sharedOptions), get_default(cfg, "options", {})) }));
		this.views.push(v);
		return v;
	};
	/**
	* @deprecated
	* This method will be removed at G2 V4.1. Replaced by {@link #createView()}
	*/
	View$1.prototype.view = function(cfg) {
		console.warn("This method will be removed at G2 V4.1. Please use chart.createView() instead.");
		return this.createView(cfg);
	};
	/**
	* 删除一个子 view
	* @param view
	* @return removedView
	*/
	View$1.prototype.removeView = function(view) {
		var removedView = remove_default(this.views, function(v) {
			return v === view;
		})[0];
		if (removedView) removedView.destroy();
		return removedView;
	};
	/**
	* 获取当前坐标系实例。
	* @returns [[Coordinate]]
	*/
	View$1.prototype.getCoordinate = function() {
		return this.coordinateInstance;
	};
	/**
	* 获取当前 view 的主题配置。
	* @returns themeObject
	*/
	View$1.prototype.getTheme = function() {
		return this.themeObject;
	};
	/**
	* 获得 x 轴字段的 scale 实例。
	* @returns view 中 Geometry 对于的 x scale
	*/
	View$1.prototype.getXScale = function() {
		var g = this.geometries[0];
		return g ? g.getXScale() : null;
	};
	/**
	* 获取 y 轴字段的 scales 实例。
	* @returns view 中 Geometry 对于的 y scale 数组
	*/
	View$1.prototype.getYScales = function() {
		var tmpMap = {};
		var yScales = [];
		this.geometries.forEach(function(g) {
			var yScale = g.getYScale();
			var field$5 = yScale.field;
			if (!tmpMap[field$5]) {
				tmpMap[field$5] = true;
				yScales.push(yScale);
			}
		});
		return yScales;
	};
	/**
	* 获取 x 轴或者 y 轴对应的所有 scale 实例。
	* @param dimType x | y
	* @returns x 轴或者 y 轴对应的所有 scale 实例。
	*/
	View$1.prototype.getScalesByDim = function(dimType) {
		var geometries = this.geometries;
		var scales = {};
		for (var i = 0, len = geometries.length; i < len; i++) {
			var geometry$34 = geometries[i];
			var scale$4 = dimType === "x" ? geometry$34.getXScale() : geometry$34.getYScale();
			if (scale$4 && !scales[scale$4.field]) scales[scale$4.field] = scale$4;
		}
		return scales;
	};
	/**
	* 根据字段名去获取 scale 实例。
	* @param field 数据字段名称
	* @param key id
	*/
	View$1.prototype.getScale = function(field$5, key) {
		var defaultKey = key ? key : this.getScaleKey(field$5);
		return this.getRootView().scalePool.getScale(defaultKey);
	};
	/**
	* @deprecated
	* This method will be removed at G2 V4.1. Please use `getScale`.
	*/
	View$1.prototype.getScaleByField = function(field$5, key) {
		return this.getScale(field$5, key);
	};
	/**
	* 返回所有配置信息。
	* @returns 所有的 view API 配置。
	*/
	View$1.prototype.getOptions = function() {
		return this.options;
	};
	/**
	* 获取 view 的数据（过滤后的数据）。
	* @returns 处理过滤器之后的数据。
	*/
	View$1.prototype.getData = function() {
		return this.filteredData;
	};
	/**
	* 获取原始数据
	* @returns 传入 G2 的原始数据
	*/
	View$1.prototype.getOriginalData = function() {
		return this.options.data;
	};
	/**
	* 获取布局后的边距 padding
	* @returns
	*/
	View$1.prototype.getPadding = function() {
		return this.autoPadding.getPadding();
	};
	/**
	* 获取当前 view 有的 geometries
	* @returns
	*/
	View$1.prototype.getGeometries = function() {
		return this.geometries;
	};
	/**
	* 获取 view 中的所有 geome
	*/
	View$1.prototype.getElements = function() {
		return reduce_default(this.geometries, function(elements, geometry$34) {
			return elements.concat(geometry$34.getElements());
		}, []);
	};
	/**
	* 根据一定的规则查找 Geometry 的 Elements。
	*
	* ```typescript
	* getElementsBy((element) => {
	*   const data = element.getData();
	*
	*   return data.a === 'a';
	* });
	* ```
	*
	* @param condition 定义查找规则的回调函数。
	* @returns
	*/
	View$1.prototype.getElementsBy = function(condition) {
		return this.getElements().filter(function(el) {
			return condition(el);
		});
	};
	/**
	* 获得绘制的层级 group。
	* @param layer 层级名称。
	* @returns 对应层级的 Group。
	*/
	View$1.prototype.getLayer = function(layer) {
		return layer === LAYER.BG ? this.backgroundGroup : layer === LAYER.MID ? this.middleGroup : layer === LAYER.FORE ? this.foregroundGroup : this.foregroundGroup;
	};
	/**
	* 对外暴露方法，判断一个点是否在绘图区域（即坐标系范围）内部。
	* @param point 坐标点
	*/
	View$1.prototype.isPointInPlot = function(point$1) {
		return isPointInCoordinate(this.getCoordinate(), point$1);
	};
	/**
	* 获得所有的 legend 对应的 attribute 实例。
	* @returns 维度字段的 Attribute 数组
	*/
	View$1.prototype.getLegendAttributes = function() {
		return flatten_default(this.geometries.map(function(g) {
			return g.getGroupAttributes();
		}));
	};
	/**
	* 获取所有的分组字段的 scale 实例。
	* @returns 获得分组字段的 scale 实例数组。
	*/
	View$1.prototype.getGroupScales = function() {
		var scales = this.geometries.map(function(g) {
			return g.getGroupScales();
		});
		return uniq$1(flatten_default(scales));
	};
	/**
	* 获取 G.Canvas 实例。
	* @returns G.Canvas 画布实例。
	*/
	View$1.prototype.getCanvas = function() {
		return this.getRootView().canvas;
	};
	/**
	* 获得根节点 view。
	*/
	View$1.prototype.getRootView = function() {
		var v = this;
		while (true) {
			if (v.parent) {
				v = v.parent;
				continue;
			}
			break;
		}
		return v;
	};
	/**
	* 获取该数据在可视化后，对应的画布坐标点。
	* @param data 原始数据记录
	* @returns 对应的画布坐标点
	*/
	View$1.prototype.getXY = function(data$2) {
		var coordinate$10 = this.getCoordinate();
		var xScales = this.getScalesByDim("x");
		var yScales = this.getScalesByDim("y");
		var x;
		var y;
		each_default(data$2, function(value$1, key) {
			if (xScales[key]) x = xScales[key].scale(value$1);
			if (yScales[key]) y = yScales[key].scale(value$1);
		});
		if (!is_nil_default(x) && !is_nil_default(y)) return coordinate$10.convert({
			x,
			y
		});
	};
	/**
	* 获取 name 对应的 controller 实例
	* @param name
	*/
	View$1.prototype.getController = function(name) {
		return find_default(this.controllers, function(c) {
			return c.name === name;
		});
	};
	/**
	* 显示 point 坐标点对应的 tooltip。
	* @param point 画布坐标点
	* @returns View
	*/
	View$1.prototype.showTooltip = function(point$1) {
		var tooltip$10 = this.getController("tooltip");
		if (tooltip$10) tooltip$10.showTooltip(point$1);
		return this;
	};
	/**
	* 隐藏 tooltip。
	* @returns View
	*/
	View$1.prototype.hideTooltip = function() {
		var tooltip$10 = this.getController("tooltip");
		if (tooltip$10) tooltip$10.hideTooltip();
		return this;
	};
	/**
	* 将 tooltip 锁定到当前位置不能移动。
	* @returns View
	*/
	View$1.prototype.lockTooltip = function() {
		var tooltip$10 = this.getController("tooltip");
		if (tooltip$10) tooltip$10.lockTooltip();
		return this;
	};
	/**
	* 将 tooltip 锁定解除。
	* @returns View
	*/
	View$1.prototype.unlockTooltip = function() {
		var tooltip$10 = this.getController("tooltip");
		if (tooltip$10) tooltip$10.unlockTooltip();
		return this;
	};
	/**
	* 是否锁定 tooltip。
	* @returns 是否锁定
	*/
	View$1.prototype.isTooltipLocked = function() {
		var tooltip$10 = this.getController("tooltip");
		return tooltip$10 && tooltip$10.isTooltipLocked();
	};
	/**
	* 获取当前 point 对应的 tooltip 数据项。
	* @param point 坐标点
	* @returns tooltip 数据项
	*/
	View$1.prototype.getTooltipItems = function(point$1) {
		var tooltip$10 = this.getController("tooltip");
		return tooltip$10 ? tooltip$10.getTooltipItems(point$1) : [];
	};
	/**
	* 获取逼近的点的数据集合
	* @param point 当前坐标点
	* @returns  数据
	*/
	View$1.prototype.getSnapRecords = function(point$1) {
		var geometries = this.geometries;
		var rst = [];
		for (var i = 0, len = geometries.length; i < len; i++) {
			var geom = geometries[i];
			var dataArray = geom.dataArray;
			geom.sort(dataArray);
			var record = void 0;
			for (var j = 0, dataLen = dataArray.length; j < dataLen; j++) {
				var data$2 = dataArray[j];
				record = findDataByPoint(point$1, data$2, geom);
				if (record) rst.push(record);
			}
		}
		var views = this.views;
		for (var i = 0, len = views.length; i < len; i++) {
			var snapRecords = views[i].getSnapRecords(point$1);
			rst = rst.concat(snapRecords);
		}
		return rst;
	};
	/**
	* 获取所有的 pure component 组件，用于布局。
	*/
	View$1.prototype.getComponents = function() {
		var components = [];
		var controllers = this.controllers;
		for (var i = 0, len = controllers.length; i < len; i++) {
			var controller = controllers[i];
			components = components.concat(controller.getComponents());
		}
		return components;
	};
	/**
	* 将 data 数据进行过滤。
	* @param data
	* @returns 过滤之后的数据
	*/
	View$1.prototype.filterData = function(data$2) {
		var filters = this.options.filters;
		if (size(filters) === 0) return data$2;
		return filter_default(data$2, function(datum, idx) {
			return Object.keys(filters).every(function(field$5) {
				var condition = filters[field$5];
				return condition(datum[field$5], datum, idx);
			});
		});
	};
	/**
	* 对某一个字段进行过滤
	* @param field
	* @param data
	*/
	View$1.prototype.filterFieldData = function(field$5, data$2) {
		var filters = this.options.filters;
		var condition = get_default(filters, field$5);
		if (is_undefined_default(condition)) return data$2;
		return data$2.filter(function(datum, idx) {
			return condition(datum[field$5], datum, idx);
		});
	};
	/**
	* 调整 coordinate 的坐标范围。
	*/
	View$1.prototype.adjustCoordinate = function() {
		var _a$5 = this.getCoordinate(), curStart = _a$5.start, curEnd = _a$5.end;
		var start = this.coordinateBBox.bl;
		var end = this.coordinateBBox.tr;
		if (is_equal_default(curStart, start) && is_equal_default(curEnd, end)) {
			this.isCoordinateChanged = false;
			return;
		}
		this.isCoordinateChanged = true;
		this.coordinateInstance = this.coordinateController.adjust(start, end);
	};
	View$1.prototype.paint = function(isUpdate) {
		this.renderDataRecursive(isUpdate);
		this.syncScale();
		this.emit(VIEW_LIFE_CIRCLE.BEFORE_PAINT);
		this.renderPaddingRecursive(isUpdate);
		this.renderLayoutRecursive(isUpdate);
		this.renderBackgroundStyleShape();
		this.renderPaintRecursive(isUpdate);
		this.emit(VIEW_LIFE_CIRCLE.AFTER_PAINT);
		this.isDataChanged = false;
	};
	/**
	* 渲染背景样式的 shape。
	* 放到 view 中创建的原因是让使用 view 绘制图形的时候，也能够处理背景色
	*/
	View$1.prototype.renderBackgroundStyleShape = function() {
		if (this.parent) return;
		var background = get_default(this.themeObject, "background");
		if (background) {
			if (!this.backgroundStyleRectShape) {
				this.backgroundStyleRectShape = this.backgroundGroup.addShape("rect", {
					attrs: {},
					zIndex: -1,
					capture: false
				});
				this.backgroundStyleRectShape.toBack();
			}
			var _a$5 = this.viewBBox, x = _a$5.x, y = _a$5.y, width = _a$5.width, height = _a$5.height;
			this.backgroundStyleRectShape.attr({
				fill: background,
				x,
				y,
				width,
				height
			});
		} else if (this.backgroundStyleRectShape) {
			this.backgroundStyleRectShape.remove(true);
			this.backgroundStyleRectShape = void 0;
		}
	};
	/**
	* 递归计算每个 view 的 padding 值，coordinateBBox 和 coordinateInstance
	* @param isUpdate
	*/
	View$1.prototype.renderPaddingRecursive = function(isUpdate) {
		this.calculateViewBBox();
		this.adjustCoordinate();
		this.initComponents(isUpdate);
		this.autoPadding = calculatePadding(this).shrink(parsePadding(this.appendPadding));
		this.coordinateBBox = this.viewBBox.shrink(this.autoPadding.getPadding());
		this.adjustCoordinate();
		this.controllers.find(function(c) {
			return c.name === "tooltip";
		}).update();
		var views = this.views;
		for (var i = 0, len = views.length; i < len; i++) views[i].renderPaddingRecursive(isUpdate);
	};
	/**
	* 递归处理 view 的布局，最终是计算各个 view 的 coordinateBBox 和 coordinateInstance
	* @param isUpdate
	*/
	View$1.prototype.renderLayoutRecursive = function(isUpdate) {
		var syncViewPaddingFn = this.syncViewPadding === true ? defaultSyncViewPadding : is_function_default(this.syncViewPadding) ? this.syncViewPadding : void 0;
		if (syncViewPaddingFn) {
			syncViewPaddingFn(this, this.views, PaddingCal);
			this.views.forEach(function(v) {
				v.coordinateBBox = v.viewBBox.shrink(v.autoPadding.getPadding());
				v.adjustCoordinate();
			});
		}
		this.doLayout();
		var views = this.views;
		for (var i = 0, len = views.length; i < len; i++) views[i].renderLayoutRecursive(isUpdate);
	};
	/**
	* 最终递归绘制组件和图形
	* @param isUpdate
	*/
	View$1.prototype.renderPaintRecursive = function(isUpdate) {
		var middleGroup = this.middleGroup;
		if (this.limitInPlot) {
			var _a$5 = getCoordinateClipCfg(this.coordinateInstance), type = _a$5.type, attrs = _a$5.attrs;
			middleGroup.setClip({
				type,
				attrs
			});
		} else middleGroup.setClip(void 0);
		this.paintGeometries(isUpdate);
		this.renderComponents(isUpdate);
		var views = this.views;
		for (var i = 0, len = views.length; i < len; i++) views[i].renderPaintRecursive(isUpdate);
	};
	/**
	* 创建 scale，递归到顶层 view 去创建和缓存 scale
	* @param field
	* @param data
	* @param scaleDef
	* @param key
	*/
	View$1.prototype.createScale = function(field$5, data$2, scaleDef, key) {
		var currentScaleDef = get_default(this.options.scales, [field$5]);
		var mergedScaleDef = __assign(__assign({}, currentScaleDef), scaleDef);
		if (this.parent) return this.parent.createScale(field$5, data$2, mergedScaleDef, key);
		return this.scalePool.createScale(field$5, data$2, mergedScaleDef, key);
	};
	/**
	* 递归渲染中的数据处理
	* @param isUpdate
	*/
	View$1.prototype.renderDataRecursive = function(isUpdate) {
		this.doFilterData();
		this.createCoordinate();
		this.initGeometries(isUpdate);
		this.renderFacet(isUpdate);
		var views = this.views;
		for (var i = 0, len = views.length; i < len; i++) views[i].renderDataRecursive(isUpdate);
	};
	/**
	* 计算 region，计算实际的像素范围坐标
	* @private
	*/
	View$1.prototype.calculateViewBBox = function() {
		var x;
		var y;
		var width;
		var height;
		if (this.parent) {
			var bbox = this.parent.coordinateBBox;
			x = bbox.x;
			y = bbox.y;
			width = bbox.width;
			height = bbox.height;
		} else {
			x = 0;
			y = 0;
			width = this.canvas.get("width");
			height = this.canvas.get("height");
		}
		var _a$5 = this.region, start = _a$5.start, end = _a$5.end;
		var viewBBox = new BBox(x + width * start.x, y + height * start.y, width * (end.x - start.x), height * (end.y - start.y));
		if (!this.viewBBox || !this.viewBBox.isEqual(viewBBox)) this.viewBBox = new BBox(x + width * start.x, y + height * start.y, width * (end.x - start.x), height * (end.y - start.y));
		this.coordinateBBox = this.viewBBox;
	};
	/**
	* 初始化事件机制：G 4.0 底层内置支持 name:event 的机制，那么只要所有组件都有自己的 name 即可。
	*
	* G2 的事件只是获取事件委托，然后在 view 嵌套结构中，形成事件冒泡机制。
	* 当前 view 只委托自己 view 中的 Component 和 Geometry 事件，并向上冒泡
	* @private
	*/
	View$1.prototype.initEvents = function() {
		this.foregroundGroup.on("*", this.onDelegateEvents);
		this.middleGroup.on("*", this.onDelegateEvents);
		this.backgroundGroup.on("*", this.onDelegateEvents);
		this.canvas.on("*", this.onCanvasEvent);
	};
	/**
	* 初始化插件
	*/
	View$1.prototype.initComponentController = function() {
		var usedControllers = this.usedControllers;
		for (var i = 0, len = usedControllers.length; i < len; i++) {
			var controllerName = usedControllers[i];
			var Ctor = getComponentController(controllerName);
			if (Ctor) this.controllers.push(new Ctor(this));
		}
	};
	View$1.prototype.createViewEvent = function(evt) {
		var shape = evt.shape, name = evt.name;
		var data$2 = shape ? shape.get("origin") : null;
		var e = new event_default(this, evt, data$2);
		e.type = name;
		return e;
	};
	/**
	* 处理 PLOT_EVENTS
	* plot event 需要处理所有的基础事件，并判断是否在画布中，然后再决定是否要 emit。
	* 对于 mouseenter、mouseleave 比较特殊，需要做一下数学比较。
	* @param e
	*/
	View$1.prototype.doPlotEvent = function(e) {
		var type = e.type, x = e.x, y = e.y;
		var point$1 = {
			x,
			y
		};
		if ([
			"mousedown",
			"mouseup",
			"mousemove",
			"mouseleave",
			"mousewheel",
			"touchstart",
			"touchmove",
			"touchend",
			"touchcancel",
			"click",
			"dblclick",
			"contextmenu"
		].includes(type)) {
			var currentInPlot = this.isPointInPlot(point$1);
			var newEvent = e.clone();
			if (currentInPlot) {
				var TYPE = "plot:".concat(type);
				newEvent.type = TYPE;
				this.emit(TYPE, newEvent);
				if (type === "mouseleave" || type === "touchend") this.isPreMouseInPlot = false;
			}
			if (type === "mousemove" || type === "touchmove") {
				if (this.isPreMouseInPlot && !currentInPlot) {
					if (type === "mousemove") {
						newEvent.type = PLOT_EVENTS.MOUSE_LEAVE;
						this.emit(PLOT_EVENTS.MOUSE_LEAVE, newEvent);
					}
					newEvent.type = PLOT_EVENTS.LEAVE;
					this.emit(PLOT_EVENTS.LEAVE, newEvent);
				} else if (!this.isPreMouseInPlot && currentInPlot) {
					if (type === "mousemove") {
						newEvent.type = PLOT_EVENTS.MOUSE_ENTER;
						this.emit(PLOT_EVENTS.MOUSE_ENTER, newEvent);
					}
					newEvent.type = PLOT_EVENTS.ENTER;
					this.emit(PLOT_EVENTS.ENTER, newEvent);
				}
				this.isPreMouseInPlot = currentInPlot;
			} else if (type === "mouseleave" || type === "touchend") {
				if (this.isPreMouseInPlot) {
					if (type === "mouseleave") {
						newEvent.type = PLOT_EVENTS.MOUSE_LEAVE;
						this.emit(PLOT_EVENTS.MOUSE_LEAVE, newEvent);
					}
					newEvent.type = PLOT_EVENTS.LEAVE;
					this.emit(PLOT_EVENTS.LEAVE, newEvent);
					this.isPreMouseInPlot = false;
				}
			}
		}
	};
	/**
	* 处理筛选器，筛选数据
	* @private
	*/
	View$1.prototype.doFilterData = function() {
		var data$2 = this.options.data;
		this.filteredData = this.filterData(data$2);
	};
	/**
	* 初始化 Geometries
	* @private
	*/
	View$1.prototype.initGeometries = function(isUpdate) {
		this.createOrUpdateScales();
		var coordinate$10 = this.getCoordinate();
		var scaleDefs = get_default(this.options, "scales", {});
		var geometries = this.geometries;
		for (var i = 0, len = geometries.length; i < len; i++) {
			var geometry$34 = geometries[i];
			geometry$34.scales = this.getGeometryScales();
			var cfg = {
				coordinate: coordinate$10,
				scaleDefs,
				data: this.filteredData,
				theme: this.themeObject,
				isDataChanged: this.isDataChanged,
				isCoordinateChanged: this.isCoordinateChanged
			};
			if (isUpdate) geometry$34.update(cfg);
			else geometry$34.init(cfg);
		}
		this.adjustScales();
	};
	/**
	* 根据 Geometry 的所有字段创建 scales
	* 如果存在，则更新，不存在则创建
	*/
	View$1.prototype.createOrUpdateScales = function() {
		var fields = this.getScaleFields();
		var groupedFields = this.getGroupedFields();
		var _a$5 = this.getOptions(), data$2 = _a$5.data, _b = _a$5.scales, scales = _b === void 0 ? {} : _b;
		var filteredData = this.filteredData;
		for (var i = 0, len = fields.length; i < len; i++) {
			var field$5 = fields[i];
			var scaleDef = scales[field$5];
			var key = this.getScaleKey(field$5);
			this.createScale(field$5, groupedFields.includes(field$5) ? data$2 : filteredData, scaleDef, key);
			this.createdScaleKeys.set(key, true);
		}
	};
	/**
	* 处理 scale 同步逻辑
	*/
	View$1.prototype.syncScale = function() {
		this.getRootView().scalePool.sync(this.getCoordinate(), this.theme);
	};
	/**
	* 获得 Geometry 中的 scale 对象
	*/
	View$1.prototype.getGeometryScales = function() {
		var fields = this.getScaleFields();
		var scales = {};
		for (var i = 0; i < fields.length; i++) {
			var field$5 = fields[i];
			scales[field$5] = this.getScaleByField(field$5);
		}
		return scales;
	};
	View$1.prototype.getScaleFields = function() {
		var fields = [];
		var tmpMap = /* @__PURE__ */ new Map();
		var geometries = this.geometries;
		for (var i = 0; i < geometries.length; i++) {
			var geometryScales = geometries[i].getScaleFields();
			uniq$1(geometryScales, fields, tmpMap);
		}
		return fields;
	};
	View$1.prototype.getGroupedFields = function() {
		var fields = [];
		var tmpMap = /* @__PURE__ */ new Map();
		var geometries = this.geometries;
		for (var i = 0; i < geometries.length; i++) {
			var groupFields = geometries[i].getGroupFields();
			uniq$1(groupFields, fields, tmpMap);
		}
		return fields;
	};
	/**
	* 调整 scale 配置
	* @private
	*/
	View$1.prototype.adjustScales = function() {
		this.adjustCategoryScaleRange();
	};
	/**
	* 调整分类 scale 的 range，防止超出坐标系外面
	* @private
	*/
	View$1.prototype.adjustCategoryScaleRange = function() {
		var _this = this;
		var xyScales = __spreadArray([this.getXScale()], __read(this.getYScales()), false).filter(function(e) {
			return !!e;
		});
		var coordinate$10 = this.getCoordinate();
		var scaleOptions = this.options.scales;
		each_default(xyScales, function(scale$4) {
			var field$5 = scale$4.field, values$1 = scale$4.values, isCategory = scale$4.isCategory, isIdentity = scale$4.isIdentity;
			if (isCategory || isIdentity) {
				if (values$1 && !get_default(scaleOptions, [field$5, "range"])) scale$4.range = getDefaultCategoryScaleRange(scale$4, coordinate$10, _this.theme);
			}
		});
	};
	/**
	* 根据 options 配置、Geometry 字段配置，自动生成 components
	* @param isUpdate 是否是更新
	* @private
	*/
	View$1.prototype.initComponents = function(isUpdate) {
		var controllers = this.controllers;
		for (var i = 0; i < controllers.length; i++) {
			var controller = controllers[i];
			if (isUpdate) controller.update();
			else {
				controller.clear();
				controller.render();
			}
		}
	};
	View$1.prototype.doLayout = function() {
		this.layoutFunc(this);
	};
	/**
	* 创建坐标系
	* @private
	*/
	View$1.prototype.createCoordinate = function() {
		var start = this.coordinateBBox.bl;
		var end = this.coordinateBBox.tr;
		this.coordinateInstance = this.coordinateController.create(start, end);
	};
	/**
	* 根据 options 配置自动渲染 geometry
	* @private
	*/
	View$1.prototype.paintGeometries = function(isUpdate) {
		var doAnimation = this.options.animate;
		var coordinate$10 = this.getCoordinate();
		var canvasRegion = {
			x: this.viewBBox.x,
			y: this.viewBBox.y,
			minX: this.viewBBox.minX,
			minY: this.viewBBox.minY,
			maxX: this.viewBBox.maxX,
			maxY: this.viewBBox.maxY,
			width: this.viewBBox.width,
			height: this.viewBBox.height
		};
		var geometries = this.geometries;
		for (var i = 0; i < geometries.length; i++) {
			var geometry$34 = geometries[i];
			geometry$34.coordinate = coordinate$10;
			geometry$34.canvasRegion = canvasRegion;
			if (!doAnimation) geometry$34.animate(false);
			geometry$34.paint(isUpdate);
		}
	};
	/**
	* 最后的绘制组件
	* @param isUpdate
	*/
	View$1.prototype.renderComponents = function(isUpdate) {
		var components = this.getComponents();
		for (var i = 0; i < components.length; i++) components[i].component.render();
	};
	/**
	* 渲染分面，会在其中进行数据分面，然后进行子 view 创建
	* @param isUpdate
	*/
	View$1.prototype.renderFacet = function(isUpdate) {
		if (this.facetInstance) if (isUpdate) this.facetInstance.update();
		else {
			this.facetInstance.clear();
			this.facetInstance.init();
			this.facetInstance.render();
		}
	};
	View$1.prototype.initOptions = function() {
		var _this = this;
		var _a$5 = this.options, _b = _a$5.geometries, geometries = _b === void 0 ? [] : _b, _c = _a$5.interactions, interactions = _c === void 0 ? [] : _c, _d = _a$5.views, views = _d === void 0 ? [] : _d, _e = _a$5.annotations, annotations = _e === void 0 ? [] : _e, coordinate$10 = _a$5.coordinate, events = _a$5.events, facets = _a$5.facets;
		if (this.coordinateController) coordinate$10 && this.coordinateController.update(coordinate$10);
		else this.coordinateController = new coordinate_default(coordinate$10);
		for (var i = 0; i < geometries.length; i++) {
			var geometryOption = geometries[i];
			this.createGeometry(geometryOption);
		}
		for (var j = 0; j < interactions.length; j++) {
			var interactionOption = interactions[j];
			var type = interactionOption.type, cfg = interactionOption.cfg;
			this.interaction(type, cfg);
		}
		for (var k = 0; k < views.length; k++) {
			var viewOption = views[k];
			this.createView(viewOption);
		}
		var annotationComponent = this.getController("annotation");
		for (var l = 0; l < annotations.length; l++) {
			var annotationOption = annotations[l];
			annotationComponent.annotation(annotationOption);
		}
		if (events) each_default(events, function(eventCallback, eventName) {
			_this.on(eventName, eventCallback);
		});
		if (facets) each_default(facets, function(facet) {
			var type$1 = facet.type, rest = __rest(facet, ["type"]);
			_this.facet(type$1, rest);
		});
	};
	View$1.prototype.createGeometry = function(geometryOption) {
		var type = geometryOption.type, _a$5 = geometryOption.cfg, cfg = _a$5 === void 0 ? {} : _a$5;
		if (this[type]) {
			var geometry_1 = this[type](cfg);
			each_default(geometryOption, function(v, k) {
				if (is_function_default(geometry_1[k])) geometry_1[k](v);
			});
		}
	};
	/**
	* scale key 的创建方式
	* @param field
	*/
	View$1.prototype.getScaleKey = function(field$5) {
		return "".concat(this.id, "-").concat(field$5);
	};
	return View$1;
}(base_default$9);
/**
* 注册 geometry 组件
* @param name
* @param Ctor
* @returns Geometry
*/
function registerGeometry(name, Ctor) {
	View.prototype[name.toLowerCase()] = function(cfg) {
		if (cfg === void 0) cfg = {};
		var props = __assign({
			container: this.middleGroup.addGroup(),
			labelsContainer: this.foregroundGroup.addGroup()
		}, cfg);
		var geometry$34 = new Ctor(props);
		this.geometries.push(geometry$34);
		return geometry$34;
	};
}
var view_default = View;

//#endregion
//#region node_modules/@antv/g2/esm/chart/chart.js
/**
* Chart 类，是使用 G2 进行绘图的入口。
*/
var Chart = function(_super) {
	__extends(Chart$1, _super);
	function Chart$1(props) {
		var _this = this;
		var container = props.container, width = props.width, height = props.height, _a$5 = props.autoFit, autoFit = _a$5 === void 0 ? false : _a$5, padding$2 = props.padding, appendPadding = props.appendPadding, _b = props.renderer, renderer = _b === void 0 ? "canvas" : _b, pixelRatio = props.pixelRatio, _c = props.localRefresh, localRefresh = _c === void 0 ? true : _c, _d = props.visible, visible = _d === void 0 ? true : _d, _e = props.supportCSSTransform, supportCSSTransform = _e === void 0 ? false : _e, _f = props.defaultInteractions, defaultInteractions = _f === void 0 ? [
			"tooltip",
			"legend-filter",
			"legend-active",
			"continuous-filter",
			"ellipsis-text",
			"axis-description"
		] : _f, options = props.options, limitInPlot$4 = props.limitInPlot, theme$3 = props.theme, syncViewPadding$1 = props.syncViewPadding;
		var ele = is_string_default(container) ? document.getElementById(container) : container;
		var wrapperElement = createDom$1("<div style=\"position:relative;\"></div>");
		ele.appendChild(wrapperElement);
		var size$1 = getChartSize(ele, autoFit, width, height);
		var canvas = new (getEngine(renderer)).Canvas(__assign({
			container: wrapperElement,
			pixelRatio,
			localRefresh,
			supportCSSTransform
		}, size$1));
		_this = _super.call(this, {
			parent: null,
			canvas,
			backgroundGroup: canvas.addGroup({ zIndex: GROUP_Z_INDEX.BG }),
			middleGroup: canvas.addGroup({ zIndex: GROUP_Z_INDEX.MID }),
			foregroundGroup: canvas.addGroup({ zIndex: GROUP_Z_INDEX.FORE }),
			padding: padding$2,
			appendPadding,
			visible,
			options,
			limitInPlot: limitInPlot$4,
			theme: theme$3,
			syncViewPadding: syncViewPadding$1
		}) || this;
		/**
		* when container size changed, change chart size props, and re-render.
		*/
		_this.onResize = debounce_default(function() {
			_this.forceFit();
		}, 300);
		_this.ele = ele;
		_this.canvas = canvas;
		_this.width = size$1.width;
		_this.height = size$1.height;
		_this.autoFit = autoFit;
		_this.localRefresh = localRefresh;
		_this.renderer = renderer;
		_this.wrapperElement = wrapperElement;
		_this.updateCanvasStyle();
		_this.bindAutoFit();
		_this.initDefaultInteractions(defaultInteractions);
		return _this;
	}
	Chart$1.prototype.initDefaultInteractions = function(interactions) {
		var _this = this;
		each_default(interactions, function(interaction$9) {
			_this.interaction(interaction$9);
		});
	};
	/**
	* 设置 WAI-ARIA 无障碍标签。如何根据图形语法自动生成 arial 内容？
	* @param ariaOption
	*/
	Chart$1.prototype.aria = function(ariaOption) {
		var ATTR = "aria-label";
		if (ariaOption === false) this.ele.removeAttribute(ATTR);
		else this.ele.setAttribute(ATTR, ariaOption.label);
	};
	/**
	* 改变图表大小，同时重新渲染。
	* @param width 图表宽度
	* @param height 图表高度
	* @returns
	*/
	Chart$1.prototype.changeSize = function(width, height) {
		if (this.width === width && this.height === height) return this;
		this.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE);
		this.width = width;
		this.height = height;
		this.canvas.changeSize(width, height);
		this.render(true);
		this.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_SIZE);
		return this;
	};
	/**
	* 清空图表，同时清除掉 aria 配置
	*/
	Chart$1.prototype.clear = function() {
		_super.prototype.clear.call(this);
		this.aria(false);
	};
	/**
	* 销毁图表，同时解绑事件，销毁创建的 G.Canvas 实例。
	* @returns void
	*/
	Chart$1.prototype.destroy = function() {
		_super.prototype.destroy.call(this);
		this.unbindAutoFit();
		this.canvas.destroy();
		removeDom(this.wrapperElement);
		this.wrapperElement = null;
	};
	/**
	* 显示或隐藏图表
	* @param visible 是否可见，true 表示显示，false 表示隐藏
	* @returns
	*/
	Chart$1.prototype.changeVisible = function(visible) {
		_super.prototype.changeVisible.call(this, visible);
		this.wrapperElement.style.display = visible ? "" : "none";
		return this;
	};
	/**
	* 自动根据容器大小 resize 画布
	*/
	Chart$1.prototype.forceFit = function() {
		if (!this.destroyed) {
			var _a$5 = getChartSize(this.ele, true, this.width, this.height), width = _a$5.width, height = _a$5.height;
			this.changeSize(width, height);
		}
	};
	Chart$1.prototype.updateCanvasStyle = function() {
		modifyCSS(this.canvas.get("el"), {
			display: "inline-block",
			verticalAlign: "middle"
		});
	};
	Chart$1.prototype.bindAutoFit = function() {
		if (this.autoFit) window.addEventListener("resize", this.onResize);
	};
	Chart$1.prototype.unbindAutoFit = function() {
		if (this.autoFit) window.removeEventListener("resize", this.onResize);
	};
	return Chart$1;
}(view_default);
var chart_default = Chart;

//#endregion
//#region node_modules/@antv/g2/esm/chart/controller/base.js
/**
* Component Controller 规范需要定义的基类
* 1. 规范的 option 输入
* 2. 统一的信息获取 API
* 3. 明确定义的组件事件（名称、数据）
*/
var Controller = function() {
	function Controller$1(view) {
		/** 是否可见 */
		this.visible = true;
		/** 所有的 component */
		this.components = [];
		this.view = view;
	}
	/**
	* clear
	* @param includeOption 是否清空 option 配置项（used in annotation）
	*/
	Controller$1.prototype.clear = function(includeOption) {
		each_default(this.components, function(co) {
			co.component.destroy();
		});
		this.components = [];
	};
	/**
	* destroy the component
	*/
	Controller$1.prototype.destroy = function() {
		this.clear();
	};
	/**
	* get all components
	* @returns components array
	*/
	Controller$1.prototype.getComponents = function() {
		return this.components;
	};
	/**
	* change visibility of component
	* @param visible
	*/
	Controller$1.prototype.changeVisible = function(visible) {
		if (this.visible === visible) return;
		this.components.forEach(function(co) {
			if (visible) co.component.show();
			else co.component.hide();
		});
		this.visible = visible;
	};
	return Controller$1;
}();

//#endregion
//#region node_modules/@antv/g2/esm/chart/controller/tooltip.js
function uniq$2(items) {
	var uniqItems = [];
	var _loop_1 = function(index$1) {
		var item = items[index$1];
		if (!find_default(uniqItems, function(subItem) {
			return subItem.color === item.color && subItem.name === item.name && subItem.value === item.value && subItem.title === item.title;
		})) uniqItems.push(item);
	};
	for (var index = 0; index < items.length; index++) _loop_1(index);
	return uniqItems;
}
/** @ignore */
var Tooltip = function(_super) {
	__extends(Tooltip$2, _super);
	function Tooltip$2() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.isLocked = false;
		return _this;
	}
	Object.defineProperty(Tooltip$2.prototype, "name", {
		get: function() {
			return "tooltip";
		},
		enumerable: false,
		configurable: true
	});
	Tooltip$2.prototype.init = function() {};
	Tooltip$2.prototype.isVisible = function() {
		return this.view.getOptions().tooltip !== false;
	};
	Tooltip$2.prototype.render = function() {};
	/**
	* Shows tooltip
	* @param point
	*/
	Tooltip$2.prototype.showTooltip = function(point$1) {
		this.point = point$1;
		if (!this.isVisible()) return;
		var view = this.view;
		var items = this.getTooltipItems(point$1);
		if (!items.length) {
			this.hideTooltip();
			return;
		}
		var title = this.getTitle(items);
		var dataPoint = {
			x: items[0].x,
			y: items[0].y
		};
		view.emit("tooltip:show", event_default.fromData(view, "tooltip:show", __assign({
			items,
			title
		}, point$1)));
		var cfg = this.getTooltipCfg();
		var follow = cfg.follow, showMarkers = cfg.showMarkers, showCrosshairs = cfg.showCrosshairs, showContent = cfg.showContent, marker = cfg.marker;
		var lastItems = this.items;
		var lastTitle = this.title;
		if (!is_equal_default(lastTitle, title) || !is_equal_default(lastItems, items)) {
			view.emit("tooltip:change", event_default.fromData(view, "tooltip:change", __assign({
				items,
				title
			}, point$1)));
			if (is_function_default(showContent) ? showContent(items) : showContent) {
				if (!this.tooltip) this.renderTooltip();
				this.tooltip.update(mix({}, cfg, {
					items: this.getItemsAfterProcess(items),
					title
				}, follow ? point$1 : {}));
				this.tooltip.show();
			}
			if (showMarkers) this.renderTooltipMarkers(items, marker);
		} else {
			if (this.tooltip && follow) {
				this.tooltip.update(point$1);
				this.tooltip.show();
			}
			if (this.tooltipMarkersGroup) this.tooltipMarkersGroup.show();
		}
		this.items = items;
		this.title = title;
		if (showCrosshairs) {
			var isCrosshairsFollowCursor = get_default(cfg, ["crosshairs", "follow"], false);
			this.renderCrosshairs(isCrosshairsFollowCursor ? point$1 : dataPoint, cfg);
		}
	};
	Tooltip$2.prototype.hideTooltip = function() {
		if (!this.getTooltipCfg().follow) {
			this.point = null;
			return;
		}
		var tooltipMarkersGroup = this.tooltipMarkersGroup;
		if (tooltipMarkersGroup) tooltipMarkersGroup.hide();
		var xCrosshair = this.xCrosshair;
		var yCrosshair = this.yCrosshair;
		if (xCrosshair) xCrosshair.hide();
		if (yCrosshair) yCrosshair.hide();
		var tooltip$10 = this.tooltip;
		if (tooltip$10) tooltip$10.hide();
		this.view.emit("tooltip:hide", event_default.fromData(this.view, "tooltip:hide", {}));
		this.point = null;
	};
	/**
	* lockTooltip
	*/
	Tooltip$2.prototype.lockTooltip = function() {
		this.isLocked = true;
		if (this.tooltip) this.tooltip.setCapture(true);
	};
	/**
	* unlockTooltip
	*/
	Tooltip$2.prototype.unlockTooltip = function() {
		this.isLocked = false;
		var cfg = this.getTooltipCfg();
		if (this.tooltip) this.tooltip.setCapture(cfg.capture);
	};
	/**
	* isTooltipLocked
	*/
	Tooltip$2.prototype.isTooltipLocked = function() {
		return this.isLocked;
	};
	Tooltip$2.prototype.clear = function() {
		var _a$5 = this, tooltip$10 = _a$5.tooltip, xCrosshair = _a$5.xCrosshair, yCrosshair = _a$5.yCrosshair, tooltipMarkersGroup = _a$5.tooltipMarkersGroup;
		if (tooltip$10) {
			tooltip$10.hide();
			tooltip$10.clear();
		}
		if (xCrosshair) xCrosshair.clear();
		if (yCrosshair) yCrosshair.clear();
		if (tooltipMarkersGroup) tooltipMarkersGroup.clear();
		if (tooltip$10 === null || tooltip$10 === void 0 ? void 0 : tooltip$10.get("customContent")) {
			this.tooltip.destroy();
			this.tooltip = null;
		}
		this.title = null;
		this.items = null;
	};
	Tooltip$2.prototype.destroy = function() {
		if (this.tooltip) this.tooltip.destroy();
		if (this.xCrosshair) this.xCrosshair.destroy();
		if (this.yCrosshair) this.yCrosshair.destroy();
		if (this.guideGroup) this.guideGroup.remove(true);
		this.reset();
	};
	Tooltip$2.prototype.reset = function() {
		this.items = null;
		this.title = null;
		this.tooltipMarkersGroup = null;
		this.tooltipCrosshairsGroup = null;
		this.xCrosshair = null;
		this.yCrosshair = null;
		this.tooltip = null;
		this.guideGroup = null;
		this.isLocked = false;
		this.point = null;
	};
	Tooltip$2.prototype.changeVisible = function(visible) {
		if (this.visible === visible) return;
		var _a$5 = this, tooltip$10 = _a$5.tooltip, tooltipMarkersGroup = _a$5.tooltipMarkersGroup, xCrosshair = _a$5.xCrosshair, yCrosshair = _a$5.yCrosshair;
		if (visible) {
			if (tooltip$10) tooltip$10.show();
			if (tooltipMarkersGroup) tooltipMarkersGroup.show();
			if (xCrosshair) xCrosshair.show();
			if (yCrosshair) yCrosshair.show();
		} else {
			if (tooltip$10) tooltip$10.hide();
			if (tooltipMarkersGroup) tooltipMarkersGroup.hide();
			if (xCrosshair) xCrosshair.hide();
			if (yCrosshair) yCrosshair.hide();
		}
		this.visible = visible;
	};
	Tooltip$2.prototype.getTooltipItems = function(point$1) {
		var e_1, _a$5, e_2, _b, e_3, _c;
		var items = this.findItemsFromView(this.view, point$1);
		if (items.length) {
			items = flatten_default(items);
			try {
				for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
					var itemArr = items_1_1.value;
					try {
						for (var itemArr_1 = (e_2 = void 0, __values(itemArr)), itemArr_1_1 = itemArr_1.next(); !itemArr_1_1.done; itemArr_1_1 = itemArr_1.next()) {
							var item = itemArr_1_1.value;
							var _d = item.mappingData, x = _d.x, y = _d.y;
							item.x = is_array_default(x) ? x[x.length - 1] : x;
							item.y = is_array_default(y) ? y[y.length - 1] : y;
						}
					} catch (e_2_1) {
						e_2 = { error: e_2_1 };
					} finally {
						try {
							if (itemArr_1_1 && !itemArr_1_1.done && (_b = itemArr_1.return)) _b.call(itemArr_1);
						} finally {
							if (e_2) throw e_2.error;
						}
					}
				}
			} catch (e_1_1) {
				e_1 = { error: e_1_1 };
			} finally {
				try {
					if (items_1_1 && !items_1_1.done && (_a$5 = items_1.return)) _a$5.call(items_1);
				} finally {
					if (e_1) throw e_1.error;
				}
			}
			if (this.getTooltipCfg().shared === false && items.length > 1) {
				var snapItem = items[0];
				var min$2 = Math.abs(point$1.y - snapItem[0].y);
				try {
					for (var items_2 = __values(items), items_2_1 = items_2.next(); !items_2_1.done; items_2_1 = items_2.next()) {
						var aItem = items_2_1.value;
						var yDistance = Math.abs(point$1.y - aItem[0].y);
						if (yDistance <= min$2) {
							snapItem = aItem;
							min$2 = yDistance;
						}
					}
				} catch (e_3_1) {
					e_3 = { error: e_3_1 };
				} finally {
					try {
						if (items_2_1 && !items_2_1.done && (_c = items_2.return)) _c.call(items_2);
					} finally {
						if (e_3) throw e_3.error;
					}
				}
				items = [snapItem];
			}
			return uniq$2(flatten_default(items));
		}
		return [];
	};
	Tooltip$2.prototype.layout = function() {};
	Tooltip$2.prototype.update = function() {
		if (this.point) this.showTooltip(this.point);
		if (this.tooltip) {
			var canvas = this.view.getCanvas();
			this.tooltip.set("region", {
				start: {
					x: 0,
					y: 0
				},
				end: {
					x: canvas.get("width"),
					y: canvas.get("height")
				}
			});
		}
	};
	/**
	* 当前鼠标点是在 enter tooltip 中
	* @param point
	*/
	Tooltip$2.prototype.isCursorEntered = function(point$1) {
		if (this.tooltip) {
			var el = this.tooltip.getContainer();
			var capture = this.tooltip.get("capture");
			if (el && capture) {
				var _a$5 = el.getBoundingClientRect(), x = _a$5.x, y = _a$5.y, width = _a$5.width, height = _a$5.height;
				return new BBox(x, y, width, height).isPointIn(point$1);
			}
		}
		return false;
	};
	Tooltip$2.prototype.getTooltipCfg = function() {
		var view = this.view;
		var option = view.getOptions().tooltip;
		var processOption = this.processCustomContent(option);
		var theme$3 = view.getTheme();
		var defaultCfg = get_default(theme$3, ["components", "tooltip"], {});
		var enterable = get_default(processOption, "enterable", defaultCfg.enterable);
		return deep_mix_default({}, defaultCfg, processOption, { capture: enterable || this.isLocked ? true : false });
	};
	Tooltip$2.prototype.processCustomContent = function(option) {
		if (is_boolean_default(option) || !get_default(option, "customContent")) return option;
		var currentCustomContent = option.customContent;
		var customContent = function(title, items) {
			var content = currentCustomContent(title, items) || "";
			return is_string_default(content) ? "<div class=\"g2-tooltip\">" + content + "</div>" : content;
		};
		return __assign(__assign({}, option), { customContent });
	};
	Tooltip$2.prototype.getTitle = function(items) {
		var title = items[0].title || items[0].name;
		this.title = title;
		return title;
	};
	Tooltip$2.prototype.renderTooltip = function() {
		var canvas = this.view.getCanvas();
		var region = {
			start: {
				x: 0,
				y: 0
			},
			end: {
				x: canvas.get("width"),
				y: canvas.get("height")
			}
		};
		var cfg = this.getTooltipCfg();
		var tooltip$10 = new HtmlTooltip(__assign(__assign({
			parent: canvas.get("el").parentNode,
			region
		}, cfg), {
			visible: false,
			crosshairs: null
		}));
		tooltip$10.init();
		this.tooltip = tooltip$10;
	};
	Tooltip$2.prototype.renderTooltipMarkers = function(items, marker) {
		var e_4, _a$5;
		var tooltipMarkersGroup = this.getTooltipMarkersGroup();
		var rootView = this.view.getRootView();
		var limitInPlot$4 = rootView.limitInPlot;
		try {
			for (var items_3 = __values(items), items_3_1 = items_3.next(); !items_3_1.done; items_3_1 = items_3.next()) {
				var item = items_3_1.value;
				var x = item.x, y = item.y;
				if (limitInPlot$4 || (tooltipMarkersGroup === null || tooltipMarkersGroup === void 0 ? void 0 : tooltipMarkersGroup.getClip())) {
					var _b = getCoordinateClipCfg(rootView.getCoordinate()), type = _b.type, attrs_1 = _b.attrs;
					tooltipMarkersGroup === null || tooltipMarkersGroup === void 0 || tooltipMarkersGroup.setClip({
						type,
						attrs: attrs_1
					});
				} else tooltipMarkersGroup === null || tooltipMarkersGroup === void 0 || tooltipMarkersGroup.setClip(void 0);
				var theme$3 = this.view.getTheme();
				var markerDefaultCfg = get_default(theme$3, [
					"components",
					"tooltip",
					"marker"
				], {});
				var attrs = __assign(__assign({
					fill: item.color,
					symbol: "circle",
					shadowColor: item.color
				}, is_function_default(marker) ? __assign(__assign({}, markerDefaultCfg), marker(item)) : marker), {
					x,
					y
				});
				tooltipMarkersGroup.addShape("marker", { attrs });
			}
		} catch (e_4_1) {
			e_4 = { error: e_4_1 };
		} finally {
			try {
				if (items_3_1 && !items_3_1.done && (_a$5 = items_3.return)) _a$5.call(items_3);
			} finally {
				if (e_4) throw e_4.error;
			}
		}
	};
	Tooltip$2.prototype.renderCrosshairs = function(point$1, cfg) {
		var crosshairsType = get_default(cfg, ["crosshairs", "type"], "x");
		if (crosshairsType === "x") {
			if (this.yCrosshair) this.yCrosshair.hide();
			this.renderXCrosshairs(point$1, cfg);
		} else if (crosshairsType === "y") {
			if (this.xCrosshair) this.xCrosshair.hide();
			this.renderYCrosshairs(point$1, cfg);
		} else if (crosshairsType === "xy") {
			this.renderXCrosshairs(point$1, cfg);
			this.renderYCrosshairs(point$1, cfg);
		}
	};
	Tooltip$2.prototype.renderXCrosshairs = function(point$1, tooltipCfg) {
		var coordinate$10 = this.getViewWithGeometry(this.view).getCoordinate();
		var start;
		var end;
		if (coordinate$10.isRect) if (coordinate$10.isTransposed) {
			start = {
				x: coordinate$10.start.x,
				y: point$1.y
			};
			end = {
				x: coordinate$10.end.x,
				y: point$1.y
			};
		} else {
			start = {
				x: point$1.x,
				y: coordinate$10.end.y
			};
			end = {
				x: point$1.x,
				y: coordinate$10.start.y
			};
		}
		else {
			var angle$1 = getAngleByPoint(coordinate$10, point$1);
			var center$1 = coordinate$10.getCenter();
			var radius = coordinate$10.getRadius();
			end = polarToCartesian(center$1.x, center$1.y, radius, angle$1);
			start = center$1;
		}
		var cfg = deep_mix_default({
			start,
			end,
			container: this.getTooltipCrosshairsGroup()
		}, get_default(tooltipCfg, "crosshairs", {}), this.getCrosshairsText("x", point$1, tooltipCfg));
		delete cfg.type;
		var xCrosshair = this.xCrosshair;
		if (xCrosshair) xCrosshair.update(cfg);
		else {
			xCrosshair = new line_default$5(cfg);
			xCrosshair.init();
		}
		xCrosshair.render();
		xCrosshair.show();
		this.xCrosshair = xCrosshair;
	};
	Tooltip$2.prototype.renderYCrosshairs = function(point$1, tooltipCfg) {
		var coordinate$10 = this.getViewWithGeometry(this.view).getCoordinate();
		var cfg;
		var type;
		if (coordinate$10.isRect) {
			var start = void 0;
			var end = void 0;
			if (coordinate$10.isTransposed) {
				start = {
					x: point$1.x,
					y: coordinate$10.end.y
				};
				end = {
					x: point$1.x,
					y: coordinate$10.start.y
				};
			} else {
				start = {
					x: coordinate$10.start.x,
					y: point$1.y
				};
				end = {
					x: coordinate$10.end.x,
					y: point$1.y
				};
			}
			cfg = {
				start,
				end
			};
			type = "Line";
		} else {
			cfg = {
				center: coordinate$10.getCenter(),
				radius: getDistanceToCenter(coordinate$10, point$1),
				startAngle: coordinate$10.startAngle,
				endAngle: coordinate$10.endAngle
			};
			type = "Circle";
		}
		cfg = deep_mix_default({ container: this.getTooltipCrosshairsGroup() }, cfg, get_default(tooltipCfg, "crosshairs", {}), this.getCrosshairsText("y", point$1, tooltipCfg));
		delete cfg.type;
		var yCrosshair = this.yCrosshair;
		if (yCrosshair) if (coordinate$10.isRect && yCrosshair.get("type") === "circle" || !coordinate$10.isRect && yCrosshair.get("type") === "line") {
			yCrosshair = new crosshair_exports[type](cfg);
			yCrosshair.init();
		} else yCrosshair.update(cfg);
		else {
			yCrosshair = new crosshair_exports[type](cfg);
			yCrosshair.init();
		}
		yCrosshair.render();
		yCrosshair.show();
		this.yCrosshair = yCrosshair;
	};
	Tooltip$2.prototype.getCrosshairsText = function(type, point$1, tooltipCfg) {
		var textCfg = get_default(tooltipCfg, ["crosshairs", "text"]);
		var follow = get_default(tooltipCfg, ["crosshairs", "follow"]);
		var items = this.items;
		if (textCfg) {
			var view = this.getViewWithGeometry(this.view);
			var firstItem = items[0];
			var xScale = view.getXScale();
			var yScale = view.getYScales()[0];
			var xValue = void 0;
			var yValue = void 0;
			if (follow) {
				var invertPoint = this.view.getCoordinate().invert(point$1);
				xValue = xScale.invert(invertPoint.x);
				yValue = yScale.invert(invertPoint.y);
			} else {
				xValue = firstItem.data[xScale.field];
				yValue = firstItem.data[yScale.field];
			}
			var content = type === "x" ? xValue : yValue;
			if (is_function_default(textCfg)) textCfg = textCfg(type, content, items, point$1);
			else textCfg.content = content;
			return { text: textCfg };
		}
	};
	Tooltip$2.prototype.getGuideGroup = function() {
		if (!this.guideGroup) this.guideGroup = this.view.foregroundGroup.addGroup({
			name: "tooltipGuide",
			capture: false
		});
		return this.guideGroup;
	};
	Tooltip$2.prototype.getTooltipMarkersGroup = function() {
		var tooltipMarkersGroup = this.tooltipMarkersGroup;
		if (tooltipMarkersGroup && !tooltipMarkersGroup.destroyed) {
			tooltipMarkersGroup.clear();
			tooltipMarkersGroup.show();
		} else {
			tooltipMarkersGroup = this.getGuideGroup().addGroup({ name: "tooltipMarkersGroup" });
			tooltipMarkersGroup.toFront();
			this.tooltipMarkersGroup = tooltipMarkersGroup;
		}
		return tooltipMarkersGroup;
	};
	Tooltip$2.prototype.getTooltipCrosshairsGroup = function() {
		var tooltipCrosshairsGroup = this.tooltipCrosshairsGroup;
		if (!tooltipCrosshairsGroup) {
			tooltipCrosshairsGroup = this.getGuideGroup().addGroup({
				name: "tooltipCrosshairsGroup",
				capture: false
			});
			tooltipCrosshairsGroup.toBack();
			this.tooltipCrosshairsGroup = tooltipCrosshairsGroup;
		}
		return tooltipCrosshairsGroup;
	};
	Tooltip$2.prototype.findItemsFromView = function(view, point$1) {
		var e_5, _a$5;
		if (view.getOptions().tooltip === false) return [];
		var tooltipCfg = this.getTooltipCfg();
		var result = findItemsFromView(view, point$1, tooltipCfg);
		try {
			for (var _b = __values(view.views), _c = _b.next(); !_c.done; _c = _b.next()) {
				var childView = _c.value;
				result = result.concat(this.findItemsFromView(childView, point$1));
			}
		} catch (e_5_1) {
			e_5 = { error: e_5_1 };
		} finally {
			try {
				if (_c && !_c.done && (_a$5 = _b.return)) _a$5.call(_b);
			} finally {
				if (e_5) throw e_5.error;
			}
		}
		return result;
	};
	Tooltip$2.prototype.getViewWithGeometry = function(view) {
		var _this = this;
		if (view.geometries.length) return view;
		return find_default(view.views, function(childView) {
			return _this.getViewWithGeometry(childView);
		});
	};
	/**
	* 根据用户配置的 items 配置，来进行用户自定义的处理，并返回最终的 items
	* 默认不做任何处理
	*/
	Tooltip$2.prototype.getItemsAfterProcess = function(originalItems) {
		var customItems = this.getTooltipCfg().customItems;
		return (customItems ? customItems : function(v) {
			return v;
		})(originalItems);
	};
	return Tooltip$2;
}(Controller);
var tooltip_default = Tooltip;

//#endregion
//#region node_modules/@antv/g2/esm/animate/animation/index.js
var ANIMATIONS_MAP = {};
/**
* 根据名称获取对应的动画执行函数
* @param type 动画函数名称
*/
function getAnimation(type) {
	return ANIMATIONS_MAP[type.toLowerCase()];
}
/**
* 注册动画执行函数
* @param type 动画执行函数名称
* @param animation 动画执行函数
*/
function registerAnimation(type, animation$6) {
	ANIMATIONS_MAP[type.toLowerCase()] = animation$6;
}

//#endregion
//#region node_modules/@antv/g2/esm/animate/index.js
var DEFAULT_ANIMATE_CFG = {
	appear: {
		duration: 450,
		easing: "easeQuadOut"
	},
	update: {
		duration: 400,
		easing: "easeQuadInOut"
	},
	enter: {
		duration: 400,
		easing: "easeQuadInOut"
	},
	leave: {
		duration: 350,
		easing: "easeQuadIn"
	}
};
var GEOMETRY_ANIMATE_CFG = {
	interval: function(coordinate$10) {
		return {
			enter: { animation: coordinate$10.isRect ? coordinate$10.isTransposed ? "scale-in-x" : "scale-in-y" : "fade-in" },
			update: { animation: coordinate$10.isPolar && coordinate$10.isTransposed ? "sector-path-update" : null },
			leave: { animation: "fade-out" }
		};
	},
	line: {
		enter: { animation: "fade-in" },
		leave: { animation: "fade-out" }
	},
	path: {
		enter: { animation: "fade-in" },
		leave: { animation: "fade-out" }
	},
	point: {
		appear: { animation: "zoom-in" },
		enter: { animation: "zoom-in" },
		leave: { animation: "zoom-out" }
	},
	area: {
		enter: { animation: "fade-in" },
		leave: { animation: "fade-out" }
	},
	polygon: {
		enter: { animation: "fade-in" },
		leave: { animation: "fade-out" }
	},
	schema: {
		enter: { animation: "fade-in" },
		leave: { animation: "fade-out" }
	},
	edge: {
		enter: { animation: "fade-in" },
		leave: { animation: "fade-out" }
	},
	label: {
		appear: {
			animation: "fade-in",
			delay: 450
		},
		enter: { animation: "fade-in" },
		update: { animation: "position-update" },
		leave: { animation: "fade-out" }
	}
};
var GEOMETRY_GROUP_APPEAR_ANIMATION = {
	line: function() {
		return { animation: "wave-in" };
	},
	area: function() {
		return { animation: "wave-in" };
	},
	path: function() {
		return { animation: "fade-in" };
	},
	interval: function(coordinate$10) {
		var animation$6;
		if (coordinate$10.isRect) animation$6 = coordinate$10.isTransposed ? "grow-in-x" : "grow-in-y";
		else {
			animation$6 = "grow-in-xy";
			if (coordinate$10.isPolar && coordinate$10.isTransposed) animation$6 = "wave-in";
		}
		return { animation: animation$6 };
	},
	schema: function(coordinate$10) {
		var animation$6;
		if (coordinate$10.isRect) animation$6 = coordinate$10.isTransposed ? "grow-in-x" : "grow-in-y";
		else animation$6 = "grow-in-xy";
		return { animation: animation$6 };
	},
	polygon: function() {
		return {
			animation: "fade-in",
			duration: 500
		};
	},
	edge: function() {
		return { animation: "fade-in" };
	}
};
function parseAnimateConfig(animateCfg, data$2) {
	return {
		delay: is_function_default(animateCfg.delay) ? animateCfg.delay(data$2) : animateCfg.delay,
		easing: is_function_default(animateCfg.easing) ? animateCfg.easing(data$2) : animateCfg.easing,
		duration: is_function_default(animateCfg.duration) ? animateCfg.duration(data$2) : animateCfg.duration,
		callback: animateCfg.callback,
		repeat: animateCfg.repeat
	};
}
/**
* @ignore
* 获取 elementName 对应的动画配置，当声明了 `animateType`，则返回 `animateType` 对应的动画配置
* @param elementName 元素名称
* @param coordinate 做表弟类型
* @param animateType 可选，动画类型
*/
function getDefaultAnimateCfg(elementName, coordinate$10, animateType) {
	var animateCfg = GEOMETRY_ANIMATE_CFG[elementName];
	if (animateCfg) {
		if (is_function_default(animateCfg)) animateCfg = animateCfg(coordinate$10);
		animateCfg = deep_mix_default({}, DEFAULT_ANIMATE_CFG, animateCfg);
		if (animateType) return animateCfg[animateType];
	}
	return animateCfg;
}
/**
* @ignore
* 工具函数
* 根据用户传入的配置为 shape 执行动画
* @param shape 执行动画的图形元素
* @param animateCfg 动画配置
* @param cfg 额外的信息
*/
function doAnimate(shape, animateCfg, cfg) {
	var data$2 = get_default(shape.get("origin"), "data", FIELD_ORIGIN);
	var animation$6 = animateCfg.animation;
	var parsedAnimateCfg = parseAnimateConfig(animateCfg, data$2);
	if (animation$6) {
		var animateFunction = getAnimation(animation$6);
		if (animateFunction) animateFunction(shape, parsedAnimateCfg, cfg);
	} else shape.animate(cfg.toAttrs, parsedAnimateCfg);
}
/**
* @ignore
* 执行 Geometry 群组入场动画
* @param container 执行群组动画的图形元素
* @param animateCfg 动画配置
* @param geometryType geometry 类型
* @param coordinate 坐标系对象
* @param minYPoint y 轴最小值对应的画布坐标点
*/
function doGroupAppearAnimate(container, animateCfg, geometryType, coordinate$10, minYPoint) {
	if (GEOMETRY_GROUP_APPEAR_ANIMATION[geometryType]) {
		var defaultCfg = GEOMETRY_GROUP_APPEAR_ANIMATION[geometryType](coordinate$10);
		var animation$6 = getAnimation(get_default(defaultCfg, "animation", ""));
		if (animation$6) {
			var cfg = __assign(__assign(__assign({}, DEFAULT_ANIMATE_CFG.appear), defaultCfg), animateCfg);
			container.stopAnimate();
			animation$6(container, cfg, {
				coordinate: coordinate$10,
				minYPoint,
				toAttrs: null
			});
		}
	}
}

//#endregion
//#region node_modules/@antv/g2/esm/geometry/shape/constant.js
/**
* Name of Background Shape
*/
var BACKGROUND_SHAPE = "element-background";

//#endregion
//#region node_modules/@antv/g2/esm/geometry/element/index.js
/**
* Element 图形元素。
* 定义：在 G2 中，我们会将数据通过图形语法映射成不同的图形，比如点图，数据集中的每条数据会对应一个点，柱状图每条数据对应一个柱子，线图则是一组数据对应一条折线，Element 即一条/一组数据对应的图形元素，它代表一条数据或者一个数据集，在图形层面，它可以是单个 Shape 也可以是多个 Shape，我们称之为图形元素。
*/
var Element$1 = function(_super) {
	__extends(Element$3, _super);
	function Element$3(cfg) {
		var _this = _super.call(this, cfg) || this;
		/** 保存 shape 对应的 label */
		_this.labelShape = [];
		_this.states = [];
		var shapeFactory = cfg.shapeFactory, container = cfg.container, offscreenGroup = cfg.offscreenGroup, elementIndex = cfg.elementIndex, _a$5 = cfg.visible, visible = _a$5 === void 0 ? true : _a$5;
		_this.shapeFactory = shapeFactory;
		_this.container = container;
		_this.offscreenGroup = offscreenGroup;
		_this.visible = visible;
		_this.elementIndex = elementIndex;
		return _this;
	}
	/**
	* 绘制图形。
	* @param model 绘制数据。
	* @param isUpdate 可选，是否是更新发生后的绘制。
	*/
	Element$3.prototype.draw = function(model, isUpdate) {
		if (isUpdate === void 0) isUpdate = false;
		this.model = model;
		this.data = model.data;
		this.shapeType = this.getShapeType(model);
		this.drawShape(model, isUpdate);
		if (this.visible === false) this.changeVisible(false);
	};
	/**
	* 更新图形。
	* @param model 更新的绘制数据。
	*/
	Element$3.prototype.update = function(model) {
		var _a$5 = this, shapeFactory = _a$5.shapeFactory, shape = _a$5.shape;
		if (!shape) return;
		this.model = model;
		this.data = model.data;
		this.shapeType = this.getShapeType(model);
		this.setShapeInfo(shape, model);
		var offscreenGroup = this.getOffscreenGroup();
		var newShape = shapeFactory.drawShape(this.shapeType, model, offscreenGroup);
		newShape.cfg.data = this.data;
		newShape.cfg.origin = model;
		newShape.cfg.element = this;
		this.syncShapeStyle(shape, newShape, this.getStates(), this.getAnimateCfg("update"));
	};
	/**
	* 销毁 element 实例。
	*/
	Element$3.prototype.destroy = function() {
		var _a$5 = this, shapeFactory = _a$5.shapeFactory, shape = _a$5.shape;
		if (shape) {
			var animateCfg = this.getAnimateCfg("leave");
			if (animateCfg) doAnimate(shape, animateCfg, {
				coordinate: shapeFactory.coordinate,
				toAttrs: __assign({}, shape.attr())
			});
			else shape.remove(true);
		}
		this.states = [];
		this.shapeFactory = void 0;
		this.container = void 0;
		this.shape = void 0;
		this.animate = void 0;
		this.geometry = void 0;
		this.labelShape = [];
		this.model = void 0;
		this.data = void 0;
		this.offscreenGroup = void 0;
		this.statesStyle = void 0;
		_super.prototype.destroy.call(this);
	};
	/**
	* 显示或者隐藏 element。
	* @param visible 是否可见。
	*/
	Element$3.prototype.changeVisible = function(visible) {
		_super.prototype.changeVisible.call(this, visible);
		if (visible) {
			if (this.shape) this.shape.show();
			if (this.labelShape) this.labelShape.forEach(function(label$16) {
				label$16.show();
			});
		} else {
			if (this.shape) this.shape.hide();
			if (this.labelShape) this.labelShape.forEach(function(label$16) {
				label$16.hide();
			});
		}
	};
	/**
	* 设置 Element 的状态。
	*
	* 目前 Element 开放三种状态：
	* 1. active
	* 2. selected
	* 3. inactive
	*
	* 这三种状态相互独立，可以进行叠加。
	*
	* 这三种状态的样式可在 [[Theme]] 主题中或者通过 `geometry.state()` 接口进行配置。
	*
	* ```ts
	* // 激活 active 状态
	* setState('active', true);
	* ```
	*
	* @param stateName 状态名
	* @param stateStatus 是否开启状态
	*/
	Element$3.prototype.setState = function(stateName, stateStatus) {
		var _a$5 = this, states = _a$5.states, shapeFactory = _a$5.shapeFactory, model = _a$5.model, shape = _a$5.shape, shapeType = _a$5.shapeType;
		var index = states.indexOf(stateName);
		if (stateStatus) {
			if (index > -1) return;
			states.push(stateName);
			if (stateName === "active" || stateName === "selected") shape === null || shape === void 0 || shape.toFront();
		} else {
			if (index === -1) return;
			states.splice(index, 1);
			if (stateName === "active" || stateName === "selected") {
				var _b = this.geometry, sortZIndex = _b.sortZIndex;
				var idx = _b.zIndexReversed ? this.geometry.elements.length - this.elementIndex : this.elementIndex;
				sortZIndex ? shape.setZIndex(idx) : shape.set("zIndex", idx);
			}
		}
		var offscreenShape = shapeFactory.drawShape(shapeType, model, this.getOffscreenGroup());
		if (states.length) this.syncShapeStyle(shape, offscreenShape, states, null);
		else this.syncShapeStyle(shape, offscreenShape, ["reset"], null);
		offscreenShape.remove(true);
		var eventObject = {
			state: stateName,
			stateStatus,
			element: this,
			target: this.container
		};
		this.container.emit("statechange", eventObject);
		propagationDelegate(this.shape, "statechange", eventObject);
	};
	/**
	* 清空状量态，恢复至初始状态。
	*/
	Element$3.prototype.clearStates = function() {
		var _this = this;
		var states = this.states;
		each_default(states, function(state$1) {
			_this.setState(state$1, false);
		});
		this.states = [];
	};
	/**
	* 查询当前 Element 上是否已设置 `stateName` 对应的状态。
	* @param stateName 状态名称。
	* @returns true 表示存在，false 表示不存在。
	*/
	Element$3.prototype.hasState = function(stateName) {
		return this.states.includes(stateName);
	};
	/**
	* 获取当前 Element 上所有的状态。
	* @returns 当前 Element 上所有的状态数组。
	*/
	Element$3.prototype.getStates = function() {
		return this.states;
	};
	/**
	* 获取 Element 对应的原始数据。
	* @returns 原始数据。
	*/
	Element$3.prototype.getData = function() {
		return this.data;
	};
	/**
	* 获取 Element 对应的图形绘制数据。
	* @returns 图形绘制数据。
	*/
	Element$3.prototype.getModel = function() {
		return this.model;
	};
	/**
	* 返回 Element 元素整体的 bbox，包含文本及文本连线（有的话）。
	* @returns 整体包围盒。
	*/
	Element$3.prototype.getBBox = function() {
		var _a$5 = this, shape = _a$5.shape, labelShape = _a$5.labelShape;
		var bbox = {
			x: 0,
			y: 0,
			minX: 0,
			minY: 0,
			maxX: 0,
			maxY: 0,
			width: 0,
			height: 0
		};
		if (shape) bbox = shape.getCanvasBBox();
		if (labelShape) labelShape.forEach(function(label$16) {
			var labelBBox = label$16.getCanvasBBox();
			bbox.x = Math.min(labelBBox.x, bbox.x);
			bbox.y = Math.min(labelBBox.y, bbox.y);
			bbox.minX = Math.min(labelBBox.minX, bbox.minX);
			bbox.minY = Math.min(labelBBox.minY, bbox.minY);
			bbox.maxX = Math.max(labelBBox.maxX, bbox.maxX);
			bbox.maxY = Math.max(labelBBox.maxY, bbox.maxY);
		});
		bbox.width = bbox.maxX - bbox.minX;
		bbox.height = bbox.maxY - bbox.minY;
		return bbox;
	};
	Element$3.prototype.getStatesStyle = function() {
		if (!this.statesStyle) {
			var _a$5 = this, shapeType = _a$5.shapeType, geometry$34 = _a$5.geometry, shapeFactory = _a$5.shapeFactory;
			var stateOption = geometry$34.stateOption;
			var defaultShapeType = shapeFactory.defaultShapeType;
			var stateTheme = shapeFactory.theme[shapeType] || shapeFactory.theme[defaultShapeType];
			this.statesStyle = deep_mix_default({}, stateTheme, stateOption);
		}
		return this.statesStyle;
	};
	Element$3.prototype.getStateStyle = function(stateName, shapeKey) {
		var statesStyle = this.getStatesStyle();
		var stateCfg = get_default(statesStyle, [stateName, "style"], {});
		var shapeStyle = stateCfg[shapeKey] || stateCfg;
		if (is_function_default(shapeStyle)) return shapeStyle(this);
		return shapeStyle;
	};
	Element$3.prototype.getAnimateCfg = function(animateType) {
		var _this = this;
		var animate = this.animate;
		if (animate) {
			var cfg_1 = animate[animateType];
			if (cfg_1) return __assign(__assign({}, cfg_1), { callback: function() {
				var _a$5;
				is_function_default(cfg_1.callback) && cfg_1.callback();
				(_a$5 = _this.geometry) === null || _a$5 === void 0 || _a$5.emit(GEOMETRY_LIFE_CIRCLE.AFTER_DRAW_ANIMATE);
			} });
			return cfg_1;
		}
		return null;
	};
	Element$3.prototype.drawShape = function(model, isUpdate) {
		var _a$5;
		if (isUpdate === void 0) isUpdate = false;
		var _b = this, shapeFactory = _b.shapeFactory, container = _b.container, shapeType = _b.shapeType;
		this.shape = shapeFactory.drawShape(shapeType, model, container);
		if (this.shape) {
			this.setShapeInfo(this.shape, model);
			var name_1 = this.shape.cfg.name;
			if (!name_1) this.shape.cfg.name = ["element", this.shapeFactory.geometryType];
			else if (is_string_default(name_1)) this.shape.cfg.name = ["element", name_1];
			var animateType = isUpdate ? "enter" : "appear";
			var animateCfg = this.getAnimateCfg(animateType);
			if (animateCfg) {
				(_a$5 = this.geometry) === null || _a$5 === void 0 || _a$5.emit(GEOMETRY_LIFE_CIRCLE.BEFORE_DRAW_ANIMATE);
				doAnimate(this.shape, animateCfg, {
					coordinate: shapeFactory.coordinate,
					toAttrs: __assign({}, this.shape.attr())
				});
			}
		}
	};
	Element$3.prototype.getOffscreenGroup = function() {
		if (!this.offscreenGroup) this.offscreenGroup = new (this.container.getGroupBase())({});
		return this.offscreenGroup;
	};
	Element$3.prototype.setShapeInfo = function(shape, data$2) {
		var _this = this;
		shape.cfg.origin = data$2;
		shape.cfg.element = this;
		if (shape.isGroup()) shape.get("children").forEach(function(child) {
			_this.setShapeInfo(child, data$2);
		});
	};
	Element$3.prototype.syncShapeStyle = function(sourceShape, targetShape, states, animateCfg, index) {
		var _this = this;
		var _a$5;
		if (states === void 0) states = [];
		if (index === void 0) index = 0;
		if (!sourceShape || !targetShape) return;
		var clip = sourceShape.get("clipShape");
		var newClip = targetShape.get("clipShape");
		this.syncShapeStyle(clip, newClip, states, animateCfg);
		if (sourceShape.isGroup()) {
			var children = sourceShape.get("children");
			var newChildren = targetShape.get("children");
			for (var i = 0; i < children.length; i++) this.syncShapeStyle(children[i], newChildren[i], states, animateCfg, index + i);
		} else {
			if (!is_empty_default(states) && !is_equal_default(states, ["reset"])) {
				var name_2 = sourceShape.get("name");
				if (is_array_default(name_2)) name_2 = name_2[1];
				each_default(states, function(state$1) {
					if (targetShape.get("name") !== BACKGROUND_SHAPE) {
						var style = _this.getStateStyle(state$1, name_2 || index);
						targetShape.attr(style);
					}
				});
			}
			var newAttrs = getReplaceAttrs(sourceShape, targetShape);
			if (this.animate) if (animateCfg) {
				(_a$5 = this.geometry) === null || _a$5 === void 0 || _a$5.emit(GEOMETRY_LIFE_CIRCLE.BEFORE_DRAW_ANIMATE);
				doAnimate(sourceShape, animateCfg, {
					coordinate: this.shapeFactory.coordinate,
					toAttrs: newAttrs,
					shapeModel: this.model
				});
			} else if (!is_empty_default(states)) {
				sourceShape.stopAnimate();
				sourceShape.animate(newAttrs, { duration: 300 });
			} else sourceShape.attr(newAttrs);
			else sourceShape.attr(newAttrs);
		}
	};
	Element$3.prototype.getShapeType = function(model) {
		var shape = get_default(model, "shape");
		return is_array_default(shape) ? shape[0] : shape;
	};
	return Element$3;
}(base_default$9);
var element_default = Element$1;

//#endregion
//#region node_modules/@antv/g2/esm/geometry/label/index.js
var GEOMETRY_LABELS_MAP = {};
var GEOMETRY_LABELS_LAYOUT_MAP = {};
/**
* 获取 `type` 对应的 [[GeometryLabel]] 类
* @param type
* @returns
*/
function getGeometryLabel(type) {
	return GEOMETRY_LABELS_MAP[type.toLowerCase()];
}
/**
* 注册定义的 GeometryLabel 类
* @param type GeometryLabel 类型名称
* @param ctor GeometryLabel 类
*/
function registerGeometryLabel(type, ctor) {
	GEOMETRY_LABELS_MAP[type.toLowerCase()] = ctor;
}
/**
* 获取 `type` 对应的 [[GeometryLabelsLayoutFn]] label 布局函数
* @param type 布局函数名称
* @returns
*/
function getGeometryLabelLayout(type) {
	return GEOMETRY_LABELS_LAYOUT_MAP[type.toLowerCase()];
}
/**
* 注册定义的 label 布局函数
* @param type label 布局函数名称
* @param layoutFn label 布局函数
*/
function registerGeometryLabelLayout(type, layoutFn) {
	GEOMETRY_LABELS_LAYOUT_MAP[type.toLowerCase()] = layoutFn;
}

//#endregion
//#region node_modules/@antv/g2/esm/geometry/shape/base.js
/** ShapeFactory 基类 */
var ShapeFactoryBase = {
	coordinate: null,
	defaultShapeType: null,
	theme: null,
	getShapePoints: function(shapeType, shapePoint) {
		var shape = this.getShape(shapeType);
		if (shape.getPoints) return shape.getPoints(shapePoint);
		return this.getDefaultPoints(shapePoint);
	},
	getShape: function(shapeType) {
		var shape = this[shapeType] || this[this.defaultShapeType];
		shape.coordinate = this.coordinate;
		return shape;
	},
	getDefaultPoints: function() {
		return [];
	},
	getDefaultStyle: function(geometryTheme) {
		return get_default(geometryTheme, [
			this.defaultShapeType,
			"default",
			"style"
		], {});
	},
	getMarker: function(shapeType, markerCfg) {
		var shape = this.getShape(shapeType);
		if (!shape.getMarker) {
			var defaultShapeType = this.defaultShapeType;
			shape = this.getShape(defaultShapeType);
		}
		var theme$3 = this.theme;
		var shapeStyle = get_default(theme$3, [shapeType, "default"], {});
		var markerStyle = shape.getMarker(markerCfg);
		return deep_mix_default({}, shapeStyle, markerStyle);
	},
	drawShape: function(shapeType, cfg, container) {
		return this.getShape(shapeType).draw(cfg, container);
	}
};
/** Shape 基类 */
var ShapeBase$2 = {
	coordinate: null,
	parsePath: function(path) {
		var coordinate$10 = this.coordinate;
		var parsedPath = parsePathString$2(path);
		if (coordinate$10.isPolar) parsedPath = convertPolarPath(coordinate$10, parsedPath);
		else parsedPath = convertNormalPath(coordinate$10, parsedPath);
		return parsedPath;
	},
	parsePoint: function(point$1) {
		return this.coordinate.convert(point$1);
	},
	parsePoints: function(points) {
		var coordinate$10 = this.coordinate;
		return points.map(function(point$1) {
			return coordinate$10.convert(point$1);
		});
	},
	draw: function(cfg, container) {}
};
var ShapeFactoryMap = {};
/**
* 注册 ShapeFactory。
* @param factoryName  ShapeFactory 名称，对应 Geometry 几何标记名称。
* @param cfg 注册 ShapeFactory 需要覆写定义的属性。
* @returns 返回 ShapeFactory 对象。
*/
function registerShapeFactory(factoryName, cfg) {
	var className = upper_first_default(factoryName);
	var geomObj = __assign(__assign(__assign({}, ShapeFactoryBase), cfg), { geometryType: factoryName });
	ShapeFactoryMap[className] = geomObj;
	return geomObj;
}
/**
* 注册 Shape。
* @param factoryName 对应的 ShapeFactory 名称。
* @param shapeType 注册的 shape 名称。
* @param cfg 注册 Shape 需要覆写定义的属性。
* @returns shape 返回注册的 shape 对象。
*/
function registerShape(factoryName, shapeType, cfg) {
	var className = upper_first_default(factoryName);
	var factory = ShapeFactoryMap[className];
	var shapeObj = __assign(__assign({}, ShapeBase$2), cfg);
	factory[shapeType] = shapeObj;
	return shapeObj;
}
/**
* 获取 factoryName 对应的 shapeFactory
* @param factoryName
* @returns shape factory
*/
function getShapeFactory(factoryName) {
	var className = upper_first_default(factoryName);
	return ShapeFactoryMap[className];
}

//#endregion
//#region node_modules/@antv/g2/esm/geometry/util/group-data.js
/** @ignore */
function group(data$2, fields, appendConditions) {
	var e_1, _a$5;
	if (appendConditions === void 0) appendConditions = {};
	if (!fields) return [data$2];
	var groups = groupToMap(data$2, fields);
	var array = [];
	if (fields.length === 1 && appendConditions[fields[0]]) {
		var values$1 = appendConditions[fields[0]];
		try {
			for (var values_1 = __values(values$1), values_1_1 = values_1.next(); !values_1_1.done; values_1_1 = values_1.next()) {
				var value$1 = values_1_1.value;
				var arr = groups["_".concat(value$1)];
				if (arr) array.push(arr);
			}
		} catch (e_1_1) {
			e_1 = { error: e_1_1 };
		} finally {
			try {
				if (values_1_1 && !values_1_1.done && (_a$5 = values_1.return)) _a$5.call(values_1);
			} finally {
				if (e_1) throw e_1.error;
			}
		}
	} else for (var k in groups) if (groups.hasOwnProperty(k)) {
		var eachGroup = groups[k];
		array.push(eachGroup);
	}
	return array;
}

//#endregion
//#region node_modules/@antv/g2/esm/geometry/util/is-model-change.js
/**
* @ignore
* Determines whether model is change
* @param currentModel
* @param preModel
* @returns
*/
function isModelChange(currentModel, preModel) {
	return some_default([
		"color",
		"shape",
		"size",
		"x",
		"y",
		"isInCircle",
		"data",
		"style",
		"defaultStyle",
		"points",
		"mappingData"
	], function(key) {
		return !is_equal_default(currentModel[key], preModel[key]);
	});
}

//#endregion
//#region node_modules/@antv/g2/esm/geometry/util/parse-fields.js
/** @ignore */
function parseFields(field$5) {
	if (is_array_default(field$5)) return field$5;
	return field$5.split("*");
}

//#endregion
//#region node_modules/@antv/g2/esm/geometry/util/diff.js
/**
* 对比当前元素和之前的元素，返回 added, updated, removed
* @param keyItem 之前的元素的，按照 key-item 的 object 的形式存储
* @param keys 现在的元素，按照 array 的形式存储
* @returns 由 added, updated, removed array 构成的 object
*/
function diff(keyItem, keys$1) {
	var added = [];
	var updated = [];
	var removed = [];
	var keyIncluded = /* @__PURE__ */ new Map();
	for (var i = 0; i < keys$1.length; i++) {
		var key = keys$1[i];
		if (keyItem[key]) updated.push(key);
		else added.push(key);
		keyIncluded.set(key, true);
	}
	Object.keys(keyItem).forEach(function(key$1) {
		if (!keyIncluded.has(key$1)) removed.push(key$1);
	});
	return {
		added,
		updated,
		removed
	};
}

//#endregion
//#region node_modules/@antv/g2/esm/geometry/base.js
/**
* Geometry 几何标记基类，主要负责数据到图形属性的映射以及绘制逻辑。
*/
var Geometry = function(_super) {
	__extends(Geometry$1, _super);
	/**
	* 创建 Geometry 实例。
	* @param cfg
	*/
	function Geometry$1(cfg) {
		var _this = _super.call(this, cfg) || this;
		/** Geometry 几何标记类型。 */
		_this.type = "base";
		/** Attribute map  */
		_this.attributes = {};
		/** Element map */
		_this.elements = [];
		/** 使用 key-value 结构存储 Element，key 为每个 Element 实例对应的唯一 ID */
		_this.elementsMap = {};
		/** animate 配置项 */
		_this.animateOption = true;
		/** 图形属性映射配置 */
		_this.attributeOption = {};
		/** 存储上一次渲染时的 element 映射表，用于更新逻辑 */
		_this.lastElementsMap = {};
		/** 是否生成多个点来绘制图形。 */
		_this.generatePoints = false;
		/** 存储发生图形属性映射前的数据 */
		_this.beforeMappingData = null;
		_this.adjusts = {};
		_this.idFields = [];
		_this.hasSorted = false;
		_this.isCoordinateChanged = false;
		var container = cfg.container, labelsContainer = cfg.labelsContainer, coordinate$10 = cfg.coordinate, data$2 = cfg.data, _a$5 = cfg.sortable, sortable = _a$5 === void 0 ? false : _a$5, _b = cfg.visible, visible = _b === void 0 ? true : _b, theme$3 = cfg.theme, _c = cfg.scales, scales = _c === void 0 ? {} : _c, _d = cfg.scaleDefs, scaleDefs = _d === void 0 ? {} : _d, intervalPadding = cfg.intervalPadding, dodgePadding = cfg.dodgePadding, maxColumnWidth = cfg.maxColumnWidth, minColumnWidth = cfg.minColumnWidth, columnWidthRatio = cfg.columnWidthRatio, roseWidthRatio = cfg.roseWidthRatio, multiplePieWidthRatio = cfg.multiplePieWidthRatio, zIndexReversed = cfg.zIndexReversed, sortZIndex = cfg.sortZIndex, useDeferredLabel = cfg.useDeferredLabel;
		_this.container = container;
		_this.labelsContainer = labelsContainer;
		_this.coordinate = coordinate$10;
		_this.data = data$2;
		_this.sortable = sortable;
		_this.visible = visible;
		_this.userTheme = theme$3;
		_this.scales = scales;
		_this.scaleDefs = scaleDefs;
		_this.intervalPadding = intervalPadding;
		_this.dodgePadding = dodgePadding;
		_this.maxColumnWidth = maxColumnWidth;
		_this.minColumnWidth = minColumnWidth;
		_this.columnWidthRatio = columnWidthRatio;
		_this.roseWidthRatio = roseWidthRatio;
		_this.multiplePieWidthRatio = multiplePieWidthRatio;
		_this.zIndexReversed = zIndexReversed;
		_this.sortZIndex = sortZIndex;
		_this.useDeferredLabel = useDeferredLabel ? typeof useDeferredLabel === "number" ? useDeferredLabel : Infinity : null;
		return _this;
	}
	/**
	* 配置 position 通道映射规则。
	*
	* @example
	* ```typescript
	* // 数据结构: [{ x: 'A', y: 10, color: 'red' }]
	* geometry.position('x*y');
	* geometry.position([ 'x', 'y' ]);
	* geometry.position({
	*   fields: [ 'x', 'y' ],
	* });
	* ```
	*
	* @param cfg 映射规则
	* @returns
	*/
	Geometry$1.prototype.position = function(cfg) {
		var positionCfg = cfg;
		if (!is_plain_object_default(cfg)) positionCfg = { fields: parseFields(cfg) };
		var fields = get_default(positionCfg, "fields");
		if (fields.length === 1) {
			fields.unshift("1");
			set_default(positionCfg, "fields", fields);
		}
		set_default(this.attributeOption, "position", positionCfg);
		return this;
	};
	Geometry$1.prototype.color = function(field$5, cfg) {
		this.createAttrOption("color", field$5, cfg);
		return this;
	};
	Geometry$1.prototype.shape = function(field$5, cfg) {
		this.createAttrOption("shape", field$5, cfg);
		return this;
	};
	Geometry$1.prototype.size = function(field$5, cfg) {
		this.createAttrOption("size", field$5, cfg);
		return this;
	};
	/**
	* 设置数据调整方式。G2 目前内置了四种类型：
	* 1. dodge
	* 2. stack
	* 3. symmetric
	* 4. jitter
	*
	*
	* **Tip**
	* + 对于 'dodge' 类型，可以额外进行如下属性的配置:
	* ```typescript
	* geometry.adjust('dodge', {
	*   marginRatio: 0, // 取 0 到 1 范围的值（相对于每个柱子宽度），用于控制一个分组中柱子之间的间距
	*   dodgeBy: 'x', // 该属性只对 'dodge' 类型生效，声明以哪个数据字段为分组依据
	* });
	* ```
	*
	* + 对于 'stack' 类型，可以额外进行如下属性的配置:
	* ```typescript
	* geometry.adjust('stack', {
	*   reverseOrder: false, // 用于控制是否对数据进行反序操作
	* });
	* ```
	*
	* @example
	* ```typescript
	* geometry.adjust('stack');
	*
	* geometry.adjust({
	*   type: 'stack',
	*   reverseOrder: false,
	* });
	*
	* // 组合使用 adjust
	* geometry.adjust([ 'stack', 'dodge' ]);
	*
	* geometry.adjust([
	*   { type: 'stack' },
	*   { type: 'dodge', dodgeBy: 'x' },
	* ]);
	* ```
	*
	* @param adjustCfg 数据调整配置
	* @returns
	*/
	Geometry$1.prototype.adjust = function(adjustCfg$1) {
		var adjusts = adjustCfg$1;
		if (is_string_default(adjustCfg$1) || is_plain_object_default(adjustCfg$1)) adjusts = [adjustCfg$1];
		each_default(adjusts, function(adjust$2, index) {
			if (!is_object_default(adjust$2)) adjusts[index] = { type: adjust$2 };
		});
		this.adjustOption = adjusts;
		return this;
	};
	Geometry$1.prototype.style = function(field$5, styleFunc) {
		if (is_string_default(field$5)) {
			var fields = parseFields(field$5);
			this.styleOption = {
				fields,
				callback: styleFunc
			};
		} else {
			var _a$5 = field$5, fields = _a$5.fields, callback = _a$5.callback, cfg = _a$5.cfg;
			if (fields || callback || cfg) this.styleOption = field$5;
			else this.styleOption = { cfg: field$5 };
		}
		return this;
	};
	Geometry$1.prototype.tooltip = function(field$5, cfg) {
		if (is_string_default(field$5)) this.tooltipOption = {
			fields: parseFields(field$5),
			callback: cfg
		};
		else this.tooltipOption = field$5;
		return this;
	};
	/**
	* Geometry 动画配置。
	*
	* + `animate(false)` 关闭动画
	* + `animate(true)` 开启动画，默认开启。
	*
	* 我们将动画分为四个场景：
	* 1. appear: 图表第一次加载时的入场动画；
	* 2. enter: 图表绘制完成，发生更新后，产生的新图形的进场动画；
	* 3. update: 图表绘制完成，数据发生变更后，有状态变更的图形的更新动画；
	* 4. leave: 图表绘制完成，数据发生变更后，被销毁图形的销毁动画。
	*
	* @example
	* ```typescript
	* animate({
	*   enter: {
	*     duration: 1000, // enter 动画执行时间
	*   },
	*   leave: false, // 关闭 leave 销毁动画
	* });
	* ```
	*
	* @param cfg 动画配置
	* @returns
	*/
	Geometry$1.prototype.animate = function(cfg) {
		this.animateOption = cfg;
		return this;
	};
	Geometry$1.prototype.label = function(field$5, secondParam, thirdParam) {
		if (is_string_default(field$5)) {
			var labelOption = {};
			labelOption.fields = parseFields(field$5);
			if (is_function_default(secondParam)) labelOption.callback = secondParam;
			else if (is_plain_object_default(secondParam)) labelOption.cfg = secondParam;
			if (thirdParam) labelOption.cfg = thirdParam;
			this.labelOption = labelOption;
		} else this.labelOption = field$5;
		return this;
	};
	/**
	* 设置状态对应的样式。
	*
	* @example
	* ```ts
	* chart.interval().state({
	*   selected: {
	*     animate: { duration: 100, easing: 'easeLinear' },
	*     style: {
	*       lineWidth: 2,
	*       stroke: '#000',
	*     },
	*   },
	* });
	* ```
	*
	* 如果图形 shape 是由多个 shape 组成，即为一个 G.Group 对象，那么针对 group 中的每个 shape，我们需要使用下列方式进行状态样式设置：
	* 如果我们为 group 中的每个 shape 设置了 'name' 属性(shape.set('name', 'xx'))，则以 'name' 作为 key，否则默认以索引值（即 shape 的 添加顺序）为 key。
	*
	* ```ts
	* chart.interval().shape('groupShape').state({
	*   selected: {
	*     style: {
	*       0: { lineWidth: 2 },
	*       1: { fillOpacity: 1 },
	*     }
	*   }
	* });
	* ```
	*
	* @param cfg 状态样式
	*/
	Geometry$1.prototype.state = function(cfg) {
		this.stateOption = cfg;
		return this;
	};
	/**
	* 用于向 shape 中传入自定义的数据。目前可能仅仅可能用于在自定义 shape 的时候，像自定义 shape 中传入自定义的数据，方便实现自定义 shape 的配置能力。
	*
	* @example
	* ```ts
	* chart.interval().customInfo({ yourData: 'hello, g2!' });
	* ```
	*
	* 然后在自定义 shape 的时候，可以拿到这个信息。
	*
	* ```ts
	* registerShape('interval', 'your-shape', {
	*   draw(shapeInfo, container) {
	*     const { customInfo } = shapeInfo;
	*     console.log(customInfo); // will log { yourData: 'hello, g2!' }.
	*   }
	* });
	* ```
	*
	* @param cfg
	*/
	Geometry$1.prototype.customInfo = function(cfg) {
		this.customOption = cfg;
		return this;
	};
	/**
	* 初始化 Geomtry 实例：
	* 创建 [[Attribute]] and [[Scale]] 实例，进行数据处理，包括分组、数值化以及数据调整。
	*/
	Geometry$1.prototype.init = function(cfg) {
		if (cfg === void 0) cfg = {};
		this.setCfg(cfg);
		this.initAttributes();
		this.processData(this.data);
		this.adjustScale();
	};
	/**
	* Geometry 更新。
	* @param [cfg] 更新的配置
	*/
	Geometry$1.prototype.update = function(cfg) {
		if (cfg === void 0) cfg = {};
		var data$2 = cfg.data, isDataChanged = cfg.isDataChanged, isCoordinateChanged = cfg.isCoordinateChanged;
		var _a$5 = this, attributeOption = _a$5.attributeOption, lastAttributeOption = _a$5.lastAttributeOption;
		if (!is_equal_default(attributeOption, lastAttributeOption)) this.init(cfg);
		else if (data$2 && (isDataChanged || !is_equal_default(data$2, this.data))) {
			this.setCfg(cfg);
			this.initAttributes();
			this.processData(data$2);
		} else this.setCfg(cfg);
		this.adjustScale();
		this.isCoordinateChanged = isCoordinateChanged;
	};
	/**
	* 将原始数据映射至图形空间，同时创建图形对象。
	*/
	Geometry$1.prototype.paint = function(isUpdate) {
		var _this = this;
		if (isUpdate === void 0) isUpdate = false;
		if (this.animateOption) this.animateOption = deep_mix_default({}, getDefaultAnimateCfg(this.type, this.coordinate), this.animateOption);
		this.defaultSize = void 0;
		this.elementsMap = {};
		this.elements = [];
		this.getOffscreenGroup().clear();
		var beforeMappingData = this.beforeMappingData;
		var dataArray = this.beforeMapping(beforeMappingData);
		this.dataArray = new Array(dataArray.length);
		for (var i = 0; i < dataArray.length; i++) {
			var data$2 = dataArray[i];
			this.dataArray[i] = this.mapping(data$2);
		}
		this.updateElements(this.dataArray, isUpdate);
		this.lastElementsMap = this.elementsMap;
		if (this.canDoGroupAnimation(isUpdate)) {
			var container = this.container;
			var type = this.type;
			var coordinate$10 = this.coordinate;
			var animateCfg = get_default(this.animateOption, "appear");
			var yScale = this.getYScale();
			var yMinPoint = coordinate$10.convert({
				x: 0,
				y: yScale.scale(this.getYMinValue())
			});
			doGroupAppearAnimate(container, animateCfg, type, coordinate$10, yMinPoint);
		}
		if (this.labelOption) {
			var deferred = this.useDeferredLabel;
			var callback = (function() {
				return _this.renderLabels(flatten_default(_this.dataArray), isUpdate);
			}).bind(this);
			if (typeof deferred === "number") {
				var timeout$1 = typeof deferred === "number" && deferred !== Infinity ? deferred : 0;
				if (!window.requestIdleCallback) setTimeout(callback, timeout$1);
				else {
					var options = timeout$1 && timeout$1 !== Infinity ? { timeout: timeout$1 } : void 0;
					window.requestIdleCallback(callback, options);
				}
			} else callback();
		}
		this.lastAttributeOption = __assign({}, this.attributeOption);
		if (this.visible === false) this.changeVisible(false);
	};
	/**
	* 清空当前 Geometry，配置项仍保留，但是内部创建的对象全部清空。
	* @override
	*/
	Geometry$1.prototype.clear = function() {
		var _a$5 = this, container = _a$5.container, geometryLabel = _a$5.geometryLabel, offscreenGroup = _a$5.offscreenGroup;
		if (container) container.clear();
		if (geometryLabel) geometryLabel.clear();
		if (offscreenGroup) offscreenGroup.clear();
		this.scaleDefs = void 0;
		this.attributes = {};
		this.scales = {};
		this.elementsMap = {};
		this.lastElementsMap = {};
		this.elements = [];
		this.adjusts = {};
		this.dataArray = null;
		this.beforeMappingData = null;
		this.lastAttributeOption = void 0;
		this.defaultSize = void 0;
		this.idFields = [];
		this.groupScales = void 0;
		this.hasSorted = false;
		this.isCoordinateChanged = false;
	};
	/**
	* 销毁 Geometry 实例。
	*/
	Geometry$1.prototype.destroy = function() {
		this.clear();
		this.container.remove(true);
		if (this.offscreenGroup) {
			this.offscreenGroup.remove(true);
			this.offscreenGroup = null;
		}
		if (this.geometryLabel) {
			this.geometryLabel.destroy();
			this.geometryLabel = null;
		}
		this.theme = void 0;
		this.shapeFactory = void 0;
		_super.prototype.destroy.call(this);
	};
	/**
	* 获取决定分组的图形属性对应的 scale 实例。
	* @returns
	*/
	Geometry$1.prototype.getGroupScales = function() {
		return this.groupScales;
	};
	/**
	* 根据名字获取图形属性实例。
	*/
	Geometry$1.prototype.getAttribute = function(name) {
		return this.attributes[name];
	};
	/** 获取 x 轴对应的 scale 实例。 */
	Geometry$1.prototype.getXScale = function() {
		return this.getAttribute("position").scales[0];
	};
	/** 获取 y 轴对应的 scale 实例。 */
	Geometry$1.prototype.getYScale = function() {
		return this.getAttribute("position").scales[1];
	};
	/**
	* 获取决定分组的图形属性实例。
	*/
	Geometry$1.prototype.getGroupAttributes = function() {
		var rst = [];
		each_default(this.attributes, function(attr) {
			if (GROUP_ATTRS.includes(attr.type)) rst.push(attr);
		});
		return rst;
	};
	/** 获取图形属性默认的映射值。 */
	Geometry$1.prototype.getDefaultValue = function(attrName) {
		var value$1;
		var attr = this.getAttribute(attrName);
		if (attr && is_empty_default(attr.scales)) value$1 = attr.values[0];
		return value$1;
	};
	/**
	* 获取该数据发生图形映射后对应的 Attribute 图形空间数据。
	* @param attr Attribute 图形属性实例。
	* @param obj 需要进行映射的原始数据。
	* @returns
	*/
	Geometry$1.prototype.getAttributeValues = function(attr, obj) {
		var params = [];
		var scales = attr.scales;
		for (var index = 0, length_1 = scales.length; index < length_1; index++) {
			var scale$4 = scales[index];
			var field$5 = scale$4.field;
			if (scale$4.isIdentity) params.push(scale$4.values);
			else params.push(obj[field$5]);
		}
		return attr.mapping.apply(attr, __spreadArray([], __read(params), false));
	};
	/**
	* 获取对应的 adjust 实例
	* @param adjustType
	* @returns
	*/
	Geometry$1.prototype.getAdjust = function(adjustType) {
		return this.adjusts[adjustType];
	};
	/**
	* 获得 coordinate 实例
	* @returns
	*/
	Geometry$1.prototype.getCoordinate = function() {
		return this.coordinate;
	};
	Geometry$1.prototype.getData = function() {
		return this.data;
	};
	/**
	* 获取 shape 对应的 marker 样式。
	* @param shapeName shape 具体名字
	* @param cfg marker 信息
	* @returns
	*/
	Geometry$1.prototype.getShapeMarker = function(shapeName, cfg) {
		return this.getShapeFactory().getMarker(shapeName, cfg);
	};
	/**
	* 根据一定的规则查找 Geometry 的 Elements。
	*
	* ```typescript
	* getElementsBy((element) => {
	*   const data = element.getData();
	*
	*   return data.a === 'a';
	* });
	* ```
	*
	* @param condition 定义查找规则的回调函数。
	* @returns
	*/
	Geometry$1.prototype.getElementsBy = function(condition) {
		return this.elements.filter(function(element) {
			return condition(element);
		});
	};
	/**
	* 获取 Geometry 的所有 Elements。
	*
	* ```typescript
	* getElements();
	* ```
	*/
	Geometry$1.prototype.getElements = function() {
		return this.elements;
	};
	/**
	* 获取数据对应的唯一 id。
	* @param data Element 对应的绘制数据
	* @returns
	*/
	Geometry$1.prototype.getElementId = function(data$2) {
		data$2 = is_array_default(data$2) ? data$2[0] : data$2;
		var originData = data$2[FIELD_ORIGIN];
		if (this.idFields.length) {
			var elementId = originData[this.idFields[0]];
			for (var index = 1; index < this.idFields.length; index++) elementId += "-" + originData[this.idFields[index]];
			return elementId;
		}
		var type = this.type;
		var xScale = this.getXScale();
		var yScale = this.getYScale();
		var xField = xScale.field || "x";
		var yField = yScale.field || "y";
		var yVal = originData[yField];
		var xVal;
		if (xScale.type === "identity") xVal = xScale.values[0];
		else xVal = originData[xField];
		var id$1;
		if (type === "interval" || type === "schema") id$1 = "".concat(xVal);
		else if (type === "line" || type === "area" || type === "path") id$1 = type;
		else id$1 = "".concat(xVal, "-").concat(yVal);
		var groupScales = this.groupScales;
		for (var index = 0, length_2 = groupScales.length; index < length_2; index++) {
			var field$5 = groupScales[index].field;
			id$1 = "".concat(id$1, "-").concat(originData[field$5]);
		}
		var dodgeAdjust = this.getAdjust("dodge");
		if (dodgeAdjust) {
			var dodgeBy = dodgeAdjust.dodgeBy;
			if (dodgeBy) id$1 = "".concat(id$1, "-").concat(originData[dodgeBy]);
		}
		if (this.getAdjust("jitter")) id$1 = "".concat(id$1, "-").concat(data$2.x, "-").concat(data$2.y);
		return id$1;
	};
	/**
	* 获取所有需要创建 scale 的字段名称。
	*/
	Geometry$1.prototype.getScaleFields = function() {
		var fields = [];
		var tmpMap = /* @__PURE__ */ new Map();
		var _a$5 = this, attributeOption = _a$5.attributeOption, labelOption = _a$5.labelOption, tooltipOption = _a$5.tooltipOption;
		for (var attributeType in attributeOption) if (attributeOption.hasOwnProperty(attributeType)) {
			var eachOpt = attributeOption[attributeType];
			if (eachOpt.fields) uniq$1(eachOpt.fields, fields, tmpMap);
			else if (eachOpt.values) uniq$1(eachOpt.values, fields, tmpMap);
		}
		if (labelOption && labelOption.fields) uniq$1(labelOption.fields, fields, tmpMap);
		if (is_object_default(tooltipOption) && tooltipOption.fields) uniq$1(tooltipOption.fields, fields, tmpMap);
		return fields;
	};
	/**
	* 显示或者隐藏 geometry。
	* @param visible
	*/
	Geometry$1.prototype.changeVisible = function(visible) {
		_super.prototype.changeVisible.call(this, visible);
		var elements = this.elements;
		for (var index = 0, length_3 = elements.length; index < length_3; index++) elements[index].changeVisible(visible);
		if (visible) {
			if (this.container) this.container.show();
			if (this.labelsContainer) this.labelsContainer.show();
		} else {
			if (this.container) this.container.hide();
			if (this.labelsContainer) this.labelsContainer.hide();
		}
	};
	/**
	* 获得所有的字段
	*/
	Geometry$1.prototype.getFields = function() {
		var uniqMap = /* @__PURE__ */ new Map();
		var fields = [];
		Object.values(this.attributeOption).forEach(function(cfg) {
			((cfg === null || cfg === void 0 ? void 0 : cfg.fields) || []).forEach(function(f) {
				if (!uniqMap.has(f)) fields.push(f);
				uniqMap.set(f, true);
			});
		}, []);
		return fields;
	};
	/**
	* 获取当前配置中的所有分组 & 分类的字段。
	* @return fields string[]
	*/
	Geometry$1.prototype.getGroupFields = function() {
		var groupFields = [];
		var tmpMap = /* @__PURE__ */ new Map();
		for (var index = 0, length_4 = GROUP_ATTRS.length; index < length_4; index++) {
			var attributeName = GROUP_ATTRS[index];
			var cfg = this.attributeOption[attributeName];
			if (cfg && cfg.fields) uniq$1(cfg.fields, groupFields, tmpMap);
		}
		return groupFields;
	};
	/**
	* 获得图形的 x y 字段。
	*/
	Geometry$1.prototype.getXYFields = function() {
		var _a$5 = __read(this.attributeOption.position.fields, 2), x = _a$5[0], y = _a$5[1];
		return [x, y];
	};
	/**
	* x 字段
	* @returns
	*/
	Geometry$1.prototype.getXField = function() {
		return get_default(this.getXYFields(), [0]);
	};
	/**
	* y 字段
	* @returns
	*/
	Geometry$1.prototype.getYField = function() {
		return get_default(this.getXYFields(), [1]);
	};
	/**
	* 获取该 Geometry 下所有生成的 shapes。
	* @returns shapes
	*/
	Geometry$1.prototype.getShapes = function() {
		return this.elements.map(function(element) {
			return element.shape;
		});
	};
	/**
	* 获取虚拟 Group。
	* @returns
	*/
	Geometry$1.prototype.getOffscreenGroup = function() {
		if (!this.offscreenGroup) this.offscreenGroup = new (this.container.getGroupBase())({});
		return this.offscreenGroup;
	};
	Geometry$1.prototype.sort = function(mappingArray) {
		if (!this.hasSorted) {
			var xScale_1 = this.getXScale();
			var xField_1 = xScale_1.field;
			for (var index = 0; index < mappingArray.length; index++) mappingArray[index].sort(function(obj1, obj2) {
				return xScale_1.translate(obj1[FIELD_ORIGIN][xField_1]) - xScale_1.translate(obj2[FIELD_ORIGIN][xField_1]);
			});
		}
		this.hasSorted = true;
	};
	/**
	* 调整度量范围。主要针对发生层叠以及一些特殊需求的 Geometry，比如 Interval 下的柱状图 Y 轴默认从 0 开始。
	*/
	Geometry$1.prototype.adjustScale = function() {
		var yScale = this.getYScale();
		if (yScale && this.getAdjust("stack")) this.updateStackRange(yScale, this.beforeMappingData);
	};
	/**
	* 获取当前 Geometry 对应的 Shape 工厂实例。
	*/
	Geometry$1.prototype.getShapeFactory = function() {
		var shapeType = this.shapeType;
		if (!getShapeFactory(shapeType)) return;
		if (!this.shapeFactory) this.shapeFactory = clone_default(getShapeFactory(shapeType));
		this.shapeFactory.coordinate = this.coordinate;
		this.shapeFactory.theme = this.theme.geometries[shapeType] || {};
		return this.shapeFactory;
	};
	/**
	* 获取每个 Shape 对应的关键点数据。
	* @param obj 经过分组 -> 数字化 -> adjust 调整后的数据记录
	* @returns
	*/
	Geometry$1.prototype.createShapePointsCfg = function(obj) {
		var xScale = this.getXScale();
		var yScale = this.getYScale();
		var x = this.normalizeValues(obj[xScale.field], xScale);
		var y;
		if (yScale) y = this.normalizeValues(obj[yScale.field], yScale);
		else y = obj.y ? obj.y : .1;
		return {
			x,
			y,
			y0: yScale ? yScale.scale(this.getYMinValue()) : void 0
		};
	};
	/**
	* 创建 Element 实例。
	* @param mappingDatum Element 对应的绘制数据
	* @param [isUpdate] 是否处于更新阶段
	* @returns element 返回创建的 Element 实例
	*/
	Geometry$1.prototype.createElement = function(mappingDatum, index, isUpdate) {
		if (isUpdate === void 0) isUpdate = false;
		var container = this.container;
		var shapeCfg = this.getDrawCfg(mappingDatum);
		var shapeFactory = this.getShapeFactory();
		var element = new element_default({
			shapeFactory,
			container,
			offscreenGroup: this.getOffscreenGroup(),
			elementIndex: index
		});
		element.animate = this.animateOption;
		element.geometry = this;
		element.draw(shapeCfg, isUpdate);
		return element;
	};
	/**
	* 获取每条数据对应的图形绘制数据。
	* @param mappingDatum 映射后的数据
	* @returns draw cfg
	*/
	Geometry$1.prototype.getDrawCfg = function(mappingDatum) {
		var originData = mappingDatum[FIELD_ORIGIN];
		var cfg = {
			mappingData: mappingDatum,
			data: originData,
			x: mappingDatum.x,
			y: mappingDatum.y,
			color: mappingDatum.color,
			size: mappingDatum.size,
			isInCircle: this.coordinate.isPolar,
			customInfo: this.customOption
		};
		var shapeName = mappingDatum.shape;
		if (!shapeName && this.getShapeFactory()) shapeName = this.getShapeFactory().defaultShapeType;
		cfg.shape = shapeName;
		var theme$3 = this.theme.geometries[this.shapeType];
		cfg.defaultStyle = get_default(theme$3, [shapeName, "default"], {}).style;
		if (!cfg.defaultStyle && this.getShapeFactory()) cfg.defaultStyle = this.getShapeFactory().getDefaultStyle(theme$3);
		var styleOption = this.styleOption;
		if (styleOption) cfg.style = this.getStyleCfg(styleOption, originData);
		if (this.generatePoints) {
			cfg.points = mappingDatum.points;
			cfg.nextPoints = mappingDatum.nextPoints;
		}
		return cfg;
	};
	Geometry$1.prototype.updateElements = function(mappingDataArray, isUpdate) {
		var e_1, _a$5, e_2, _b, e_3, _c;
		if (isUpdate === void 0) isUpdate = false;
		var keyDatum = /* @__PURE__ */ new Map();
		var keys$1 = [];
		var keyIndex = /* @__PURE__ */ new Map();
		var index = 0;
		for (var i = 0; i < mappingDataArray.length; i++) {
			var mappingData = mappingDataArray[i];
			for (var j = 0; j < mappingData.length; j++) {
				var mappingDatum = mappingData[j];
				var key = this.getElementId(mappingDatum);
				var finalKey = keyDatum.has(key) ? "".concat(key, "-").concat(i, "-").concat(j) : key;
				keys$1.push(finalKey);
				keyDatum.set(finalKey, mappingDatum);
				keyIndex.set(finalKey, index);
				index++;
			}
		}
		this.elements = new Array(index);
		var _d = diff(this.lastElementsMap, keys$1), added = _d.added, updated = _d.updated, removed = _d.removed;
		try {
			for (var added_1 = __values(added), added_1_1 = added_1.next(); !added_1_1.done; added_1_1 = added_1.next()) {
				var key = added_1_1.value;
				var mappingDatum = keyDatum.get(key);
				var i = keyIndex.get(key);
				var element = this.createElement(mappingDatum, i, isUpdate);
				this.elements[i] = element;
				this.elementsMap[key] = element;
				if (element.shape) element.shape.set("zIndex", this.zIndexReversed ? this.elements.length - i : i);
			}
		} catch (e_1_1) {
			e_1 = { error: e_1_1 };
		} finally {
			try {
				if (added_1_1 && !added_1_1.done && (_a$5 = added_1.return)) _a$5.call(added_1);
			} finally {
				if (e_1) throw e_1.error;
			}
		}
		try {
			for (var updated_1 = __values(updated), updated_1_1 = updated_1.next(); !updated_1_1.done; updated_1_1 = updated_1.next()) {
				var key = updated_1_1.value;
				var element = this.lastElementsMap[key];
				var mappingDatum = keyDatum.get(key);
				var currentShapeCfg = this.getDrawCfg(mappingDatum);
				var preShapeCfg = element.getModel();
				var i = keyIndex.get(key);
				if (this.isCoordinateChanged || isModelChange(currentShapeCfg, preShapeCfg)) {
					element.animate = this.animateOption;
					element.update(currentShapeCfg);
				}
				this.elements[i] = element;
				this.elementsMap[key] = element;
				if (element.shape) element.shape.set("zIndex", this.zIndexReversed ? this.elements.length - i : i);
			}
		} catch (e_2_1) {
			e_2 = { error: e_2_1 };
		} finally {
			try {
				if (updated_1_1 && !updated_1_1.done && (_b = updated_1.return)) _b.call(updated_1);
			} finally {
				if (e_2) throw e_2.error;
			}
		}
		if (this.container) this.container.sort();
		try {
			for (var removed_1 = __values(removed), removed_1_1 = removed_1.next(); !removed_1_1.done; removed_1_1 = removed_1.next()) {
				var key = removed_1_1.value;
				var element = this.lastElementsMap[key];
				element.animate = this.animateOption;
				element.destroy();
			}
		} catch (e_3_1) {
			e_3 = { error: e_3_1 };
		} finally {
			try {
				if (removed_1_1 && !removed_1_1.done && (_c = removed_1.return)) _c.call(removed_1);
			} finally {
				if (e_3) throw e_3.error;
			}
		}
	};
	/**
	* 获取渲染的 label 类型。
	*/
	Geometry$1.prototype.getLabelType = function() {
		var _a$5 = this, labelOption = _a$5.labelOption, coordinate$10 = _a$5.coordinate, type = _a$5.type;
		var coordinateType = coordinate$10.type, isTransposed = coordinate$10.isTransposed;
		var labelType = get_default(labelOption, ["cfg", "type"]);
		if (!labelType) if (coordinateType === "polar") labelType = isTransposed ? "pie" : "polar";
		else if (coordinateType === "theta") labelType = "pie";
		else if (type === "interval" || type === "polygon") labelType = "interval";
		else labelType = "base";
		return labelType;
	};
	/**
	* 获取 Y 轴上的最小值。
	*/
	Geometry$1.prototype.getYMinValue = function() {
		var yScale = this.getYScale();
		var min$2 = yScale.min, max$2 = yScale.max;
		var value$1;
		if (min$2 >= 0) value$1 = min$2;
		else if (max$2 <= 0) value$1 = max$2;
		else value$1 = 0;
		return value$1;
	};
	Geometry$1.prototype.createAttrOption = function(attrName, field$5, cfg) {
		if (is_nil_default(field$5) || is_object_default(field$5)) if (is_object_default(field$5) && is_equal_default(Object.keys(field$5), ["values"])) set_default(this.attributeOption, attrName, { fields: field$5.values });
		else set_default(this.attributeOption, attrName, field$5);
		else {
			var attrCfg = {};
			if (is_number_default(field$5)) attrCfg.values = [field$5];
			else attrCfg.fields = parseFields(field$5);
			if (cfg) if (is_function_default(cfg)) attrCfg.callback = cfg;
			else attrCfg.values = cfg;
			set_default(this.attributeOption, attrName, attrCfg);
		}
	};
	Geometry$1.prototype.initAttributes = function() {
		var _this = this;
		var _a$5 = this, attributes = _a$5.attributes, attributeOption = _a$5.attributeOption, theme$3 = _a$5.theme, shapeType = _a$5.shapeType;
		this.groupScales = [];
		var tmpMap = {};
		var _loop_1 = function(attrType$1) {
			if (attributeOption.hasOwnProperty(attrType$1)) {
				var option = attributeOption[attrType$1];
				if (!option) return { value: void 0 };
				var attrCfg = __assign({}, option);
				var callback = attrCfg.callback, values$1 = attrCfg.values, _b = attrCfg.fields;
				var scales = (_b === void 0 ? [] : _b).map(function(field$5) {
					var scale$4 = _this.scales[field$5];
					if (!tmpMap[field$5] && GROUP_ATTRS.includes(attrType$1)) {
						if (inferScaleType(scale$4, get_default(_this.scaleDefs, field$5), attrType$1, _this.type) === "cat") {
							_this.groupScales.push(scale$4);
							tmpMap[field$5] = true;
						}
					}
					return scale$4;
				});
				attrCfg.scales = scales;
				if (attrType$1 !== "position" && scales.length === 1 && scales[0].type === "identity") attrCfg.values = scales[0].values;
				else if (!callback && !values$1) {
					if (attrType$1 === "size") attrCfg.values = theme$3.sizes;
					else if (attrType$1 === "shape") attrCfg.values = theme$3.shapes[shapeType] || [];
					else if (attrType$1 === "color") if (scales.length) attrCfg.values = scales[0].values.length <= 10 ? theme$3.colors10 : theme$3.colors20;
					else attrCfg.values = theme$3.colors10;
				}
				attributes[attrType$1] = new (getAttribute(attrType$1))(attrCfg);
			}
		};
		for (var attrType in attributeOption) {
			var state_1 = _loop_1(attrType);
			if (typeof state_1 === "object") return state_1.value;
		}
	};
	Geometry$1.prototype.processData = function(data$2) {
		var e_4, _a$5;
		this.hasSorted = false;
		var categoryScales = this.getAttribute("position").scales.filter(function(scale$5) {
			return scale$5.isCategory;
		});
		var groupedArray = this.groupData(data$2);
		var beforeAdjust = [];
		for (var i = 0, len = groupedArray.length; i < len; i++) {
			var subData = groupedArray[i];
			var arr = [];
			for (var j = 0, subLen = subData.length; j < subLen; j++) {
				var originData = subData[j];
				var item = {};
				for (var k in originData) item[k] = originData[k];
				item[FIELD_ORIGIN] = originData;
				try {
					for (var categoryScales_1 = (e_4 = void 0, __values(categoryScales)), categoryScales_1_1 = categoryScales_1.next(); !categoryScales_1_1.done; categoryScales_1_1 = categoryScales_1.next()) {
						var scale$4 = categoryScales_1_1.value;
						var field$5 = scale$4.field;
						item[field$5] = scale$4.translate(item[field$5]);
					}
				} catch (e_4_1) {
					e_4 = { error: e_4_1 };
				} finally {
					try {
						if (categoryScales_1_1 && !categoryScales_1_1.done && (_a$5 = categoryScales_1.return)) _a$5.call(categoryScales_1);
					} finally {
						if (e_4) throw e_4.error;
					}
				}
				arr.push(item);
			}
			beforeAdjust.push(arr);
		}
		var dataArray = this.adjustData(beforeAdjust);
		this.beforeMappingData = dataArray;
		return dataArray;
	};
	Geometry$1.prototype.adjustData = function(dataArray) {
		var adjustOption = this.adjustOption;
		var _a$5 = this, intervalPadding = _a$5.intervalPadding, dodgePadding = _a$5.dodgePadding, theme$3 = _a$5.theme;
		var maxColumnWidth = this.maxColumnWidth || theme$3.maxColumnWidth;
		var minColumnWidth = this.minColumnWidth || theme$3.minColumnWidth;
		var columnWidthRatio = this.columnWidthRatio || theme$3.columnWidthRatio;
		var result = dataArray;
		if (adjustOption) {
			var xScale_2 = this.getXScale();
			var yScale = this.getYScale();
			var xField = xScale_2.field;
			var yField = yScale ? yScale.field : null;
			var xDimensionLength = getXDimensionLength(this.coordinate);
			var groupNum = xScale_2.values.length;
			var sizeAttr = this.getAttribute("size");
			var defaultSize = void 0;
			if (sizeAttr) defaultSize = sizeAttr.values[0];
			for (var i = 0, len = adjustOption.length; i < len; i++) {
				var adjust$2 = adjustOption[i];
				var adjustCfg$1 = __assign({
					xField,
					yField,
					intervalPadding,
					dodgePadding,
					xDimensionLength,
					groupNum,
					defaultSize,
					maxColumnWidth,
					minColumnWidth,
					columnWidthRatio
				}, adjust$2);
				var type = adjust$2.type;
				if (type === "dodge") {
					var adjustNames = [];
					if (xScale_2.isCategory || xScale_2.type === "identity") adjustNames.push("x");
					else if (!yScale) adjustNames.push("y");
					else throw new Error("dodge is not support linear attribute, please use category attribute!");
					adjustCfg$1.adjustNames = adjustNames;
					adjustCfg$1.dodgeRatio = columnWidthRatio;
				} else if (type === "stack") {
					var coordinate$10 = this.coordinate;
					if (!yScale) {
						adjustCfg$1.height = coordinate$10.getHeight();
						adjustCfg$1.size = this.getDefaultValue("size") || 3;
					}
					if (!coordinate$10.isTransposed && is_nil_default(adjustCfg$1.reverseOrder)) adjustCfg$1.reverseOrder = true;
				}
				var adjustCtor = getAdjust(type);
				adjustCfg$1.dimValuesMap = {};
				if (xScale_2 && xScale_2.values) adjustCfg$1.dimValuesMap[xScale_2.field] = xScale_2.values.map(function(v) {
					return xScale_2.translate(v);
				});
				var adjustInstance = new adjustCtor(adjustCfg$1);
				result = adjustInstance.process(result);
				this.adjusts[type] = adjustInstance;
			}
		}
		return result;
	};
	Geometry$1.prototype.groupData = function(data$2) {
		var groupScales = this.getGroupScales();
		var scaleDefs = this.scaleDefs;
		var appendConditions = {};
		var groupFields = [];
		for (var index = 0; index < groupScales.length; index++) {
			var field$5 = groupScales[index].field;
			groupFields.push(field$5);
			if (get_default(scaleDefs, [field$5, "values"])) appendConditions[field$5] = scaleDefs[field$5].values;
		}
		return group(data$2, groupFields, appendConditions);
	};
	Geometry$1.prototype.updateStackRange = function(scale$4, dataArray) {
		var mergeArray = flatten_default(dataArray);
		var field$5 = scale$4.field;
		var min$2 = scale$4.min;
		var max$2 = scale$4.max;
		for (var index = 0; index < mergeArray.length; index++) {
			var obj = mergeArray[index];
			var tmpMin = Math.min.apply(null, obj[field$5]);
			var tmpMax = Math.max.apply(null, obj[field$5]);
			if (tmpMin < min$2) min$2 = tmpMin;
			if (tmpMax > max$2) max$2 = tmpMax;
		}
		var scaleDefs = this.scaleDefs;
		var cfg = {};
		if (min$2 < scale$4.min && !get_default(scaleDefs, [field$5, "min"])) cfg.min = min$2;
		if (max$2 > scale$4.max && !get_default(scaleDefs, [field$5, "max"])) cfg.max = max$2;
		scale$4.change(cfg);
	};
	Geometry$1.prototype.beforeMapping = function(beforeMappingData) {
		var source = beforeMappingData;
		if (this.sortable) this.sort(source);
		if (this.generatePoints) for (var index = 0, length_5 = source.length; index < length_5; index++) {
			var currentData = source[index];
			this.generateShapePoints(currentData);
			var nextData = source[index + 1];
			if (nextData) {
				this.generateShapePoints(nextData);
				currentData[0].nextPoints = nextData[0].points;
			}
		}
		return source;
	};
	Geometry$1.prototype.generateShapePoints = function(data$2) {
		var shapeFactory = this.getShapeFactory();
		var shapeAttr = this.getAttribute("shape");
		for (var index = 0; index < data$2.length; index++) {
			var obj = data$2[index];
			var cfg = this.createShapePointsCfg(obj);
			var shape = shapeAttr ? this.getAttributeValues(shapeAttr, obj) : null;
			obj.points = shapeFactory.getShapePoints(shape, cfg);
		}
	};
	Geometry$1.prototype.normalizeValues = function(values$1, scale$4) {
		var rst = [];
		if (is_array_default(values$1)) for (var index = 0; index < values$1.length; index++) {
			var value$1 = values$1[index];
			rst.push(scale$4.scale(value$1));
		}
		else rst = scale$4.scale(values$1);
		return rst;
	};
	Geometry$1.prototype.mapping = function(data$2) {
		var attributes = this.attributes;
		var mappingData = [];
		for (var index = 0; index < data$2.length; index++) {
			var record = data$2[index];
			var newRecord = {
				_origin: record[FIELD_ORIGIN],
				points: record.points,
				nextPoints: record.nextPoints
			};
			for (var k in attributes) if (attributes.hasOwnProperty(k)) {
				var attr = attributes[k];
				var names = attr.names;
				var values$1 = this.getAttributeValues(attr, record);
				if (names.length > 1) for (var j = 0; j < values$1.length; j += 1) {
					var val = values$1[j];
					var name_1 = names[j];
					newRecord[name_1] = is_array_default(val) && val.length === 1 ? val[0] : val;
				}
				else newRecord[names[0]] = values$1.length === 1 ? values$1[0] : values$1;
			}
			this.convertPoint(newRecord);
			mappingData.push(newRecord);
		}
		return mappingData;
	};
	Geometry$1.prototype.convertPoint = function(mappingRecord) {
		var x = mappingRecord.x, y = mappingRecord.y;
		var rstX;
		var rstY;
		var obj;
		var coordinate$10 = this.coordinate;
		if (is_array_default(x) && is_array_default(y)) {
			rstX = [];
			rstY = [];
			for (var i = 0, j = 0, xLen = x.length, yLen = y.length; i < xLen && j < yLen; i += 1, j += 1) {
				obj = coordinate$10.convert({
					x: x[i],
					y: y[j]
				});
				rstX.push(obj.x);
				rstY.push(obj.y);
			}
		} else if (is_array_default(y)) {
			rstY = [];
			for (var index = 0; index < y.length; index++) {
				var yVal = y[index];
				obj = coordinate$10.convert({
					x,
					y: yVal
				});
				if (rstX && rstX !== obj.x) {
					if (!is_array_default(rstX)) rstX = [rstX];
					rstX.push(obj.x);
				} else rstX = obj.x;
				rstY.push(obj.y);
			}
		} else if (is_array_default(x)) {
			rstX = [];
			for (var index = 0; index < x.length; index++) {
				var xVal = x[index];
				obj = coordinate$10.convert({
					x: xVal,
					y
				});
				if (rstY && rstY !== obj.y) {
					if (!is_array_default(rstY)) rstY = [rstY];
					rstY.push(obj.y);
				} else rstY = obj.y;
				rstX.push(obj.x);
			}
		} else {
			var point$1 = coordinate$10.convert({
				x,
				y
			});
			rstX = point$1.x;
			rstY = point$1.y;
		}
		mappingRecord.x = rstX;
		mappingRecord.y = rstY;
	};
	Geometry$1.prototype.getStyleCfg = function(styleOption, originData) {
		var _a$5 = styleOption.fields, fields = _a$5 === void 0 ? [] : _a$5, callback = styleOption.callback, cfg = styleOption.cfg;
		if (cfg) return cfg;
		var params = fields.map(function(field$5) {
			return originData[field$5];
		});
		return callback.apply(void 0, __spreadArray([], __read(params), false));
	};
	Geometry$1.prototype.setCfg = function(cfg) {
		var _this = this;
		var coordinate$10 = cfg.coordinate, data$2 = cfg.data, theme$3 = cfg.theme, scaleDefs = cfg.scaleDefs;
		if (coordinate$10) this.coordinate = coordinate$10;
		if (data$2) this.data = data$2;
		if (scaleDefs) {
			this.scaleDefs = scaleDefs;
			this.idFields = [];
			each_default(scaleDefs, function(scaleDef, field$5) {
				if (scaleDef && scaleDef.key) _this.idFields.push(field$5);
			});
		}
		if (theme$3) this.theme = this.userTheme ? deep_mix_default({}, theme$3, this.userTheme) : theme$3;
	};
	Geometry$1.prototype.renderLabels = function(mappingArray, isUpdate) {
		if (isUpdate === void 0) isUpdate = false;
		return __awaiter(this, void 0, void 0, function() {
			var geometryLabel, labelType, GeometryLabelsCtor, labelsMap, elementLabels, _a$5, _b, _c, element, labels;
			var e_5, _d;
			var _this = this;
			return __generator(this, function(_e) {
				switch (_e.label) {
					case 0:
						geometryLabel = this.geometryLabel;
						this.emit(GEOMETRY_LIFE_CIRCLE.BEFORE_RENDER_LABEL);
						if (!geometryLabel) {
							labelType = this.getLabelType();
							GeometryLabelsCtor = getGeometryLabel(labelType);
							geometryLabel = new GeometryLabelsCtor(this);
							this.geometryLabel = geometryLabel;
						}
						return [4, geometryLabel.render(mappingArray, isUpdate)];
					case 1:
						_e.sent();
						labelsMap = geometryLabel.labelsRenderer.shapesMap;
						elementLabels = /* @__PURE__ */ new Map();
						each_default(labelsMap, function(labelGroup, labelGroupId) {
							var labelChildren = labelGroup.getChildren() || [];
							for (var j = 0; j < labelChildren.length; j++) {
								var labelShape = labelChildren[j];
								var element$1 = _this.elementsMap[labelShape.get("elementId") || labelGroupId.split(" ")[0]];
								if (element$1) {
									labelShape.cfg.name = ["element", "label"];
									labelShape.cfg.element = element$1;
									var labels$1 = elementLabels.get(element$1) || /* @__PURE__ */ new Set();
									labels$1.add(labelGroup);
									elementLabels.set(element$1, labels$1);
								}
							}
						});
						try {
							for (_a$5 = __values(elementLabels.entries()), _b = _a$5.next(); !_b.done; _b = _a$5.next()) {
								_c = __read(_b.value, 2), element = _c[0], labels = _c[1];
								element.labelShape = __spreadArray([], __read(labels), false);
							}
						} catch (e_5_1) {
							e_5 = { error: e_5_1 };
						} finally {
							try {
								if (_b && !_b.done && (_d = _a$5.return)) _d.call(_a$5);
							} finally {
								if (e_5) throw e_5.error;
							}
						}
						this.emit(GEOMETRY_LIFE_CIRCLE.AFTER_RENDER_LABEL);
						return [2];
				}
			});
		});
	};
	/**
	* 是否需要进行群组入场动画
	* 规则：
	* 1. 如果发生更新，则不进行
	* 2. 如果用户关闭 geometry 动画，则不进行
	* 3. 如果用户关闭了 appear 动画，则不进行
	* 4. 如果用户配置了 appear.animation，则不进行
	*/
	Geometry$1.prototype.canDoGroupAnimation = function(isUpdate) {
		return !isUpdate && this.animateOption && (get_default(this.animateOption, "appear") === void 0 || get_default(this.animateOption, "appear") && get_default(this.animateOption, ["appear", "animation"]) === void 0);
	};
	return Geometry$1;
}(base_default$9);
var base_default$4 = Geometry;

//#endregion
//#region node_modules/@antv/g2/esm/util/transform.js
var transform$4 = transform$6;
/**
* 对元素进行平移操作。
* @param element 进行变换的元素
* @param x x 方向位移
* @param y y 方向位移
*/
function translate(element, x, y) {
	var matrix = transform$4(element.getMatrix(), [[
		"t",
		x,
		y
	]]);
	element.setMatrix(matrix);
}
/**
* 获取元素旋转矩阵 (以元素的左上角为旋转点)
* @param element 进行变换的元素
* @param rotateRadian 旋转弧度
*/
function getRotateMatrix(element, rotateRadian) {
	var _a$5 = element.attr(), x = _a$5.x, y = _a$5.y;
	return transform$4(element.getMatrix(), [
		[
			"t",
			-x,
			-y
		],
		["r", rotateRadian],
		[
			"t",
			x,
			y
		]
	]);
}
/**
* 对元素进行旋转操作。
* @param element 进行变换的元素
* @param rotateRadian 旋转弧度
*/
function rotate(element, rotateRadian) {
	var matrix = getRotateMatrix(element, rotateRadian);
	element.setMatrix(matrix);
}
/**
* 围绕图形中心点进行缩放
* @param element 进行缩放的图形元素
* @param ratio 缩放比例
*/
function zoom(element, ratio) {
	var bbox = element.getBBox();
	var x = (bbox.minX + bbox.maxX) / 2;
	var y = (bbox.minY + bbox.maxY) / 2;
	element.applyToMatrix([
		x,
		y,
		1
	]);
	var matrix = transform$4(element.getMatrix(), [
		[
			"t",
			-x,
			-y
		],
		[
			"s",
			ratio,
			ratio
		],
		[
			"t",
			x,
			y
		]
	]);
	element.setMatrix(matrix);
}

//#endregion
//#region node_modules/@antv/g2/esm/geometry/label/util/index.js
/**
* 查找 Label Group 中的文本 shape 对象
* @param label
*/
function findLabelTextShape(label$16) {
	return label$16.find(function(el) {
		return el.get("type") === "text";
	});
}
/**
* 获取标签背景信息: box (无旋转) + rotation (旋转角度)
*/
function getLabelBackgroundInfo(labelGroup, labelItem, padding$2) {
	if (padding$2 === void 0) padding$2 = [
		0,
		0,
		0,
		0
	];
	var content = labelGroup && labelGroup.getChildren()[0];
	if (content) {
		var labelShape = content.clone();
		if (labelItem === null || labelItem === void 0 ? void 0 : labelItem.rotate) rotate(labelShape, -labelItem.rotate);
		var _a$5 = labelShape.getCanvasBBox(), x = _a$5.x, y = _a$5.y, width = _a$5.width, height = _a$5.height;
		labelShape.destroy();
		var boxPadding = padding$2;
		if (is_nil_default(boxPadding)) boxPadding = [
			2,
			2,
			2,
			2
		];
		else if (is_number_default(boxPadding)) boxPadding = new Array(4).fill(boxPadding);
		return {
			x: x - boxPadding[3],
			y: y - boxPadding[0],
			width: width + boxPadding[1] + boxPadding[3],
			height: height + boxPadding[0] + boxPadding[2],
			rotation: (labelItem === null || labelItem === void 0 ? void 0 : labelItem.rotate) || 0
		};
	}
	return {
		x: 0,
		y: 0,
		width: 0,
		height: 0,
		rotation: 0
	};
}
/**
* 计算两个矩形之间的堆叠区域面积
*/
function getOverlapArea$2(a, b, margin) {
	if (margin === void 0) margin = 0;
	var xOverlap = Math.max(0, Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin));
	var yOverlap = Math.max(0, Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin));
	return xOverlap * yOverlap;
}
/** 检测是否和已布局的堆叠 */
function checkShapeOverlap$2(cur, dones) {
	var box$1 = cur.getBBox();
	return some_default(dones, function(done) {
		var target = done.getBBox();
		return getOverlapArea$2(box$1, target, 2) > 0;
	});
}

//#endregion
//#region node_modules/@antv/g2/esm/component/update-label.js
/**
* @desc 更新 label (目前没有根据 id 索引，还是会存在一点小问题的，只能根据 idx 索引)
* @done shape 属性更新
* @done shape delete
* @done shape append
*
* @param fromShape old labelShape
* @param toShape new labelShape
* @param cfg
*/
function updateLabel(fromShape, toShape, cfg) {
	var data$2 = cfg.data, origin = cfg.origin, animateCfg = cfg.animateCfg, coordinate$10 = cfg.coordinate;
	var updateAnimateCfg = get_default(animateCfg, "update");
	fromShape.set("data", data$2);
	fromShape.set("origin", origin);
	fromShape.set("animateCfg", animateCfg);
	fromShape.set("coordinate", coordinate$10);
	fromShape.set("visible", toShape.get("visible"));
	(fromShape.getChildren() || []).forEach(function(fromChild, idx) {
		var toChild = toShape.getChildByIndex(idx);
		if (!toChild) {
			fromShape.removeChild(fromChild);
			fromChild.remove(true);
		} else {
			fromChild.set("data", data$2);
			fromChild.set("origin", origin);
			fromChild.set("animateCfg", animateCfg);
			fromChild.set("coordinate", coordinate$10);
			var newAttrs = getReplaceAttrs(fromChild, toChild);
			if (updateAnimateCfg) doAnimate(fromChild, updateAnimateCfg, {
				toAttrs: newAttrs,
				coordinate: coordinate$10
			});
			else fromChild.attr(newAttrs);
			if (toChild.isGroup()) updateLabel(fromChild, toChild, cfg);
		}
	});
	each_default(toShape.getChildren(), function(child, idx) {
		if (is_array_default(fromShape.getChildren()) && idx >= fromShape.getCount()) {
			if (!child.destroyed) fromShape.add(child);
		}
	});
}

//#endregion
//#region node_modules/@antv/g2/esm/component/labels.js
/**
* Geometry labels 渲染组件
*/
var Labels = function() {
	function Labels$1(cfg) {
		/** 存储当前 shape 的映射表，键值为 shape id */
		this.shapesMap = {};
		var layout$1 = cfg.layout, container = cfg.container;
		this.layout = layout$1;
		this.container = container;
	}
	/**
	* 渲染文本
	*/
	Labels$1.prototype.render = function(items, shapes, isUpdate) {
		if (isUpdate === void 0) isUpdate = false;
		return __awaiter(this, void 0, void 0, function() {
			var shapesMap, offscreenGroup, items_1, items_1_1, item, lastShapesMap;
			var e_1, _a$5;
			var _this = this;
			return __generator(this, function(_b) {
				switch (_b.label) {
					case 0:
						shapesMap = {};
						offscreenGroup = this.createOffscreenGroup();
						if (!items.length) return [3, 2];
						try {
							for (items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
								item = items_1_1.value;
								if (item) shapesMap[item.id] = this.renderLabel(item, offscreenGroup);
							}
						} catch (e_1_1) {
							e_1 = { error: e_1_1 };
						} finally {
							try {
								if (items_1_1 && !items_1_1.done && (_a$5 = items_1.return)) _a$5.call(items_1);
							} finally {
								if (e_1) throw e_1.error;
							}
						}
						return [4, this.doLayout(items, shapes, shapesMap)];
					case 1:
						_b.sent();
						this.renderLabelLine(items, shapesMap);
						this.renderLabelBackground(items, shapesMap);
						this.adjustLabel(items, shapesMap);
						_b.label = 2;
					case 2:
						lastShapesMap = this.shapesMap;
						each_default(shapesMap, function(shape, id$1) {
							if (shape.destroyed) delete shapesMap[id$1];
							else {
								if (lastShapesMap[id$1]) {
									var data$2 = shape.get("data");
									var origin_1 = shape.get("origin");
									var coordinate$10 = shape.get("coordinate");
									var currentAnimateCfg = shape.get("animateCfg");
									var currentShape = lastShapesMap[id$1];
									updateLabel(currentShape, shapesMap[id$1], {
										data: data$2,
										origin: origin_1,
										animateCfg: currentAnimateCfg,
										coordinate: coordinate$10
									});
									shapesMap[id$1] = currentShape;
								} else {
									if (_this.container.destroyed) return;
									_this.container.add(shape);
									var animateCfg = get_default(shape.get("animateCfg"), isUpdate ? "enter" : "appear");
									if (animateCfg) doAnimate(shape, animateCfg, {
										toAttrs: __assign({}, shape.attr()),
										coordinate: shape.get("coordinate")
									});
								}
								delete lastShapesMap[id$1];
							}
						});
						each_default(lastShapesMap, function(deleteShape) {
							var animateCfg = get_default(deleteShape.get("animateCfg"), "leave");
							if (animateCfg) doAnimate(deleteShape, animateCfg, {
								toAttrs: null,
								coordinate: deleteShape.get("coordinate")
							});
							else deleteShape.remove(true);
						});
						this.shapesMap = shapesMap;
						offscreenGroup.destroy();
						return [2];
				}
			});
		});
	};
	/** 清除当前 labels */
	Labels$1.prototype.clear = function() {
		this.container.clear();
		this.shapesMap = {};
	};
	/** 销毁 */
	Labels$1.prototype.destroy = function() {
		this.container.destroy();
		this.shapesMap = null;
	};
	Labels$1.prototype.renderLabel = function(cfg, container) {
		var id$1 = cfg.id, elementId = cfg.elementId, data$2 = cfg.data, mappingData = cfg.mappingData, coordinate$10 = cfg.coordinate, animate = cfg.animate, content = cfg.content, capture = cfg.capture;
		var shapeAppendCfg = {
			id: id$1,
			elementId,
			capture,
			data: data$2,
			origin: __assign(__assign({}, mappingData), { data: mappingData[FIELD_ORIGIN] }),
			coordinate: coordinate$10
		};
		var labelGroup = container.addGroup(__assign({
			name: "label",
			animateCfg: this.animate === false || animate === null || animate === false ? false : deep_mix_default({}, this.animate, animate)
		}, shapeAppendCfg));
		var labelShape;
		if (content.isGroup && content.isGroup() || content.isShape && content.isShape()) {
			var _a$5 = content.getCanvasBBox(), width = _a$5.width, height = _a$5.height;
			var textAlign = get_default(cfg, "textAlign", "left");
			var x = cfg.x;
			var y = cfg.y - height / 2;
			if (textAlign === "center") x = x - width / 2;
			else if (textAlign === "right" || textAlign === "end") x = x - width;
			translate(content, x, y);
			labelShape = content;
			labelGroup.add(content);
		} else {
			var fill = get_default(cfg, ["style", "fill"]);
			labelShape = labelGroup.addShape("text", __assign({ attrs: __assign(__assign({
				x: cfg.x,
				y: cfg.y,
				textAlign: cfg.textAlign,
				textBaseline: get_default(cfg, "textBaseline", "middle"),
				text: cfg.content
			}, cfg.style), { fill: is_null_default(fill) ? cfg.color : fill }) }, shapeAppendCfg));
		}
		if (cfg.rotate) rotate(labelShape, cfg.rotate);
		return labelGroup;
	};
	Labels$1.prototype.doLayout = function(items, shapes, shapesMap) {
		return __awaiter(this, void 0, void 0, function() {
			var layouts;
			var _this = this;
			return __generator(this, function(_a$5) {
				switch (_a$5.label) {
					case 0:
						if (!this.layout) return [3, 2];
						layouts = is_array_default(this.layout) ? this.layout : [this.layout];
						return [4, Promise.all(layouts.map(function(layout$1) {
							var layoutFn = getGeometryLabelLayout(get_default(layout$1, "type", ""));
							if (!layoutFn) return;
							var labelShapes = [];
							var geometryShapes = [];
							each_default(shapesMap, function(labelShape, id$1) {
								labelShapes.push(labelShape);
								geometryShapes.push(shapes[labelShape.get("elementId")]);
							});
							return layoutFn(items, labelShapes, geometryShapes, _this.region, layout$1.cfg);
						}))];
					case 1:
						_a$5.sent();
						_a$5.label = 2;
					case 2: return [2];
				}
			});
		});
	};
	Labels$1.prototype.renderLabelLine = function(labelItems, shapesMap) {
		each_default(labelItems, function(labelItem) {
			var coordinate$10 = get_default(labelItem, "coordinate");
			if (!labelItem || !coordinate$10) return;
			var center$1 = coordinate$10.getCenter();
			var radius = coordinate$10.getRadius();
			if (!labelItem.labelLine) return;
			var labelLineCfg = get_default(labelItem, "labelLine", {});
			var id$1 = labelItem.id;
			var path = labelLineCfg.path;
			if (!path) {
				var start = polarToCartesian(center$1.x, center$1.y, radius, labelItem.angle);
				path = [[
					"M",
					start.x,
					start.y
				], [
					"L",
					labelItem.x,
					labelItem.y
				]];
			}
			var labelGroup = shapesMap[id$1];
			if (!labelGroup.destroyed) labelGroup.addShape("path", {
				capture: false,
				attrs: __assign({
					path,
					stroke: labelItem.color ? labelItem.color : get_default(labelItem, ["style", "fill"], "#000"),
					fill: null
				}, labelLineCfg.style),
				id: id$1,
				origin: labelItem.mappingData,
				data: labelItem.data,
				coordinate: labelItem.coordinate
			});
		});
	};
	/**
	* 绘制标签背景
	* @param labelItems
	*/
	Labels$1.prototype.renderLabelBackground = function(labelItems, shapesMap) {
		each_default(labelItems, function(labelItem) {
			var coordinate$10 = get_default(labelItem, "coordinate");
			var background = get_default(labelItem, "background");
			if (!background || !coordinate$10) return;
			var id$1 = labelItem.id;
			var labelGroup = shapesMap[id$1];
			if (!labelGroup.destroyed) {
				var labelContentShape = labelGroup.getChildren()[0];
				if (labelContentShape) {
					var _a$5 = getLabelBackgroundInfo(labelGroup, labelItem, background.padding), rotation = _a$5.rotation, box$1 = __rest(_a$5, ["rotation"]);
					var backgroundShape = labelGroup.addShape("rect", {
						attrs: __assign(__assign({}, box$1), background.style || {}),
						id: id$1,
						origin: labelItem.mappingData,
						data: labelItem.data,
						coordinate: labelItem.coordinate
					});
					backgroundShape.setZIndex(-1);
					if (rotation) {
						var matrix = labelContentShape.getMatrix();
						backgroundShape.setMatrix(matrix);
					}
				}
			}
		});
	};
	Labels$1.prototype.createOffscreenGroup = function() {
		return new (this.container.getGroupBase())({});
	};
	Labels$1.prototype.adjustLabel = function(items, shapesMap) {
		each_default(items, function(item) {
			if (item) {
				var id$1 = item.id;
				var labelGroup = shapesMap[id$1];
				if (!labelGroup.destroyed) {
					var labelShapes = labelGroup.findAll(function(ele) {
						return ele.get("type") !== "path";
					});
					each_default(labelShapes, function(labelShape) {
						if (labelShape) {
							if (item.offsetX) labelShape.attr("x", labelShape.attr("x") + item.offsetX);
							if (item.offsetY) labelShape.attr("y", labelShape.attr("y") + item.offsetY);
						}
					});
				}
			}
		});
	};
	return Labels$1;
}();
var labels_default = Labels;

//#endregion
//#region node_modules/@antv/g2/esm/geometry/label/base.js
function avg(arr) {
	var sum = 0;
	each_default(arr, function(value$1) {
		sum += value$1;
	});
	return sum / arr.length;
}
/**
* Geometry Label 基类，用于生成 Geometry 下所有 label 的配置项信息
*/
var GeometryLabel = function() {
	function GeometryLabel$1(geometry$34) {
		this.geometry = geometry$34;
	}
	GeometryLabel$1.prototype.getLabelItems = function(mapppingArray) {
		var _this = this;
		var items = [];
		var labelCfgs = this.getLabelCfgs(mapppingArray);
		each_default(mapppingArray, function(mappingData, index) {
			var labelCfg = labelCfgs[index];
			if (!labelCfg || is_nil_default(mappingData.x) || is_nil_default(mappingData.y)) {
				items.push(null);
				return;
			}
			var labelContent = !is_array_default(labelCfg.content) ? [labelCfg.content] : labelCfg.content;
			labelCfg.content = labelContent;
			var total = labelContent.length;
			each_default(labelContent, function(content, subIndex) {
				if (is_nil_default(content) || content === "") {
					items.push(null);
					return;
				}
				var item = __assign(__assign({}, labelCfg), _this.getLabelPoint(labelCfg, mappingData, subIndex));
				if (!item.textAlign) item.textAlign = _this.getLabelAlign(item, subIndex, total);
				if (item.offset <= 0) item.labelLine = null;
				items.push(item);
			});
		});
		return items;
	};
	GeometryLabel$1.prototype.render = function(mappingArray, isUpdate) {
		if (isUpdate === void 0) isUpdate = false;
		return __awaiter(this, void 0, void 0, function() {
			var labelItems, labelsRenderer, shapes;
			return __generator(this, function(_a$5) {
				switch (_a$5.label) {
					case 0:
						labelItems = this.getLabelItems(mappingArray);
						labelsRenderer = this.getLabelsRenderer();
						shapes = this.getGeometryShapes();
						return [4, labelsRenderer.render(labelItems, shapes, isUpdate)];
					case 1:
						_a$5.sent();
						return [2];
				}
			});
		});
	};
	GeometryLabel$1.prototype.clear = function() {
		var labelsRenderer = this.labelsRenderer;
		if (labelsRenderer) labelsRenderer.clear();
	};
	GeometryLabel$1.prototype.destroy = function() {
		var labelsRenderer = this.labelsRenderer;
		if (labelsRenderer) labelsRenderer.destroy();
		this.labelsRenderer = null;
	};
	GeometryLabel$1.prototype.getCoordinate = function() {
		return this.geometry.coordinate;
	};
	/**
	* 获取 label 的默认配置
	*/
	GeometryLabel$1.prototype.getDefaultLabelCfg = function(offset, position) {
		var geometry$34 = this.geometry;
		var type = geometry$34.type, theme$3 = geometry$34.theme;
		if (type === "polygon" || type === "interval" && position === "middle" || offset < 0 && ![
			"line",
			"point",
			"path"
		].includes(type)) return get_default(theme$3, "innerLabels", {});
		return get_default(theme$3, "labels", {});
	};
	/**
	* 获取当前 label 的最终配置
	* @param labelCfg
	*/
	GeometryLabel$1.prototype.getThemedLabelCfg = function(labelCfg) {
		var geometry$34 = this.geometry;
		var defaultLabelCfg = this.getDefaultLabelCfg();
		var type = geometry$34.type, theme$3 = geometry$34.theme;
		var themedLabelCfg;
		if (type === "polygon" || labelCfg.offset < 0 && ![
			"line",
			"point",
			"path"
		].includes(type)) themedLabelCfg = deep_mix_default({}, defaultLabelCfg, theme$3.innerLabels, labelCfg);
		else themedLabelCfg = deep_mix_default({}, defaultLabelCfg, theme$3.labels, labelCfg);
		return themedLabelCfg;
	};
	/**
	* 设置 label 位置
	* @param labelPointCfg
	* @param mappingData
	* @param index
	* @param position
	*/
	GeometryLabel$1.prototype.setLabelPosition = function(labelPointCfg, mappingData, index, position) {};
	/**
	* @desc 获取 label offset
	*/
	GeometryLabel$1.prototype.getLabelOffset = function(offset) {
		var coordinate$10 = this.getCoordinate();
		var vector = this.getOffsetVector(offset);
		return coordinate$10.isTransposed ? vector[0] : vector[1];
	};
	/**
	* 获取每个 label 的偏移量 (矢量)
	* @param labelCfg
	* @param index
	* @param total
	* @return {Point} offsetPoint
	*/
	GeometryLabel$1.prototype.getLabelOffsetPoint = function(labelCfg, index, total) {
		var offset = labelCfg.offset;
		var transposed = this.getCoordinate().isTransposed;
		var dim = transposed ? "x" : "y";
		var factor = transposed ? 1 : -1;
		var offsetPoint = {
			x: 0,
			y: 0
		};
		if (index > 0 || total === 1) offsetPoint[dim] = offset * factor;
		else offsetPoint[dim] = offset * factor * -1;
		return offsetPoint;
	};
	/**
	* 获取每个 label 的位置
	* @param labelCfg
	* @param mappingData
	* @param index
	* @returns label point
	*/
	GeometryLabel$1.prototype.getLabelPoint = function(labelCfg, mappingData, index) {
		var coordinate$10 = this.getCoordinate();
		var total = labelCfg.content.length;
		function getDimValue(value$1, idx, isAvg) {
			if (isAvg === void 0) isAvg = false;
			var v = value$1;
			if (is_array_default(v)) if (labelCfg.content.length === 1) if (isAvg) v = avg(v);
			else if (v.length <= 2) v = v[value$1.length - 1];
			else v = avg(v);
			else v = v[idx];
			return v;
		}
		var label$16 = {
			content: labelCfg.content[index],
			x: 0,
			y: 0,
			start: {
				x: 0,
				y: 0
			},
			color: "#fff"
		};
		var shape = is_array_default(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;
		var isFunnel = shape === "funnel" || shape === "pyramid";
		if (this.geometry.type === "polygon") {
			var centroid = getPolygonCentroid(mappingData.x, mappingData.y);
			label$16.x = centroid[0];
			label$16.y = centroid[1];
		} else if (this.geometry.type === "interval" && !isFunnel) {
			label$16.x = getDimValue(mappingData.x, index, true);
			label$16.y = getDimValue(mappingData.y, index);
		} else {
			label$16.x = getDimValue(mappingData.x, index);
			label$16.y = getDimValue(mappingData.y, index);
		}
		if (isFunnel) {
			var nextPoints = get_default(mappingData, "nextPoints");
			var points = get_default(mappingData, "points");
			if (nextPoints) {
				var point1 = coordinate$10.convert(points[1]);
				var point2 = coordinate$10.convert(nextPoints[1]);
				label$16.x = (point1.x + point2.x) / 2;
				label$16.y = (point1.y + point2.y) / 2;
			} else if (shape === "pyramid") {
				var point1 = coordinate$10.convert(points[1]);
				var point2 = coordinate$10.convert(points[2]);
				label$16.x = (point1.x + point2.x) / 2;
				label$16.y = (point1.y + point2.y) / 2;
			}
		}
		if (labelCfg.position) this.setLabelPosition(label$16, mappingData, index, labelCfg.position);
		var offsetPoint = this.getLabelOffsetPoint(labelCfg, index, total);
		label$16.start = {
			x: label$16.x,
			y: label$16.y
		};
		label$16.x += offsetPoint.x;
		label$16.y += offsetPoint.y;
		label$16.color = mappingData.color;
		return label$16;
	};
	/**
	* 获取文本的对齐方式
	* @param item
	* @param index
	* @param total
	* @returns
	*/
	GeometryLabel$1.prototype.getLabelAlign = function(item, index, total) {
		var align = "center";
		if (this.getCoordinate().isTransposed) {
			var offset = item.offset;
			if (offset < 0) align = "right";
			else if (offset === 0) align = "center";
			else align = "left";
			if (total > 1 && index === 0) {
				if (align === "right") align = "left";
				else if (align === "left") align = "right";
			}
		}
		return align;
	};
	/**
	* 获取每一个 label 的唯一 id
	* @param mappingData label 对应的图形的绘制数据
	*/
	GeometryLabel$1.prototype.getLabelId = function(mappingData) {
		var geometry$34 = this.geometry;
		var type = geometry$34.type;
		var xScale = geometry$34.getXScale();
		var yScale = geometry$34.getYScale();
		var origin = mappingData[FIELD_ORIGIN];
		var labelId = geometry$34.getElementId(mappingData);
		if (type === "line" || type === "area") labelId += " ".concat(origin[xScale.field]);
		else if (type === "path") labelId += " ".concat(origin[xScale.field], "-").concat(origin[yScale.field]);
		return labelId;
	};
	GeometryLabel$1.prototype.getLabelsRenderer = function() {
		var _a$5 = this.geometry, labelsContainer = _a$5.labelsContainer, labelOption = _a$5.labelOption, canvasRegion = _a$5.canvasRegion, animateOption = _a$5.animateOption;
		var coordinate$10 = this.geometry.coordinate;
		var labelsRenderer = this.labelsRenderer;
		if (!labelsRenderer) {
			labelsRenderer = new labels_default({
				container: labelsContainer,
				layout: get_default(labelOption, ["cfg", "layout"], { type: this.defaultLayout })
			});
			this.labelsRenderer = labelsRenderer;
		}
		labelsRenderer.region = canvasRegion;
		labelsRenderer.animate = animateOption ? getDefaultAnimateCfg("label", coordinate$10) : false;
		return labelsRenderer;
	};
	GeometryLabel$1.prototype.getLabelCfgs = function(mapppingArray) {
		var _this = this;
		var geometry$34 = this.geometry;
		var labelOption = geometry$34.labelOption, scales = geometry$34.scales, coordinate$10 = geometry$34.coordinate;
		var _a$5 = labelOption, fields = _a$5.fields, callback = _a$5.callback, cfg = _a$5.cfg;
		var labelScales = fields.map(function(field$5) {
			return scales[field$5];
		});
		var labelCfgs = [];
		each_default(mapppingArray, function(mappingData, index) {
			var origin = mappingData[FIELD_ORIGIN];
			var originText = _this.getLabelText(origin, labelScales);
			var callbackCfg;
			if (callback) {
				var originValues = fields.map(function(field$5) {
					return origin[field$5];
				});
				callbackCfg = callback.apply(void 0, __spreadArray([], __read(originValues), false));
				if (is_nil_default(callbackCfg)) {
					labelCfgs.push(null);
					return;
				}
			}
			var labelCfg = __assign(__assign({
				id: _this.getLabelId(mappingData),
				elementId: _this.geometry.getElementId(mappingData),
				data: origin,
				mappingData,
				coordinate: coordinate$10
			}, cfg), callbackCfg);
			if (is_function_default(labelCfg.position)) labelCfg.position = labelCfg.position(origin, mappingData, index);
			var offset = _this.getLabelOffset(labelCfg.offset || 0);
			var defaultLabelCfg = _this.getDefaultLabelCfg(offset, labelCfg.position);
			labelCfg = deep_mix_default({}, defaultLabelCfg, labelCfg);
			labelCfg.offset = _this.getLabelOffset(labelCfg.offset || 0);
			var content = labelCfg.content;
			if (is_function_default(content)) labelCfg.content = content(origin, mappingData, index);
			else if (is_undefined_default(content)) labelCfg.content = originText[0];
			labelCfgs.push(labelCfg);
		});
		return labelCfgs;
	};
	GeometryLabel$1.prototype.getLabelText = function(origin, scales) {
		var labelTexts = [];
		each_default(scales, function(scale$4) {
			var value$1 = origin[scale$4.field];
			if (is_array_default(value$1)) value$1 = value$1.map(function(subVal) {
				return scale$4.getText(subVal);
			});
			else value$1 = scale$4.getText(value$1);
			if (is_nil_default(value$1) || value$1 === "") labelTexts.push(null);
			else labelTexts.push(value$1);
		});
		return labelTexts;
	};
	GeometryLabel$1.prototype.getOffsetVector = function(offset) {
		if (offset === void 0) offset = 0;
		var coordinate$10 = this.getCoordinate();
		var actualOffset = 0;
		if (is_number_default(offset)) actualOffset = offset;
		return coordinate$10.isTransposed ? coordinate$10.applyMatrix(actualOffset, 0) : coordinate$10.applyMatrix(0, actualOffset);
	};
	GeometryLabel$1.prototype.getGeometryShapes = function() {
		var geometry$34 = this.geometry;
		var shapes = {};
		each_default(geometry$34.elementsMap, function(element, id$1) {
			shapes[id$1] = element.shape;
		});
		each_default(geometry$34.getOffscreenGroup().getChildren(), function(child) {
			var id$1 = geometry$34.getElementId(child.get("origin").mappingData);
			shapes[id$1] = child;
		});
		return shapes;
	};
	return GeometryLabel$1;
}();
var base_default = GeometryLabel;

//#endregion
//#region node_modules/@antv/g2/esm/util/attr.js
/**
* @ignore
* get the mapping value by attribute, if mapping value is nil, return def
* @param attr
* @param value
* @param def
* @returns get mapping value
*/
function getMappingValue(attr, value$1, def) {
	if (!attr) return def;
	var r;
	if (attr.callback && attr.callback.length > 1) {
		var restArgs = Array(attr.callback.length - 1).fill("");
		r = attr.mapping.apply(attr, __spreadArray([value$1], __read(restArgs), false)).join("");
	} else r = attr.mapping(value$1).join("");
	return r || def;
}

//#endregion
//#region node_modules/@antv/g2/esm/util/marker.js
/** @ignore */
var MarkerSymbols = {
	hexagon: function(x, y, r) {
		var diffX = r / 2 * Math.sqrt(3);
		return [
			[
				"M",
				x,
				y - r
			],
			[
				"L",
				x + diffX,
				y - r / 2
			],
			[
				"L",
				x + diffX,
				y + r / 2
			],
			[
				"L",
				x,
				y + r
			],
			[
				"L",
				x - diffX,
				y + r / 2
			],
			[
				"L",
				x - diffX,
				y - r / 2
			],
			["Z"]
		];
	},
	bowtie: function(x, y, r) {
		var diffY = r - 1.5;
		return [
			[
				"M",
				x - r,
				y - diffY
			],
			[
				"L",
				x + r,
				y + diffY
			],
			[
				"L",
				x + r,
				y - diffY
			],
			[
				"L",
				x - r,
				y + diffY
			],
			["Z"]
		];
	},
	cross: function(x, y, r) {
		return [
			[
				"M",
				x - r,
				y - r
			],
			[
				"L",
				x + r,
				y + r
			],
			[
				"M",
				x + r,
				y - r
			],
			[
				"L",
				x - r,
				y + r
			]
		];
	},
	tick: function(x, y, r) {
		return [
			[
				"M",
				x - r / 2,
				y - r
			],
			[
				"L",
				x + r / 2,
				y - r
			],
			[
				"M",
				x,
				y - r
			],
			[
				"L",
				x,
				y + r
			],
			[
				"M",
				x - r / 2,
				y + r
			],
			[
				"L",
				x + r / 2,
				y + r
			]
		];
	},
	plus: function(x, y, r) {
		return [
			[
				"M",
				x - r,
				y
			],
			[
				"L",
				x + r,
				y
			],
			[
				"M",
				x,
				y - r
			],
			[
				"L",
				x,
				y + r
			]
		];
	},
	hyphen: function(x, y, r) {
		return [[
			"M",
			x - r,
			y
		], [
			"L",
			x + r,
			y
		]];
	},
	line: function(x, y, r) {
		return [[
			"M",
			x,
			y - r
		], [
			"L",
			x,
			y + r
		]];
	}
};

//#endregion
//#region node_modules/@antv/g2/esm/util/legend.js
/** 线条形 marker symbol */
var STROKES_SYMBOLS = [
	"line",
	"cross",
	"tick",
	"plus",
	"hyphen"
];
/**
* 处理用户配置的 marker style
* @param markerStyle
* @param userMarker.style
* @returns {ShapeAttrs} newStyle
*/
function handleUserMarkerStyle(markerStyle, style) {
	if (is_function_default(style)) return style(markerStyle);
	return deep_mix_default({}, markerStyle, style);
}
/**
* 根据 marker 是否为线条形 symbol, 来调整下样式
* @param symbol
* @param style
* @param color
*/
function adpatorMarkerStyle(marker, color$2) {
	var symbol = marker.symbol;
	if (is_string_default(symbol) && STROKES_SYMBOLS.indexOf(symbol) !== -1) {
		var markerStyle = get_default(marker, "style", {});
		var lineWidth = get_default(markerStyle, "lineWidth", 1);
		var stroke = markerStyle.stroke || markerStyle.fill || color$2;
		marker.style = deep_mix_default({}, marker.style, {
			lineWidth,
			stroke,
			fill: null
		});
	}
}
/**
* 设置 marker 的 symbol，将 字符串的 symbol 转换为真正的绘制命令
* @param marker
*/
function setMarkerSymbol(marker) {
	var symbol = marker.symbol;
	if (is_string_default(symbol) && MarkerSymbols[symbol]) marker.symbol = MarkerSymbols[symbol];
}
/**
* @ignore
* get the legend layout from direction
* @param direction
* @returns layout 'horizontal' | 'vertical'
*/
function getLegendLayout(direction$1) {
	return direction$1.startsWith(DIRECTION.LEFT) || direction$1.startsWith(DIRECTION.RIGHT) ? "vertical" : "horizontal";
}
/**
* @ignore
* get the legend items
* @param view
* @param geometry
* @param attr
* @param themeMarker
* @param markerCfg
* @returns legend items
*/
function getLegendItems(view, geometry$34, attr, themeMarker, userMarker) {
	var scale$4 = attr.getScale(attr.type);
	if (scale$4.isCategory) {
		var field_1 = scale$4.field;
		var colorAttr_1 = geometry$34.getAttribute("color");
		var shapeAttr_1 = geometry$34.getAttribute("shape");
		var defaultColor_1 = view.getTheme().defaultColor;
		var isInPolar_1 = geometry$34.coordinate.isPolar;
		return scale$4.getTicks().map(function(tick, index) {
			var _a$5;
			var text = tick.text, scaleValue = tick.value;
			var name = text;
			var value$1 = scale$4.invert(scaleValue);
			var unchecked = view.filterFieldData(field_1, [(_a$5 = {}, _a$5[field_1] = value$1, _a$5)]).length === 0;
			each_default(view.views, function(subView) {
				var _a$6;
				if (!subView.filterFieldData(field_1, [(_a$6 = {}, _a$6[field_1] = value$1, _a$6)]).length) unchecked = true;
			});
			var color$2 = getMappingValue(colorAttr_1, value$1, defaultColor_1);
			var shape = getMappingValue(shapeAttr_1, value$1, "point");
			var marker = geometry$34.getShapeMarker(shape, {
				color: color$2,
				isInPolar: isInPolar_1
			});
			var markerCfg = userMarker;
			if (is_function_default(markerCfg)) markerCfg = markerCfg(name, index, __assign({
				name,
				value: value$1
			}, deep_mix_default({}, themeMarker, marker)));
			marker = deep_mix_default({}, themeMarker, marker, omit(__assign({}, markerCfg), ["style"]));
			adpatorMarkerStyle(marker, color$2);
			if (markerCfg && markerCfg.style) marker.style = handleUserMarkerStyle(marker.style, markerCfg.style);
			setMarkerSymbol(marker);
			return {
				id: value$1,
				name,
				value: value$1,
				marker,
				unchecked
			};
		});
	}
	return [];
}
/**
*
* @ignore
* custom legend 的 items 获取
* @param themeMarker
* @param userMarker
* @param customItems
*/
function getCustomLegendItems(themeMarker, userMarker, customItems) {
	return customItems.map(function(item, index) {
		var markerCfg = userMarker;
		if (is_function_default(markerCfg)) markerCfg = markerCfg(item.name, index, deep_mix_default({}, themeMarker, item));
		var itemMarker = is_function_default(item.marker) ? item.marker(item.name, index, deep_mix_default({}, themeMarker, item)) : item.marker;
		var marker = deep_mix_default({}, themeMarker, markerCfg, itemMarker);
		setMarkerSymbol(marker);
		item.marker = marker;
		return item;
	});
}
/**
* get the legend cfg from theme, will mix the common cfg of legend theme
*
* @param theme view theme object
* @param direction legend direction
* @returns legend theme cfg
*/
function getLegendThemeCfg(theme$3, direction$1) {
	var legendTheme = get_default(theme$3, ["components", "legend"], {});
	return deep_mix_default({}, get_default(legendTheme, ["common"], {}), deep_mix_default({}, get_default(legendTheme, [direction$1], {})));
}

//#endregion
//#region node_modules/@antv/g2/esm/geometry/shape/util/get-path-points.js
function isValueEmpty(value$1) {
	if (value$1) return false;
	return value$1 === null || value$1 === void 0 || isNaN(value$1);
}
function isYNil(point$1) {
	if (is_array_default(point$1)) return isValueEmpty(point$1[1].y);
	var value$1 = point$1.y;
	return is_array_default(value$1) ? isValueEmpty(value$1[0]) : isValueEmpty(value$1);
}
/**
* @ignore
* 分割数据，用于处理在一组点数据中，y 对应的数值存在 null/undefined/NaN 的情况
* 应用于折线图、区域图以及路径图
*
* ```typescript
* // return [[{x: 1, y: 2}, {x: 3, y: 3}]]
* getPathPoints([{x: 1, y: 2}, {x: 2, y: null}, {x: 3, y: 3}], true);
* // return [[{x: 1, y: 2}], [{x: 3, y: 3}]]
* getPathPoints([{x: 1, y: 2}, {x: 2, y: null}, {x: 3, y: 3}], false);
* // return [[[{ x: 1, y: 10 }, { x: 2, y: 2 }], [{ x: 9, y: 34 }, { x: 1, y: 1 }]]]
* getPathPoints([
*   [{ x: 1, y: 10 }, { x: 2, y: 2 }],
*   [{ x: 4, y: 2 }, { x: 8, y: NaN }],
*   [{ x: 9, y: 34 }, { x: 1, y: 1 }],
* ], true);
* ```
*
* @param points 要进行处理点集合
* @param connectNulls 是否连接空值数据
* @param showSinglePoint 是否展示孤立点
* @returns 返回处理后的点集合
*/
function getPathPoints(points, connectNulls, showSinglePoint) {
	if (connectNulls === void 0) connectNulls = false;
	if (showSinglePoint === void 0) showSinglePoint = true;
	if (!points.length || points.length === 1 && !showSinglePoint) return [];
	if (connectNulls) {
		var filtered = [];
		for (var i = 0, len = points.length; i < len; i++) {
			var point$1 = points[i];
			if (!isYNil(point$1)) filtered.push(point$1);
		}
		return [filtered];
	}
	var result = [];
	var tmp = [];
	for (var i = 0, len = points.length; i < len; i++) {
		var point$1 = points[i];
		if (isYNil(point$1)) {
			if (tmp.length) {
				if (!(tmp.length === 1 && !showSinglePoint)) result.push(tmp);
				tmp = [];
			}
		} else tmp.push(point$1);
	}
	if (tmp.length) result.push(tmp);
	return result;
}
/**
* 获取小提琴图的边界 path
* @param points
* @returns
*/
function getViolinPath(points) {
	var path = [];
	for (var i = 0; i < points.length; i++) {
		var point$1 = points[i];
		if (point$1) {
			var action = i === 0 ? "M" : "L";
			path.push([
				action,
				point$1.x,
				point$1.y
			]);
		}
	}
	var first = points[0];
	if (first) {
		path.push([
			"L",
			first.x,
			first.y
		]);
		path.push(["z"]);
	}
	return path;
}
/**
* 获取小提琴图 平滑的边界 path
* @param points
* @returns
*/
function getSmoothViolinPath(points) {
	var half = points.length / 2;
	var leftPoints = [];
	var rightPoints = [];
	for (var i = 0; i < points.length; i++) if (i < half) leftPoints.push(points[i]);
	else rightPoints.push(points[i]);
	var leftPath = getSplinePath$1(leftPoints, false);
	var rightPath = getSplinePath$1(rightPoints, false);
	if (rightPoints.length) leftPath.push([
		"L",
		rightPoints[0].x,
		rightPoints[0].y
	]);
	rightPath.shift();
	var path = leftPath.concat(rightPath);
	if (leftPoints.length) path.push([
		"L",
		leftPoints[0].x,
		leftPoints[0].y
	]);
	path.push(["z"]);
	return path;
}

//#endregion
//#region node_modules/@antv/g2/esm/geometry/shape/util/get-style.js
/**
* @ignore
* 获取 Shape 的图形属性
* @param cfg
* @param isStroke 是否需要描边
* @param isFill 是否需要填充
* @param [sizeName] 可选，表示图形大小的属性，lineWidth 或者 r
* @returns
*/
function getStyle(cfg, isStroke, isFill, sizeName) {
	if (sizeName === void 0) sizeName = "";
	var _a$5 = cfg.style, style = _a$5 === void 0 ? {} : _a$5, defaultStyle = cfg.defaultStyle, color$2 = cfg.color, size$1 = cfg.size;
	var attrs = __assign(__assign({}, defaultStyle), style);
	if (color$2) {
		if (isStroke) {
			if (!style.stroke) attrs.stroke = color$2;
		}
		if (isFill) {
			if (!style.fill) attrs.fill = color$2;
		}
	}
	if (sizeName && is_nil_default(style[sizeName]) && !is_nil_default(size$1)) attrs[sizeName] = size$1;
	return attrs;
}
/**
* 获取 矩形背景 的样式
* @param cfg
*/
function getBackgroundRectStyle(cfg) {
	return deep_mix_default({}, {
		fill: "#CCD6EC",
		fillOpacity: .3
	}, get_default(cfg, ["background", "style"]));
}

//#endregion
//#region node_modules/@antv/g2/esm/geometry/shape/util/split-points.js
/**
* @ignore
* 拆分点数据
* @example
* // result: [{x: 20, y: 20}, {x: 20, y: 30}]
* splitPoints({x: 20,y: [20, 30]});
* @example
* // result: [{x: 20, y: 20}, {x: 30, y: 30}]
* splitPoints({x: [20, 30],y: [20, 30]});
* @param obj
*/
function splitPoints(obj) {
	var x = obj.x;
	return (is_array_default(obj.y) ? obj.y : [obj.y]).map(function(eachY, index) {
		return {
			x: is_array_default(x) ? x[index] : x,
			y: eachY
		};
	});
}

//#endregion
//#region node_modules/@antv/g2/esm/geometry/shape/line/util.js
var LineSymbols = {
	line: function(x, y, r) {
		return [[
			"M",
			x - r,
			y
		], [
			"L",
			x + r,
			y
		]];
	},
	dot: function(x, y, r) {
		return [[
			"M",
			x - r,
			y
		], [
			"L",
			x + r,
			y
		]];
	},
	dash: function(x, y, r) {
		return [[
			"M",
			x - r,
			y
		], [
			"L",
			x + r,
			y
		]];
	},
	smooth: function(x, y, r) {
		return [
			[
				"M",
				x - r,
				y
			],
			[
				"A",
				r / 2,
				r / 2,
				0,
				1,
				1,
				x,
				y
			],
			[
				"A",
				r / 2,
				r / 2,
				0,
				1,
				0,
				x + r,
				y
			]
		];
	},
	hv: function(x, y, r) {
		return [
			[
				"M",
				x - r - 1,
				y - 2.5
			],
			[
				"L",
				x,
				y - 2.5
			],
			[
				"L",
				x,
				y + 2.5
			],
			[
				"L",
				x + r + 1,
				y + 2.5
			]
		];
	},
	vh: function(x, y, r) {
		return [
			[
				"M",
				x - r - 1,
				y + 2.5
			],
			[
				"L",
				x,
				y + 2.5
			],
			[
				"L",
				x,
				y - 2.5
			],
			[
				"L",
				x + r + 1,
				y - 2.5
			]
		];
	},
	hvh: function(x, y, r) {
		return [
			[
				"M",
				x - (r + 1),
				y + 2.5
			],
			[
				"L",
				x - r / 2,
				y + 2.5
			],
			[
				"L",
				x - r / 2,
				y - 2.5
			],
			[
				"L",
				x + r / 2,
				y - 2.5
			],
			[
				"L",
				x + r / 2,
				y + 2.5
			],
			[
				"L",
				x + r + 1,
				y + 2.5
			]
		];
	},
	vhv: function(x, y) {
		return [
			[
				"M",
				x - 5,
				y + 2.5
			],
			[
				"L",
				x - 5,
				y
			],
			[
				"L",
				x,
				y
			],
			[
				"L",
				x,
				y - 3
			],
			[
				"L",
				x,
				y + 3
			],
			[
				"L",
				x + 6.5,
				y + 3
			]
		];
	}
};
/**
* Gets line marker
* @ignore
* @param markerCfg
* @param shapeType
* @returns 返回 Line 的 marker 配置
*/
function getLineMarker(markerCfg, shapeType) {
	var color$2 = markerCfg.color;
	return {
		symbol: LineSymbols[shapeType],
		style: {
			lineWidth: 2,
			r: 6,
			stroke: color$2
		}
	};
}

//#endregion
//#region node_modules/@antv/g2/esm/geometry/shape/line/index.js
function getShapeAttrs$1(cfg, smooth, constraint) {
	var isStack = cfg.isStack, connectNulls = cfg.connectNulls, isInCircle = cfg.isInCircle, showSinglePoint = cfg.showSinglePoint;
	var shapeAttrs = getStyle(cfg, true, false, "lineWidth");
	var points = getPathPoints(cfg.points, connectNulls, showSinglePoint);
	var path = [];
	for (var i = 0, len = points.length; i < len; i++) {
		var eachLinePoints = points[i];
		path = path.concat(getPath$3(eachLinePoints, isInCircle, isStack, smooth, constraint, shapeAttrs));
	}
	shapeAttrs.path = path;
	return shapeAttrs;
}
function getSinglePath(points, isInCircle, smooth, constraint, style) {
	if (points.length === 1) return [
		[
			"M",
			points[0].x,
			points[0].y - style.lineWidth / 2
		],
		[
			"L",
			points[0].x,
			points[0].y
		],
		[
			"L",
			points[0].x,
			points[0].y + style.lineWidth / 2
		]
	];
	var path;
	if (!smooth) {
		path = getLinePath(points, false);
		if (isInCircle) path.push(["Z"]);
	} else {
		if (isInCircle && points.length) points.push({
			x: points[0].x,
			y: points[0].y
		});
		path = getSplinePath$1(points, false, constraint);
	}
	return path;
}
function getRangePath(points, isInCircle, isStack, smooth, constraint, style) {
	var topPoints = [];
	var bottomPoints = [];
	each_default(points, function(point$1) {
		var result = splitPoints(point$1);
		topPoints.push(result[1]);
		bottomPoints.push(result[0]);
	});
	var topPath = getSinglePath(topPoints, isInCircle, smooth, constraint, style);
	var bottomPath = getSinglePath(bottomPoints, isInCircle, smooth, constraint, style);
	if (isStack) return topPath;
	return topPath.concat(bottomPath);
}
/**
* 获取折线图 path
*/
function getPath$3(points, isInCircle, isStack, smooth, constraint, style) {
	if (points.length) {
		var first = points[0];
		return is_array_default(first.y) ? getRangePath(points, isInCircle, isStack, smooth, constraint, style) : getSinglePath(points, isInCircle, smooth, constraint, style);
	}
	return [];
}
var LineShapeFactory = registerShapeFactory("line", { defaultShapeType: "line" });
each_default([
	"line",
	"dot",
	"dash",
	"smooth"
], function(shapeType) {
	registerShape("line", shapeType, {
		draw: function(cfg, container) {
			var smooth = shapeType === "smooth";
			var constraint;
			if (smooth) {
				var _a$5 = this.coordinate, start = _a$5.start, end = _a$5.end;
				constraint = [[start.x, end.y], [end.x, start.y]];
			}
			var attrs = getShapeAttrs$1(cfg, smooth, constraint);
			return container.addShape({
				type: "path",
				attrs,
				name: "line",
				capture: !smooth
			});
		},
		getMarker: function(markerCfg) {
			return getLineMarker(markerCfg, shapeType);
		}
	});
});

//#endregion
//#region node_modules/@antv/g2/esm/core.js
var VERSION = "4.2.12";
var Util = {
	getLegendItems,
	translate,
	rotate,
	zoom,
	transform: transform$4,
	getAngle,
	getSectorPath,
	polarToCartesian,
	getDelegationObject,
	getTooltipItems,
	getMappingValue,
	getPath: getPath$3,
	getPathPoints
};

//#endregion
//#region node_modules/@antv/g2/esm/theme/style-sheet/dark.js
var WHITE_COLORS = {
	100: "#000",
	95: "#0D0D0D",
	85: "#262626",
	65: "#595959",
	45: "#8C8C8C",
	25: "#BFBFBF",
	15: "#D9D9D9",
	6: "#F0F0F0"
};
var BLACK_COLORS = {
	100: "#FFFFFF",
	95: "#F2F2F2",
	85: "#D9D9D9",
	65: "#A6A6A6",
	45: "#737373",
	25: "#404040",
	15: "#262626",
	6: "#0F0F0F"
};
var QUALITATIVE_10 = [
	"#5B8FF9",
	"#5AD8A6",
	"#5D7092",
	"#F6BD16",
	"#E86452",
	"#6DC8EC",
	"#945FB9",
	"#FF9845",
	"#1E9493",
	"#FF99C3"
];
var QUALITATIVE_20 = [
	"#5B8FF9",
	"#CDDDFD",
	"#5AD8A6",
	"#CDF3E4",
	"#5D7092",
	"#CED4DE",
	"#F6BD16",
	"#FCEBB9",
	"#E86452",
	"#F8D0CB",
	"#6DC8EC",
	"#D3EEF9",
	"#945FB9",
	"#DECFEA",
	"#FF9845",
	"#FFE0C7",
	"#1E9493",
	"#BBDEDE",
	"#FF99C3",
	"#FFE0ED"
];
/** 单色顺序色板 */
var SINGLE_SEQUENCE = [
	"#B8E1FF",
	"#9AC5FF",
	"#7DAAFF",
	"#5B8FF9",
	"#3D76DD",
	"#085EC0",
	"#0047A5",
	"#00318A",
	"#001D70"
];
var createDarkStyleSheet = function(cfg) {
	if (cfg === void 0) cfg = {};
	var _a$5 = cfg.paletteQualitative10, paletteQualitative10 = _a$5 === void 0 ? QUALITATIVE_10 : _a$5, _b = cfg.paletteQualitative20, paletteQualitative20 = _b === void 0 ? QUALITATIVE_20 : _b;
	var _c = cfg.brandColor;
	var token$1 = {
		backgroundColor: "#141414",
		brandColor: _c === void 0 ? paletteQualitative10[0] : _c,
		subColor: "rgba(255,255,255,0.05)",
		paletteQualitative10,
		paletteQualitative20,
		paletteSemanticRed: "#F4664A",
		paletteSemanticGreen: "#30BF78",
		paletteSemanticYellow: "#FAAD14",
		paletteSequence: SINGLE_SEQUENCE,
		fontFamily: "\"Segoe UI\", Roboto, \"Helvetica Neue\", Arial,\n    \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\",\n    \"Noto Color Emoji\"",
		axisLineBorderColor: BLACK_COLORS[25],
		axisLineBorder: 1,
		axisLineDash: null,
		axisTitleTextFillColor: BLACK_COLORS[65],
		axisTitleTextFontSize: 12,
		axisTitleTextLineHeight: 12,
		axisTitleTextFontWeight: "normal",
		axisTitleSpacing: 12,
		axisDescriptionIconFillColor: WHITE_COLORS[85],
		axisTickLineBorderColor: BLACK_COLORS[25],
		axisTickLineLength: 4,
		axisTickLineBorder: 1,
		axisSubTickLineBorderColor: BLACK_COLORS[15],
		axisSubTickLineLength: 2,
		axisSubTickLineBorder: 1,
		axisLabelFillColor: BLACK_COLORS[45],
		axisLabelFontSize: 12,
		axisLabelLineHeight: 12,
		axisLabelFontWeight: "normal",
		axisLabelOffset: 8,
		axisGridBorderColor: BLACK_COLORS[15],
		axisGridBorder: 1,
		axisGridLineDash: null,
		legendTitleTextFillColor: BLACK_COLORS[45],
		legendTitleTextFontSize: 12,
		legendTitleTextLineHeight: 21,
		legendTitleTextFontWeight: "normal",
		legendMarkerColor: QUALITATIVE_10[0],
		legendMarkerSpacing: 8,
		legendMarkerSize: 4,
		legendCircleMarkerSize: 4,
		legendSquareMarkerSize: 4,
		legendLineMarkerSize: 5,
		legendItemNameFillColor: BLACK_COLORS[65],
		legendItemNameFontSize: 12,
		legendItemNameLineHeight: 12,
		legendItemNameFontWeight: "normal",
		legendItemSpacing: 24,
		legendItemMarginBottom: 12,
		legendSpacing: 16,
		legendPadding: [
			8,
			8,
			8,
			8
		],
		legendHorizontalPadding: [
			8,
			0,
			8,
			0
		],
		legendVerticalPadding: [
			0,
			8,
			0,
			8
		],
		legendPageNavigatorMarkerSize: 12,
		legendPageNavigatorMarkerInactiveFillColor: BLACK_COLORS[45],
		legendPageNavigatorMarkerInactiveFillOpacity: .45,
		legendPageNavigatorMarkerFillColor: BLACK_COLORS[45],
		legendPageNavigatorMarkerFillOpacity: 1,
		legendPageNavigatorTextFillColor: BLACK_COLORS[65],
		legendPageNavigatorTextFontSize: 12,
		sliderRailFillColor: BLACK_COLORS[15],
		sliderRailBorder: 0,
		sliderRailBorderColor: null,
		sliderRailWidth: 100,
		sliderRailHeight: 12,
		sliderLabelTextFillColor: BLACK_COLORS[45],
		sliderLabelTextFontSize: 12,
		sliderLabelTextLineHeight: 12,
		sliderLabelTextFontWeight: "normal",
		sliderHandlerFillColor: WHITE_COLORS[6],
		sliderHandlerWidth: 10,
		sliderHandlerHeight: 14,
		sliderHandlerBorder: 1,
		sliderHandlerBorderColor: WHITE_COLORS[25],
		annotationArcBorderColor: BLACK_COLORS[15],
		annotationArcBorder: 1,
		annotationLineBorderColor: BLACK_COLORS[25],
		annotationLineBorder: 1,
		annotationLineDash: null,
		annotationTextFillColor: BLACK_COLORS[65],
		annotationTextFontSize: 12,
		annotationTextLineHeight: 12,
		annotationTextFontWeight: "normal",
		annotationTextBorderColor: null,
		annotationTextBorder: 0,
		annotationRegionFillColor: BLACK_COLORS[100],
		annotationRegionFillOpacity: .06,
		annotationRegionBorder: 0,
		annotationRegionBorderColor: null,
		annotationDataMarkerLineLength: 16,
		tooltipCrosshairsBorderColor: BLACK_COLORS[25],
		tooltipCrosshairsBorder: 1,
		tooltipCrosshairsLineDash: null,
		tooltipContainerFillColor: "#1f1f1f",
		tooltipContainerFillOpacity: .95,
		tooltipContainerShadow: "0px 2px 4px rgba(0,0,0,.5)",
		tooltipContainerBorderRadius: 3,
		tooltipTextFillColor: BLACK_COLORS[65],
		tooltipTextFontSize: 12,
		tooltipTextLineHeight: 12,
		tooltipTextFontWeight: "bold",
		labelFillColor: BLACK_COLORS[65],
		labelFillColorDark: "#2c3542",
		labelFillColorLight: "#ffffff",
		labelFontSize: 12,
		labelLineHeight: 12,
		labelFontWeight: "normal",
		labelBorderColor: null,
		labelBorder: 0,
		innerLabelFillColor: WHITE_COLORS[100],
		innerLabelFontSize: 12,
		innerLabelLineHeight: 12,
		innerLabelFontWeight: "normal",
		innerLabelBorderColor: null,
		innerLabelBorder: 0,
		overflowLabelFillColor: BLACK_COLORS[65],
		overflowLabelFillColorDark: "#2c3542",
		overflowLabelFillColorLight: "#ffffff",
		overflowLabelFontSize: 12,
		overflowLabelLineHeight: 12,
		overflowLabelFontWeight: "normal",
		overflowLabelBorderColor: WHITE_COLORS[100],
		overflowLabelBorder: 1,
		labelLineBorder: 1,
		labelLineBorderColor: BLACK_COLORS[25],
		cSliderRailHieght: 16,
		cSliderBackgroundFillColor: "#416180",
		cSliderBackgroundFillOpacity: .05,
		cSliderForegroundFillColor: "#5B8FF9",
		cSliderForegroundFillOpacity: .15,
		cSliderHandlerHeight: 24,
		cSliderHandlerWidth: 10,
		cSliderHandlerFillColor: "#F7F7F7",
		cSliderHandlerFillOpacity: 1,
		cSliderHandlerHighlightFillColor: "#FFF",
		cSliderHandlerBorderColor: "#BFBFBF",
		cSliderHandlerBorder: 1,
		cSliderHandlerBorderRadius: 2,
		cSliderTextFillColor: "#fff",
		cSliderTextFillOpacity: .45,
		cSliderTextFontSize: 12,
		cSliderTextLineHeight: 12,
		cSliderTextFontWeight: "normal",
		cSliderTextBorderColor: null,
		cSliderTextBorder: 0,
		scrollbarTrackFillColor: "rgba(255,255,255,0.65)",
		scrollbarThumbFillColor: "rgba(0,0,0,0.35)",
		scrollbarThumbHighlightFillColor: "rgba(0,0,0,0.45)",
		pointFillColor: QUALITATIVE_10[0],
		pointFillOpacity: .95,
		pointSize: 4,
		pointBorder: 1,
		pointBorderColor: WHITE_COLORS[100],
		pointBorderOpacity: 1,
		pointActiveBorderColor: BLACK_COLORS[100],
		pointSelectedBorder: 2,
		pointSelectedBorderColor: BLACK_COLORS[100],
		pointInactiveFillOpacity: .3,
		pointInactiveBorderOpacity: .3,
		hollowPointSize: 4,
		hollowPointBorder: 1,
		hollowPointBorderColor: QUALITATIVE_10[0],
		hollowPointBorderOpacity: .95,
		hollowPointFillColor: WHITE_COLORS[100],
		hollowPointActiveBorder: 1,
		hollowPointActiveBorderColor: BLACK_COLORS[100],
		hollowPointActiveBorderOpacity: 1,
		hollowPointSelectedBorder: 2,
		hollowPointSelectedBorderColor: BLACK_COLORS[100],
		hollowPointSelectedBorderOpacity: 1,
		hollowPointInactiveBorderOpacity: .3,
		lineBorder: 2,
		lineBorderColor: QUALITATIVE_10[0],
		lineBorderOpacity: 1,
		lineActiveBorder: 3,
		lineSelectedBorder: 3,
		lineInactiveBorderOpacity: .3,
		areaFillColor: QUALITATIVE_10[0],
		areaFillOpacity: .25,
		areaActiveFillColor: QUALITATIVE_10[0],
		areaActiveFillOpacity: .5,
		areaSelectedFillColor: QUALITATIVE_10[0],
		areaSelectedFillOpacity: .5,
		areaInactiveFillOpacity: .3,
		hollowAreaBorderColor: QUALITATIVE_10[0],
		hollowAreaBorder: 2,
		hollowAreaBorderOpacity: 1,
		hollowAreaActiveBorder: 3,
		hollowAreaActiveBorderColor: BLACK_COLORS[100],
		hollowAreaSelectedBorder: 3,
		hollowAreaSelectedBorderColor: BLACK_COLORS[100],
		hollowAreaInactiveBorderOpacity: .3,
		intervalFillColor: QUALITATIVE_10[0],
		intervalFillOpacity: .95,
		intervalActiveBorder: 1,
		intervalActiveBorderColor: BLACK_COLORS[100],
		intervalActiveBorderOpacity: 1,
		intervalSelectedBorder: 2,
		intervalSelectedBorderColor: BLACK_COLORS[100],
		intervalSelectedBorderOpacity: 1,
		intervalInactiveBorderOpacity: .3,
		intervalInactiveFillOpacity: .3,
		hollowIntervalBorder: 2,
		hollowIntervalBorderColor: QUALITATIVE_10[0],
		hollowIntervalBorderOpacity: 1,
		hollowIntervalFillColor: WHITE_COLORS[100],
		hollowIntervalActiveBorder: 2,
		hollowIntervalActiveBorderColor: BLACK_COLORS[100],
		hollowIntervalSelectedBorder: 3,
		hollowIntervalSelectedBorderColor: BLACK_COLORS[100],
		hollowIntervalSelectedBorderOpacity: 1,
		hollowIntervalInactiveBorderOpacity: .3
	};
	return __assign(__assign({}, token$1), cfg);
};
var antvDark = createDarkStyleSheet();

//#endregion
//#region node_modules/@antv/g-canvas/esm/util/util.js
function getPixelRatio$1() {
	return window ? window.devicePixelRatio : 1;
}
/**
* 两点之间的距离
* @param {number} x1 起始点 x
* @param {number} y1 起始点 y
* @param {number} x2 结束点 x
* @param {number} y2 结束点 y
*/
function distance$2(x1, y1, x2, y2) {
	var dx = x1 - x2;
	var dy = y1 - y2;
	return Math.sqrt(dx * dx + dy * dy);
}
/**
* 是否在包围盒内
* @param {number} minX   包围盒开始的点 x
* @param {number} minY   包围盒开始的点 y
* @param {number} width  宽度
* @param {number} height 高度
* @param {[type]} x      检测点的 x
* @param {[type]} y      监测点的 y
*/
function inBox(minX, minY, width, height, x, y) {
	return x >= minX && x <= minX + width && y >= minY && y <= minY + height;
}
function intersectRect(box1, box2) {
	return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
}
function mergeRegion(region1, region2) {
	if (!region1 || !region2) return region1 || region2;
	return {
		minX: Math.min(region1.minX, region2.minX),
		minY: Math.min(region1.minY, region2.minY),
		maxX: Math.max(region1.maxX, region2.maxX),
		maxY: Math.max(region1.maxY, region2.maxY)
	};
}
/**
* 判断两个点是否重合，点坐标的格式为 [x, y]
* @param {Array} point1 第一个点
* @param {Array} point2 第二个点
*/
function isSamePoint$1(point1, point2) {
	return point1[0] === point2[0] && point1[1] === point2[1];
}

//#endregion
//#region node_modules/@antv/g-canvas/esm/util/parse.js
var regexLG$1 = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG$1 = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexPR$1 = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
var regexColorStop$1 = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;
function addStop$1(steps, gradient$1) {
	var arr = steps.match(regexColorStop$1);
	each_default(arr, function(item) {
		var itemArr = item.split(":");
		gradient$1.addColorStop(itemArr[0], itemArr[1]);
	});
}
/**
* 将边和填充设置的颜色转换成线性渐变对象
* @param {CanvasRenderingContext2D} context canvas 上下文
* @param {IElement}                 element  图形元素
* @param {string}                   gradientStr   颜色
* @returns {any} 渐变对象
*/
function parseLineGradient$1(context, element, gradientStr) {
	var arr = regexLG$1.exec(gradientStr);
	var angle$1 = parseFloat(arr[1]) % 360 * (Math.PI / 180);
	var steps = arr[2];
	var box$1 = element.getBBox();
	var start;
	var end;
	if (angle$1 >= 0 && angle$1 < 1 / 2 * Math.PI) {
		start = {
			x: box$1.minX,
			y: box$1.minY
		};
		end = {
			x: box$1.maxX,
			y: box$1.maxY
		};
	} else if (1 / 2 * Math.PI <= angle$1 && angle$1 < Math.PI) {
		start = {
			x: box$1.maxX,
			y: box$1.minY
		};
		end = {
			x: box$1.minX,
			y: box$1.maxY
		};
	} else if (Math.PI <= angle$1 && angle$1 < 3 / 2 * Math.PI) {
		start = {
			x: box$1.maxX,
			y: box$1.maxY
		};
		end = {
			x: box$1.minX,
			y: box$1.minY
		};
	} else {
		start = {
			x: box$1.minX,
			y: box$1.maxY
		};
		end = {
			x: box$1.maxX,
			y: box$1.minY
		};
	}
	var tanTheta = Math.tan(angle$1);
	var tanTheta2 = tanTheta * tanTheta;
	var x = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;
	var y = tanTheta * (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.y;
	var gradient$1 = context.createLinearGradient(start.x, start.y, x, y);
	addStop$1(steps, gradient$1);
	return gradient$1;
}
/**
* 将边和填充设置的颜色转换成圆形渐变对象
* @param {CanvasRenderingContext2D} context canvas 上下文
* @param {IElement}                 element  图形元素
* @param {string}                   gradientStr   颜色
* @returns {any} 渐变对象
*/
function parseRadialGradient$1(context, element, gradientStr) {
	var arr = regexRG$1.exec(gradientStr);
	var fx = parseFloat(arr[1]);
	var fy = parseFloat(arr[2]);
	var fr = parseFloat(arr[3]);
	var steps = arr[4];
	if (fr === 0) {
		var colors = steps.match(regexColorStop$1);
		return colors[colors.length - 1].split(":")[1];
	}
	var box$1 = element.getBBox();
	var width = box$1.maxX - box$1.minX;
	var height = box$1.maxY - box$1.minY;
	var r = Math.sqrt(width * width + height * height) / 2;
	var gradient$1 = context.createRadialGradient(box$1.minX + width * fx, box$1.minY + height * fy, 0, box$1.minX + width / 2, box$1.minY + height / 2, fr * r);
	addStop$1(steps, gradient$1);
	return gradient$1;
}
/**
* 边和填充设置的颜色转换成 pattern
* @param {CanvasRenderingContext2D} context canvas 上下文
* @param {IElement}                 element  图形元素
* @param {string}                   patternStr   生成 pattern 的字符串
*/
function parsePattern(context, element, patternStr) {
	if (element.get("patternSource") && element.get("patternSource") === patternStr) return element.get("pattern");
	var pattern$1;
	var img;
	var arr = regexPR$1.exec(patternStr);
	var repeat = arr[1];
	var source = arr[2];
	function onload() {
		pattern$1 = context.createPattern(img, repeat);
		element.set("pattern", pattern$1);
		element.set("patternSource", patternStr);
	}
	switch (repeat) {
		case "a":
			repeat = "repeat";
			break;
		case "x":
			repeat = "repeat-x";
			break;
		case "y":
			repeat = "repeat-y";
			break;
		case "n":
			repeat = "no-repeat";
			break;
		default: repeat = "no-repeat";
	}
	img = new Image();
	if (!source.match(/^data:/i)) img.crossOrigin = "Anonymous";
	img.src = source;
	if (img.complete) onload();
	else {
		img.onload = onload;
		img.src = img.src;
	}
	return pattern$1;
}
function parseStyle(context, element, color$2) {
	var bbox = element.getBBox();
	if (isNaN(bbox.x) || isNaN(bbox.y) || isNaN(bbox.width) || isNaN(bbox.height)) return color$2;
	if (is_string_default(color$2)) {
		if (color$2[1] === "(" || color$2[2] === "(") {
			if (color$2[0] === "l") return parseLineGradient$1(context, element, color$2);
			if (color$2[0] === "r") return parseRadialGradient$1(context, element, color$2);
			if (color$2[0] === "p") return parsePattern(context, element, color$2);
		}
		return color$2;
	}
	if (color$2 instanceof CanvasPattern) return color$2;
}
function parseRadius$2(radius) {
	var r1 = 0;
	var r2 = 0;
	var r3 = 0;
	var r4 = 0;
	if (is_array_default(radius)) if (radius.length === 1) r1 = r2 = r3 = r4 = radius[0];
	else if (radius.length === 2) {
		r1 = r3 = radius[0];
		r2 = r4 = radius[1];
	} else if (radius.length === 3) {
		r1 = radius[0];
		r2 = r4 = radius[1];
		r3 = radius[2];
	} else {
		r1 = radius[0];
		r2 = radius[1];
		r3 = radius[2];
		r4 = radius[3];
	}
	else r1 = r2 = r3 = r4 = radius;
	return [
		r1,
		r2,
		r3,
		r4
	];
}

//#endregion
//#region node_modules/@antv/g-canvas/esm/util/arc-params.js
function vMag$1(v) {
	return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
}
function vRatio$1(u, v) {
	return vMag$1(u) * vMag$1(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag$1(u) * vMag$1(v)) : 1;
}
function vAngle$1(u, v) {
	return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio$1(u, v));
}
function getArcParams(startPoint, params) {
	var rx = params[1];
	var ry = params[2];
	var xRotation = esm_default$2(to_radian_default(params[3]), Math.PI * 2);
	var arcFlag = params[4];
	var sweepFlag = params[5];
	var x1 = startPoint[0];
	var y1 = startPoint[1];
	var x2 = params[6];
	var y2 = params[7];
	var xp = Math.cos(xRotation) * (x1 - x2) / 2 + Math.sin(xRotation) * (y1 - y2) / 2;
	var yp = -1 * Math.sin(xRotation) * (x1 - x2) / 2 + Math.cos(xRotation) * (y1 - y2) / 2;
	var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
	if (lambda > 1) {
		rx *= Math.sqrt(lambda);
		ry *= Math.sqrt(lambda);
	}
	var diff$1 = rx * rx * (yp * yp) + ry * ry * (xp * xp);
	var f = diff$1 ? Math.sqrt((rx * rx * (ry * ry) - diff$1) / diff$1) : 1;
	if (arcFlag === sweepFlag) f *= -1;
	if (isNaN(f)) f = 0;
	var cxp = ry ? f * rx * yp / ry : 0;
	var cyp = rx ? f * -ry * xp / rx : 0;
	var cx = (x1 + x2) / 2 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
	var cy = (y1 + y2) / 2 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
	var u = [(xp - cxp) / rx, (yp - cyp) / ry];
	var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
	var theta = vAngle$1([1, 0], u);
	var dTheta = vAngle$1(u, v);
	if (vRatio$1(u, v) <= -1) dTheta = Math.PI;
	if (vRatio$1(u, v) >= 1) dTheta = 0;
	if (sweepFlag === 0 && dTheta > 0) dTheta = dTheta - 2 * Math.PI;
	if (sweepFlag === 1 && dTheta < 0) dTheta = dTheta + 2 * Math.PI;
	return {
		cx,
		cy,
		rx: isSamePoint$1(startPoint, [x2, y2]) ? 0 : rx,
		ry: isSamePoint$1(startPoint, [x2, y2]) ? 0 : ry,
		startAngle: theta,
		endAngle: theta + dTheta,
		xRotation,
		arcFlag,
		sweepFlag
	};
}

//#endregion
//#region node_modules/@antv/g-canvas/esm/util/arrow.js
var sin = Math.sin, cos = Math.cos, atan2 = Math.atan2, PI = Math.PI;
function _addDefaultArrow(shape, attrs, x1, y1, x2, y2, isStart) {
	var stroke = attrs.stroke, lineWidth = attrs.lineWidth;
	var x = x1 - x2;
	var y = y1 - y2;
	var rad = atan2(y, x);
	var arrowShape = new path_default$5({
		type: "path",
		canvas: shape.get("canvas"),
		isArrowShape: true,
		attrs: {
			path: "M" + 10 * cos(PI / 6) + "," + 10 * sin(PI / 6) + " L0,0 L" + 10 * cos(PI / 6) + ",-" + 10 * sin(PI / 6),
			stroke,
			lineWidth
		}
	});
	arrowShape.translate(x2, y2);
	arrowShape.rotateAtPoint(x2, y2, rad);
	shape.set(isStart ? "startArrowShape" : "endArrowShape", arrowShape);
}
/**
* 箭头 path 的设置要求
* 1. 箭头顶点坐标需要为 (0, 0)
* 2. 箭头夹角的中心分割线需要与 X 轴正方向对齐
*/
function _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, isStart) {
	var startArrow = attrs.startArrow, endArrow = attrs.endArrow, stroke = attrs.stroke, lineWidth = attrs.lineWidth;
	var arrowAttrs = isStart ? startArrow : endArrow;
	var d = arrowAttrs.d, arrowFill = arrowAttrs.fill, arrowStroke = arrowAttrs.stroke, arrowLineWidth = arrowAttrs.lineWidth, restAttrs = __rest(arrowAttrs, [
		"d",
		"fill",
		"stroke",
		"lineWidth"
	]);
	var x = x1 - x2;
	var y = y1 - y2;
	var rad = atan2(y, x);
	if (d) {
		x2 = x2 - cos(rad) * d;
		y2 = y2 - sin(rad) * d;
	}
	var arrowShape = new path_default$5({
		type: "path",
		canvas: shape.get("canvas"),
		isArrowShape: true,
		attrs: __assign(__assign({}, restAttrs), {
			stroke: arrowStroke || stroke,
			lineWidth: arrowLineWidth || lineWidth,
			fill: arrowFill
		})
	});
	arrowShape.translate(x2, y2);
	arrowShape.rotateAtPoint(x2, y2, rad);
	shape.set(isStart ? "startArrowShape" : "endArrowShape", arrowShape);
}
/**
* 如果自定义箭头并且有 d 需要做偏移，如果直接画，线条会超出箭头尖端，因此需要根据箭头偏移 d, 返回线需要缩短的距离
* |----------------
* |<|--------------
* |
* @param {number} x1 起始点 x
* @param {number} y1 起始点 y
* @param {number} x2 箭头作用点 x
* @param {number} y2 箭头作用点 y
* @param {number} d  箭头沿线条方向的偏移距离
* @return {{dx: number, dy: number}} 返回线条偏移距离
*/
function getShortenOffset(x1, y1, x2, y2, d) {
	var rad = atan2(y2 - y1, x2 - x1);
	return {
		dx: cos(rad) * d,
		dy: sin(rad) * d
	};
}
/**
* 绘制起始箭头
* @param {IShape} shape 图形
* @param {ShapeAttrs} attrs shape 的绘图属性
* @param {number} x1 起始点 x
* @param {number} y1 起始点 y
* @param {number} x2 箭头作用点 x
* @param {number} y2 箭头作用点 y
*/
function addStartArrow(shape, attrs, x1, y1, x2, y2) {
	if (typeof attrs.startArrow === "object") _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, true);
	else if (attrs.startArrow) _addDefaultArrow(shape, attrs, x1, y1, x2, y2, true);
	else shape.set("startArrowShape", null);
}
/**
* 绘制结束箭头
* @param {IShape} shape 图形
* @param {ShapeAttrs} attrs shape 的绘图属性
* @param {number} x1 起始点 x
* @param {number} y1 起始点 y
* @param {number} x2 箭头作用点 x
* @param {number} y2 箭头作用点 y
*/
function addEndArrow(shape, attrs, x1, y1, x2, y2) {
	if (typeof attrs.endArrow === "object") _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, false);
	else if (attrs.endArrow) _addDefaultArrow(shape, attrs, x1, y1, x2, y2, false);
	else shape.set("startArrowShape", null);
}

//#endregion
//#region node_modules/@antv/g-canvas/esm/util/draw.js
var SHAPE_ATTRS_MAP = {
	fill: "fillStyle",
	stroke: "strokeStyle",
	opacity: "globalAlpha"
};
function applyAttrsToContext(context, element) {
	var attrs = element.attr();
	for (var k in attrs) {
		var v = attrs[k];
		var name_1 = SHAPE_ATTRS_MAP[k] ? SHAPE_ATTRS_MAP[k] : k;
		if (name_1 === "matrix" && v) context.transform(v[0], v[1], v[3], v[4], v[6], v[7]);
		else if (name_1 === "lineDash" && context.setLineDash) is_array_default(v) && context.setLineDash(v);
		else {
			if (name_1 === "strokeStyle" || name_1 === "fillStyle") v = parseStyle(context, element, v);
			else if (name_1 === "globalAlpha") v = v * context.globalAlpha;
			context[name_1] = v;
		}
	}
}
function drawChildren$1(context, children, region) {
	for (var i = 0; i < children.length; i++) {
		var child = children[i];
		if (child.cfg.visible) child.draw(context, region);
		else child.skipDraw();
	}
}
function checkRefresh(canvas, children, region) {
	var refreshElements = canvas.get("refreshElements");
	each_default(refreshElements, function(el) {
		if (el !== canvas) {
			var parent_1 = el.cfg.parent;
			while (parent_1 && parent_1 !== canvas && !parent_1.cfg.refresh) {
				parent_1.cfg.refresh = true;
				parent_1 = parent_1.cfg.parent;
			}
		}
	});
	if (refreshElements[0] === canvas) setChildrenRefresh(children, region);
	else checkChildrenRefresh(children, region);
}
function checkChildrenRefresh(children, region) {
	for (var i = 0; i < children.length; i++) {
		var child = children[i];
		if (child.cfg.visible) if (child.cfg.hasChanged) {
			child.cfg.refresh = true;
			if (child.isGroup()) setChildrenRefresh(child.cfg.children, region);
		} else if (child.cfg.refresh) {
			if (child.isGroup()) checkChildrenRefresh(child.cfg.children, region);
		} else {
			var refresh = checkElementRefresh(child, region);
			child.cfg.refresh = refresh;
			if (refresh && child.isGroup()) checkChildrenRefresh(child.cfg.children, region);
		}
	}
}
function clearChanged(elements) {
	for (var i = 0; i < elements.length; i++) {
		var el = elements[i];
		el.cfg.hasChanged = false;
		if (el.isGroup() && !el.destroyed) clearChanged(el.cfg.children);
	}
}
function setChildrenRefresh(children, region) {
	for (var i = 0; i < children.length; i++) {
		var child = children[i];
		if (!child.cfg.visible) continue;
		child.cfg.refresh = true;
		if (child.isGroup()) setChildrenRefresh(child.get("children"), region);
	}
}
function checkElementRefresh(shape, region) {
	var bbox = shape.cfg.cacheCanvasBBox;
	return shape.cfg.isInView && bbox && intersectRect(bbox, region);
}
function drawPath(shape, context, attrs, arcParamsCache) {
	var path = attrs.path, startArrow = attrs.startArrow, endArrow = attrs.endArrow;
	if (!path) return;
	var currentPoint = [0, 0];
	var startMovePoint = [0, 0];
	var distance$7 = {
		dx: 0,
		dy: 0
	};
	context.beginPath();
	for (var i = 0; i < path.length; i++) {
		var params = path[i];
		var command = params[0];
		if (i === 0 && startArrow && startArrow.d) {
			var tangent = shape.getStartTangent();
			distance$7 = getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], startArrow.d);
		} else if (i === path.length - 2 && path[i + 1][0] === "Z" && endArrow && endArrow.d) {
			if (path[i + 1][0] === "Z") {
				var tangent = shape.getEndTangent();
				distance$7 = getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);
			}
		} else if (i === path.length - 1 && endArrow && endArrow.d) {
			if (path[0] !== "Z") {
				var tangent = shape.getEndTangent();
				distance$7 = getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);
			}
		}
		var dx = distance$7.dx, dy = distance$7.dy;
		switch (command) {
			case "M":
				context.moveTo(params[1] - dx, params[2] - dy);
				startMovePoint = [params[1], params[2]];
				break;
			case "L":
				context.lineTo(params[1] - dx, params[2] - dy);
				break;
			case "Q":
				context.quadraticCurveTo(params[1], params[2], params[3] - dx, params[4] - dy);
				break;
			case "C":
				context.bezierCurveTo(params[1], params[2], params[3], params[4], params[5] - dx, params[6] - dy);
				break;
			case "A":
				var arcParams = void 0;
				if (arcParamsCache) {
					arcParams = arcParamsCache[i];
					if (!arcParams) {
						arcParams = getArcParams(currentPoint, params);
						arcParamsCache[i] = arcParams;
					}
				} else arcParams = getArcParams(currentPoint, params);
				var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation, sweepFlag = arcParams.sweepFlag;
				if (context.ellipse) context.ellipse(cx, cy, rx, ry, xRotation, startAngle, endAngle, 1 - sweepFlag);
				else {
					var r = rx > ry ? rx : ry;
					var scaleX = rx > ry ? 1 : rx / ry;
					var scaleY = rx > ry ? ry / rx : 1;
					context.translate(cx, cy);
					context.rotate(xRotation);
					context.scale(scaleX, scaleY);
					context.arc(0, 0, r, startAngle, endAngle, 1 - sweepFlag);
					context.scale(1 / scaleX, 1 / scaleY);
					context.rotate(-xRotation);
					context.translate(-cx, -cy);
				}
				break;
			case "Z":
				context.closePath();
				break;
			default: break;
		}
		if (command === "Z") currentPoint = startMovePoint;
		else {
			var len = params.length;
			currentPoint = [params[len - 2], params[len - 1]];
		}
	}
}
function refreshElement$1(element, changeType) {
	var canvas = element.get("canvas");
	if (canvas) {
		if (changeType === "remove") element._cacheCanvasBBox = element.get("cacheCanvasBBox");
		if (!element.get("hasChanged")) {
			element.set("hasChanged", true);
			if (!(element.cfg.parent && element.cfg.parent.get("hasChanged"))) {
				canvas.refreshElement(element, changeType, canvas);
				if (canvas.get("autoDraw")) canvas.draw();
			}
		}
	}
}
function getRefreshRegion(element) {
	var region;
	if (!element.destroyed) {
		var cacheBox = element.get("cacheCanvasBBox");
		var validCache = cacheBox && !!(cacheBox.width && cacheBox.height);
		var bbox = element.getCanvasBBox();
		var validBBox = bbox && !!(bbox.width && bbox.height);
		if (validCache && validBBox) region = mergeRegion(cacheBox, bbox);
		else if (validCache) region = cacheBox;
		else if (validBBox) region = bbox;
	} else region = element["_cacheCanvasBBox"];
	return region;
}
function getMergedRegion(elements) {
	if (!elements.length) return null;
	var minXArr = [];
	var minYArr = [];
	var maxXArr = [];
	var maxYArr = [];
	each_default(elements, function(el) {
		var region = getRefreshRegion(el);
		if (region) {
			minXArr.push(region.minX);
			minYArr.push(region.minY);
			maxXArr.push(region.maxX);
			maxYArr.push(region.maxY);
		}
	});
	return {
		minX: min_default(minXArr),
		minY: min_default(minYArr),
		maxX: max_default(maxXArr),
		maxY: max_default(maxYArr)
	};
}
function mergeView(region, viewRegion) {
	if (!region || !viewRegion) return null;
	if (!intersectRect(region, viewRegion)) return null;
	return {
		minX: Math.max(region.minX, viewRegion.minX),
		minY: Math.max(region.minY, viewRegion.minY),
		maxX: Math.min(region.maxX, viewRegion.maxX),
		maxY: Math.min(region.maxY, viewRegion.maxY)
	};
}

//#endregion
//#region node_modules/@antv/g-canvas/esm/group.js
var Group$1 = function(_super) {
	__extends(Group$2, _super);
	function Group$2() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	/**
	* 一些方法调用会引起画布变化
	* @param {ChangeType} changeType 改变的类型
	*/
	Group$2.prototype.onCanvasChange = function(changeType) {
		refreshElement$1(this, changeType);
	};
	Group$2.prototype.getShapeBase = function() {
		return shape_exports$1;
	};
	Group$2.prototype.getGroupBase = function() {
		return Group$2;
	};
	Group$2.prototype._applyClip = function(context, clip) {
		if (clip) {
			context.save();
			applyAttrsToContext(context, clip);
			clip.createPath(context);
			context.restore();
			context.clip();
			clip._afterDraw();
		}
	};
	Group$2.prototype.cacheCanvasBBox = function() {
		var children = this.cfg.children;
		var xArr = [];
		var yArr = [];
		each_default(children, function(child) {
			var bbox$1 = child.cfg.cacheCanvasBBox;
			if (bbox$1 && child.cfg.isInView) {
				xArr.push(bbox$1.minX, bbox$1.maxX);
				yArr.push(bbox$1.minY, bbox$1.maxY);
			}
		});
		var bbox = null;
		if (xArr.length) {
			var minX = min_default(xArr);
			var maxX = max_default(xArr);
			var minY = min_default(yArr);
			var maxY$1 = max_default(yArr);
			bbox = {
				minX,
				minY,
				x: minX,
				y: minY,
				maxX,
				maxY: maxY$1,
				width: maxX - minX,
				height: maxY$1 - minY
			};
			var canvas = this.cfg.canvas;
			if (canvas) {
				var viewRange = canvas.getViewRange();
				this.set("isInView", intersectRect(bbox, viewRange));
			}
		} else this.set("isInView", false);
		this.set("cacheCanvasBBox", bbox);
	};
	Group$2.prototype.draw = function(context, region) {
		var children = this.cfg.children;
		var allowDraw = region ? this.cfg.refresh : true;
		if (children.length && allowDraw) {
			context.save();
			applyAttrsToContext(context, this);
			this._applyClip(context, this.getClip());
			drawChildren$1(context, children, region);
			context.restore();
			this.cacheCanvasBBox();
		}
		this.cfg.refresh = null;
		this.set("hasChanged", false);
	};
	Group$2.prototype.skipDraw = function() {
		this.set("cacheCanvasBBox", null);
		this.set("hasChanged", false);
	};
	return Group$2;
}(group_default$1);
var group_default$2 = Group$1;

//#endregion
//#region node_modules/@antv/g-canvas/esm/shape/base.js
var ShapeBase$1 = function(_super) {
	__extends(ShapeBase$3, _super);
	function ShapeBase$3() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	ShapeBase$3.prototype.getDefaultAttrs = function() {
		var attrs = _super.prototype.getDefaultAttrs.call(this);
		return __assign(__assign({}, attrs), {
			lineWidth: 1,
			lineAppendWidth: 0,
			strokeOpacity: 1,
			fillOpacity: 1
		});
	};
	ShapeBase$3.prototype.getShapeBase = function() {
		return shape_exports$1;
	};
	ShapeBase$3.prototype.getGroupBase = function() {
		return group_default$2;
	};
	/**
	* 一些方法调用会引起画布变化
	* @param {ChangeType} changeType 改变的类型
	*/
	ShapeBase$3.prototype.onCanvasChange = function(changeType) {
		refreshElement$1(this, changeType);
	};
	ShapeBase$3.prototype.calculateBBox = function() {
		var type = this.get("type");
		var lineWidth = this.getHitLineWidth();
		var box$1 = getMethod(type)(this);
		var halfLineWidth = lineWidth / 2;
		var minX = box$1.x - halfLineWidth;
		var minY = box$1.y - halfLineWidth;
		var maxX = box$1.x + box$1.width + halfLineWidth;
		var maxY$1 = box$1.y + box$1.height + halfLineWidth;
		return {
			x: minX,
			minX,
			y: minY,
			minY,
			width: box$1.width + lineWidth,
			height: box$1.height + lineWidth,
			maxX,
			maxY: maxY$1
		};
	};
	ShapeBase$3.prototype.isFill = function() {
		return !!this.attrs["fill"] || this.isClipShape();
	};
	ShapeBase$3.prototype.isStroke = function() {
		return !!this.attrs["stroke"];
	};
	ShapeBase$3.prototype._applyClip = function(context, clip) {
		if (clip) {
			context.save();
			applyAttrsToContext(context, clip);
			clip.createPath(context);
			context.restore();
			context.clip();
			clip._afterDraw();
		}
	};
	ShapeBase$3.prototype.draw = function(context, region) {
		var clip = this.cfg.clipShape;
		if (region) {
			if (this.cfg.refresh === false) {
				this.set("hasChanged", false);
				return;
			}
			var bbox = this.getCanvasBBox();
			if (!intersectRect(region, bbox)) {
				this.set("hasChanged", false);
				if (this.cfg.isInView) this._afterDraw();
				return;
			}
		}
		context.save();
		applyAttrsToContext(context, this);
		this._applyClip(context, clip);
		this.drawPath(context);
		context.restore();
		this._afterDraw();
	};
	ShapeBase$3.prototype.getCanvasViewBox = function() {
		var canvas = this.cfg.canvas;
		if (canvas) return canvas.getViewRange();
		return null;
	};
	ShapeBase$3.prototype.cacheCanvasBBox = function() {
		var canvasBBox = this.getCanvasViewBox();
		if (canvasBBox) {
			var bbox = this.getCanvasBBox();
			var isInView = intersectRect(bbox, canvasBBox);
			this.set("isInView", isInView);
			if (isInView) this.set("cacheCanvasBBox", bbox);
			else this.set("cacheCanvasBBox", null);
		}
	};
	ShapeBase$3.prototype._afterDraw = function() {
		this.cacheCanvasBBox();
		this.set("hasChanged", false);
		this.set("refresh", null);
	};
	ShapeBase$3.prototype.skipDraw = function() {
		this.set("cacheCanvasBBox", null);
		this.set("isInView", null);
		this.set("hasChanged", false);
	};
	/**
	* 绘制图形的路径
	* @param {CanvasRenderingContext2D} context 上下文
	*/
	ShapeBase$3.prototype.drawPath = function(context) {
		this.createPath(context);
		this.strokeAndFill(context);
		this.afterDrawPath(context);
	};
	/**
	* @protected
	* 填充图形
	* @param {CanvasRenderingContext2D} context context 上下文
	*/
	ShapeBase$3.prototype.fill = function(context) {
		context.fill();
	};
	/**
	* @protected
	* 绘制图形边框
	* @param {CanvasRenderingContext2D} context context 上下文
	*/
	ShapeBase$3.prototype.stroke = function(context) {
		context.stroke();
	};
	ShapeBase$3.prototype.strokeAndFill = function(context) {
		var _a$5 = this.attrs, lineWidth = _a$5.lineWidth, opacity = _a$5.opacity, strokeOpacity = _a$5.strokeOpacity, fillOpacity = _a$5.fillOpacity;
		if (this.isFill()) if (!is_nil_default(fillOpacity) && fillOpacity !== 1) {
			context.globalAlpha = fillOpacity;
			this.fill(context);
			context.globalAlpha = opacity;
		} else this.fill(context);
		if (this.isStroke()) {
			if (lineWidth > 0) {
				if (!is_nil_default(strokeOpacity) && strokeOpacity !== 1) context.globalAlpha = strokeOpacity;
				this.stroke(context);
			}
		}
		this.afterDrawPath(context);
	};
	/**
	* @protected
	* 绘制图形的路径
	* @param {CanvasRenderingContext2D} context 上下文
	*/
	ShapeBase$3.prototype.createPath = function(context) {};
	/**
	* 绘制完成 path 后的操作
	* @param {CanvasRenderingContext2D} context 上下文
	*/
	ShapeBase$3.prototype.afterDrawPath = function(context) {};
	ShapeBase$3.prototype.isInShape = function(refX, refY) {
		var isStroke = this.isStroke();
		var isFill = this.isFill();
		var lineWidth = this.getHitLineWidth();
		return this.isInStrokeOrPath(refX, refY, isStroke, isFill, lineWidth);
	};
	ShapeBase$3.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
		return false;
	};
	/**
	* 获取线拾取的宽度
	* @returns {number} 线的拾取宽度
	*/
	ShapeBase$3.prototype.getHitLineWidth = function() {
		if (!this.isStroke()) return 0;
		var attrs = this.attrs;
		return attrs["lineWidth"] + attrs["lineAppendWidth"];
	};
	return ShapeBase$3;
}(shape_default);
var base_default$6 = ShapeBase$1;

//#endregion
//#region node_modules/@antv/g-canvas/esm/shape/circle.js
var Circle$2 = function(_super) {
	__extends(Circle$5, _super);
	function Circle$5() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	Circle$5.prototype.getDefaultAttrs = function() {
		var attrs = _super.prototype.getDefaultAttrs.call(this);
		return __assign(__assign({}, attrs), {
			x: 0,
			y: 0,
			r: 0
		});
	};
	Circle$5.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
		var attrs = this.attr();
		var cx = attrs.x;
		var cy = attrs.y;
		var r = attrs.r;
		var halfLineWidth = lineWidth / 2;
		var absDistance = distance$2(cx, cy, x, y);
		if (isFill && isStroke) return absDistance <= r + halfLineWidth;
		if (isFill) return absDistance <= r;
		if (isStroke) return absDistance >= r - halfLineWidth && absDistance <= r + halfLineWidth;
		return false;
	};
	Circle$5.prototype.createPath = function(context) {
		var attrs = this.attr();
		var cx = attrs.x;
		var cy = attrs.y;
		var r = attrs.r;
		context.beginPath();
		context.arc(cx, cy, r, 0, Math.PI * 2, false);
		context.closePath();
	};
	return Circle$5;
}(base_default$6);
var circle_default$4 = Circle$2;

//#endregion
//#region node_modules/@antv/g-canvas/esm/shape/ellipse.js
function ellipseDistance(squareX, squareY, rx, ry) {
	return squareX / (rx * rx) + squareY / (ry * ry);
}
var Ellipse$1 = function(_super) {
	__extends(Ellipse$2, _super);
	function Ellipse$2() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	Ellipse$2.prototype.getDefaultAttrs = function() {
		var attrs = _super.prototype.getDefaultAttrs.call(this);
		return __assign(__assign({}, attrs), {
			x: 0,
			y: 0,
			rx: 0,
			ry: 0
		});
	};
	Ellipse$2.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
		var attrs = this.attr();
		var halfLineWith = lineWidth / 2;
		var cx = attrs.x;
		var cy = attrs.y;
		var rx = attrs.rx, ry = attrs.ry;
		var squareX = (x - cx) * (x - cx);
		var squareY = (y - cy) * (y - cy);
		if (isFill && isStroke) return ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
		if (isFill) return ellipseDistance(squareX, squareY, rx, ry) <= 1;
		if (isStroke) return ellipseDistance(squareX, squareY, rx - halfLineWith, ry - halfLineWith) >= 1 && ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
		return false;
	};
	Ellipse$2.prototype.createPath = function(context) {
		var attrs = this.attr();
		var cx = attrs.x;
		var cy = attrs.y;
		var rx = attrs.rx;
		var ry = attrs.ry;
		context.beginPath();
		if (context.ellipse) context.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2, false);
		else {
			var r = rx > ry ? rx : ry;
			var scaleX = rx > ry ? 1 : rx / ry;
			var scaleY = rx > ry ? ry / rx : 1;
			context.save();
			context.translate(cx, cy);
			context.scale(scaleX, scaleY);
			context.arc(0, 0, r, 0, Math.PI * 2);
			context.restore();
			context.closePath();
		}
	};
	return Ellipse$2;
}(base_default$6);
var ellipse_default$1 = Ellipse$1;

//#endregion
//#region node_modules/@antv/g-canvas/esm/shape/image.js
function isCanvas(dom) {
	return dom instanceof HTMLElement && is_string_default(dom.nodeName) && dom.nodeName.toUpperCase() === "CANVAS";
}
var ImageShape = function(_super) {
	__extends(ImageShape$1, _super);
	function ImageShape$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	ImageShape$1.prototype.getDefaultAttrs = function() {
		var attrs = _super.prototype.getDefaultAttrs.call(this);
		return __assign(__assign({}, attrs), {
			x: 0,
			y: 0,
			width: 0,
			height: 0
		});
	};
	ImageShape$1.prototype.initAttrs = function(attrs) {
		this._setImage(attrs.img);
	};
	ImageShape$1.prototype.isStroke = function() {
		return false;
	};
	ImageShape$1.prototype.isOnlyHitBox = function() {
		return true;
	};
	ImageShape$1.prototype._afterLoading = function() {
		if (this.get("toDraw") === true) {
			var canvas = this.get("canvas");
			if (canvas) canvas.draw();
			else this.createPath(this.get("context"));
		}
	};
	ImageShape$1.prototype._setImage = function(img) {
		var _this = this;
		var attrs = this.attrs;
		if (is_string_default(img)) {
			var image_1 = new Image();
			image_1.onload = function() {
				if (_this.destroyed) return false;
				_this.attr("img", image_1);
				_this.set("loading", false);
				_this._afterLoading();
				var callback = _this.get("callback");
				if (callback) callback.call(_this);
			};
			image_1.crossOrigin = "Anonymous";
			image_1.src = img;
			this.set("loading", true);
		} else if (img instanceof Image) {
			if (!attrs.width) attrs.width = img.width;
			if (!attrs.height) attrs.height = img.height;
		} else if (isCanvas(img)) {
			if (!attrs.width) attrs.width = Number(img.getAttribute("width"));
			if (!attrs.height) attrs.height, Number(img.getAttribute("height"));
		}
	};
	ImageShape$1.prototype.onAttrChange = function(name, value$1, originValue) {
		_super.prototype.onAttrChange.call(this, name, value$1, originValue);
		if (name === "img") this._setImage(value$1);
	};
	ImageShape$1.prototype.createPath = function(context) {
		if (this.get("loading")) {
			this.set("toDraw", true);
			this.set("context", context);
			return;
		}
		var attrs = this.attr();
		var x = attrs.x, y = attrs.y, width = attrs.width, height = attrs.height, sx = attrs.sx, sy = attrs.sy, swidth = attrs.swidth, sheight = attrs.sheight;
		var img = attrs.img;
		if (img instanceof Image || isCanvas(img)) if (!is_nil_default(sx) && !is_nil_default(sy) && !is_nil_default(swidth) && !is_nil_default(sheight)) context.drawImage(img, sx, sy, swidth, sheight, x, y, width, height);
		else context.drawImage(img, x, y, width, height);
	};
	return ImageShape$1;
}(base_default$6);
var image_default$1 = ImageShape;

//#endregion
//#region node_modules/@antv/g-canvas/esm/util/in-stroke/line.js
function inLine(x1, y1, x2, y2, lineWidth, x, y) {
	var minX = Math.min(x1, x2);
	var maxX = Math.max(x1, x2);
	var minY = Math.min(y1, y2);
	var maxY$1 = Math.max(y1, y2);
	var halfWidth = lineWidth / 2;
	if (!(x >= minX - halfWidth && x <= maxX + halfWidth && y >= minY - halfWidth && y <= maxY$1 + halfWidth)) return false;
	return line_default$2.pointToLine(x1, y1, x2, y2, x, y) <= lineWidth / 2;
}

//#endregion
//#region node_modules/@antv/g-canvas/esm/shape/line.js
var Line$3 = function(_super) {
	__extends(Line$6, _super);
	function Line$6() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	Line$6.prototype.getDefaultAttrs = function() {
		var attrs = _super.prototype.getDefaultAttrs.call(this);
		return __assign(__assign({}, attrs), {
			x1: 0,
			y1: 0,
			x2: 0,
			y2: 0,
			startArrow: false,
			endArrow: false
		});
	};
	Line$6.prototype.initAttrs = function(attrs) {
		this.setArrow();
	};
	Line$6.prototype.onAttrChange = function(name, value$1, originValue) {
		_super.prototype.onAttrChange.call(this, name, value$1, originValue);
		this.setArrow();
	};
	Line$6.prototype.setArrow = function() {
		var attrs = this.attr();
		var x1 = attrs.x1, y1 = attrs.y1, x2 = attrs.x2, y2 = attrs.y2, startArrow = attrs.startArrow, endArrow = attrs.endArrow;
		if (startArrow) addStartArrow(this, attrs, x2, y2, x1, y1);
		if (endArrow) addEndArrow(this, attrs, x1, y1, x2, y2);
	};
	Line$6.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
		if (!isStroke || !lineWidth) return false;
		var _a$5 = this.attr(), x1 = _a$5.x1, y1 = _a$5.y1, x2 = _a$5.x2, y2 = _a$5.y2;
		return inLine(x1, y1, x2, y2, lineWidth, x, y);
	};
	Line$6.prototype.createPath = function(context) {
		var attrs = this.attr();
		var x1 = attrs.x1, y1 = attrs.y1, x2 = attrs.x2, y2 = attrs.y2, startArrow = attrs.startArrow, endArrow = attrs.endArrow;
		var startArrowDistance = {
			dx: 0,
			dy: 0
		};
		var endArrowDistance = {
			dx: 0,
			dy: 0
		};
		if (startArrow && startArrow.d) startArrowDistance = getShortenOffset(x1, y1, x2, y2, attrs.startArrow.d);
		if (endArrow && endArrow.d) endArrowDistance = getShortenOffset(x1, y1, x2, y2, attrs.endArrow.d);
		context.beginPath();
		context.moveTo(x1 + startArrowDistance.dx, y1 + startArrowDistance.dy);
		context.lineTo(x2 - endArrowDistance.dx, y2 - endArrowDistance.dy);
	};
	Line$6.prototype.afterDrawPath = function(context) {
		var startArrowShape = this.get("startArrowShape");
		var endArrowShape = this.get("endArrowShape");
		if (startArrowShape) startArrowShape.draw(context);
		if (endArrowShape) endArrowShape.draw(context);
	};
	/**
	* Get length of line
	* @return {number} length
	*/
	Line$6.prototype.getTotalLength = function() {
		var _a$5 = this.attr(), x1 = _a$5.x1, y1 = _a$5.y1, x2 = _a$5.x2, y2 = _a$5.y2;
		return line_default$2.length(x1, y1, x2, y2);
	};
	/**
	* Get point according to ratio
	* @param {number} ratio
	* @return {Point} point
	*/
	Line$6.prototype.getPoint = function(ratio) {
		var _a$5 = this.attr(), x1 = _a$5.x1, y1 = _a$5.y1, x2 = _a$5.x2, y2 = _a$5.y2;
		return line_default$2.pointAt(x1, y1, x2, y2, ratio);
	};
	return Line$6;
}(base_default$6);
var line_default$3 = Line$3;

//#endregion
//#region node_modules/@antv/g-canvas/node_modules/@antv/path-util/esm/parse-path.js
var regexTags = /[MLHVQTCSAZ]([^MLHVQTCSAZ]*)/gi;
var regexDot = /[^\s\,]+/gi;
function parsePath(p) {
	var path = p || [];
	if (is_array_default(path)) return path;
	if (is_string_default(path)) {
		path = path.match(regexTags);
		each_default(path, function(item, index) {
			item = item.match(regexDot);
			if (item[0].length > 1) {
				var tag = item[0].charAt(0);
				item.splice(1, 0, item[0].substr(1));
				item[0] = tag;
			}
			each_default(item, function(sub$1, i) {
				if (!isNaN(sub$1)) item[i] = +sub$1;
			});
			path[index] = item;
		});
		return path;
	}
}
var parse_path_default = parsePath;

//#endregion
//#region node_modules/@antv/g-canvas/node_modules/@antv/path-util/esm/parse-path-string.js
var SPACES$1 = "	\n\v\f\r \xA0 ᠎             　\u2028\u2029";
var PATH_COMMAND$1 = new RegExp("([a-z])[" + SPACES$1 + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + SPACES$1 + "]*,?[" + SPACES$1 + "]*)+)", "ig");
var PATH_VALUES$1 = new RegExp("(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[" + SPACES$1 + "]*,?[" + SPACES$1 + "]*", "ig");
function parsePathString$1(pathString) {
	if (!pathString) return null;
	if (is_array_default(pathString)) return pathString;
	var paramCounts = {
		a: 7,
		c: 6,
		o: 2,
		h: 1,
		l: 2,
		m: 2,
		r: 4,
		q: 4,
		s: 4,
		t: 2,
		v: 1,
		u: 3,
		z: 0
	};
	var data$2 = [];
	String(pathString).replace(PATH_COMMAND$1, function(a, b, c) {
		var params = [];
		var name = b.toLowerCase();
		c.replace(PATH_VALUES$1, function(a$1, b$1) {
			b$1 && params.push(+b$1);
		});
		if (name === "m" && params.length > 2) {
			data$2.push([b].concat(params.splice(0, 2)));
			name = "l";
			b = b === "m" ? "l" : "L";
		}
		if (name === "o" && params.length === 1) data$2.push([b, params[0]]);
		if (name === "r") data$2.push([b].concat(params));
		else while (params.length >= paramCounts[name]) {
			data$2.push([b].concat(params.splice(0, paramCounts[name])));
			if (!paramCounts[name]) break;
		}
		return "";
	});
	return data$2;
}

//#endregion
//#region node_modules/@antv/g-canvas/node_modules/@antv/path-util/esm/path-2-absolute.js
var REGEX_MD = /[a-z]/;
function toSymmetry$1(p, c) {
	return [c[0] + (c[0] - p[0]), c[1] + (c[1] - p[1])];
}
function pathToAbsolute(pathString) {
	var pathArray = parsePathString$1(pathString);
	if (!pathArray || !pathArray.length) return [[
		"M",
		0,
		0
	]];
	var needProcess = false;
	for (var i = 0; i < pathArray.length; i++) {
		var cmd = pathArray[i][0];
		if (REGEX_MD.test(cmd) || [
			"V",
			"H",
			"T",
			"S"
		].indexOf(cmd) >= 0) {
			needProcess = true;
			break;
		}
	}
	if (!needProcess) return pathArray;
	var res = [];
	var x = 0;
	var y = 0;
	var mx = 0;
	var my = 0;
	var start = 0;
	var first = pathArray[0];
	if (first[0] === "M" || first[0] === "m") {
		x = +first[1];
		y = +first[2];
		mx = x;
		my = y;
		start++;
		res[0] = [
			"M",
			x,
			y
		];
	}
	for (var i = start, ii = pathArray.length; i < ii; i++) {
		var pa = pathArray[i];
		var preParams = res[i - 1];
		var r = [];
		var cmd = pa[0];
		var upCmd = cmd.toUpperCase();
		if (cmd !== upCmd) {
			r[0] = upCmd;
			switch (upCmd) {
				case "A":
					r[1] = pa[1];
					r[2] = pa[2];
					r[3] = pa[3];
					r[4] = pa[4];
					r[5] = pa[5];
					r[6] = +pa[6] + x;
					r[7] = +pa[7] + y;
					break;
				case "V":
					r[1] = +pa[1] + y;
					break;
				case "H":
					r[1] = +pa[1] + x;
					break;
				case "M":
					mx = +pa[1] + x;
					my = +pa[2] + y;
					r[1] = mx;
					r[2] = my;
					break;
				default: for (var j = 1, jj = pa.length; j < jj; j++) r[j] = +pa[j] + (j % 2 ? x : y);
			}
		} else r = pathArray[i];
		switch (upCmd) {
			case "Z":
				x = +mx;
				y = +my;
				break;
			case "H":
				x = r[1];
				r = [
					"L",
					x,
					y
				];
				break;
			case "V":
				y = r[1];
				r = [
					"L",
					x,
					y
				];
				break;
			case "T":
				x = r[1];
				y = r[2];
				var symetricT = toSymmetry$1([preParams[1], preParams[2]], [preParams[3], preParams[4]]);
				r = [
					"Q",
					symetricT[0],
					symetricT[1],
					x,
					y
				];
				break;
			case "S":
				x = r[r.length - 2];
				y = r[r.length - 1];
				var length_1 = preParams.length;
				var symetricS = toSymmetry$1([preParams[length_1 - 4], preParams[length_1 - 3]], [preParams[length_1 - 2], preParams[length_1 - 1]]);
				r = [
					"C",
					symetricS[0],
					symetricS[1],
					r[1],
					r[2],
					x,
					y
				];
				break;
			case "M":
				mx = r[r.length - 2];
				my = r[r.length - 1];
				break;
			default:
				x = r[r.length - 2];
				y = r[r.length - 1];
		}
		res.push(r);
	}
	return res;
}

//#endregion
//#region node_modules/@antv/g-canvas/node_modules/@antv/path-util/esm/process/arc-2-cubic.js
var TAU$1 = Math.PI * 2;

//#endregion
//#region node_modules/@antv/g-canvas/node_modules/@antv/path-util/esm/get-arc-params.js
function vMag(v) {
	return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
}
function vRatio(u, v) {
	return vMag(u) * vMag(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v)) : 1;
}
function vAngle(u, v) {
	return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
}
/**
* 判断两个点是否重合，点坐标的格式为 [x, y]
* @param {Array} point1 第一个点
* @param {Array} point2 第二个点
*/
function isSamePoint(point1, point2) {
	return point1[0] === point2[0] && point1[1] === point2[1];
}
function getArcParams$1(startPoint, params) {
	var rx = params[1];
	var ry = params[2];
	var xRotation = esm_default$2(to_radian_default(params[3]), Math.PI * 2);
	var arcFlag = params[4];
	var sweepFlag = params[5];
	var x1 = startPoint[0];
	var y1 = startPoint[1];
	var x2 = params[6];
	var y2 = params[7];
	var xp = Math.cos(xRotation) * (x1 - x2) / 2 + Math.sin(xRotation) * (y1 - y2) / 2;
	var yp = -1 * Math.sin(xRotation) * (x1 - x2) / 2 + Math.cos(xRotation) * (y1 - y2) / 2;
	var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
	if (lambda > 1) {
		rx *= Math.sqrt(lambda);
		ry *= Math.sqrt(lambda);
	}
	var diff$1 = rx * rx * (yp * yp) + ry * ry * (xp * xp);
	var f = diff$1 ? Math.sqrt((rx * rx * (ry * ry) - diff$1) / diff$1) : 1;
	if (arcFlag === sweepFlag) f *= -1;
	if (isNaN(f)) f = 0;
	var cxp = ry ? f * rx * yp / ry : 0;
	var cyp = rx ? f * -ry * xp / rx : 0;
	var cx = (x1 + x2) / 2 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
	var cy = (y1 + y2) / 2 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
	var u = [(xp - cxp) / rx, (yp - cyp) / ry];
	var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
	var theta = vAngle([1, 0], u);
	var dTheta = vAngle(u, v);
	if (vRatio(u, v) <= -1) dTheta = Math.PI;
	if (vRatio(u, v) >= 1) dTheta = 0;
	if (sweepFlag === 0 && dTheta > 0) dTheta = dTheta - 2 * Math.PI;
	if (sweepFlag === 1 && dTheta < 0) dTheta = dTheta + 2 * Math.PI;
	return {
		cx,
		cy,
		rx: isSamePoint(startPoint, [x2, y2]) ? 0 : rx,
		ry: isSamePoint(startPoint, [x2, y2]) ? 0 : ry,
		startAngle: theta,
		endAngle: theta + dTheta,
		xRotation,
		arcFlag,
		sweepFlag
	};
}

//#endregion
//#region node_modules/@antv/g-canvas/node_modules/@antv/path-util/esm/path-2-segments.js
function toSymmetry(point$1, center$1) {
	return [center$1[0] + (center$1[0] - point$1[0]), center$1[1] + (center$1[1] - point$1[1])];
}
function getSegments(path) {
	path = parse_path_default(path);
	var segments = [];
	var currentPoint = null;
	var nextParams = null;
	var startMovePoint = null;
	var lastStartMovePointIndex = 0;
	var count$1 = path.length;
	for (var i = 0; i < count$1; i++) {
		var params = path[i];
		nextParams = path[i + 1];
		var command = params[0];
		var segment = {
			command,
			prePoint: currentPoint,
			params,
			startTangent: null,
			endTangent: null
		};
		switch (command) {
			case "M":
				startMovePoint = [params[1], params[2]];
				lastStartMovePointIndex = i;
				break;
			case "A":
				segment["arcParams"] = getArcParams$1(currentPoint, params);
				break;
			default: break;
		}
		if (command === "Z") {
			currentPoint = startMovePoint;
			nextParams = path[lastStartMovePointIndex + 1];
		} else {
			var len = params.length;
			currentPoint = [params[len - 2], params[len - 1]];
		}
		if (nextParams && nextParams[0] === "Z") {
			nextParams = path[lastStartMovePointIndex];
			if (segments[lastStartMovePointIndex]) segments[lastStartMovePointIndex].prePoint = currentPoint;
		}
		segment["currentPoint"] = currentPoint;
		if (segments[lastStartMovePointIndex] && isSamePoint(currentPoint, segments[lastStartMovePointIndex].currentPoint)) segments[lastStartMovePointIndex].prePoint = segment.prePoint;
		segment["nextPoint"] = nextParams ? [nextParams[nextParams.length - 2], nextParams[nextParams.length - 1]] : null;
		var prePoint = segment.prePoint;
		if ([
			"L",
			"H",
			"V"
		].includes(command)) {
			segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
			segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
		} else if (command === "Q") {
			var cp = [params[1], params[2]];
			segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
			segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
		} else if (command === "T") {
			var preSegment = segments[i - 1];
			var cp = toSymmetry(preSegment.currentPoint, prePoint);
			if (preSegment.command === "Q") {
				segment.command = "Q";
				segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
				segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
			} else {
				segment.command = "TL";
				segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
				segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
			}
		} else if (command === "C") {
			var cp1 = [params[1], params[2]];
			var cp2 = [params[3], params[4]];
			segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
			segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
			if (segment.startTangent[0] === 0 && segment.startTangent[1] === 0) segment.startTangent = [cp1[0] - cp2[0], cp1[1] - cp2[1]];
			if (segment.endTangent[0] === 0 && segment.endTangent[1] === 0) segment.endTangent = [cp2[0] - cp1[0], cp2[1] - cp1[1]];
		} else if (command === "S") {
			var preSegment = segments[i - 1];
			var cp1 = toSymmetry(preSegment.currentPoint, prePoint);
			var cp2 = [params[1], params[2]];
			if (preSegment.command === "C") {
				segment.command = "C";
				segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
				segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
			} else {
				segment.command = "SQ";
				segment.startTangent = [prePoint[0] - cp2[0], prePoint[1] - cp2[1]];
				segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
			}
		} else if (command === "A") {
			var d = .001;
			var _a$5 = segment["arcParams"] || {}, _b = _a$5.cx, cx = _b === void 0 ? 0 : _b, _c = _a$5.cy, cy = _c === void 0 ? 0 : _c, _d = _a$5.rx, rx = _d === void 0 ? 0 : _d, _e = _a$5.ry, ry = _e === void 0 ? 0 : _e, _f = _a$5.sweepFlag, sweepFlag = _f === void 0 ? 0 : _f, _g = _a$5.startAngle, startAngle = _g === void 0 ? 0 : _g, _h = _a$5.endAngle, endAngle = _h === void 0 ? 0 : _h;
			if (sweepFlag === 0) d *= -1;
			var dx1 = rx * Math.cos(startAngle - d) + cx;
			var dy1 = ry * Math.sin(startAngle - d) + cy;
			segment.startTangent = [dx1 - startMovePoint[0], dy1 - startMovePoint[1]];
			var dx2 = rx * Math.cos(startAngle + endAngle + d) + cx;
			var dy2 = ry * Math.sin(startAngle + endAngle - d) + cy;
			segment.endTangent = [prePoint[0] - dx2, prePoint[1] - dy2];
		}
		segments.push(segment);
	}
	return segments;
}

//#endregion
//#region node_modules/@antv/g-canvas/esm/shape/marker.js
var Symbols$1 = {
	circle: function(x, y, r) {
		return [
			[
				"M",
				x - r,
				y
			],
			[
				"A",
				r,
				r,
				0,
				1,
				0,
				x + r,
				y
			],
			[
				"A",
				r,
				r,
				0,
				1,
				0,
				x - r,
				y
			]
		];
	},
	square: function(x, y, r) {
		return [
			[
				"M",
				x - r,
				y - r
			],
			[
				"L",
				x + r,
				y - r
			],
			[
				"L",
				x + r,
				y + r
			],
			[
				"L",
				x - r,
				y + r
			],
			["Z"]
		];
	},
	diamond: function(x, y, r) {
		return [
			[
				"M",
				x - r,
				y
			],
			[
				"L",
				x,
				y - r
			],
			[
				"L",
				x + r,
				y
			],
			[
				"L",
				x,
				y + r
			],
			["Z"]
		];
	},
	triangle: function(x, y, r) {
		var diffY = r * Math.sin(1 / 3 * Math.PI);
		return [
			[
				"M",
				x - r,
				y + diffY
			],
			[
				"L",
				x,
				y - diffY
			],
			[
				"L",
				x + r,
				y + diffY
			],
			["Z"]
		];
	},
	"triangle-down": function(x, y, r) {
		var diffY = r * Math.sin(1 / 3 * Math.PI);
		return [
			[
				"M",
				x - r,
				y - diffY
			],
			[
				"L",
				x + r,
				y - diffY
			],
			[
				"L",
				x,
				y + diffY
			],
			["Z"]
		];
	}
};
var Marker$1 = function(_super) {
	__extends(Marker$2, _super);
	function Marker$2() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	Marker$2.prototype.initAttrs = function(attrs) {
		this._resetParamsCache();
	};
	Marker$2.prototype._resetParamsCache = function() {
		this.set("paramsCache", {});
	};
	Marker$2.prototype.onAttrChange = function(name, value$1, originValue) {
		_super.prototype.onAttrChange.call(this, name, value$1, originValue);
		if ([
			"symbol",
			"x",
			"y",
			"r",
			"radius"
		].indexOf(name) !== -1) this._resetParamsCache();
	};
	Marker$2.prototype.isOnlyHitBox = function() {
		return true;
	};
	Marker$2.prototype._getR = function(attrs) {
		return is_nil_default(attrs.r) ? attrs.radius : attrs.r;
	};
	Marker$2.prototype._getPath = function() {
		var attrs = this.attr();
		var x = attrs.x, y = attrs.y;
		var symbol = attrs.symbol || "circle";
		var r = this._getR(attrs);
		var method;
		var path;
		if (is_function_default(symbol)) {
			method = symbol;
			path = method(x, y, r);
			path = pathToAbsolute(path);
		} else {
			method = Marker$2.Symbols[symbol];
			if (!method) {
				console.warn(symbol + " marker is not supported.");
				return null;
			}
			path = method(x, y, r);
		}
		return path;
	};
	Marker$2.prototype.createPath = function(context) {
		var path = this._getPath();
		var paramsCache = this.get("paramsCache");
		drawPath(this, context, { path }, paramsCache);
	};
	Marker$2.Symbols = Symbols$1;
	return Marker$2;
}(base_default$6);
var marker_default$1 = Marker$1;

//#endregion
//#region node_modules/@antv/g-canvas/esm/util/in-path/point-in-path.js
function isPointInPath(shape, x, y) {
	var ctx$3 = getOffScreenContext();
	shape.createPath(ctx$3);
	return ctx$3.isPointInPath(x, y);
}

//#endregion
//#region node_modules/@antv/g-canvas/esm/util/in-path/polygon.js
/**
* @fileoverview 判断点是否在多边形内
* @author dxq613@gmail.com
*/
var tolerance = 1e-6;
function dcmp(x) {
	if (Math.abs(x) < tolerance) return 0;
	return x < 0 ? -1 : 1;
}
function onSegment(p1, p2, q) {
	if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q[0] && q[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q[1] && q[1] <= Math.max(p1[1], p2[1])) return true;
	return false;
}
function isInPolygon(points, x, y) {
	var isHit = false;
	var n = points.length;
	if (n <= 2) return false;
	for (var i = 0; i < n; i++) {
		var p1 = points[i];
		var p2 = points[(i + 1) % n];
		if (onSegment(p1, p2, [x, y])) return true;
		if (dcmp(p1[1] - y) > 0 !== dcmp(p2[1] - y) > 0 && dcmp(x - (y - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) isHit = !isHit;
	}
	return isHit;
}

//#endregion
//#region node_modules/@antv/g-canvas/esm/util/in-stroke/arc.js
function arc(cx, cy, r, startAngle, endAngle, lineWidth, x, y) {
	var angle$1 = (Math.atan2(y - cy, x - cx) + Math.PI * 2) % (Math.PI * 2);
	if (angle$1 < startAngle || angle$1 > endAngle) return false;
	var point$1 = {
		x: cx + r * Math.cos(angle$1),
		y: cy + r * Math.sin(angle$1)
	};
	return distance$2(point$1.x, point$1.y, x, y) <= lineWidth / 2;
}

//#endregion
//#region node_modules/@antv/g-canvas/esm/util/path.js
var transform$3 = transform$6;
function hasArc(path) {
	var hasArc$1 = false;
	var count$1 = path.length;
	for (var i = 0; i < count$1; i++) {
		var cmd = path[i][0];
		if (cmd === "C" || cmd === "A" || cmd === "Q") {
			hasArc$1 = true;
			break;
		}
	}
	return hasArc$1;
}
function isPointInStroke(segments, lineWidth, x, y, length$1) {
	var isHit = false;
	var halfWidth = lineWidth / 2;
	for (var i = 0; i < segments.length; i++) {
		var segment = segments[i];
		var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint, box$1 = segment.box;
		if (box$1 && !inBox(box$1.x - halfWidth, box$1.y - halfWidth, box$1.width + lineWidth, box$1.height + lineWidth, x, y)) continue;
		switch (segment.command) {
			case "L":
			case "Z":
				isHit = inLine(prePoint[0], prePoint[1], currentPoint[0], currentPoint[1], lineWidth, x, y);
				break;
			case "Q":
				isHit = quadratic_default.pointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], x, y) <= lineWidth / 2;
				break;
			case "C":
				isHit = cubic_default.pointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6], x, y, length$1) <= lineWidth / 2;
				break;
			case "A":
				var arcParams = segment.arcParams;
				var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation;
				var p = [
					x,
					y,
					1
				];
				var r = rx > ry ? rx : ry;
				var scaleX = rx > ry ? 1 : rx / ry;
				var scaleY = rx > ry ? ry / rx : 1;
				var m = transform$3(null, [
					[
						"t",
						-cx,
						-cy
					],
					["r", -xRotation],
					[
						"s",
						1 / scaleX,
						1 / scaleY
					]
				]);
				transformMat3(p, p, m);
				isHit = arc(0, 0, r, startAngle, endAngle, lineWidth, p[0], p[1]);
				break;
			default: break;
		}
		if (isHit) break;
	}
	return isHit;
}
/**
* 提取出内部的闭合多边形和非闭合的多边形，假设 path 不存在圆弧
* @param {Array} path 路径
* @returns {Array} 点的集合
*/
function extractPolygons(path) {
	var count$1 = path.length;
	var polygons = [];
	var polylines = [];
	var points = [];
	for (var i = 0; i < count$1; i++) {
		var params = path[i];
		var cmd = params[0];
		if (cmd === "M") {
			if (points.length) {
				polylines.push(points);
				points = [];
			}
			points.push([params[1], params[2]]);
		} else if (cmd === "Z") {
			if (points.length) {
				polygons.push(points);
				points = [];
			}
		} else points.push([params[1], params[2]]);
	}
	if (points.length > 0) polylines.push(points);
	return {
		polygons,
		polylines
	};
}
var path_default$6 = __assign({
	hasArc,
	extractPolygons,
	isPointInStroke
}, path_exports);

//#endregion
//#region node_modules/@antv/g-canvas/esm/shape/path.js
function isInPolygons(polygons, x, y) {
	var isHit = false;
	for (var i = 0; i < polygons.length; i++) {
		var points = polygons[i];
		isHit = isInPolygon(points, x, y);
		if (isHit) break;
	}
	return isHit;
}
var Path$2 = function(_super) {
	__extends(Path$3, _super);
	function Path$3() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	Path$3.prototype.getDefaultAttrs = function() {
		var attrs = _super.prototype.getDefaultAttrs.call(this);
		return __assign(__assign({}, attrs), {
			startArrow: false,
			endArrow: false
		});
	};
	Path$3.prototype.initAttrs = function(attrs) {
		this._setPathArr(attrs.path);
		this.setArrow();
	};
	Path$3.prototype.onAttrChange = function(name, value$1, originValue) {
		_super.prototype.onAttrChange.call(this, name, value$1, originValue);
		if (name === "path") this._setPathArr(value$1);
		this.setArrow();
	};
	Path$3.prototype._setPathArr = function(path) {
		this.attrs.path = pathToAbsolute(path);
		var hasArc$1 = path_default$6.hasArc(path);
		this.set("hasArc", hasArc$1);
		this.set("paramsCache", {});
		this.set("segments", null);
		this.set("curve", null);
		this.set("tCache", null);
		this.set("totalLength", null);
	};
	Path$3.prototype.getSegments = function() {
		var segments = this.get("segements");
		if (!segments) {
			segments = getSegments(this.attr("path"));
			this.set("segments", segments);
		}
		return segments;
	};
	Path$3.prototype.setArrow = function() {
		var attrs = this.attr();
		var startArrow = attrs.startArrow, endArrow = attrs.endArrow;
		if (startArrow) {
			var tangent = this.getStartTangent();
			addStartArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);
		}
		if (endArrow) {
			var tangent = this.getEndTangent();
			addEndArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);
		}
	};
	Path$3.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
		var segments = this.getSegments();
		var hasArc$1 = this.get("hasArc");
		var isHit = false;
		if (isStroke) {
			var length_1 = this.getTotalLength();
			isHit = path_default$6.isPointInStroke(segments, lineWidth, x, y, length_1);
		}
		if (!isHit && isFill) if (hasArc$1) isHit = isPointInPath(this, x, y);
		else {
			var path = this.attr("path");
			var extractResutl = path_default$6.extractPolygons(path);
			isHit = isInPolygons(extractResutl.polygons, x, y) || isInPolygons(extractResutl.polylines, x, y);
		}
		return isHit;
	};
	Path$3.prototype.createPath = function(context) {
		var attrs = this.attr();
		var paramsCache = this.get("paramsCache");
		drawPath(this, context, attrs, paramsCache);
	};
	Path$3.prototype.afterDrawPath = function(context) {
		var startArrowShape = this.get("startArrowShape");
		var endArrowShape = this.get("endArrowShape");
		if (startArrowShape) startArrowShape.draw(context);
		if (endArrowShape) endArrowShape.draw(context);
	};
	/**
	* Get total length of path
	* @return {number} length
	*/
	Path$3.prototype.getTotalLength = function() {
		var totalLength = this.get("totalLength");
		if (!is_nil_default(totalLength)) return totalLength;
		this._calculateCurve();
		this._setTcache();
		return this.get("totalLength");
	};
	/**
	* Get point according to ratio
	* @param {number} ratio
	* @return {Point} point
	*/
	Path$3.prototype.getPoint = function(ratio) {
		var tCache = this.get("tCache");
		if (!tCache) {
			this._calculateCurve();
			this._setTcache();
			tCache = this.get("tCache");
		}
		var subt;
		var index;
		var curve = this.get("curve");
		if (!tCache || tCache.length === 0) {
			if (curve) return {
				x: curve[0][1],
				y: curve[0][2]
			};
			return null;
		}
		each_default(tCache, function(v, i) {
			if (ratio >= v[0] && ratio <= v[1]) {
				subt = (ratio - v[0]) / (v[1] - v[0]);
				index = i;
			}
		});
		var seg = curve[index];
		if (is_nil_default(seg) || is_nil_default(index)) return null;
		var l = seg.length;
		var nextSeg = curve[index + 1];
		return cubic_default.pointAt(seg[l - 2], seg[l - 1], nextSeg[1], nextSeg[2], nextSeg[3], nextSeg[4], nextSeg[5], nextSeg[6], subt);
	};
	Path$3.prototype._calculateCurve = function() {
		var path = this.attr().path;
		this.set("curve", path_default$6.pathToCurve(path));
	};
	Path$3.prototype._setTcache = function() {
		var totalLength = 0;
		var tempLength = 0;
		var tCache = [];
		var segmentT;
		var segmentL;
		var segmentN;
		var l;
		var curve = this.get("curve");
		if (!curve) return;
		each_default(curve, function(segment, i) {
			segmentN = curve[i + 1];
			l = segment.length;
			if (segmentN) totalLength += cubic_default.length(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]) || 0;
		});
		this.set("totalLength", totalLength);
		if (totalLength === 0) {
			this.set("tCache", []);
			return;
		}
		each_default(curve, function(segment, i) {
			segmentN = curve[i + 1];
			l = segment.length;
			if (segmentN) {
				segmentT = [];
				segmentT[0] = tempLength / totalLength;
				segmentL = cubic_default.length(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]);
				tempLength += segmentL || 0;
				segmentT[1] = tempLength / totalLength;
				tCache.push(segmentT);
			}
		});
		this.set("tCache", tCache);
	};
	/**
	* Get start tangent vector
	* @return {Array}
	*/
	Path$3.prototype.getStartTangent = function() {
		var segments = this.getSegments();
		var result;
		if (segments.length > 1) {
			var startPoint = segments[0].currentPoint;
			var endPoint = segments[1].currentPoint;
			var tangent = segments[1].startTangent;
			result = [];
			if (tangent) {
				result.push([startPoint[0] - tangent[0], startPoint[1] - tangent[1]]);
				result.push([startPoint[0], startPoint[1]]);
			} else {
				result.push([endPoint[0], endPoint[1]]);
				result.push([startPoint[0], startPoint[1]]);
			}
		}
		return result;
	};
	/**
	* Get end tangent vector
	* @return {Array}
	*/
	Path$3.prototype.getEndTangent = function() {
		var segments = this.getSegments();
		var length$1 = segments.length;
		var result;
		if (length$1 > 1) {
			var startPoint = segments[length$1 - 2].currentPoint;
			var endPoint = segments[length$1 - 1].currentPoint;
			var tangent = segments[length$1 - 1].endTangent;
			result = [];
			if (tangent) {
				result.push([endPoint[0] - tangent[0], endPoint[1] - tangent[1]]);
				result.push([endPoint[0], endPoint[1]]);
			} else {
				result.push([startPoint[0], startPoint[1]]);
				result.push([endPoint[0], endPoint[1]]);
			}
		}
		return result;
	};
	return Path$3;
}(base_default$6);
var path_default$5 = Path$2;

//#endregion
//#region node_modules/@antv/g-canvas/esm/util/in-stroke/polyline.js
function inPolyline(points, lineWidth, x, y, isClose) {
	var count$1 = points.length;
	if (count$1 < 2) return false;
	for (var i = 0; i < count$1 - 1; i++) {
		var x1 = points[i][0];
		var y1 = points[i][1];
		var x2 = points[i + 1][0];
		var y2 = points[i + 1][1];
		if (inLine(x1, y1, x2, y2, lineWidth, x, y)) return true;
	}
	if (isClose) {
		var first = points[0];
		var last$1 = points[count$1 - 1];
		if (inLine(first[0], first[1], last$1[0], last$1[1], lineWidth, x, y)) return true;
	}
	return false;
}

//#endregion
//#region node_modules/@antv/g-canvas/esm/shape/polygon.js
var Polygon$2 = function(_super) {
	__extends(Polygon$3, _super);
	function Polygon$3() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	Polygon$3.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
		var points = this.attr().points;
		var isHit = false;
		if (isStroke) isHit = inPolyline(points, lineWidth, x, y, true);
		if (!isHit && isFill) isHit = isInPolygon(points, x, y);
		return isHit;
	};
	Polygon$3.prototype.createPath = function(context) {
		var points = this.attr().points;
		if (points.length < 2) return;
		context.beginPath();
		for (var i = 0; i < points.length; i++) {
			var point$1 = points[i];
			if (i === 0) context.moveTo(point$1[0], point$1[1]);
			else context.lineTo(point$1[0], point$1[1]);
		}
		context.closePath();
	};
	return Polygon$3;
}(base_default$6);
var polygon_default$2 = Polygon$2;

//#endregion
//#region node_modules/@antv/g-canvas/esm/shape/polyline.js
var PolyLine = function(_super) {
	__extends(PolyLine$1, _super);
	function PolyLine$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	PolyLine$1.prototype.getDefaultAttrs = function() {
		var attrs = _super.prototype.getDefaultAttrs.call(this);
		return __assign(__assign({}, attrs), {
			startArrow: false,
			endArrow: false
		});
	};
	PolyLine$1.prototype.initAttrs = function(attrs) {
		this.setArrow();
	};
	PolyLine$1.prototype.onAttrChange = function(name, value$1, originValue) {
		_super.prototype.onAttrChange.call(this, name, value$1, originValue);
		this.setArrow();
		if (["points"].indexOf(name) !== -1) this._resetCache();
	};
	PolyLine$1.prototype._resetCache = function() {
		this.set("totalLength", null);
		this.set("tCache", null);
	};
	PolyLine$1.prototype.setArrow = function() {
		var attrs = this.attr();
		var _a$5 = this.attrs, points = _a$5.points, startArrow = _a$5.startArrow, endArrow = _a$5.endArrow;
		var length$1 = points.length;
		var x1 = points[0][0];
		var y1 = points[0][1];
		var x2 = points[length$1 - 1][0];
		var y2 = points[length$1 - 1][1];
		if (startArrow) addStartArrow(this, attrs, points[1][0], points[1][1], x1, y1);
		if (endArrow) addEndArrow(this, attrs, points[length$1 - 2][0], points[length$1 - 2][1], x2, y2);
	};
	PolyLine$1.prototype.isFill = function() {
		return false;
	};
	PolyLine$1.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
		if (!isStroke || !lineWidth) return false;
		var points = this.attr().points;
		return inPolyline(points, lineWidth, x, y, false);
	};
	PolyLine$1.prototype.isStroke = function() {
		return true;
	};
	PolyLine$1.prototype.createPath = function(context) {
		var _a$5 = this.attr(), points = _a$5.points, startArrow = _a$5.startArrow, endArrow = _a$5.endArrow;
		var length$1 = points.length;
		if (points.length < 2) return;
		var x1 = points[0][0];
		var y1 = points[0][1];
		var x2 = points[length$1 - 1][0];
		var y2 = points[length$1 - 1][1];
		if (startArrow && startArrow.d) {
			var distance$7 = getShortenOffset(x1, y1, points[1][0], points[1][1], startArrow.d);
			x1 += distance$7.dx;
			y1 += distance$7.dy;
		}
		if (endArrow && endArrow.d) {
			var distance$7 = getShortenOffset(points[length$1 - 2][0], points[length$1 - 2][1], x2, y2, endArrow.d);
			x2 -= distance$7.dx;
			y2 -= distance$7.dy;
		}
		context.beginPath();
		context.moveTo(x1, y1);
		for (var i = 0; i < length$1 - 1; i++) {
			var point$1 = points[i];
			context.lineTo(point$1[0], point$1[1]);
		}
		context.lineTo(x2, y2);
	};
	PolyLine$1.prototype.afterDrawPath = function(context) {
		var startArrowShape = this.get("startArrowShape");
		var endArrowShape = this.get("endArrowShape");
		if (startArrowShape) startArrowShape.draw(context);
		if (endArrowShape) endArrowShape.draw(context);
	};
	/**
	* Get length of polyline
	* @return {number} length
	*/
	PolyLine$1.prototype.getTotalLength = function() {
		var points = this.attr().points;
		var totalLength = this.get("totalLength");
		if (!is_nil_default(totalLength)) return totalLength;
		this.set("totalLength", polyline_default$1.length(points));
		return this.get("totalLength");
	};
	/**
	* Get point according to ratio
	* @param {number} ratio
	* @return {Point} point
	*/
	PolyLine$1.prototype.getPoint = function(ratio) {
		var points = this.attr().points;
		var tCache = this.get("tCache");
		if (!tCache) {
			this._setTcache();
			tCache = this.get("tCache");
		}
		var subt;
		var index;
		each_default(tCache, function(v, i) {
			if (ratio >= v[0] && ratio <= v[1]) {
				subt = (ratio - v[0]) / (v[1] - v[0]);
				index = i;
			}
		});
		return line_default$2.pointAt(points[index][0], points[index][1], points[index + 1][0], points[index + 1][1], subt);
	};
	PolyLine$1.prototype._setTcache = function() {
		var points = this.attr().points;
		if (!points || points.length === 0) return;
		var totalLength = this.getTotalLength();
		if (totalLength <= 0) return;
		var tempLength = 0;
		var tCache = [];
		var segmentT;
		var segmentL;
		each_default(points, function(p, i) {
			if (points[i + 1]) {
				segmentT = [];
				segmentT[0] = tempLength / totalLength;
				segmentL = line_default$2.length(p[0], p[1], points[i + 1][0], points[i + 1][1]);
				tempLength += segmentL;
				segmentT[1] = tempLength / totalLength;
				tCache.push(segmentT);
			}
		});
		this.set("tCache", tCache);
	};
	/**
	* Get start tangent vector
	* @return {Array}
	*/
	PolyLine$1.prototype.getStartTangent = function() {
		var points = this.attr().points;
		var result = [];
		result.push([points[1][0], points[1][1]]);
		result.push([points[0][0], points[0][1]]);
		return result;
	};
	/**
	* Get end tangent vector
	* @return {Array}
	*/
	PolyLine$1.prototype.getEndTangent = function() {
		var points = this.attr().points;
		var l = points.length - 1;
		var result = [];
		result.push([points[l - 1][0], points[l - 1][1]]);
		result.push([points[l][0], points[l][1]]);
		return result;
	};
	return PolyLine$1;
}(base_default$6);
var polyline_default$2 = PolyLine;

//#endregion
//#region node_modules/@antv/g-canvas/esm/util/in-stroke/rect.js
function inRect(minX, minY, width, height, lineWidth, x, y) {
	var halfWidth = lineWidth / 2;
	return inBox(minX - halfWidth, minY - halfWidth, width, lineWidth, x, y) || inBox(minX + width - halfWidth, minY - halfWidth, lineWidth, height, x, y) || inBox(minX + halfWidth, minY + height - halfWidth, width, lineWidth, x, y) || inBox(minX - halfWidth, minY + halfWidth, lineWidth, height, x, y);
}

//#endregion
//#region node_modules/@antv/g-canvas/esm/util/in-stroke/rect-radius.js
function rectWithRadius(minX, minY, width, height, radius, lineWidth, x, y) {
	lineWidth / 2;
	return inLine(minX + radius, minY, minX + width - radius, minY, lineWidth, x, y) || inLine(minX + width, minY + radius, minX + width, minY + height - radius, lineWidth, x, y) || inLine(minX + width - radius, minY + height, minX + radius, minY + height, lineWidth, x, y) || inLine(minX, minY + height - radius, minX, minY + radius, lineWidth, x, y) || arc(minX + width - radius, minY + radius, radius, 1.5 * Math.PI, 2 * Math.PI, lineWidth, x, y) || arc(minX + width - radius, minY + height - radius, radius, 0, .5 * Math.PI, lineWidth, x, y) || arc(minX + radius, minY + height - radius, radius, .5 * Math.PI, Math.PI, lineWidth, x, y) || arc(minX + radius, minY + radius, radius, Math.PI, 1.5 * Math.PI, lineWidth, x, y);
}

//#endregion
//#region node_modules/@antv/g-canvas/esm/shape/rect.js
var Rect$2 = function(_super) {
	__extends(Rect$3, _super);
	function Rect$3() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	Rect$3.prototype.getDefaultAttrs = function() {
		var attrs = _super.prototype.getDefaultAttrs.call(this);
		return __assign(__assign({}, attrs), {
			x: 0,
			y: 0,
			width: 0,
			height: 0,
			radius: 0
		});
	};
	Rect$3.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
		var attrs = this.attr();
		var minX = attrs.x;
		var minY = attrs.y;
		var width = attrs.width;
		var height = attrs.height;
		var radius = attrs.radius;
		if (!radius) {
			var halfWidth = lineWidth / 2;
			if (isFill && isStroke) return inBox(minX - halfWidth, minY - halfWidth, width + halfWidth, height + halfWidth, x, y);
			if (isFill) return inBox(minX, minY, width, height, x, y);
			if (isStroke) return inRect(minX, minY, width, height, lineWidth, x, y);
		} else {
			var isHit = false;
			if (isStroke) isHit = rectWithRadius(minX, minY, width, height, radius, lineWidth, x, y);
			if (!isHit && isFill) isHit = isPointInPath(this, x, y);
			return isHit;
		}
	};
	Rect$3.prototype.createPath = function(context) {
		var attrs = this.attr();
		var x = attrs.x;
		var y = attrs.y;
		var width = attrs.width;
		var height = attrs.height;
		var radius = attrs.radius;
		context.beginPath();
		if (radius === 0) context.rect(x, y, width, height);
		else {
			var _a$5 = parseRadius$2(radius), r1 = _a$5[0], r2 = _a$5[1], r3 = _a$5[2], r4 = _a$5[3];
			context.moveTo(x + r1, y);
			context.lineTo(x + width - r2, y);
			r2 !== 0 && context.arc(x + width - r2, y + r2, r2, -Math.PI / 2, 0);
			context.lineTo(x + width, y + height - r3);
			r3 !== 0 && context.arc(x + width - r3, y + height - r3, r3, 0, Math.PI / 2);
			context.lineTo(x + r4, y + height);
			r4 !== 0 && context.arc(x + r4, y + height - r4, r4, Math.PI / 2, Math.PI);
			context.lineTo(x, y + r1);
			r1 !== 0 && context.arc(x + r1, y + r1, r1, Math.PI, Math.PI * 1.5);
			context.closePath();
		}
	};
	return Rect$3;
}(base_default$6);
var rect_default$4 = Rect$2;

//#endregion
//#region node_modules/@antv/g-canvas/esm/shape/text.js
var Text$1 = function(_super) {
	__extends(Text$2, _super);
	function Text$2() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	Text$2.prototype.getDefaultAttrs = function() {
		var attrs = _super.prototype.getDefaultAttrs.call(this);
		return __assign(__assign({}, attrs), {
			x: 0,
			y: 0,
			text: null,
			fontSize: 12,
			fontFamily: "sans-serif",
			fontStyle: "normal",
			fontWeight: "normal",
			fontVariant: "normal",
			textAlign: "start",
			textBaseline: "bottom"
		});
	};
	Text$2.prototype.isOnlyHitBox = function() {
		return true;
	};
	Text$2.prototype.initAttrs = function(attrs) {
		this._assembleFont();
		if (attrs.text) this._setText(attrs.text);
	};
	Text$2.prototype._assembleFont = function() {
		var attrs = this.attrs;
		attrs.font = assembleFont(attrs);
	};
	Text$2.prototype._setText = function(text) {
		var textArr = null;
		if (is_string_default(text) && text.indexOf("\n") !== -1) textArr = text.split("\n");
		this.set("textArr", textArr);
	};
	Text$2.prototype.onAttrChange = function(name, value$1, originValue) {
		_super.prototype.onAttrChange.call(this, name, value$1, originValue);
		if (name.startsWith("font")) this._assembleFont();
		if (name === "text") this._setText(value$1);
	};
	Text$2.prototype._getSpaceingY = function() {
		var attrs = this.attrs;
		var lineHeight = attrs.lineHeight;
		var fontSize = attrs.fontSize * 1;
		return lineHeight ? lineHeight - fontSize : fontSize * .14;
	};
	Text$2.prototype._drawTextArr = function(context, textArr, isFill) {
		var attrs = this.attrs;
		var textBaseline = attrs.textBaseline;
		var x = attrs.x;
		var y = attrs.y;
		var fontSize = attrs.fontSize * 1;
		var spaceingY = this._getSpaceingY();
		var height = getTextHeight(attrs.text, attrs.fontSize, attrs.lineHeight);
		var subY;
		each_default(textArr, function(subText, index) {
			subY = y + index * (spaceingY + fontSize) - height + fontSize;
			if (textBaseline === "middle") subY += height - fontSize - (height - fontSize) / 2;
			if (textBaseline === "top") subY += height - fontSize;
			if (!is_nil_default(subText)) if (isFill) context.fillText(subText, x, subY);
			else context.strokeText(subText, x, subY);
		});
	};
	Text$2.prototype._drawText = function(context, isFill) {
		var attrs = this.attr();
		var x = attrs.x;
		var y = attrs.y;
		var textArr = this.get("textArr");
		if (textArr) this._drawTextArr(context, textArr, isFill);
		else {
			var text = attrs.text;
			if (!is_nil_default(text)) if (isFill) context.fillText(text, x, y);
			else context.strokeText(text, x, y);
		}
	};
	Text$2.prototype.strokeAndFill = function(context) {
		var _a$5 = this.attrs, lineWidth = _a$5.lineWidth, opacity = _a$5.opacity, strokeOpacity = _a$5.strokeOpacity, fillOpacity = _a$5.fillOpacity;
		if (this.isStroke()) {
			if (lineWidth > 0) {
				if (!is_nil_default(strokeOpacity) && strokeOpacity !== 1) context.globalAlpha = opacity;
				this.stroke(context);
			}
		}
		if (this.isFill()) if (!is_nil_default(fillOpacity) && fillOpacity !== 1) {
			context.globalAlpha = fillOpacity;
			this.fill(context);
			context.globalAlpha = opacity;
		} else this.fill(context);
		this.afterDrawPath(context);
	};
	Text$2.prototype.fill = function(context) {
		this._drawText(context, true);
	};
	Text$2.prototype.stroke = function(context) {
		this._drawText(context, false);
	};
	return Text$2;
}(base_default$6);
var text_default$1 = Text$1;

//#endregion
//#region node_modules/@antv/g-canvas/esm/shape/index.js
var shape_exports$1 = /* @__PURE__ */ __export({
	Base: () => base_default$6,
	Circle: () => circle_default$4,
	Ellipse: () => ellipse_default$1,
	Image: () => image_default$1,
	Line: () => line_default$3,
	Marker: () => marker_default$1,
	Path: () => path_default$5,
	Polygon: () => polygon_default$2,
	Polyline: () => polyline_default$2,
	Rect: () => rect_default$4,
	Text: () => text_default$1
});

//#endregion
//#region node_modules/@antv/g-canvas/esm/util/hit.js
function invertFromMatrix(v, matrix) {
	if (matrix) {
		var invertMatrix = invert(matrix);
		return multiplyVec2(invertMatrix, v);
	}
	return v;
}
function getRefXY(element, x, y) {
	var totalMatrix = element.getTotalMatrix();
	if (totalMatrix) {
		var _a$5 = invertFromMatrix([
			x,
			y,
			1
		], totalMatrix), refX = _a$5[0], refY = _a$5[1];
		return [refX, refY];
	}
	return [x, y];
}
function preTest(element, x, y) {
	if (element.isCanvas && element.isCanvas()) return true;
	if (!isAllowCapture(element) || element.cfg.isInView === false) return false;
	if (element.cfg.clipShape) {
		var _a$5 = getRefXY(element, x, y), refX = _a$5[0], refY = _a$5[1];
		if (element.isClipped(refX, refY)) return false;
	}
	var bbox = element.cfg.cacheCanvasBBox || element.getCanvasBBox();
	if (!(x >= bbox.minX && x <= bbox.maxX && y >= bbox.minY && y <= bbox.maxY)) return false;
	return true;
}
function getShape(container, x, y) {
	if (!preTest(container, x, y)) return null;
	var shape = null;
	var children = container.getChildren();
	for (var i = children.length - 1; i >= 0; i--) {
		var child = children[i];
		if (child.isGroup()) shape = getShape(child, x, y);
		else if (preTest(child, x, y)) {
			var curShape = child;
			var _a$5 = getRefXY(child, x, y), refX = _a$5[0], refY = _a$5[1];
			if (curShape.isInShape(refX, refY)) shape = child;
		}
		if (shape) break;
	}
	return shape;
}

//#endregion
//#region node_modules/@antv/g-canvas/esm/canvas.js
var Canvas$1 = function(_super) {
	__extends(Canvas$3, _super);
	function Canvas$3() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	Canvas$3.prototype.getDefaultCfg = function() {
		var cfg = _super.prototype.getDefaultCfg.call(this);
		cfg["renderer"] = "canvas";
		cfg["autoDraw"] = true;
		cfg["localRefresh"] = true;
		cfg["refreshElements"] = [];
		cfg["clipView"] = true;
		cfg["quickHit"] = false;
		return cfg;
	};
	/**
	* 一些方法调用会引起画布变化
	* @param {ChangeType} changeType 改变的类型
	*/
	Canvas$3.prototype.onCanvasChange = function(changeType) {
		/**
		* 触发画布更新的三种 changeType
		* 1. attr: 修改画布的绘图属性
		* 2. sort: 画布排序，图形的层次会发生变化
		* 3. changeSize: 改变画布大小
		*/
		if (changeType === "attr" || changeType === "sort" || changeType === "changeSize") {
			this.set("refreshElements", [this]);
			this.draw();
		}
	};
	Canvas$3.prototype.getShapeBase = function() {
		return shape_exports$1;
	};
	Canvas$3.prototype.getGroupBase = function() {
		return group_default$2;
	};
	/**
	* 获取屏幕像素比
	*/
	Canvas$3.prototype.getPixelRatio = function() {
		var pixelRatio = this.get("pixelRatio") || getPixelRatio$1();
		return pixelRatio >= 1 ? Math.ceil(pixelRatio) : 1;
	};
	Canvas$3.prototype.getViewRange = function() {
		return {
			minX: 0,
			minY: 0,
			maxX: this.cfg.width,
			maxY: this.cfg.height
		};
	};
	Canvas$3.prototype.createDom = function() {
		var element = document.createElement("canvas");
		var context = element.getContext("2d");
		this.set("context", context);
		return element;
	};
	Canvas$3.prototype.setDOMSize = function(width, height) {
		_super.prototype.setDOMSize.call(this, width, height);
		var context = this.get("context");
		var el = this.get("el");
		var pixelRatio = this.getPixelRatio();
		el.width = pixelRatio * width;
		el.height = pixelRatio * height;
		if (pixelRatio > 1) context.scale(pixelRatio, pixelRatio);
	};
	Canvas$3.prototype.clear = function() {
		_super.prototype.clear.call(this);
		this._clearFrame();
		var context = this.get("context");
		var element = this.get("el");
		context.clearRect(0, 0, element.width, element.height);
	};
	Canvas$3.prototype.getShape = function(x, y) {
		var shape;
		if (this.get("quickHit")) shape = getShape(this, x, y);
		else shape = _super.prototype.getShape.call(this, x, y, null);
		return shape;
	};
	Canvas$3.prototype._getRefreshRegion = function() {
		var elements = this.get("refreshElements");
		var viewRegion = this.getViewRange();
		var region;
		if (elements.length && elements[0] === this) region = viewRegion;
		else {
			region = getMergedRegion(elements);
			if (region) {
				region.minX = Math.floor(region.minX);
				region.minY = Math.floor(region.minY);
				region.maxX = Math.ceil(region.maxX);
				region.maxY = Math.ceil(region.maxY);
				region.maxY += 1;
				if (this.get("clipView")) region = mergeView(region, viewRegion);
			}
		}
		return region;
	};
	/**
	* 刷新图形元素，这里仅仅是放入队列，下次绘制时进行绘制
	* @param {IElement} element 图形元素
	*/
	Canvas$3.prototype.refreshElement = function(element) {
		this.get("refreshElements").push(element);
	};
	Canvas$3.prototype._clearFrame = function() {
		var drawFrame = this.get("drawFrame");
		if (drawFrame) {
			cancelAnimationFrame(drawFrame);
			this.set("drawFrame", null);
			this.set("refreshElements", []);
		}
	};
	Canvas$3.prototype.draw = function() {
		var drawFrame = this.get("drawFrame");
		if (this.get("autoDraw") && drawFrame) return;
		this._startDraw();
	};
	Canvas$3.prototype._drawAll = function() {
		var context = this.get("context");
		var element = this.get("el");
		var children = this.getChildren();
		context.clearRect(0, 0, element.width, element.height);
		applyAttrsToContext(context, this);
		drawChildren$1(context, children);
		this.set("refreshElements", []);
	};
	Canvas$3.prototype._drawRegion = function() {
		var context = this.get("context");
		var refreshElements = this.get("refreshElements");
		var children = this.getChildren();
		var region = this._getRefreshRegion();
		if (region) {
			context.clearRect(region.minX, region.minY, region.maxX - region.minX, region.maxY - region.minY);
			context.save();
			context.beginPath();
			context.rect(region.minX, region.minY, region.maxX - region.minX, region.maxY - region.minY);
			context.clip();
			applyAttrsToContext(context, this);
			checkRefresh(this, children, region);
			drawChildren$1(context, children, region);
			context.restore();
		} else if (refreshElements.length) clearChanged(refreshElements);
		each_default(refreshElements, function(element) {
			if (element.get("hasChanged")) element.set("hasChanged", false);
		});
		this.set("refreshElements", []);
	};
	Canvas$3.prototype._startDraw = function() {
		var _this = this;
		var drawFrame = this.get("drawFrame");
		var drawFrameCallback = this.get("drawFrameCallback");
		if (!drawFrame) {
			drawFrame = requestAnimationFrame(function() {
				if (_this.get("localRefresh")) _this._drawRegion();
				else _this._drawAll();
				_this.set("drawFrame", null);
				if (drawFrameCallback) drawFrameCallback();
			});
			this.set("drawFrame", drawFrame);
		}
	};
	Canvas$3.prototype.skipDraw = function() {};
	Canvas$3.prototype.removeDom = function() {
		var el = this.get("el");
		el.width = 0;
		el.height = 0;
		el.parentNode.removeChild(el);
	};
	return Canvas$3;
}(canvas_default$1);
var canvas_default$2 = Canvas$1;

//#endregion
//#region node_modules/@antv/g-canvas/esm/index.js
var esm_exports$1 = /* @__PURE__ */ __export({
	AbstractCanvas: () => canvas_default$1,
	AbstractGroup: () => group_default$1,
	AbstractShape: () => shape_default,
	Base: () => base_default$15,
	Canvas: () => canvas_default$2,
	Event: () => graph_event_default,
	Group: () => group_default$2,
	PathUtil: () => path_exports,
	Shape: () => shape_exports$1,
	assembleFont: () => assembleFont,
	getArcParams: () => getArcParams,
	getBBoxMethod: () => getMethod,
	getOffScreenContext: () => getOffScreenContext,
	getTextHeight: () => getTextHeight,
	invert: () => invert,
	isAllowCapture: () => isAllowCapture,
	multiplyVec2: () => multiplyVec2,
	registerBBox: () => register,
	registerEasing: () => registerEasing,
	version: () => version$2
});
var version$2 = "0.5.12";

//#endregion
//#region node_modules/@antv/g-svg/esm/constant.js
var SHAPE_TO_TAGS = {
	rect: "path",
	circle: "circle",
	line: "line",
	path: "path",
	marker: "path",
	text: "text",
	polyline: "polyline",
	polygon: "polygon",
	image: "image",
	ellipse: "ellipse",
	dom: "foreignObject"
};
var SVG_ATTR_MAP = {
	opacity: "opacity",
	fillStyle: "fill",
	fill: "fill",
	fillOpacity: "fill-opacity",
	strokeStyle: "stroke",
	strokeOpacity: "stroke-opacity",
	stroke: "stroke",
	x: "x",
	y: "y",
	r: "r",
	rx: "rx",
	ry: "ry",
	width: "width",
	height: "height",
	x1: "x1",
	x2: "x2",
	y1: "y1",
	y2: "y2",
	lineCap: "stroke-linecap",
	lineJoin: "stroke-linejoin",
	lineWidth: "stroke-width",
	lineDash: "stroke-dasharray",
	lineDashOffset: "stroke-dashoffset",
	miterLimit: "stroke-miterlimit",
	font: "font",
	fontSize: "font-size",
	fontStyle: "font-style",
	fontVariant: "font-variant",
	fontWeight: "font-weight",
	fontFamily: "font-family",
	startArrow: "marker-start",
	endArrow: "marker-end",
	path: "d",
	class: "class",
	id: "id",
	style: "style",
	preserveAspectRatio: "preserveAspectRatio"
};

//#endregion
//#region node_modules/@antv/g-svg/esm/util/dom.js
/**
* 创建并返回图形的 svg 元素
* @param type svg类型
*/
function createSVGElement(type) {
	return document.createElementNS("http://www.w3.org/2000/svg", type);
}
/**
* 创建并返回图形的 dom 元素
* @param  {IShape} shape 图形
* @return {SVGElement}
*/
function createDom(shape) {
	var type = SHAPE_TO_TAGS[shape.type];
	var parent = shape.getParent();
	if (!type) throw new Error("the type " + shape.type + " is not supported by svg");
	var element = createSVGElement(type);
	if (shape.get("id")) element.id = shape.get("id");
	shape.set("el", element);
	shape.set("attrs", {});
	if (parent) {
		var parentNode = parent.get("el");
		if (parentNode) parentNode.appendChild(element);
		else {
			parentNode = parent.createDom();
			parent.set("el", parentNode);
			parentNode.appendChild(element);
		}
	}
	return element;
}
/**
* 对 dom 元素进行排序
* @param {IElement} element  元素
* @param {sorter}   function 排序函数
*/
function sortDom(element, sorter) {
	var el = element.get("el");
	var childList = to_array_default(el.children).sort(sorter);
	var fragment = document.createDocumentFragment();
	childList.forEach(function(child) {
		fragment.appendChild(child);
	});
	el.appendChild(fragment);
}
/**
* 将 dom 元素移动到父元素下的指定位置
* @param {SVGElement} element     dom 元素
* @param {number}     targetIndex 目标位置(从 0 开始)
*/
function moveTo(element, targetIndex) {
	var parentNode = element.parentNode;
	var siblings = Array.from(parentNode.childNodes).filter(function(node) {
		return node.nodeType === 1 && node.nodeName.toLowerCase() !== "defs";
	});
	var target = siblings[targetIndex];
	var currentIndex = siblings.indexOf(element);
	if (target) {
		if (currentIndex > targetIndex) parentNode.insertBefore(element, target);
		else if (currentIndex < targetIndex) {
			var targetNext = siblings[targetIndex + 1];
			if (targetNext) parentNode.insertBefore(element, targetNext);
			else parentNode.appendChild(element);
		}
	} else parentNode.appendChild(element);
}

//#endregion
//#region node_modules/@antv/g-svg/esm/util/svg.js
function setShadow(model, context) {
	var el = model.cfg.el;
	var attrs = model.attr();
	var cfg = {
		dx: attrs.shadowOffsetX,
		dy: attrs.shadowOffsetY,
		blur: attrs.shadowBlur,
		color: attrs.shadowColor
	};
	if (!cfg.dx && !cfg.dy && !cfg.blur && !cfg.color) el.removeAttribute("filter");
	else {
		var id$1 = context.find("filter", cfg);
		if (!id$1) id$1 = context.addShadow(cfg);
		el.setAttribute("filter", "url(#" + id$1 + ")");
	}
}
function setTransform(model) {
	var matrix = model.attr().matrix;
	if (matrix) {
		var el = model.cfg.el;
		var transform$7 = [];
		for (var i = 0; i < 9; i += 3) transform$7.push(matrix[i] + "," + matrix[i + 1]);
		transform$7 = transform$7.join(",");
		if (transform$7.indexOf("NaN") === -1) el.setAttribute("transform", "matrix(" + transform$7 + ")");
		else console.warn("invalid matrix:", matrix);
	}
}
function setClip(model, context) {
	var clip = model.getClip();
	var el = model.get("el");
	if (!clip) el.removeAttribute("clip-path");
	else if (clip && !el.hasAttribute("clip-path")) {
		createDom(clip);
		clip.createPath(context);
		var id$1 = context.addClip(clip);
		el.setAttribute("clip-path", "url(#" + id$1 + ")");
	}
}

//#endregion
//#region node_modules/@antv/g-svg/esm/util/draw.js
function drawChildren(context, children) {
	children.forEach(function(child) {
		child.draw(context);
	});
}
/**
* 更新元素，包括 group 和 shape
* @param {IElement} element       SVG 元素
* @param {ChangeType} changeType  更新类型
*/
function refreshElement(element, changeType) {
	var canvas = element.get("canvas");
	if (canvas && canvas.get("autoDraw")) {
		var context = canvas.get("context");
		var parent_1 = element.getParent();
		var parentChildren = parent_1 ? parent_1.getChildren() : [canvas];
		var el = element.get("el");
		if (changeType === "remove") {
			if (element.get("isClipShape")) {
				var clipPathEl = el && el.parentNode;
				var defsEl = clipPathEl && clipPathEl.parentNode;
				if (clipPathEl && defsEl) defsEl.removeChild(clipPathEl);
			} else if (el && el.parentNode) el.parentNode.removeChild(el);
		} else if (changeType === "show") el.setAttribute("visibility", "visible");
		else if (changeType === "hide") el.setAttribute("visibility", "hidden");
		else if (changeType === "zIndex") moveTo(el, parentChildren.indexOf(element));
		else if (changeType === "sort") {
			var children_1 = element.get("children");
			if (children_1 && children_1.length) sortDom(element, function(a, b) {
				return children_1.indexOf(a) - children_1.indexOf(b) ? 1 : 0;
			});
		} else if (changeType === "clear") {
			if (el) el.innerHTML = "";
		} else if (changeType === "matrix") setTransform(element);
		else if (changeType === "clip") setClip(element, context);
		else if (changeType === "attr") {} else if (changeType === "add") element.draw(context);
	}
}

//#endregion
//#region node_modules/@antv/g-svg/esm/group.js
var Group = function(_super) {
	__extends(Group$2, _super);
	function Group$2() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	Group$2.prototype.isEntityGroup = function() {
		return true;
	};
	Group$2.prototype.createDom = function() {
		var element = createSVGElement("g");
		this.set("el", element);
		var parent = this.getParent();
		if (parent) {
			var parentNode = parent.get("el");
			if (parentNode) parentNode.appendChild(element);
			else {
				parentNode = parent.createDom();
				parent.set("el", parentNode);
				parentNode.appendChild(element);
			}
		}
		return element;
	};
	Group$2.prototype.afterAttrsChange = function(targetAttrs) {
		_super.prototype.afterAttrsChange.call(this, targetAttrs);
		var canvas = this.get("canvas");
		if (canvas && canvas.get("autoDraw")) {
			var context = canvas.get("context");
			this.createPath(context, targetAttrs);
		}
	};
	/**
	* 一些方法调用会引起画布变化
	* @param {ChangeType} changeType 改变的类型
	*/
	Group$2.prototype.onCanvasChange = function(changeType) {
		refreshElement(this, changeType);
	};
	Group$2.prototype.getShapeBase = function() {
		return shape_exports;
	};
	Group$2.prototype.getGroupBase = function() {
		return Group$2;
	};
	Group$2.prototype.draw = function(context) {
		var children = this.getChildren();
		var el = this.get("el");
		if (this.get("destroyed")) {
			if (el) el.parentNode.removeChild(el);
		} else {
			if (!el) this.createDom();
			setClip(this, context);
			this.createPath(context);
			if (children.length) drawChildren(context, children);
		}
	};
	/**
	* 绘制分组的路径
	* @param {Defs} context 上下文
	* @param {ShapeAttrs} targetAttrs 渲染的目标属性
	*/
	Group$2.prototype.createPath = function(context, targetAttrs) {
		var attrs = this.attr();
		var el = this.get("el");
		each_default(targetAttrs || attrs, function(value$1, attr) {
			if (SVG_ATTR_MAP[attr]) el.setAttribute(SVG_ATTR_MAP[attr], value$1);
		});
		setTransform(this);
	};
	return Group$2;
}(group_default$1);
var group_default = Group;

//#endregion
//#region node_modules/@antv/g-svg/esm/shape/base.js
var ShapeBase = function(_super) {
	__extends(ShapeBase$3, _super);
	function ShapeBase$3() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = "svg";
		_this.canFill = false;
		_this.canStroke = false;
		return _this;
	}
	ShapeBase$3.prototype.getDefaultAttrs = function() {
		var attrs = _super.prototype.getDefaultAttrs.call(this);
		return __assign(__assign({}, attrs), {
			lineWidth: 1,
			lineAppendWidth: 0,
			strokeOpacity: 1,
			fillOpacity: 1
		});
	};
	ShapeBase$3.prototype.afterAttrsChange = function(targetAttrs) {
		_super.prototype.afterAttrsChange.call(this, targetAttrs);
		var canvas = this.get("canvas");
		if (canvas && canvas.get("autoDraw")) {
			var context = canvas.get("context");
			this.draw(context, targetAttrs);
		}
	};
	ShapeBase$3.prototype.getShapeBase = function() {
		return shape_exports;
	};
	ShapeBase$3.prototype.getGroupBase = function() {
		return group_default;
	};
	/**
	* 一些方法调用会引起画布变化
	* @param {ChangeType} changeType 改变的类型
	*/
	ShapeBase$3.prototype.onCanvasChange = function(changeType) {
		refreshElement(this, changeType);
	};
	ShapeBase$3.prototype.calculateBBox = function() {
		var el = this.get("el");
		var bbox = null;
		if (el) bbox = el.getBBox();
		else {
			var bboxMethod = getMethod(this.get("type"));
			if (bboxMethod) bbox = bboxMethod(this);
		}
		if (bbox) {
			var x = bbox.x, y = bbox.y, width = bbox.width, height = bbox.height;
			var lineWidth = this.getHitLineWidth();
			var halfWidth = lineWidth / 2;
			var minX = x - halfWidth;
			var minY = y - halfWidth;
			var maxX = x + width + halfWidth;
			var maxY$1 = y + height + halfWidth;
			return {
				x: minX,
				y: minY,
				minX,
				minY,
				maxX,
				maxY: maxY$1,
				width: width + lineWidth,
				height: height + lineWidth
			};
		}
		return {
			x: 0,
			y: 0,
			minX: 0,
			minY: 0,
			maxX: 0,
			maxY: 0,
			width: 0,
			height: 0
		};
	};
	ShapeBase$3.prototype.isFill = function() {
		var _a$5 = this.attr(), fill = _a$5.fill, fillStyle = _a$5.fillStyle;
		return (fill || fillStyle || this.isClipShape()) && this.canFill;
	};
	ShapeBase$3.prototype.isStroke = function() {
		var _a$5 = this.attr(), stroke = _a$5.stroke, strokeStyle = _a$5.strokeStyle;
		return (stroke || strokeStyle) && this.canStroke;
	};
	ShapeBase$3.prototype.draw = function(context, targetAttrs) {
		var el = this.get("el");
		if (this.get("destroyed")) {
			if (el) el.parentNode.removeChild(el);
		} else {
			if (!el) createDom(this);
			setClip(this, context);
			this.createPath(context, targetAttrs);
			this.shadow(context, targetAttrs);
			this.strokeAndFill(context, targetAttrs);
			this.transform(targetAttrs);
		}
	};
	/**
	* @protected
	* 绘制图形的路径
	* @param {Defs} context 上下文
	* @param {ShapeAttrs} targetAttrs 渲染的目标属性
	*/
	ShapeBase$3.prototype.createPath = function(context, targetAttrs) {};
	ShapeBase$3.prototype.strokeAndFill = function(context, targetAttrs) {
		var attrs = targetAttrs || this.attr();
		var fill = attrs.fill, fillStyle = attrs.fillStyle, stroke = attrs.stroke, strokeStyle = attrs.strokeStyle, fillOpacity = attrs.fillOpacity, strokeOpacity = attrs.strokeOpacity, lineWidth = attrs.lineWidth;
		var el = this.get("el");
		if (this.canFill) {
			if (!targetAttrs) this._setColor(context, "fill", fill || fillStyle);
			else if ("fill" in attrs) this._setColor(context, "fill", fill);
			else if ("fillStyle" in attrs) this._setColor(context, "fill", fillStyle);
			if (fillOpacity) el.setAttribute(SVG_ATTR_MAP["fillOpacity"], fillOpacity);
		}
		if (this.canStroke && lineWidth > 0) {
			if (!targetAttrs) this._setColor(context, "stroke", stroke || strokeStyle);
			else if ("stroke" in attrs) this._setColor(context, "stroke", stroke);
			else if ("strokeStyle" in attrs) this._setColor(context, "stroke", strokeStyle);
			if (strokeOpacity) el.setAttribute(SVG_ATTR_MAP["strokeOpacity"], strokeOpacity);
			if (lineWidth) el.setAttribute(SVG_ATTR_MAP["lineWidth"], lineWidth);
		}
	};
	ShapeBase$3.prototype._setColor = function(context, attr, value$1) {
		var el = this.get("el");
		if (!value$1) {
			el.setAttribute(SVG_ATTR_MAP[attr], "none");
			return;
		}
		value$1 = value$1.trim();
		if (/^[r,R,L,l]{1}[\s]*\(/.test(value$1)) {
			var id$1 = context.find("gradient", value$1);
			if (!id$1) id$1 = context.addGradient(value$1);
			el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id$1 + ")");
		} else if (/^[p,P]{1}[\s]*\(/.test(value$1)) {
			var id$1 = context.find("pattern", value$1);
			if (!id$1) id$1 = context.addPattern(value$1);
			el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id$1 + ")");
		} else el.setAttribute(SVG_ATTR_MAP[attr], value$1);
	};
	ShapeBase$3.prototype.shadow = function(context, targetAttrs) {
		var attrs = this.attr();
		var _a$5 = targetAttrs || attrs, shadowOffsetX = _a$5.shadowOffsetX, shadowOffsetY = _a$5.shadowOffsetY, shadowBlur = _a$5.shadowBlur, shadowColor = _a$5.shadowColor;
		if (shadowOffsetX || shadowOffsetY || shadowBlur || shadowColor) setShadow(this, context);
	};
	ShapeBase$3.prototype.transform = function(targetAttrs) {
		var attrs = this.attr();
		if ((targetAttrs || attrs).matrix) setTransform(this);
	};
	ShapeBase$3.prototype.isInShape = function(refX, refY) {
		return this.isPointInPath(refX, refY);
	};
	ShapeBase$3.prototype.isPointInPath = function(refX, refY) {
		var el = this.get("el");
		var bbox = this.get("canvas").get("el").getBoundingClientRect();
		var clientX = refX + bbox.left;
		var clientY = refY + bbox.top;
		var element = document.elementFromPoint(clientX, clientY);
		if (element && element.isEqualNode(el)) return true;
		return false;
	};
	/**
	* 获取线拾取的宽度
	* @returns {number} 线的拾取宽度
	*/
	ShapeBase$3.prototype.getHitLineWidth = function() {
		var _a$5 = this.attrs, lineWidth = _a$5.lineWidth, lineAppendWidth = _a$5.lineAppendWidth;
		if (this.isStroke()) return lineWidth + lineAppendWidth;
		return 0;
	};
	return ShapeBase$3;
}(shape_default);
var base_default$5 = ShapeBase;

//#endregion
//#region node_modules/@antv/g-svg/esm/shape/circle.js
var Circle$1 = function(_super) {
	__extends(Circle$5, _super);
	function Circle$5() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = "circle";
		_this.canFill = true;
		_this.canStroke = true;
		return _this;
	}
	Circle$5.prototype.getDefaultAttrs = function() {
		var attrs = _super.prototype.getDefaultAttrs.call(this);
		return __assign(__assign({}, attrs), {
			x: 0,
			y: 0,
			r: 0
		});
	};
	Circle$5.prototype.createPath = function(context, targetAttrs) {
		var attrs = this.attr();
		var el = this.get("el");
		each_default(targetAttrs || attrs, function(value$1, attr) {
			if (attr === "x" || attr === "y") el.setAttribute("c" + attr, value$1);
			else if (SVG_ATTR_MAP[attr]) el.setAttribute(SVG_ATTR_MAP[attr], value$1);
		});
	};
	return Circle$5;
}(base_default$5);
var circle_default$3 = Circle$1;

//#endregion
//#region node_modules/@antv/g-svg/esm/shape/dom.js
var Dom = function(_super) {
	__extends(Dom$1, _super);
	function Dom$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = "dom";
		_this.canFill = false;
		_this.canStroke = false;
		return _this;
	}
	Dom$1.prototype.createPath = function(context, targetAttrs) {
		var attrs = this.attr();
		var el = this.get("el");
		each_default(targetAttrs || attrs, function(value$1, attr) {
			if (SVG_ATTR_MAP[attr]) el.setAttribute(SVG_ATTR_MAP[attr], value$1);
		});
		if (typeof attrs["html"] === "function") {
			var element = attrs["html"].call(this, attrs);
			if (element instanceof Element || element instanceof HTMLDocument) {
				var children = el.childNodes;
				for (var i = children.length - 1; i >= 0; i--) el.removeChild(children[i]);
				el.appendChild(element);
			} else el.innerHTML = element;
		} else el.innerHTML = attrs["html"];
	};
	return Dom$1;
}(base_default$5);
var dom_default = Dom;

//#endregion
//#region node_modules/@antv/g-svg/esm/shape/ellipse.js
var Ellipse = function(_super) {
	__extends(Ellipse$2, _super);
	function Ellipse$2() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = "ellipse";
		_this.canFill = true;
		_this.canStroke = true;
		return _this;
	}
	Ellipse$2.prototype.getDefaultAttrs = function() {
		var attrs = _super.prototype.getDefaultAttrs.call(this);
		return __assign(__assign({}, attrs), {
			x: 0,
			y: 0,
			rx: 0,
			ry: 0
		});
	};
	Ellipse$2.prototype.createPath = function(context, targetAttrs) {
		var attrs = this.attr();
		var el = this.get("el");
		each_default(targetAttrs || attrs, function(value$1, attr) {
			if (attr === "x" || attr === "y") el.setAttribute("c" + attr, value$1);
			else if (SVG_ATTR_MAP[attr]) el.setAttribute(SVG_ATTR_MAP[attr], value$1);
		});
	};
	return Ellipse$2;
}(base_default$5);
var ellipse_default = Ellipse;

//#endregion
//#region node_modules/@antv/g-svg/esm/shape/image.js
var Image$1 = function(_super) {
	__extends(Image$2, _super);
	function Image$2() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = "image";
		_this.canFill = false;
		_this.canStroke = false;
		return _this;
	}
	Image$2.prototype.getDefaultAttrs = function() {
		var attrs = _super.prototype.getDefaultAttrs.call(this);
		return __assign(__assign({}, attrs), {
			x: 0,
			y: 0,
			width: 0,
			height: 0
		});
	};
	Image$2.prototype.createPath = function(context, targetAttrs) {
		var _this = this;
		var attrs = this.attr();
		var el = this.get("el");
		each_default(targetAttrs || attrs, function(value$1, attr) {
			if (attr === "img") _this._setImage(attrs.img);
			else if (SVG_ATTR_MAP[attr]) el.setAttribute(SVG_ATTR_MAP[attr], value$1);
		});
	};
	Image$2.prototype.setAttr = function(name, value$1) {
		this.attrs[name] = value$1;
		if (name === "img") this._setImage(value$1);
	};
	Image$2.prototype._setImage = function(img) {
		var attrs = this.attr();
		var el = this.get("el");
		if (is_string_default(img)) el.setAttribute("href", img);
		else if (img instanceof window.Image) {
			if (!attrs.width) {
				el.setAttribute("width", img.width);
				this.attr("width", img.width);
			}
			if (!attrs.height) {
				el.setAttribute("height", img.height);
				this.attr("height", img.height);
			}
			el.setAttribute("href", img.src);
		} else if (img instanceof HTMLElement && is_string_default(img.nodeName) && img.nodeName.toUpperCase() === "CANVAS") el.setAttribute("href", img.toDataURL());
		else if (img instanceof ImageData) {
			var canvas = document.createElement("canvas");
			canvas.setAttribute("width", "" + img.width);
			canvas.setAttribute("height", "" + img.height);
			canvas.getContext("2d").putImageData(img, 0, 0);
			if (!attrs.width) {
				el.setAttribute("width", "" + img.width);
				this.attr("width", img.width);
			}
			if (!attrs.height) {
				el.setAttribute("height", "" + img.height);
				this.attr("height", img.height);
			}
			el.setAttribute("href", canvas.toDataURL());
		}
	};
	return Image$2;
}(base_default$5);
var image_default = Image$1;

//#endregion
//#region node_modules/@antv/g-svg/esm/shape/line.js
var Line$2 = function(_super) {
	__extends(Line$6, _super);
	function Line$6() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = "line";
		_this.canFill = false;
		_this.canStroke = true;
		return _this;
	}
	Line$6.prototype.getDefaultAttrs = function() {
		var attrs = _super.prototype.getDefaultAttrs.call(this);
		return __assign(__assign({}, attrs), {
			x1: 0,
			y1: 0,
			x2: 0,
			y2: 0,
			startArrow: false,
			endArrow: false
		});
	};
	Line$6.prototype.createPath = function(context, targetAttrs) {
		var attrs = this.attr();
		var el = this.get("el");
		each_default(targetAttrs || attrs, function(value$1, attr) {
			if (attr === "startArrow" || attr === "endArrow") if (value$1) {
				var id$1 = is_object_default(value$1) ? context.addArrow(attrs, SVG_ATTR_MAP[attr]) : context.getDefaultArrow(attrs, SVG_ATTR_MAP[attr]);
				el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id$1 + ")");
			} else el.removeAttribute(SVG_ATTR_MAP[attr]);
			else if (SVG_ATTR_MAP[attr]) el.setAttribute(SVG_ATTR_MAP[attr], value$1);
		});
	};
	/**
	* Use math calculation to get length of line
	* @return {number} length
	*/
	Line$6.prototype.getTotalLength = function() {
		var _a$5 = this.attr(), x1 = _a$5.x1, y1 = _a$5.y1, x2 = _a$5.x2, y2 = _a$5.y2;
		return line_default$2.length(x1, y1, x2, y2);
	};
	/**
	* Use math calculation to get point according to ratio as same sa Canvas version
	* @param {number} ratio
	* @return {Point} point
	*/
	Line$6.prototype.getPoint = function(ratio) {
		var _a$5 = this.attr(), x1 = _a$5.x1, y1 = _a$5.y1, x2 = _a$5.x2, y2 = _a$5.y2;
		return line_default$2.pointAt(x1, y1, x2, y2, ratio);
	};
	return Line$6;
}(base_default$5);
var line_default$1 = Line$2;

//#endregion
//#region node_modules/@antv/g-svg/esm/shape/marker/symbols.js
var Symbols = {
	circle: function(x, y, r) {
		return [
			[
				"M",
				x,
				y
			],
			[
				"m",
				-r,
				0
			],
			[
				"a",
				r,
				r,
				0,
				1,
				0,
				r * 2,
				0
			],
			[
				"a",
				r,
				r,
				0,
				1,
				0,
				-r * 2,
				0
			]
		];
	},
	square: function(x, y, r) {
		return [
			[
				"M",
				x - r,
				y - r
			],
			[
				"L",
				x + r,
				y - r
			],
			[
				"L",
				x + r,
				y + r
			],
			[
				"L",
				x - r,
				y + r
			],
			["Z"]
		];
	},
	diamond: function(x, y, r) {
		return [
			[
				"M",
				x - r,
				y
			],
			[
				"L",
				x,
				y - r
			],
			[
				"L",
				x + r,
				y
			],
			[
				"L",
				x,
				y + r
			],
			["Z"]
		];
	},
	triangle: function(x, y, r) {
		var diffY = r * Math.sin(1 / 3 * Math.PI);
		return [
			[
				"M",
				x - r,
				y + diffY
			],
			[
				"L",
				x,
				y - diffY
			],
			[
				"L",
				x + r,
				y + diffY
			],
			["z"]
		];
	},
	triangleDown: function(x, y, r) {
		var diffY = r * Math.sin(1 / 3 * Math.PI);
		return [
			[
				"M",
				x - r,
				y - diffY
			],
			[
				"L",
				x + r,
				y - diffY
			],
			[
				"L",
				x,
				y + diffY
			],
			["Z"]
		];
	}
};
var symbols_default = {
	get: function(type) {
		return Symbols[type];
	},
	register: function(type, func) {
		Symbols[type] = func;
	},
	remove: function(type) {
		delete Symbols[type];
	},
	getAll: function() {
		return Symbols;
	}
};

//#endregion
//#region node_modules/@antv/g-svg/esm/shape/marker/index.js
var Marker = function(_super) {
	__extends(Marker$2, _super);
	function Marker$2() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = "marker";
		_this.canFill = true;
		_this.canStroke = true;
		return _this;
	}
	Marker$2.prototype.createPath = function(context) {
		this.get("el").setAttribute("d", this._assembleMarker());
	};
	Marker$2.prototype._assembleMarker = function() {
		var d = this._getPath();
		if (is_array_default(d)) return d.map(function(path) {
			return path.join(" ");
		}).join("");
		return d;
	};
	Marker$2.prototype._getPath = function() {
		var attrs = this.attr();
		var x = attrs.x, y = attrs.y;
		var r = attrs.r || attrs.radius;
		var symbol = attrs.symbol || "circle";
		var method;
		if (is_function_default(symbol)) method = symbol;
		else method = symbols_default.get(symbol);
		if (!method) {
			console.warn(method + " symbol is not exist.");
			return null;
		}
		return method(x, y, r);
	};
	Marker$2.symbolsFactory = symbols_default;
	return Marker$2;
}(base_default$5);
var marker_default = Marker;

//#endregion
//#region node_modules/@antv/g-svg/esm/shape/path.js
var Path$1 = function(_super) {
	__extends(Path$3, _super);
	function Path$3() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = "path";
		_this.canFill = true;
		_this.canStroke = true;
		return _this;
	}
	Path$3.prototype.getDefaultAttrs = function() {
		var attrs = _super.prototype.getDefaultAttrs.call(this);
		return __assign(__assign({}, attrs), {
			startArrow: false,
			endArrow: false
		});
	};
	Path$3.prototype.createPath = function(context, targetAttrs) {
		var _this = this;
		var attrs = this.attr();
		var el = this.get("el");
		each_default(targetAttrs || attrs, function(value$1, attr) {
			if (attr === "path" && is_array_default(value$1)) el.setAttribute("d", _this._formatPath(value$1));
			else if (attr === "startArrow" || attr === "endArrow") if (value$1) {
				var id$1 = is_object_default(value$1) ? context.addArrow(attrs, SVG_ATTR_MAP[attr]) : context.getDefaultArrow(attrs, SVG_ATTR_MAP[attr]);
				el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id$1 + ")");
			} else el.removeAttribute(SVG_ATTR_MAP[attr]);
			else if (SVG_ATTR_MAP[attr]) el.setAttribute(SVG_ATTR_MAP[attr], value$1);
		});
	};
	Path$3.prototype._formatPath = function(value$1) {
		var newValue = value$1.map(function(path) {
			return path.join(" ");
		}).join("");
		if (~newValue.indexOf("NaN")) return "";
		return newValue;
	};
	/**
	* Get total length of path
	* 尽管通过浏览器的 SVGPathElement.getTotalLength() 接口获取的 path 长度，
	* 与 Canvas 版本通过数学计算的方式得到的长度有一些细微差异，但最大误差在个位数像素，精度上可以能接受
	* @return {number} length
	*/
	Path$3.prototype.getTotalLength = function() {
		var el = this.get("el");
		return el ? el.getTotalLength() : null;
	};
	/**
	* Get point according to ratio
	* @param {number} ratio
	* @return {Point} point
	*/
	Path$3.prototype.getPoint = function(ratio) {
		var el = this.get("el");
		var totalLength = this.getTotalLength();
		if (totalLength === 0) return null;
		var point$1 = el ? el.getPointAtLength(ratio * totalLength) : null;
		return point$1 ? {
			x: point$1.x,
			y: point$1.y
		} : null;
	};
	return Path$3;
}(base_default$5);
var path_default$4 = Path$1;

//#endregion
//#region node_modules/@antv/g-svg/esm/shape/polygon.js
var Polygon$1 = function(_super) {
	__extends(Polygon$3, _super);
	function Polygon$3() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = "polygon";
		_this.canFill = true;
		_this.canStroke = true;
		return _this;
	}
	Polygon$3.prototype.createPath = function(context, targetAttrs) {
		var attrs = this.attr();
		var el = this.get("el");
		each_default(targetAttrs || attrs, function(value$1, attr) {
			if (attr === "points" && is_array_default(value$1) && value$1.length >= 2) el.setAttribute("points", value$1.map(function(point$1) {
				return point$1[0] + "," + point$1[1];
			}).join(" "));
			else if (SVG_ATTR_MAP[attr]) el.setAttribute(SVG_ATTR_MAP[attr], value$1);
		});
	};
	return Polygon$3;
}(base_default$5);
var polygon_default$1 = Polygon$1;

//#endregion
//#region node_modules/@antv/g-svg/esm/shape/polyline.js
var Polyline = function(_super) {
	__extends(Polyline$1, _super);
	function Polyline$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = "polyline";
		_this.canFill = true;
		_this.canStroke = true;
		return _this;
	}
	Polyline$1.prototype.getDefaultAttrs = function() {
		var attrs = _super.prototype.getDefaultAttrs.call(this);
		return __assign(__assign({}, attrs), {
			startArrow: false,
			endArrow: false
		});
	};
	Polyline$1.prototype.onAttrChange = function(name, value$1, originValue) {
		_super.prototype.onAttrChange.call(this, name, value$1, originValue);
		if (["points"].indexOf(name) !== -1) this._resetCache();
	};
	Polyline$1.prototype._resetCache = function() {
		this.set("totalLength", null);
		this.set("tCache", null);
	};
	Polyline$1.prototype.createPath = function(context, targetAttrs) {
		var attrs = this.attr();
		var el = this.get("el");
		each_default(targetAttrs || attrs, function(value$1, attr) {
			if (attr === "points" && is_array_default(value$1) && value$1.length >= 2) el.setAttribute("points", value$1.map(function(point$1) {
				return point$1[0] + "," + point$1[1];
			}).join(" "));
			else if (SVG_ATTR_MAP[attr]) el.setAttribute(SVG_ATTR_MAP[attr], value$1);
		});
	};
	/**
	* Get length of polyline
	* @return {number} length
	*/
	Polyline$1.prototype.getTotalLength = function() {
		var points = this.attr().points;
		var totalLength = this.get("totalLength");
		if (!is_nil_default(totalLength)) return totalLength;
		this.set("totalLength", polyline_default$1.length(points));
		return this.get("totalLength");
	};
	/**
	* Get point according to ratio
	* @param {number} ratio
	* @return {Point} point
	*/
	Polyline$1.prototype.getPoint = function(ratio) {
		var points = this.attr().points;
		var tCache = this.get("tCache");
		if (!tCache) {
			this._setTcache();
			tCache = this.get("tCache");
		}
		var subt;
		var index;
		each_default(tCache, function(v, i) {
			if (ratio >= v[0] && ratio <= v[1]) {
				subt = (ratio - v[0]) / (v[1] - v[0]);
				index = i;
			}
		});
		return line_default$2.pointAt(points[index][0], points[index][1], points[index + 1][0], points[index + 1][1], subt);
	};
	Polyline$1.prototype._setTcache = function() {
		var points = this.attr().points;
		if (!points || points.length === 0) return;
		var totalLength = this.getTotalLength();
		if (totalLength <= 0) return;
		var tempLength = 0;
		var tCache = [];
		var segmentT;
		var segmentL;
		each_default(points, function(p, i) {
			if (points[i + 1]) {
				segmentT = [];
				segmentT[0] = tempLength / totalLength;
				segmentL = line_default$2.length(p[0], p[1], points[i + 1][0], points[i + 1][1]);
				tempLength += segmentL;
				segmentT[1] = tempLength / totalLength;
				tCache.push(segmentT);
			}
		});
		this.set("tCache", tCache);
	};
	/**
	* Get start tangent vector
	* @return {Array}
	*/
	Polyline$1.prototype.getStartTangent = function() {
		var points = this.attr().points;
		var result = [];
		result.push([points[1][0], points[1][1]]);
		result.push([points[0][0], points[0][1]]);
		return result;
	};
	/**
	* Get end tangent vector
	* @return {Array}
	*/
	Polyline$1.prototype.getEndTangent = function() {
		var points = this.attr().points;
		var l = points.length - 1;
		var result = [];
		result.push([points[l - 1][0], points[l - 1][1]]);
		result.push([points[l][0], points[l][1]]);
		return result;
	};
	return Polyline$1;
}(base_default$5);
var polyline_default = Polyline;

//#endregion
//#region node_modules/@antv/g-svg/esm/util/format.js
function parseRadius$1(radius) {
	var r1 = 0;
	var r2 = 0;
	var r3 = 0;
	var r4 = 0;
	if (is_array_default(radius)) if (radius.length === 1) r1 = r2 = r3 = r4 = radius[0];
	else if (radius.length === 2) {
		r1 = r3 = radius[0];
		r2 = r4 = radius[1];
	} else if (radius.length === 3) {
		r1 = radius[0];
		r2 = r4 = radius[1];
		r3 = radius[2];
	} else {
		r1 = radius[0];
		r2 = radius[1];
		r3 = radius[2];
		r4 = radius[3];
	}
	else r1 = r2 = r3 = r4 = radius;
	return {
		r1,
		r2,
		r3,
		r4
	};
}

//#endregion
//#region node_modules/@antv/g-svg/esm/shape/rect.js
var Rect$1 = function(_super) {
	__extends(Rect$3, _super);
	function Rect$3() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = "rect";
		_this.canFill = true;
		_this.canStroke = true;
		return _this;
	}
	Rect$3.prototype.getDefaultAttrs = function() {
		var attrs = _super.prototype.getDefaultAttrs.call(this);
		return __assign(__assign({}, attrs), {
			x: 0,
			y: 0,
			width: 0,
			height: 0,
			radius: 0
		});
	};
	Rect$3.prototype.createPath = function(context, targetAttrs) {
		var _this = this;
		var attrs = this.attr();
		var el = this.get("el");
		var completed = false;
		var pathRelatedAttrs = [
			"x",
			"y",
			"width",
			"height",
			"radius"
		];
		each_default(targetAttrs || attrs, function(value$1, attr) {
			if (pathRelatedAttrs.indexOf(attr) !== -1 && !completed) {
				el.setAttribute("d", _this._assembleRect(attrs));
				completed = true;
			} else if (pathRelatedAttrs.indexOf(attr) === -1 && SVG_ATTR_MAP[attr]) el.setAttribute(SVG_ATTR_MAP[attr], value$1);
		});
	};
	Rect$3.prototype._assembleRect = function(attrs) {
		var x = attrs.x;
		var y = attrs.y;
		var w = attrs.width;
		var h = attrs.height;
		var radius = attrs.radius;
		if (!radius) return "M " + x + "," + y + " l " + w + ",0 l 0," + h + " l" + -w + " 0 z";
		var r = parseRadius$1(radius);
		if (is_array_default(radius)) if (radius.length === 1) r.r1 = r.r2 = r.r3 = r.r4 = radius[0];
		else if (radius.length === 2) {
			r.r1 = r.r3 = radius[0];
			r.r2 = r.r4 = radius[1];
		} else if (radius.length === 3) {
			r.r1 = radius[0];
			r.r2 = r.r4 = radius[1];
			r.r3 = radius[2];
		} else {
			r.r1 = radius[0];
			r.r2 = radius[1];
			r.r3 = radius[2];
			r.r4 = radius[3];
		}
		else r.r1 = r.r2 = r.r3 = r.r4 = radius;
		return [
			["M " + (x + r.r1) + "," + y],
			["l " + (w - r.r1 - r.r2) + ",0"],
			["a " + r.r2 + "," + r.r2 + ",0,0,1," + r.r2 + "," + r.r2],
			["l 0," + (h - r.r2 - r.r3)],
			["a " + r.r3 + "," + r.r3 + ",0,0,1," + -r.r3 + "," + r.r3],
			["l " + (r.r3 + r.r4 - w) + ",0"],
			["a " + r.r4 + "," + r.r4 + ",0,0,1," + -r.r4 + "," + -r.r4],
			["l 0," + (r.r4 + r.r1 - h)],
			["a " + r.r1 + "," + r.r1 + ",0,0,1," + r.r1 + "," + -r.r1],
			["z"]
		].join(" ");
	};
	return Rect$3;
}(base_default$5);
var rect_default$3 = Rect$1;

//#endregion
//#region node_modules/@antv/g-svg/esm/shape/text.js
var LETTER_SPACING = .3;
var BASELINE_MAP = {
	top: "before-edge",
	middle: "central",
	bottom: "after-edge",
	alphabetic: "baseline",
	hanging: "hanging"
};
var BASELINE_MAP_FOR_FIREFOX = {
	top: "text-before-edge",
	middle: "central",
	bottom: "text-after-edge",
	alphabetic: "alphabetic",
	hanging: "hanging"
};
var ANCHOR_MAP = {
	left: "left",
	start: "left",
	center: "middle",
	right: "end",
	end: "end"
};
var Text = function(_super) {
	__extends(Text$2, _super);
	function Text$2() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = "text";
		_this.canFill = true;
		_this.canStroke = true;
		return _this;
	}
	Text$2.prototype.getDefaultAttrs = function() {
		var attrs = _super.prototype.getDefaultAttrs.call(this);
		return __assign(__assign({}, attrs), {
			x: 0,
			y: 0,
			text: null,
			fontSize: 12,
			fontFamily: "sans-serif",
			fontStyle: "normal",
			fontWeight: "normal",
			fontVariant: "normal",
			textAlign: "start",
			textBaseline: "bottom"
		});
	};
	Text$2.prototype.createPath = function(context, targetAttrs) {
		var _this = this;
		var attrs = this.attr();
		var el = this.get("el");
		this._setFont();
		each_default(targetAttrs || attrs, function(value$1, attr) {
			if (attr === "text") _this._setText("" + value$1);
			else if (attr === "matrix" && value$1) setTransform(_this);
			else if (SVG_ATTR_MAP[attr]) el.setAttribute(SVG_ATTR_MAP[attr], value$1);
		});
		el.setAttribute("paint-order", "stroke");
		el.setAttribute("style", "stroke-linecap:butt; stroke-linejoin:miter;");
	};
	Text$2.prototype._setFont = function() {
		var el = this.get("el");
		var _a$5 = this.attr(), textBaseline = _a$5.textBaseline, textAlign = _a$5.textAlign;
		var browser$1 = detect();
		if (browser$1 && browser$1.name === "firefox") el.setAttribute("dominant-baseline", BASELINE_MAP_FOR_FIREFOX[textBaseline] || "alphabetic");
		else el.setAttribute("alignment-baseline", BASELINE_MAP[textBaseline] || "baseline");
		el.setAttribute("text-anchor", ANCHOR_MAP[textAlign] || "left");
	};
	Text$2.prototype._setText = function(text) {
		var el = this.get("el");
		var _a$5 = this.attr(), x = _a$5.x, _b = _a$5.textBaseline, baseline = _b === void 0 ? "bottom" : _b;
		if (!text) el.innerHTML = "";
		else if (~text.indexOf("\n")) {
			var textArr = text.split("\n");
			var textLen_1 = textArr.length - 1;
			var arr_1 = "";
			each_default(textArr, function(segment, i) {
				if (i === 0) {
					if (baseline === "alphabetic") arr_1 += "<tspan x=\"" + x + "\" dy=\"" + -textLen_1 + "em\">" + segment + "</tspan>";
					else if (baseline === "top") arr_1 += "<tspan x=\"" + x + "\" dy=\"0.9em\">" + segment + "</tspan>";
					else if (baseline === "middle") arr_1 += "<tspan x=\"" + x + "\" dy=\"" + -(textLen_1 - 1) / 2 + "em\">" + segment + "</tspan>";
					else if (baseline === "bottom") arr_1 += "<tspan x=\"" + x + "\" dy=\"-" + (textLen_1 + LETTER_SPACING) + "em\">" + segment + "</tspan>";
					else if (baseline === "hanging") arr_1 += "<tspan x=\"" + x + "\" dy=\"" + (-(textLen_1 - 1) - LETTER_SPACING) + "em\">" + segment + "</tspan>";
				} else arr_1 += "<tspan x=\"" + x + "\" dy=\"1em\">" + segment + "</tspan>";
			});
			el.innerHTML = arr_1;
		} else el.innerHTML = text;
	};
	return Text$2;
}(base_default$5);
var text_default = Text;

//#endregion
//#region node_modules/@antv/g-svg/esm/shape/index.js
var shape_exports = /* @__PURE__ */ __export({
	Base: () => base_default$5,
	Circle: () => circle_default$3,
	Dom: () => dom_default,
	Ellipse: () => ellipse_default,
	Image: () => image_default,
	Line: () => line_default$1,
	Marker: () => marker_default,
	Path: () => path_default$4,
	Polygon: () => polygon_default$1,
	Polyline: () => polyline_default,
	Rect: () => rect_default$3,
	Text: () => text_default
});

//#endregion
//#region node_modules/@antv/g-svg/esm/defs/gradient.js
var regexLG = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexColorStop = /[\d.]+:(#[^\s]+|[^)]+\))/gi;
function addStop(steps) {
	var arr = steps.match(regexColorStop);
	if (!arr) return "";
	var stops = "";
	arr.sort(function(a, b) {
		a = a.split(":");
		b = b.split(":");
		return Number(a[0]) - Number(b[0]);
	});
	each_default(arr, function(item) {
		item = item.split(":");
		stops += "<stop offset=\"" + item[0] + "\" stop-color=\"" + item[1] + "\"></stop>";
	});
	return stops;
}
function parseLineGradient(color$2, el) {
	var arr = regexLG.exec(color$2);
	var angle$1 = esm_default$2(to_radian_default(parseFloat(arr[1])), Math.PI * 2);
	var steps = arr[2];
	var start;
	var end;
	if (angle$1 >= 0 && angle$1 < .5 * Math.PI) {
		start = {
			x: 0,
			y: 0
		};
		end = {
			x: 1,
			y: 1
		};
	} else if (.5 * Math.PI <= angle$1 && angle$1 < Math.PI) {
		start = {
			x: 1,
			y: 0
		};
		end = {
			x: 0,
			y: 1
		};
	} else if (Math.PI <= angle$1 && angle$1 < 1.5 * Math.PI) {
		start = {
			x: 1,
			y: 1
		};
		end = {
			x: 0,
			y: 0
		};
	} else {
		start = {
			x: 0,
			y: 1
		};
		end = {
			x: 1,
			y: 0
		};
	}
	var tanTheta = Math.tan(angle$1);
	var tanTheta2 = tanTheta * tanTheta;
	var x = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;
	var y = tanTheta * (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.y;
	el.setAttribute("x1", start.x);
	el.setAttribute("y1", start.y);
	el.setAttribute("x2", x);
	el.setAttribute("y2", y);
	el.innerHTML = addStop(steps);
}
function parseRadialGradient(color$2, self$3) {
	var arr = regexRG.exec(color$2);
	var cx = parseFloat(arr[1]);
	var cy = parseFloat(arr[2]);
	var r = parseFloat(arr[3]);
	var steps = arr[4];
	self$3.setAttribute("cx", cx);
	self$3.setAttribute("cy", cy);
	self$3.setAttribute("r", r);
	self$3.innerHTML = addStop(steps);
}
var Gradient = function() {
	function Gradient$1(cfg) {
		this.cfg = {};
		var el = null;
		var id$1 = unique_id_default("gradient_");
		if (cfg.toLowerCase()[0] === "l") {
			el = createSVGElement("linearGradient");
			parseLineGradient(cfg, el);
		} else {
			el = createSVGElement("radialGradient");
			parseRadialGradient(cfg, el);
		}
		el.setAttribute("id", id$1);
		this.el = el;
		this.id = id$1;
		this.cfg = cfg;
		return this;
	}
	Gradient$1.prototype.match = function(type, attr) {
		return this.cfg === attr;
	};
	return Gradient$1;
}();
var gradient_default = Gradient;

//#endregion
//#region node_modules/@antv/g-svg/esm/defs/shadow.js
var ATTR_MAP = {
	shadowColor: "color",
	shadowOpacity: "opacity",
	shadowBlur: "blur",
	shadowOffsetX: "dx",
	shadowOffsetY: "dy"
};
var SHADOW_DIMENSION = {
	x: "-40%",
	y: "-40%",
	width: "200%",
	height: "200%"
};
var Shadow = function() {
	function Shadow$1(cfg) {
		this.type = "filter";
		this.cfg = {};
		this.type = "filter";
		var el = createSVGElement("filter");
		each_default(SHADOW_DIMENSION, function(v, k) {
			el.setAttribute(k, v);
		});
		this.el = el;
		this.id = unique_id_default("filter_");
		this.el.id = this.id;
		this.cfg = cfg;
		this._parseShadow(cfg, el);
		return this;
	}
	Shadow$1.prototype.match = function(type, cfg) {
		if (this.type !== type) return false;
		var flag = true;
		var config = this.cfg;
		each_default(Object.keys(config), function(attr) {
			if (config[attr] !== cfg[attr]) {
				flag = false;
				return false;
			}
		});
		return flag;
	};
	Shadow$1.prototype.update = function(name, value$1) {
		var config = this.cfg;
		config[ATTR_MAP[name]] = value$1;
		this._parseShadow(config, this.el);
		return this;
	};
	Shadow$1.prototype._parseShadow = function(config, el) {
		el.innerHTML = "<feDropShadow\n      dx=\"" + (config.dx || 0) + "\"\n      dy=\"" + (config.dy || 0) + "\"\n      stdDeviation=\"" + (config.blur ? config.blur / 10 : 0) + "\"\n      flood-color=\"" + (config.color ? config.color : "#000") + "\"\n      flood-opacity=\"" + (config.opacity ? config.opacity : 1) + "\"\n      />";
	};
	return Shadow$1;
}();
var shadow_default = Shadow;

//#endregion
//#region node_modules/@antv/g-svg/esm/defs/arrow.js
var Arrow = function() {
	function Arrow$1(attrs, type) {
		this.cfg = {};
		var el = createSVGElement("marker");
		var id$1 = unique_id_default("marker_");
		el.setAttribute("id", id$1);
		var shape = createSVGElement("path");
		shape.setAttribute("stroke", attrs.stroke || "none");
		shape.setAttribute("fill", attrs.fill || "none");
		el.appendChild(shape);
		el.setAttribute("overflow", "visible");
		el.setAttribute("orient", "auto-start-reverse");
		this.el = el;
		this.child = shape;
		this.id = id$1;
		var cfg = attrs[type === "marker-start" ? "startArrow" : "endArrow"];
		this.stroke = attrs.stroke || "#000";
		if (cfg === true) this._setDefaultPath(type, shape);
		else {
			this.cfg = cfg;
			this._setMarker(attrs.lineWidth, shape);
		}
		return this;
	}
	Arrow$1.prototype.match = function() {
		return false;
	};
	Arrow$1.prototype._setDefaultPath = function(type, el) {
		var parent = this.el;
		el.setAttribute("d", "M0,0 L" + 10 * Math.cos(Math.PI / 6) + ",5 L0,10");
		parent.setAttribute("refX", "" + 10 * Math.cos(Math.PI / 6));
		parent.setAttribute("refY", "5");
	};
	Arrow$1.prototype._setMarker = function(r, el) {
		var parent = this.el;
		var path = this.cfg.path;
		var d = this.cfg.d;
		if (is_array_default(path)) path = path.map(function(segment) {
			return segment.join(" ");
		}).join("");
		el.setAttribute("d", path);
		parent.appendChild(el);
		if (d) parent.setAttribute("refX", "" + d / r);
	};
	Arrow$1.prototype.update = function(fill) {
		var child = this.child;
		if (child.attr) child.attr("fill", fill);
		else child.setAttribute("fill", fill);
	};
	return Arrow$1;
}();
var arrow_default = Arrow;

//#endregion
//#region node_modules/@antv/g-svg/esm/defs/clip.js
var Clip = function() {
	function Clip$1(cfg) {
		this.type = "clip";
		this.cfg = {};
		var el = createSVGElement("clipPath");
		this.el = el;
		this.id = unique_id_default("clip_");
		el.id = this.id;
		var shapeEl = cfg.cfg.el;
		el.appendChild(shapeEl);
		this.cfg = cfg;
		return this;
	}
	Clip$1.prototype.match = function() {
		return false;
	};
	Clip$1.prototype.remove = function() {
		var el = this.el;
		el.parentNode.removeChild(el);
	};
	return Clip$1;
}();
var clip_default = Clip;

//#endregion
//#region node_modules/@antv/g-svg/esm/defs/pattern.js
var regexPR = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
var Pattern = function() {
	function Pattern$1(cfg) {
		this.cfg = {};
		var el = createSVGElement("pattern");
		el.setAttribute("patternUnits", "userSpaceOnUse");
		var child = createSVGElement("image");
		el.appendChild(child);
		var id$1 = unique_id_default("pattern_");
		el.id = id$1;
		this.el = el;
		this.id = id$1;
		this.cfg = cfg;
		var source = regexPR.exec(cfg)[2];
		child.setAttribute("href", source);
		var img = new Image();
		if (!source.match(/^data:/i)) img.crossOrigin = "Anonymous";
		img.src = source;
		function onload() {
			el.setAttribute("width", "" + img.width);
			el.setAttribute("height", "" + img.height);
		}
		if (img.complete) onload();
		else {
			img.onload = onload;
			img.src = img.src;
		}
		return this;
	}
	Pattern$1.prototype.match = function(type, attr) {
		return this.cfg === attr;
	};
	return Pattern$1;
}();
var pattern_default = Pattern;

//#endregion
//#region node_modules/@antv/g-svg/esm/defs/index.js
var Defs = function() {
	function Defs$1(canvas) {
		var el = createSVGElement("defs");
		el.id = unique_id_default("defs_");
		canvas.appendChild(el);
		this.children = [];
		this.defaultArrow = {};
		this.el = el;
		this.canvas = canvas;
	}
	Defs$1.prototype.find = function(type, attr) {
		var children = this.children;
		var result = null;
		for (var i = 0; i < children.length; i++) if (children[i].match(type, attr)) {
			result = children[i].id;
			break;
		}
		return result;
	};
	Defs$1.prototype.findById = function(id$1) {
		var children = this.children;
		var flag = null;
		for (var i = 0; i < children.length; i++) if (children[i].id === id$1) {
			flag = children[i];
			break;
		}
		return flag;
	};
	Defs$1.prototype.add = function(item) {
		this.children.push(item);
		item.canvas = this.canvas;
		item.parent = this;
	};
	Defs$1.prototype.getDefaultArrow = function(attrs, name) {
		var stroke = attrs.stroke || attrs.strokeStyle;
		if (this.defaultArrow[stroke]) return this.defaultArrow[stroke].id;
		var arrow = new arrow_default(attrs, name);
		this.defaultArrow[stroke] = arrow;
		this.el.appendChild(arrow.el);
		this.add(arrow);
		return arrow.id;
	};
	Defs$1.prototype.addGradient = function(cfg) {
		var gradient$1 = new gradient_default(cfg);
		this.el.appendChild(gradient$1.el);
		this.add(gradient$1);
		return gradient$1.id;
	};
	Defs$1.prototype.addArrow = function(attrs, name) {
		var arrow = new arrow_default(attrs, name);
		this.el.appendChild(arrow.el);
		this.add(arrow);
		return arrow.id;
	};
	Defs$1.prototype.addShadow = function(cfg) {
		var shadow = new shadow_default(cfg);
		this.el.appendChild(shadow.el);
		this.add(shadow);
		return shadow.id;
	};
	Defs$1.prototype.addPattern = function(cfg) {
		var pattern$1 = new pattern_default(cfg);
		this.el.appendChild(pattern$1.el);
		this.add(pattern$1);
		return pattern$1.id;
	};
	Defs$1.prototype.addClip = function(cfg) {
		var clip = new clip_default(cfg);
		this.el.appendChild(clip.el);
		this.add(clip);
		return clip.id;
	};
	return Defs$1;
}();
var defs_default = Defs;

//#endregion
//#region node_modules/@antv/g-svg/esm/canvas.js
var Canvas = function(_super) {
	__extends(Canvas$3, _super);
	function Canvas$3(cfg) {
		return _super.call(this, __assign(__assign({}, cfg), {
			autoDraw: true,
			renderer: "svg"
		})) || this;
	}
	Canvas$3.prototype.getShapeBase = function() {
		return shape_exports;
	};
	Canvas$3.prototype.getGroupBase = function() {
		return group_default;
	};
	Canvas$3.prototype.getShape = function(x, y, ev) {
		var target = ev.target || ev.srcElement;
		if (!SHAPE_TO_TAGS[target.tagName]) {
			var parent_1 = target.parentNode;
			while (parent_1 && !SHAPE_TO_TAGS[parent_1.tagName]) parent_1 = parent_1.parentNode;
			target = parent_1;
		}
		return this.find(function(child) {
			return child.get("el") === target;
		});
	};
	Canvas$3.prototype.createDom = function() {
		var element = createSVGElement("svg");
		var context = new defs_default(element);
		element.setAttribute("width", "" + this.get("width"));
		element.setAttribute("height", "" + this.get("height"));
		this.set("context", context);
		return element;
	};
	/**
	* 一些方法调用会引起画布变化
	* @param {ChangeType} changeType 改变的类型
	*/
	Canvas$3.prototype.onCanvasChange = function(changeType) {
		var context = this.get("context");
		var el = this.get("el");
		if (changeType === "sort") {
			var children_1 = this.get("children");
			if (children_1 && children_1.length) sortDom(this, function(a, b) {
				return children_1.indexOf(a) - children_1.indexOf(b) ? 1 : 0;
			});
		} else if (changeType === "clear") {
			if (el) {
				el.innerHTML = "";
				var defsEl = context.el;
				defsEl.innerHTML = "";
				el.appendChild(defsEl);
			}
		} else if (changeType === "matrix") setTransform(this);
		else if (changeType === "clip") setClip(this, context);
		else if (changeType === "changeSize") {
			el.setAttribute("width", "" + this.get("width"));
			el.setAttribute("height", "" + this.get("height"));
		}
	};
	Canvas$3.prototype.draw = function() {
		var context = this.get("context");
		var children = this.getChildren();
		setClip(this, context);
		if (children.length) drawChildren(context, children);
	};
	return Canvas$3;
}(canvas_default$1);
var canvas_default = Canvas;

//#endregion
//#region node_modules/@antv/g-svg/esm/index.js
var esm_exports$2 = /* @__PURE__ */ __export({
	AbstractCanvas: () => canvas_default$1,
	AbstractGroup: () => group_default$1,
	AbstractShape: () => shape_default,
	Base: () => base_default$15,
	Canvas: () => canvas_default,
	Event: () => graph_event_default,
	Group: () => group_default,
	PathUtil: () => path_exports,
	Shape: () => shape_exports,
	assembleFont: () => assembleFont,
	getBBoxMethod: () => getMethod,
	getOffScreenContext: () => getOffScreenContext,
	getTextHeight: () => getTextHeight,
	invert: () => invert,
	isAllowCapture: () => isAllowCapture,
	multiplyVec2: () => multiplyVec2,
	registerBBox: () => register,
	registerEasing: () => registerEasing,
	version: () => version$1
});
var version$1 = "0.5.6";

//#endregion
//#region node_modules/@antv/g2/esm/geometry/path.js
/**
* Path 几何标记。
* 用于绘制路径图等。
*/
var Path = function(_super) {
	__extends(Path$3, _super);
	function Path$3(cfg) {
		var _this = _super.call(this, cfg) || this;
		_this.type = "path";
		_this.shapeType = "line";
		var _a$5 = cfg.connectNulls, connectNulls = _a$5 === void 0 ? false : _a$5, _b = cfg.showSinglePoint, showSinglePoint = _b === void 0 ? true : _b;
		_this.connectNulls = connectNulls;
		_this.showSinglePoint = showSinglePoint;
		return _this;
	}
	/**
	* 创建所有的 Element 实例，对于 Path、Line、Area，一组数据对应一个 Element。
	* @param mappingData
	* @param [isUpdate]
	* @returns elements
	*/
	Path$3.prototype.updateElements = function(mappingDataArray, isUpdate) {
		var e_1, _a$5, e_2, _b, e_3, _c;
		if (isUpdate === void 0) isUpdate = false;
		var keyData = /* @__PURE__ */ new Map();
		var keyIndex = /* @__PURE__ */ new Map();
		var keys$1 = [];
		var index = 0;
		for (var i = 0; i < mappingDataArray.length; i++) {
			var mappingData = mappingDataArray[i];
			var key = this.getElementId(mappingData);
			keys$1.push(key);
			keyData.set(key, mappingData);
			keyIndex.set(key, index);
			index++;
		}
		this.elements = new Array(index);
		var _d = diff(this.lastElementsMap, keys$1), added = _d.added, updated = _d.updated, removed = _d.removed;
		try {
			for (var added_1 = __values(added), added_1_1 = added_1.next(); !added_1_1.done; added_1_1 = added_1.next()) {
				var key = added_1_1.value;
				var mappingData = keyData.get(key);
				var shapeFactory = this.getShapeFactory();
				var shapeCfg = this.getShapeInfo(mappingData);
				var i = keyIndex.get(key);
				var element = new element_default({
					shapeFactory,
					container: this.container,
					offscreenGroup: this.getOffscreenGroup(),
					elementIndex: i
				});
				element.geometry = this;
				element.animate = this.animateOption;
				element.draw(shapeCfg, isUpdate);
				this.elementsMap[key] = element;
				this.elements[i] = element;
			}
		} catch (e_1_1) {
			e_1 = { error: e_1_1 };
		} finally {
			try {
				if (added_1_1 && !added_1_1.done && (_a$5 = added_1.return)) _a$5.call(added_1);
			} finally {
				if (e_1) throw e_1.error;
			}
		}
		try {
			for (var updated_1 = __values(updated), updated_1_1 = updated_1.next(); !updated_1_1.done; updated_1_1 = updated_1.next()) {
				var key = updated_1_1.value;
				var mappingData = keyData.get(key);
				var element = this.lastElementsMap[key];
				var i = keyIndex.get(key);
				var shapeCfg = this.getShapeInfo(mappingData);
				var preShapeCfg = element.getModel();
				if (this.isCoordinateChanged || isModelChange(preShapeCfg, shapeCfg)) {
					element.animate = this.animateOption;
					element.update(shapeCfg);
				}
				this.elementsMap[key] = element;
				this.elements[i] = element;
			}
		} catch (e_2_1) {
			e_2 = { error: e_2_1 };
		} finally {
			try {
				if (updated_1_1 && !updated_1_1.done && (_b = updated_1.return)) _b.call(updated_1);
			} finally {
				if (e_2) throw e_2.error;
			}
		}
		try {
			for (var removed_1 = __values(removed), removed_1_1 = removed_1.next(); !removed_1_1.done; removed_1_1 = removed_1.next()) {
				var key = removed_1_1.value;
				var element = this.lastElementsMap[key];
				element.animate = this.animateOption;
				element.destroy();
			}
		} catch (e_3_1) {
			e_3 = { error: e_3_1 };
		} finally {
			try {
				if (removed_1_1 && !removed_1_1.done && (_c = removed_1.return)) _c.call(removed_1);
			} finally {
				if (e_3) throw e_3.error;
			}
		}
	};
	/**
	* 获取组成一条线（一组数据）的所有点以及数据
	* @param mappingData 映射后的数组
	*/
	Path$3.prototype.getPointsAndData = function(mappingData) {
		var points = [];
		var data$2 = [];
		for (var i = 0, len = mappingData.length; i < len; i++) {
			var obj = mappingData[i];
			points.push({
				x: obj.x,
				y: obj.y
			});
			data$2.push(obj[FIELD_ORIGIN]);
		}
		return {
			points,
			data: data$2
		};
	};
	Path$3.prototype.getShapeInfo = function(mappingData) {
		var shapeCfg = this.getDrawCfg(mappingData[0]);
		var _a$5 = this.getPointsAndData(mappingData), points = _a$5.points, data$2 = _a$5.data;
		shapeCfg.mappingData = mappingData;
		shapeCfg.data = data$2;
		shapeCfg.isStack = !!this.getAdjust("stack");
		shapeCfg.points = points;
		shapeCfg.connectNulls = this.connectNulls;
		shapeCfg.showSinglePoint = this.showSinglePoint;
		return shapeCfg;
	};
	return Path$3;
}(base_default$4);
var path_default$1 = Path;

//#endregion
//#region node_modules/@antv/g2/esm/geometry/shape/area/util.js
function getPath$2(points, isInCircle, smooth, registeredShape, constraint) {
	var path = [];
	if (points.length) {
		var topLinePoints_1 = [];
		var bottomLinePoints_1 = [];
		for (var i = 0, len = points.length; i < len; i++) {
			var point$1 = points[i];
			topLinePoints_1.push(point$1[1]);
			bottomLinePoints_1.push(point$1[0]);
		}
		bottomLinePoints_1 = bottomLinePoints_1.reverse();
		each_default([topLinePoints_1, bottomLinePoints_1], function(pointsData, index) {
			var subPath = [];
			var parsedPoints = registeredShape.parsePoints(pointsData);
			var p1 = parsedPoints[0];
			if (topLinePoints_1.length === 1 && bottomLinePoints_1.length === 1) subPath = index === 0 ? [[
				"M",
				p1.x - .5,
				p1.y
			], [
				"L",
				p1.x + .5,
				p1.y
			]] : [[
				"L",
				p1.x + .5,
				p1.y
			], [
				"L",
				p1.x - .5,
				p1.y
			]];
			else {
				if (isInCircle) parsedPoints.push({
					x: p1.x,
					y: p1.y
				});
				if (smooth) subPath = getSplinePath$1(parsedPoints, false, constraint);
				else subPath = getLinePath(parsedPoints, false);
				if (index > 0) subPath[0][0] = "L";
			}
			path = path.concat(subPath);
		});
		path.push(["Z"]);
	}
	return path;
}
/**
* @ignore
* Gets shape attrs
* @param cfg
* @param isStroke
* @param smooth
* @param registeredShape
* @param [constraint]
* @returns
*/
function getShapeAttrs(cfg, isStroke, smooth, registeredShape, constraint) {
	var attrs = getStyle(cfg, isStroke, !isStroke, "lineWidth");
	var connectNulls = cfg.connectNulls, isInCircle = cfg.isInCircle, points = cfg.points, showSinglePoint = cfg.showSinglePoint;
	var pathPoints = getPathPoints(points, connectNulls, showSinglePoint);
	var path = [];
	for (var i = 0, len = pathPoints.length; i < len; i++) {
		var eachPoints = pathPoints[i];
		path = path.concat(getPath$2(eachPoints, isInCircle, smooth, registeredShape, constraint));
	}
	attrs.path = path;
	return attrs;
}
/**
* @ignore
* Gets constraint
* @param coordinate
* @returns constraint
*/
function getConstraint(coordinate$10) {
	var start = coordinate$10.start, end = coordinate$10.end;
	return [[start.x, end.y], [end.x, start.y]];
}

//#endregion
//#region node_modules/@antv/g2/esm/geometry/shape/area/index.js
var AreaShapeFactory = registerShapeFactory("area", {
	defaultShapeType: "area",
	getDefaultPoints: function(pointInfo) {
		var x = pointInfo.x, y0 = pointInfo.y0;
		return (is_array_default(pointInfo.y) ? pointInfo.y : [y0, pointInfo.y]).map(function(yItem) {
			return {
				x,
				y: yItem
			};
		});
	}
});
registerShape("area", "area", {
	draw: function(cfg, container) {
		var attrs = getShapeAttrs(cfg, false, false, this);
		return container.addShape({
			type: "path",
			attrs,
			name: "area"
		});
	},
	getMarker: function(markerCfg) {
		return {
			symbol: function(x, y, r) {
				if (r === void 0) r = 5.5;
				return [
					[
						"M",
						x - r,
						y - 4
					],
					[
						"L",
						x + r,
						y - 4
					],
					[
						"L",
						x + r,
						y + 4
					],
					[
						"L",
						x - r,
						y + 4
					],
					["Z"]
				];
			},
			style: {
				r: 5,
				fill: markerCfg.color,
				fillOpacity: 1
			}
		};
	}
});

//#endregion
//#region node_modules/@antv/g2/esm/geometry/area.js
/**
* Area 几何标记类。
* 常用于绘制面积图。
*/
var Area$1 = function(_super) {
	__extends(Area$2, _super);
	function Area$2(cfg) {
		var _this = _super.call(this, cfg) || this;
		_this.type = "area";
		_this.shapeType = "area";
		/** 生成图形关键点 */
		_this.generatePoints = true;
		/**
		* 面积图是否从 0 基准线开始填充。
		* 1. 默认值为 `true`，表现如下：
		* ![image](https://gw.alipayobjects.com/zos/rmsportal/ZQqwUCczalrKqGgagOVp.png)
		* 2. 当值为 `false` 时，表现如下：
		* ![image](https://gw.alipayobjects.com/zos/rmsportal/yPswkaXvUpCYOdhocGwB.png)
		*/
		_this.startOnZero = true;
		var _a$5 = cfg.startOnZero, startOnZero = _a$5 === void 0 ? true : _a$5, _b = cfg.sortable, sortable = _b === void 0 ? false : _b, _c = cfg.showSinglePoint, showSinglePoint = _c === void 0 ? false : _c;
		_this.startOnZero = startOnZero;
		_this.sortable = sortable;
		_this.showSinglePoint = showSinglePoint;
		return _this;
	}
	/**
	* 获取图形绘制的关键点以及数据
	* @param mappingData 映射后的数据
	*/
	Area$2.prototype.getPointsAndData = function(mappingData) {
		var points = [];
		var data$2 = [];
		for (var i = 0, len = mappingData.length; i < len; i++) {
			var obj = mappingData[i];
			points.push(obj.points);
			data$2.push(obj[FIELD_ORIGIN]);
		}
		return {
			points,
			data: data$2
		};
	};
	/**
	* 获取 Y 轴上的最小值
	* @returns y 字段最小值
	*/
	Area$2.prototype.getYMinValue = function() {
		if (this.startOnZero) return _super.prototype.getYMinValue.call(this);
		return this.getYScale().min;
	};
	return Area$2;
}(path_default$1);
var area_default = Area$1;

//#endregion
//#region node_modules/@antv/g2/esm/geometry/shape/edge/index.js
var EdgeShapeFactory = registerShapeFactory("edge", {
	defaultShapeType: "line",
	getDefaultPoints: function(pointInfo) {
		return splitPoints(pointInfo);
	}
});
registerShape("edge", "line", {
	draw: function(cfg, container) {
		var style = getStyle(cfg, true, false, "lineWidth");
		var path = getLinePath(this.parsePoints(cfg.points), this.coordinate.isPolar);
		return container.addShape("path", { attrs: __assign(__assign({}, style), { path }) });
	},
	getMarker: function(markerCfg) {
		return {
			symbol: "circle",
			style: {
				r: 4.5,
				fill: markerCfg.color
			}
		};
	}
});

//#endregion
//#region node_modules/@antv/g2/esm/geometry/edge.js
/**
* Edge 几何标记，用于绘制关系图中的**边**图形，如：
* 1. 流程图
* 2. 树
* 3. 弧长连接图
* 4. 和弦图
* 5. 桑基图
*/
var Edge = function(_super) {
	__extends(Edge$1, _super);
	function Edge$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = "edge";
		_this.shapeType = "edge";
		_this.generatePoints = true;
		return _this;
	}
	return Edge$1;
}(base_default$4);
var edge_default = Edge;

//#endregion
//#region node_modules/@antv/g2/esm/geometry/heatmap.js
/**
* 用于绘制热力图。
*/
var Heatmap$1 = function(_super) {
	__extends(Heatmap$2, _super);
	function Heatmap$2() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = "heatmap";
		_this.paletteCache = {};
		return _this;
	}
	Heatmap$2.prototype.updateElements = function(mappingDataArray, isUpdate) {
		if (isUpdate === void 0) isUpdate = false;
		for (var i = 0; i < mappingDataArray.length; i++) {
			var mappingData = mappingDataArray[i];
			var range = this.prepareRange(mappingData);
			var radius = this.prepareSize();
			var blur_1 = get_default(this.styleOption, ["cfg", "shadowBlur"]);
			if (!is_number_default(blur_1)) blur_1 = radius / 2;
			this.prepareGreyScaleBlurredCircle(radius, blur_1);
			this.drawWithRange(mappingData, range, radius, blur_1);
		}
	};
	/** 热力图暂时不支持 callback 回调（文档需要说明下） */
	Heatmap$2.prototype.color = function(field$5, cfg) {
		this.createAttrOption("color", field$5, typeof cfg !== "function" ? cfg : "");
		return this;
	};
	/**
	* clear
	*/
	Heatmap$2.prototype.clear = function() {
		_super.prototype.clear.call(this);
		this.clearShadowCanvasCtx();
		this.paletteCache = {};
	};
	Heatmap$2.prototype.prepareRange = function(data$2) {
		var colorField = this.getAttribute("color").getFields()[0];
		var min$2 = Infinity;
		var max$2 = -Infinity;
		data$2.forEach(function(row) {
			var value$1 = row[FIELD_ORIGIN][colorField];
			if (value$1 > max$2) max$2 = value$1;
			if (value$1 < min$2) min$2 = value$1;
		});
		if (min$2 === max$2) min$2 = max$2 - 1;
		return [min$2, max$2];
	};
	Heatmap$2.prototype.prepareSize = function() {
		var radius = this.getDefaultValue("size");
		if (!is_number_default(radius)) radius = this.getDefaultSize();
		return radius;
	};
	Heatmap$2.prototype.prepareGreyScaleBlurredCircle = function(radius, blur) {
		var grayScaleBlurredCanvas = this.getGrayScaleBlurredCanvas();
		var r2 = radius + blur;
		var ctx$3 = grayScaleBlurredCanvas.getContext("2d");
		grayScaleBlurredCanvas.width = grayScaleBlurredCanvas.height = r2 * 2;
		ctx$3.clearRect(0, 0, grayScaleBlurredCanvas.width, grayScaleBlurredCanvas.height);
		ctx$3.shadowOffsetX = ctx$3.shadowOffsetY = r2 * 2;
		ctx$3.shadowBlur = blur;
		ctx$3.shadowColor = "black";
		ctx$3.beginPath();
		ctx$3.arc(-r2, -r2, radius, 0, Math.PI * 2, true);
		ctx$3.closePath();
		ctx$3.fill();
	};
	Heatmap$2.prototype.drawWithRange = function(data$2, range, radius, blur) {
		var e_1, _a$5;
		var _b = this.coordinate, start = _b.start, end = _b.end;
		var width = this.coordinate.getWidth();
		var height = this.coordinate.getHeight();
		var valueField = this.getAttribute("color").getFields()[0];
		this.clearShadowCanvasCtx();
		var ctx$3 = this.getShadowCanvasCtx();
		if (range) data$2 = data$2.filter(function(row) {
			return row[FIELD_ORIGIN][valueField] <= range[1] && row[FIELD_ORIGIN][valueField] >= range[0];
		});
		var scale$4 = this.scales[valueField];
		try {
			for (var data_1 = __values(data$2), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
				var obj = data_1_1.value;
				var _c = this.getDrawCfg(obj), x = _c.x, y = _c.y;
				var alpha = scale$4.scale(obj[FIELD_ORIGIN][valueField]);
				this.drawGrayScaleBlurredCircle(x - start.x, y - end.y, radius + blur, alpha, ctx$3);
			}
		} catch (e_1_1) {
			e_1 = { error: e_1_1 };
		} finally {
			try {
				if (data_1_1 && !data_1_1.done && (_a$5 = data_1.return)) _a$5.call(data_1);
			} finally {
				if (e_1) throw e_1.error;
			}
		}
		var colored = ctx$3.getImageData(0, 0, width, height);
		this.clearShadowCanvasCtx();
		this.colorize(colored);
		ctx$3.putImageData(colored, 0, 0);
		var imageShape = this.getImageShape();
		imageShape.attr("x", start.x);
		imageShape.attr("y", end.y);
		imageShape.attr("width", width);
		imageShape.attr("height", height);
		imageShape.attr("img", ctx$3.canvas);
		imageShape.set("origin", this.getShapeInfo(data$2));
	};
	Heatmap$2.prototype.getDefaultSize = function() {
		var position = this.getAttribute("position");
		var coordinate$10 = this.coordinate;
		return Math.min(coordinate$10.getWidth() / (position.scales[0].ticks.length * 4), coordinate$10.getHeight() / (position.scales[1].ticks.length * 4));
	};
	Heatmap$2.prototype.clearShadowCanvasCtx = function() {
		var ctx$3 = this.getShadowCanvasCtx();
		ctx$3.clearRect(0, 0, ctx$3.canvas.width, ctx$3.canvas.height);
	};
	Heatmap$2.prototype.getShadowCanvasCtx = function() {
		var canvas = this.shadowCanvas;
		if (!canvas) {
			canvas = document.createElement("canvas");
			this.shadowCanvas = canvas;
		}
		canvas.width = this.coordinate.getWidth();
		canvas.height = this.coordinate.getHeight();
		return canvas.getContext("2d");
	};
	Heatmap$2.prototype.getGrayScaleBlurredCanvas = function() {
		if (!this.grayScaleBlurredCanvas) this.grayScaleBlurredCanvas = document.createElement("canvas");
		return this.grayScaleBlurredCanvas;
	};
	Heatmap$2.prototype.drawGrayScaleBlurredCircle = function(x, y, r, alpha, ctx$3) {
		var grayScaleBlurredCanvas = this.getGrayScaleBlurredCanvas();
		ctx$3.globalAlpha = alpha;
		ctx$3.drawImage(grayScaleBlurredCanvas, x - r, y - r);
	};
	Heatmap$2.prototype.colorize = function(img) {
		var colorAttr = this.getAttribute("color");
		var pixels = img.data;
		var paletteCache = this.paletteCache;
		for (var i = 3; i < pixels.length; i += 4) {
			var alpha = pixels[i];
			if (is_number_default(alpha)) {
				var palette = paletteCache[alpha] ? paletteCache[alpha] : esm_default.rgb2arr(colorAttr.gradient(alpha / 256));
				pixels[i - 3] = palette[0];
				pixels[i - 2] = palette[1];
				pixels[i - 1] = palette[2];
				pixels[i] = alpha;
			}
		}
	};
	Heatmap$2.prototype.getImageShape = function() {
		var imageShape = this.imageShape;
		if (imageShape) return imageShape;
		imageShape = this.container.addShape({
			type: "image",
			attrs: {}
		});
		this.imageShape = imageShape;
		return imageShape;
	};
	Heatmap$2.prototype.getShapeInfo = function(mappingData) {
		var shapeCfg = this.getDrawCfg(mappingData[0]);
		var data$2 = mappingData.map(function(obj) {
			return obj[FIELD_ORIGIN];
		});
		return __assign(__assign({}, shapeCfg), {
			mappingData,
			data: data$2
		});
	};
	return Heatmap$2;
}(base_default$4);
var heatmap_default = Heatmap$1;

//#endregion
//#region node_modules/@antv/g2/esm/geometry/shape/interval/util.js
/**
* @ignore
* 根据数据点生成矩形的四个关键点
* @param pointInfo 数据点信息
* @param [isPyramid] 是否为尖底漏斗图
* @returns rect points 返回矩形四个顶点信息
*/
function getRectPoints$1(pointInfo) {
	var _a$5, _b;
	var x = pointInfo.x, y = pointInfo.y, y0 = pointInfo.y0, size$1 = pointInfo.size;
	var yMin;
	var yMax;
	if (is_array_default(y)) _a$5 = __read(y, 2), yMin = _a$5[0], yMax = _a$5[1];
	else {
		yMin = y0;
		yMax = y;
	}
	var xMin;
	var xMax;
	if (is_array_default(x)) _b = __read(x, 2), xMin = _b[0], xMax = _b[1];
	else {
		xMin = x - size$1 / 2;
		xMax = x + size$1 / 2;
	}
	var points = [{
		x: xMin,
		y: yMin
	}, {
		x: xMin,
		y: yMax
	}];
	points.push({
		x: xMax,
		y: yMax
	}, {
		x: xMax,
		y: yMin
	});
	return points;
}
/**
* @ignore
* 根据矩形关键点绘制 path
* @param points 关键点数组
* @param isClosed path 是否需要闭合
* @returns 返回矩形的 path
*/
function getRectPath$1(points, isClosed) {
	if (isClosed === void 0) isClosed = true;
	var path = [];
	var firstPoint = points[0];
	path.push([
		"M",
		firstPoint.x,
		firstPoint.y
	]);
	for (var i = 1, len = points.length; i < len; i++) path.push([
		"L",
		points[i].x,
		points[i].y
	]);
	if (isClosed) {
		path.push([
			"L",
			firstPoint.x,
			firstPoint.y
		]);
		path.push(["z"]);
	}
	return path;
}
/**
* 处理 rect path 的 radius
* @returns 返回矩形 path 的四个角的 arc 半径
*/
function parseRadius(radius, minLength) {
	var r1 = 0;
	var r2 = 0;
	var r3 = 0;
	var r4 = 0;
	if (is_array_default(radius)) if (radius.length === 1) r1 = r2 = r3 = r4 = radius[0];
	else if (radius.length === 2) {
		r1 = r3 = radius[0];
		r2 = r4 = radius[1];
	} else if (radius.length === 3) {
		r1 = radius[0];
		r2 = r4 = radius[1];
		r3 = radius[2];
	} else {
		r1 = radius[0];
		r2 = radius[1];
		r3 = radius[2];
		r4 = radius[3];
	}
	else r1 = r2 = r3 = r4 = radius;
	if (r1 + r2 > minLength) {
		r1 = r1 ? minLength / (1 + r2 / r1) : 0;
		r2 = minLength - r1;
	}
	if (r3 + r4 > minLength) {
		r3 = r3 ? minLength / (1 + r4 / r3) : 0;
		r4 = minLength - r3;
	}
	return [
		r1 || 0,
		r2 || 0,
		r3 || 0,
		r4 || 0
	];
}
/**
* 获取 interval 矩形背景的 path
* @param cfg 关键点的信息
* @param points 已转化为画布坐标的 4 个关键点
* @param coordinate 坐标系
* @returns 返回矩形背景的 path
*/
function getBackgroundRectPath(cfg, points, coordinate$10) {
	var path = [];
	if (coordinate$10.isRect) {
		var p0 = coordinate$10.isTransposed ? {
			x: coordinate$10.start.x,
			y: points[0].y
		} : {
			x: points[0].x,
			y: coordinate$10.start.y
		};
		var p1 = coordinate$10.isTransposed ? {
			x: coordinate$10.end.x,
			y: points[2].y
		} : {
			x: points[3].x,
			y: coordinate$10.end.y
		};
		var radius = get_default(cfg, [
			"background",
			"style",
			"radius"
		]);
		if (radius) {
			var width = coordinate$10.isTransposed ? Math.abs(points[0].y - points[2].y) : points[2].x - points[1].x;
			var height = coordinate$10.isTransposed ? coordinate$10.getWidth() : coordinate$10.getHeight();
			var _a$5 = __read(parseRadius(radius, Math.min(width, height)), 4), r1 = _a$5[0], r2 = _a$5[1], r3 = _a$5[2], r4 = _a$5[3];
			var isReflectYTransposed_1 = coordinate$10.isTransposed && coordinate$10.isReflect("y");
			var bump = isReflectYTransposed_1 ? 0 : 1;
			var opposite = function(r) {
				return isReflectYTransposed_1 ? -r : r;
			};
			path.push([
				"M",
				p0.x,
				p1.y + opposite(r1)
			]);
			r1 !== 0 && path.push([
				"A",
				r1,
				r1,
				0,
				0,
				bump,
				p0.x + r1,
				p1.y
			]);
			path.push([
				"L",
				p1.x - r2,
				p1.y
			]);
			r2 !== 0 && path.push([
				"A",
				r2,
				r2,
				0,
				0,
				bump,
				p1.x,
				p1.y + opposite(r2)
			]);
			path.push([
				"L",
				p1.x,
				p0.y - opposite(r3)
			]);
			r3 !== 0 && path.push([
				"A",
				r3,
				r3,
				0,
				0,
				bump,
				p1.x - r3,
				p0.y
			]);
			path.push([
				"L",
				p0.x + r4,
				p0.y
			]);
			r4 !== 0 && path.push([
				"A",
				r4,
				r4,
				0,
				0,
				bump,
				p0.x,
				p0.y - opposite(r4)
			]);
		} else {
			path.push([
				"M",
				p0.x,
				p0.y
			]);
			path.push([
				"L",
				p1.x,
				p0.y
			]);
			path.push([
				"L",
				p1.x,
				p1.y
			]);
			path.push([
				"L",
				p0.x,
				p1.y
			]);
			path.push([
				"L",
				p0.x,
				p0.y
			]);
		}
		path.push(["z"]);
	}
	if (coordinate$10.isPolar) {
		var center$1 = coordinate$10.getCenter();
		var _b = getAngle(cfg, coordinate$10), startAngle = _b.startAngle, endAngle = _b.endAngle;
		if (coordinate$10.type !== "theta" && !coordinate$10.isTransposed) path = getSectorPath(center$1.x, center$1.y, coordinate$10.getRadius(), startAngle, endAngle);
		else {
			var pow = function(v) {
				return Math.pow(v, 2);
			};
			var r1 = Math.sqrt(pow(center$1.x - points[0].x) + pow(center$1.y - points[0].y));
			var r2 = Math.sqrt(pow(center$1.x - points[2].x) + pow(center$1.y - points[2].y));
			path = getSectorPath(center$1.x, center$1.y, r1, coordinate$10.startAngle, coordinate$10.endAngle, r2);
		}
	}
	return path;
}
/**
* @ignore
* 根据矩形关键点绘制 path
* @param points 关键点数组
* @param lineCap 'round'圆角样式
* @param coor 坐标
* @returns 返回矩形的 path
*/
function getIntervalRectPath(points, lineCap, coor) {
	var width = coor.getWidth();
	var height = coor.getHeight();
	var isRect = coor.type === "rect";
	var path = [];
	var r = (points[2].x - points[1].x) / 2;
	var ry = coor.isTransposed ? r * height / width : r * width / height;
	if (lineCap === "round") {
		if (isRect) {
			path.push([
				"M",
				points[0].x,
				points[0].y + ry
			]);
			path.push([
				"L",
				points[1].x,
				points[1].y - ry
			]);
			path.push([
				"A",
				r,
				r,
				0,
				0,
				1,
				points[2].x,
				points[2].y - ry
			]);
			path.push([
				"L",
				points[3].x,
				points[3].y + ry
			]);
			path.push([
				"A",
				r,
				r,
				0,
				0,
				1,
				points[0].x,
				points[0].y + ry
			]);
		} else {
			path.push([
				"M",
				points[0].x,
				points[0].y
			]);
			path.push([
				"L",
				points[1].x,
				points[1].y
			]);
			path.push([
				"A",
				r,
				r,
				0,
				0,
				1,
				points[2].x,
				points[2].y
			]);
			path.push([
				"L",
				points[3].x,
				points[3].y
			]);
			path.push([
				"A",
				r,
				r,
				0,
				0,
				1,
				points[0].x,
				points[0].y
			]);
		}
		path.push(["z"]);
	} else path = getRectPath$1(points);
	return path;
}
/**
* @ignore
* 根据 funnel 关键点绘制漏斗图的 path
* @param points 图形关键点信息
* @param nextPoints 下一个数据的图形关键点信息
* @param isPyramid 是否为尖底漏斗图
* @returns 返回漏斗图的图形 path
*/
function getFunnelPath(points, nextPoints, isPyramid) {
	var path = [];
	if (!is_nil_default(nextPoints)) path.push([
		"M",
		points[0].x,
		points[0].y
	], [
		"L",
		points[1].x,
		points[1].y
	], [
		"L",
		nextPoints[1].x,
		nextPoints[1].y
	], [
		"L",
		nextPoints[0].x,
		nextPoints[0].y
	], ["Z"]);
	else if (isPyramid) path.push([
		"M",
		points[0].x,
		points[0].y
	], [
		"L",
		points[1].x,
		points[1].y
	], [
		"L",
		(points[2].x + points[3].x) / 2,
		(points[2].y + points[3].y) / 2
	], ["Z"]);
	else path.push([
		"M",
		points[0].x,
		points[0].y
	], [
		"L",
		points[1].x,
		points[1].y
	], [
		"L",
		points[2].x,
		points[2].y
	], [
		"L",
		points[3].x,
		points[3].y
	], ["Z"]);
	return path;
}
/**
* 交换两个对象
*/
function swap$1(p0, p1) {
	return [p1, p0];
}
/**
* 获取 倒角 矩形
* - 目前只适用于笛卡尔坐标系下
*/
function getRectWithCornerRadius(points, coordinate$10, radius) {
	var _a$5, _b, _c, _d, _e, _f, _g;
	var _h = __read(__spreadArray([], __read(points), false), 4), p0 = _h[0], p1 = _h[1], p2 = _h[2], p3 = _h[3];
	var _j = __read(typeof radius === "number" ? Array(4).fill(radius) : radius, 4), r1 = _j[0], r2 = _j[1], r3 = _j[2], r4 = _j[3];
	if (coordinate$10.isTransposed) _a$5 = __read(swap$1(p1, p3), 2), p1 = _a$5[0], p3 = _a$5[1];
	/**
	* 存在镜像
	*/
	if (coordinate$10.isReflect("y")) {
		_b = __read(swap$1(p0, p1), 2), p0 = _b[0], p1 = _b[1];
		_c = __read(swap$1(p2, p3), 2), p2 = _c[0], p3 = _c[1];
	}
	if (coordinate$10.isReflect("x")) {
		_d = __read(swap$1(p0, p3), 2), p0 = _d[0], p3 = _d[1];
		_e = __read(swap$1(p1, p2), 2), p1 = _e[0], p2 = _e[1];
	}
	var path = [];
	/**
	*  p1 → p2
	*  ↑    ↓
	*  p0 ← p3
	*
	*  负数的情况，关键点会变成下面的形式
	*
	*  p0 ← p3               p2 ← p1
	*  ↓    ↑                ↓     ↑
	*  p1 → p2  --> (转置下)  p3 → p0
	*/
	var abs = function(v) {
		return Math.abs(v);
	};
	_f = __read(parseRadius([
		r1,
		r2,
		r3,
		r4
	], Math.min(abs(p3.x - p0.x), abs(p1.y - p0.y))).map(function(d) {
		return abs(d);
	}), 4), r1 = _f[0], r2 = _f[1], r3 = _f[2], r4 = _f[3];
	if (coordinate$10.isTransposed) _g = __read([
		r4,
		r1,
		r2,
		r3
	], 4), r1 = _g[0], r2 = _g[1], r3 = _g[2], r4 = _g[3];
	if (p0.y < p1.y) {
		path.push([
			"M",
			p3.x,
			p3.y + r3
		]);
		r3 !== 0 && path.push([
			"A",
			r3,
			r3,
			0,
			0,
			0,
			p3.x - r3,
			p3.y
		]);
		path.push([
			"L",
			p0.x + r4,
			p0.y
		]);
		r4 !== 0 && path.push([
			"A",
			r4,
			r4,
			0,
			0,
			0,
			p0.x,
			p0.y + r4
		]);
		path.push([
			"L",
			p1.x,
			p1.y - r1
		]);
		r1 !== 0 && path.push([
			"A",
			r1,
			r1,
			0,
			0,
			0,
			p1.x + r1,
			p1.y
		]);
		path.push([
			"L",
			p2.x - r2,
			p2.y
		]);
		r2 !== 0 && path.push([
			"A",
			r2,
			r2,
			0,
			0,
			0,
			p2.x,
			p2.y - r2
		]);
		path.push([
			"L",
			p3.x,
			p3.y + r3
		]);
		path.push(["z"]);
	} else if (p3.x < p0.x) {
		path.push([
			"M",
			p2.x + r2,
			p2.y
		]);
		r2 !== 0 && path.push([
			"A",
			r2,
			r2,
			0,
			0,
			0,
			p2.x,
			p2.y + r2
		]);
		path.push([
			"L",
			p3.x,
			p3.y - r3
		]);
		r3 !== 0 && path.push([
			"A",
			r3,
			r3,
			0,
			0,
			0,
			p3.x + r3,
			p3.y
		]);
		path.push([
			"L",
			p0.x - r4,
			p0.y
		]);
		r4 !== 0 && path.push([
			"A",
			r4,
			r4,
			0,
			0,
			0,
			p0.x,
			p0.y - r4
		]);
		path.push([
			"L",
			p1.x,
			p1.y + r1
		]);
		r1 !== 0 && path.push([
			"A",
			r1,
			r1,
			0,
			0,
			0,
			p1.x - r1,
			p1.y
		]);
		path.push([
			"L",
			p2.x + r2,
			p2.y
		]);
		path.push(["z"]);
	} else {
		path.push([
			"M",
			p1.x,
			p1.y + r1
		]);
		r1 !== 0 && path.push([
			"A",
			r1,
			r1,
			0,
			0,
			1,
			p1.x + r1,
			p1.y
		]);
		path.push([
			"L",
			p2.x - r2,
			p2.y
		]);
		r2 !== 0 && path.push([
			"A",
			r2,
			r2,
			0,
			0,
			1,
			p2.x,
			p2.y + r2
		]);
		path.push([
			"L",
			p3.x,
			p3.y - r3
		]);
		r3 !== 0 && path.push([
			"A",
			r3,
			r3,
			0,
			0,
			1,
			p3.x - r3,
			p3.y
		]);
		path.push([
			"L",
			p0.x + r4,
			p0.y
		]);
		r4 !== 0 && path.push([
			"A",
			r4,
			r4,
			0,
			0,
			1,
			p0.x,
			p0.y - r4
		]);
		path.push([
			"L",
			p1.x,
			p1.y + r1
		]);
		path.push(["z"]);
	}
	return path;
}

//#endregion
//#region node_modules/@antv/g2/esm/geometry/shape/interval/index.js
/** Interval 的 shape 工厂 */
var IntervalShapeFactory = registerShapeFactory("interval", {
	defaultShapeType: "rect",
	getDefaultPoints: function(pointInfo) {
		return getRectPoints$1(pointInfo);
	}
});
/** Inerval 默认 shape，填充的矩形 */
registerShape("interval", "rect", {
	draw: function(cfg, container) {
		var style = getStyle(cfg, false, true);
		var group$1 = container;
		var backgroundCfg = cfg === null || cfg === void 0 ? void 0 : cfg.background;
		if (backgroundCfg) {
			group$1 = container.addGroup({ name: "interval-group" });
			var backgroundStyle = getBackgroundRectStyle(cfg);
			var backgroundPath = getBackgroundRectPath(cfg, this.parsePoints(cfg.points), this.coordinate);
			group$1.addShape("path", {
				attrs: __assign(__assign({}, backgroundStyle), { path: backgroundPath }),
				capture: false,
				zIndex: -1,
				name: BACKGROUND_SHAPE
			});
		}
		var path;
		if (style.radius && this.coordinate.isRect) path = getRectWithCornerRadius(this.parsePoints(cfg.points), this.coordinate, style.radius);
		else path = this.parsePath(getIntervalRectPath(cfg.points, style.lineCap, this.coordinate));
		var shape = group$1.addShape("path", {
			attrs: __assign(__assign({}, style), { path }),
			name: "interval"
		});
		return backgroundCfg ? group$1 : shape;
	},
	getMarker: function(markerCfg) {
		var color$2 = markerCfg.color;
		if (markerCfg.isInPolar) return {
			symbol: "circle",
			style: {
				r: 4.5,
				fill: color$2
			}
		};
		return {
			symbol: "square",
			style: {
				r: 4,
				fill: color$2
			}
		};
	}
});

//#endregion
//#region node_modules/@antv/g2/esm/geometry/util/shape-size.js
function findMinDistance(arr, scale$4) {
	var count$1 = arr.length;
	var sourceArr = arr;
	if (is_string_default(sourceArr[0])) sourceArr = arr.map(function(v) {
		return scale$4.translate(v);
	});
	var distance$7 = sourceArr[1] - sourceArr[0];
	for (var i = 2; i < count$1; i++) {
		var tmp = sourceArr[i] - sourceArr[i - 1];
		if (distance$7 > tmp) distance$7 = tmp;
	}
	return distance$7;
}
function getDodgeCount(dataArray, dodgeBy) {
	if (dodgeBy) {
		var mergeData = flatten_default(dataArray);
		return values_of_key_default(mergeData, dodgeBy).length;
	}
	return dataArray.length;
}
/** @ignore */
function getDefaultSize(geometry$34) {
	var theme$3 = geometry$34.theme;
	var coordinate$10 = geometry$34.coordinate;
	var xScale = geometry$34.getXScale();
	var xValues = xScale.values;
	var dataArray = geometry$34.beforeMappingData;
	var count$1 = xValues.length;
	var xDimensionLength = getXDimensionLength(geometry$34.coordinate);
	var intervalPadding = geometry$34.intervalPadding, dodgePadding = geometry$34.dodgePadding;
	var maxColumnWidth = geometry$34.maxColumnWidth || theme$3.maxColumnWidth;
	var minColumnWidth = geometry$34.minColumnWidth || theme$3.minColumnWidth;
	var columnWidthRatio = geometry$34.columnWidthRatio || theme$3.columnWidthRatio;
	var multiplePieWidthRatio = geometry$34.multiplePieWidthRatio || theme$3.multiplePieWidthRatio;
	var roseWidthRatio = geometry$34.roseWidthRatio || theme$3.roseWidthRatio;
	if (xScale.isLinear && xValues.length > 1) {
		xValues.sort();
		var interval$2 = findMinDistance(xValues, xScale);
		count$1 = (xScale.max - xScale.min) / interval$2;
		if (xValues.length > count$1) count$1 = xValues.length;
	}
	var range = xScale.range;
	var normalizedSize = 1 / count$1;
	var wr = 1;
	if (coordinate$10.isPolar) if (coordinate$10.isTransposed && count$1 > 1) wr = multiplePieWidthRatio;
	else wr = roseWidthRatio;
	else {
		if (xScale.isLinear) normalizedSize *= range[1] - range[0];
		wr = columnWidthRatio;
	}
	if (!is_nil_default(intervalPadding) && intervalPadding >= 0) {
		var normalizedIntervalPadding = intervalPadding / xDimensionLength;
		normalizedSize = (1 - (count$1 - 1) * normalizedIntervalPadding) / count$1;
	} else normalizedSize *= wr;
	if (geometry$34.getAdjust("dodge")) {
		var dodgeBy = geometry$34.getAdjust("dodge").dodgeBy;
		var dodgeCount = getDodgeCount(dataArray, dodgeBy);
		if (!is_nil_default(dodgePadding) && dodgePadding >= 0) {
			var normalizedDodgePadding = dodgePadding / xDimensionLength;
			normalizedSize = (normalizedSize - normalizedDodgePadding * (dodgeCount - 1)) / dodgeCount;
		} else if (!is_nil_default(intervalPadding) && intervalPadding >= 0) {
			normalizedSize *= wr;
			normalizedSize = normalizedSize / dodgeCount;
		} else normalizedSize = normalizedSize / dodgeCount;
		normalizedSize = normalizedSize >= 0 ? normalizedSize : 0;
	}
	if (!is_nil_default(maxColumnWidth) && maxColumnWidth >= 0) {
		var normalizedMaxColumnWidth = maxColumnWidth / xDimensionLength;
		if (normalizedSize > normalizedMaxColumnWidth) normalizedSize = normalizedMaxColumnWidth;
	}
	if (!is_nil_default(minColumnWidth) && minColumnWidth >= 0) {
		var normalizedMinColumnWidth = minColumnWidth / xDimensionLength;
		if (normalizedSize < normalizedMinColumnWidth) normalizedSize = normalizedMinColumnWidth;
	}
	return normalizedSize;
}

//#endregion
//#region node_modules/@antv/g2/esm/geometry/interval.js
/**
* Interval 几何标记。
* 用于绘制柱状图、饼图、条形图、玫瑰图等。
*/
var Interval = function(_super) {
	__extends(Interval$1, _super);
	function Interval$1(cfg) {
		var _this = _super.call(this, cfg) || this;
		_this.type = "interval";
		_this.shapeType = "interval";
		_this.generatePoints = true;
		_this.background = cfg.background;
		return _this;
	}
	/**
	* 获取每条数据的 Shape 绘制信息
	* @param obj 经过分组 -> 数字化 -> adjust 调整后的数据记录
	* @returns
	*/
	Interval$1.prototype.createShapePointsCfg = function(obj) {
		var cfg = _super.prototype.createShapePointsCfg.call(this, obj);
		var size$1;
		var sizeAttr = this.getAttribute("size");
		if (sizeAttr) {
			size$1 = this.getAttributeValues(sizeAttr, obj)[0];
			var coordinate$10 = this.coordinate;
			var coordinateWidth = getXDimensionLength(coordinate$10);
			size$1 = size$1 / coordinateWidth;
		} else {
			if (!this.defaultSize) this.defaultSize = getDefaultSize(this);
			size$1 = this.defaultSize;
		}
		cfg.size = size$1;
		return cfg;
	};
	/**
	* 调整 y 轴的 scale 范围。
	* 对于 Y 轴为数值轴柱状图，默认从 0 开始 生长。
	*/
	Interval$1.prototype.adjustScale = function() {
		_super.prototype.adjustScale.call(this);
		var yScale = this.getYScale();
		if (this.coordinate.type === "theta") yScale.change({
			nice: false,
			min: 0,
			max: getMaxScale(yScale)
		});
		else {
			var scaleDefs = this.scaleDefs;
			var field$5 = yScale.field, min$2 = yScale.min, max$2 = yScale.max;
			if (yScale.type !== "time") {
				if (min$2 > 0 && !get_default(scaleDefs, [field$5, "min"])) yScale.change({ min: 0 });
				if (max$2 <= 0 && !get_default(scaleDefs, [field$5, "max"])) yScale.change({ max: 0 });
			}
		}
	};
	/**
	* @override
	*/
	Interval$1.prototype.getDrawCfg = function(mappingData) {
		var shapeCfg = _super.prototype.getDrawCfg.call(this, mappingData);
		shapeCfg.background = this.background;
		return shapeCfg;
	};
	return Interval$1;
}(base_default$4);
var interval_default = Interval;

//#endregion
//#region node_modules/@antv/g2/esm/geometry/line.js
/**
* Line 几何标记。
* 常用于折线图的绘制。
*/
var Line$1 = function(_super) {
	__extends(Line$6, _super);
	function Line$6(cfg) {
		var _this = _super.call(this, cfg) || this;
		_this.type = "line";
		var _a$5 = cfg.sortable;
		_this.sortable = _a$5 === void 0 ? false : _a$5;
		return _this;
	}
	return Line$6;
}(path_default$1);
var line_default = Line$1;

//#endregion
//#region node_modules/@antv/g2/esm/geometry/shape/point/util.js
var SHAPES = [
	"circle",
	"square",
	"bowtie",
	"diamond",
	"hexagon",
	"triangle",
	"triangle-down"
];
var HOLLOW_SHAPES = [
	"cross",
	"tick",
	"plus",
	"hyphen",
	"line"
];
/**
* @ignore
* Draws points
* @param shape
* @param cfg
* @param container
* @param shapeName
* @param isStroke
* @returns points
*/
function drawPoints(shape, cfg, container, shapeName, isStroke) {
	var e_1, _a$5;
	var style = getStyle(cfg, isStroke, !isStroke, "r");
	var points = shape.parsePoints(cfg.points);
	var pointPosition = points[0];
	if (cfg.isStack) pointPosition = points[1];
	else if (points.length > 1) {
		var group$1 = container.addGroup();
		try {
			for (var points_1 = __values(points), points_1_1 = points_1.next(); !points_1_1.done; points_1_1 = points_1.next()) {
				var point$1 = points_1_1.value;
				group$1.addShape({
					type: "marker",
					attrs: __assign(__assign(__assign({}, style), { symbol: MarkerSymbols[shapeName] || shapeName }), point$1)
				});
			}
		} catch (e_1_1) {
			e_1 = { error: e_1_1 };
		} finally {
			try {
				if (points_1_1 && !points_1_1.done && (_a$5 = points_1.return)) _a$5.call(points_1);
			} finally {
				if (e_1) throw e_1.error;
			}
		}
		return group$1;
	}
	return container.addShape({
		type: "marker",
		attrs: __assign(__assign(__assign({}, style), { symbol: MarkerSymbols[shapeName] || shapeName }), pointPosition)
	});
}

//#endregion
//#region node_modules/@antv/g2/esm/geometry/shape/point/index.js
var PointShapeFactory = registerShapeFactory("point", {
	defaultShapeType: "hollow-circle",
	getDefaultPoints: function(pointInfo) {
		return splitPoints(pointInfo);
	}
});
each_default(SHAPES, function(shapeName) {
	registerShape("point", "hollow-".concat(shapeName), {
		draw: function(cfg, container) {
			return drawPoints(this, cfg, container, shapeName, true);
		},
		getMarker: function(markerCfg) {
			var color$2 = markerCfg.color;
			return {
				symbol: MarkerSymbols[shapeName] || shapeName,
				style: {
					r: 4.5,
					stroke: color$2,
					fill: null
				}
			};
		}
	});
});

//#endregion
//#region node_modules/@antv/g2/esm/geometry/point.js
/**
* Point 几何标记。
* 常用于绘制点图。
*/
var Point = function(_super) {
	__extends(Point$1, _super);
	function Point$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = "point";
		_this.shapeType = "point";
		_this.generatePoints = true;
		return _this;
	}
	/**
	* 获取一个点的绘制信息。
	* @param mappingDatum
	* @returns draw cfg
	*/
	Point$1.prototype.getDrawCfg = function(mappingDatum) {
		var shapeCfg = _super.prototype.getDrawCfg.call(this, mappingDatum);
		return __assign(__assign({}, shapeCfg), { isStack: !!this.getAdjust("stack") });
	};
	return Point$1;
}(base_default$4);
var point_default = Point;

//#endregion
//#region node_modules/@antv/g2/esm/geometry/shape/polygon/index.js
function getPath$1(points) {
	var flag = points[0];
	var i = 1;
	var path = [[
		"M",
		flag.x,
		flag.y
	]];
	while (i < points.length) {
		var c = points[i];
		if (c.x !== points[i - 1].x || c.y !== points[i - 1].y) {
			path.push([
				"L",
				c.x,
				c.y
			]);
			if (c.x === flag.x && c.y === flag.y && i < points.length - 1) {
				flag = points[i + 1];
				path.push(["Z"]);
				path.push([
					"M",
					flag.x,
					flag.y
				]);
				i++;
			}
		}
		i++;
	}
	if (!is_equal_default(last(path), flag)) path.push([
		"L",
		flag.x,
		flag.y
	]);
	path.push(["Z"]);
	return path;
}
var PolygonShapeFactory = registerShapeFactory("polygon", {
	defaultShapeType: "polygon",
	getDefaultPoints: function(pointInfo) {
		var points = [];
		each_default(pointInfo.x, function(subX, index) {
			var subY = pointInfo.y[index];
			points.push({
				x: subX,
				y: subY
			});
		});
		return points;
	}
});
registerShape("polygon", "polygon", {
	draw: function(cfg, container) {
		if (!is_empty_default(cfg.points)) {
			var shapeAttrs = getStyle(cfg, true, true);
			var path = this.parsePath(getPath$1(cfg.points));
			return container.addShape("path", {
				attrs: __assign(__assign({}, shapeAttrs), { path }),
				name: "polygon"
			});
		}
	},
	getMarker: function(markerCfg) {
		return {
			symbol: "square",
			style: {
				r: 4,
				fill: markerCfg.color
			}
		};
	}
});

//#endregion
//#region node_modules/@antv/g2/esm/geometry/polygon.js
/**
* Polygon 几何标记。
* 常用于绘制色块图、日历图等。
*/
var Polygon = function(_super) {
	__extends(Polygon$3, _super);
	function Polygon$3() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = "polygon";
		_this.shapeType = "polygon";
		_this.generatePoints = true;
		return _this;
	}
	/**
	* 获取 Shape 的关键点数据。
	* @param obj
	* @returns
	*/
	Polygon$3.prototype.createShapePointsCfg = function(obj) {
		var cfg = _super.prototype.createShapePointsCfg.call(this, obj);
		var x = cfg.x;
		var y = cfg.y;
		var temp;
		if (!(is_array_default(x) && is_array_default(y))) {
			var xScale = this.getXScale();
			var yScale = this.getYScale();
			var xCount = xScale.values.length;
			var yCount = yScale.values.length;
			var xOffset = .5 * 1 / xCount;
			var yOffset = .5 * 1 / yCount;
			if (xScale.isCategory && yScale.isCategory) {
				x = [
					x - xOffset,
					x - xOffset,
					x + xOffset,
					x + xOffset
				];
				y = [
					y - yOffset,
					y + yOffset,
					y + yOffset,
					y - yOffset
				];
			} else if (is_array_default(x)) {
				temp = x;
				x = [
					temp[0],
					temp[0],
					temp[1],
					temp[1]
				];
				y = [
					y - yOffset / 2,
					y + yOffset / 2,
					y + yOffset / 2,
					y - yOffset / 2
				];
			} else if (is_array_default(y)) {
				temp = y;
				y = [
					temp[0],
					temp[1],
					temp[1],
					temp[0]
				];
				x = [
					x - xOffset / 2,
					x - xOffset / 2,
					x + xOffset / 2,
					x + xOffset / 2
				];
			}
			cfg.x = x;
			cfg.y = y;
		}
		return cfg;
	};
	return Polygon$3;
}(base_default$4);
var polygon_default = Polygon;

//#endregion
//#region node_modules/@antv/g2/esm/geometry/shape/schema/index.js
var SchemaShapeFactory = registerShapeFactory("schema", { defaultShapeType: "" });

//#endregion
//#region node_modules/@antv/g2/esm/geometry/schema.js
/**
* Schema 几何标记，用于一些自定义图形的绘制，比如箱型图、股票图等。
*/
var Schema = function(_super) {
	__extends(Schema$1, _super);
	function Schema$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = "schema";
		_this.shapeType = "schema";
		_this.generatePoints = true;
		return _this;
	}
	/**
	* 获取 Shape 的关键点数据。
	* @param record
	* @returns
	*/
	Schema$1.prototype.createShapePointsCfg = function(record) {
		var cfg = _super.prototype.createShapePointsCfg.call(this, record);
		var size$1;
		var sizeAttr = this.getAttribute("size");
		if (sizeAttr) {
			size$1 = this.getAttributeValues(sizeAttr, record)[0];
			var coordinate$10 = this.coordinate;
			var coordinateWidth = getXDimensionLength(coordinate$10);
			size$1 = size$1 / coordinateWidth;
		} else {
			if (!this.defaultSize) this.defaultSize = getDefaultSize(this);
			size$1 = this.defaultSize;
		}
		cfg.size = size$1;
		return cfg;
	};
	return Schema$1;
}(base_default$4);
var schema_default = Schema;

//#endregion
//#region node_modules/@antv/g2/esm/geometry/shape/violin/index.js
function normalizeSize(arr) {
	if (!is_array_default(arr)) return [];
	var maxValue = max_default(arr);
	return map_default(arr, function(num) {
		return num / maxValue;
	});
}
var ViolinShapeFactory = registerShapeFactory("violin", {
	defaultShapeType: "violin",
	getDefaultPoints: function(pointInfo) {
		var radius = pointInfo.size / 2;
		var points = [];
		var sizeArr = normalizeSize(pointInfo._size);
		each_default(pointInfo.y, function(y, index) {
			var offset = sizeArr[index] * radius;
			var isMin = index === 0;
			var isMax = index === pointInfo.y.length - 1;
			points.push({
				isMin,
				isMax,
				x: pointInfo.x - offset,
				y
			});
			points.unshift({
				isMin,
				isMax,
				x: pointInfo.x + offset,
				y
			});
		});
		return points;
	}
});
registerShape("violin", "violin", {
	draw: function(cfg, container) {
		var shapeAttrs = getStyle(cfg, true, true);
		var path = this.parsePath(getViolinPath(cfg.points));
		return container.addShape("path", {
			attrs: __assign(__assign({}, shapeAttrs), { path }),
			name: "violin"
		});
	},
	getMarker: function(markerCfg) {
		return {
			symbol: "circle",
			style: {
				r: 4,
				fill: markerCfg.color
			}
		};
	}
});

//#endregion
//#region node_modules/@antv/g2/esm/geometry/violin.js
/**
* Violin 几何标记。
* 用于绘制小提琴图。
*/
var Violin$1 = function(_super) {
	__extends(Violin$2, _super);
	function Violin$2() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = "violin";
		_this.shapeType = "violin";
		_this.generatePoints = true;
		return _this;
	}
	/**
	* 获取 Shape 的关键点数据。
	* @param record
	* @returns
	*/
	Violin$2.prototype.createShapePointsCfg = function(record) {
		var cfg = _super.prototype.createShapePointsCfg.call(this, record);
		var size$1;
		var sizeAttr = this.getAttribute("size");
		if (sizeAttr) {
			size$1 = this.getAttributeValues(sizeAttr, record)[0];
			var coordinate$10 = this.coordinate;
			var coordinateWidth = getXDimensionLength(coordinate$10);
			size$1 = size$1 / coordinateWidth;
		} else {
			if (!this.defaultSize) this.defaultSize = getDefaultSize(this);
			size$1 = this.defaultSize;
		}
		cfg.size = size$1;
		cfg._size = get_default(record[FIELD_ORIGIN], [this._sizeField]);
		return cfg;
	};
	/**
	* @override
	*/
	Violin$2.prototype.initAttributes = function() {
		var attributeOption = this.attributeOption;
		this._sizeField = attributeOption.size ? attributeOption.size.fields[0] : this._sizeField ? this._sizeField : "size";
		delete attributeOption.size;
		_super.prototype.initAttributes.call(this);
	};
	return Violin$2;
}(base_default$4);
var violin_default = Violin$1;

//#endregion
//#region node_modules/@antv/g2/esm/geometry/shape/area/line.js
/**
* 描边但不填充的区域图
*/
registerShape("area", "line", {
	draw: function(cfg, container) {
		var attrs = getShapeAttrs(cfg, true, false, this);
		return container.addShape({
			type: "path",
			attrs,
			name: "area"
		});
	},
	getMarker: function(markerCfg) {
		return {
			symbol: function(x, y, r) {
				if (r === void 0) r = 5.5;
				return [
					[
						"M",
						x - r,
						y - 4
					],
					[
						"L",
						x + r,
						y - 4
					],
					[
						"L",
						x + r,
						y + 4
					],
					[
						"L",
						x - r,
						y + 4
					],
					["Z"]
				];
			},
			style: {
				r: 5,
				stroke: markerCfg.color,
				fill: null
			}
		};
	}
});

//#endregion
//#region node_modules/@antv/g2/esm/geometry/shape/area/smooth.js
/**
* 填充的平滑曲面图
*/
registerShape("area", "smooth", {
	draw: function(cfg, container) {
		var coordinate$10 = this.coordinate;
		var attrs = getShapeAttrs(cfg, false, true, this, getConstraint(coordinate$10));
		return container.addShape({
			type: "path",
			attrs,
			name: "area"
		});
	},
	getMarker: function(markerCfg) {
		return {
			symbol: function(x, y, r) {
				if (r === void 0) r = 5.5;
				return [
					[
						"M",
						x - r,
						y - 4
					],
					[
						"L",
						x + r,
						y - 4
					],
					[
						"L",
						x + r,
						y + 4
					],
					[
						"L",
						x - r,
						y + 4
					],
					["Z"]
				];
			},
			style: {
				r: 5,
				fill: markerCfg.color,
				fillOpacity: 1
			}
		};
	}
});

//#endregion
//#region node_modules/@antv/g2/esm/geometry/shape/area/smooth-line.js
/** 描边的平滑曲面图 */
registerShape("area", "smooth-line", {
	draw: function(cfg, container) {
		var coordinate$10 = this.coordinate;
		var attrs = getShapeAttrs(cfg, true, true, this, getConstraint(coordinate$10));
		return container.addShape({
			type: "path",
			attrs,
			name: "area"
		});
	},
	getMarker: function(markerCfg) {
		return {
			symbol: function(x, y, r) {
				if (r === void 0) r = 5.5;
				return [
					[
						"M",
						x - r,
						y - 4
					],
					[
						"L",
						x + r,
						y - 4
					],
					[
						"L",
						x + r,
						y + 4
					],
					[
						"L",
						x - r,
						y + 4
					],
					["Z"]
				];
			},
			style: {
				r: 5,
				stroke: markerCfg.color,
				fill: null
			}
		};
	}
});

//#endregion
//#region node_modules/@antv/g2/esm/geometry/shape/edge/util.js
/**
* @ignore
* Gets cpath
* @param from
* @param to
* @returns
*/
function getCPath(from, to) {
	return [
		"C",
		from.x * 1 / 2 + to.x * 1 / 2,
		from.y,
		from.x * 1 / 2 + to.x * 1 / 2,
		to.y,
		to.x,
		to.y
	];
}
/**
* @ignore
* Gets qpath
* @param to
* @param center
* @returns
*/
function getQPath(to, center$1) {
	var points = [];
	points.push({
		x: center$1.x,
		y: center$1.y
	});
	points.push(to);
	var sub$1 = ["Q"];
	each_default(points, function(point$1) {
		sub$1.push(point$1.x, point$1.y);
	});
	return sub$1;
}

//#endregion
//#region node_modules/@antv/g2/esm/geometry/shape/edge/arc.js
function getArcShapePath(from, to, center$1) {
	var sub$1 = getQPath(to, center$1);
	var path = [[
		"M",
		from.x,
		from.y
	]];
	path.push(sub$1);
	return path;
}
function getArcShapeWeightPath(points, center$1) {
	var arc1 = getQPath(points[1], center$1);
	var arc2 = getQPath(points[3], center$1);
	var path = [[
		"M",
		points[0].x,
		points[0].y
	]];
	path.push(arc2);
	path.push([
		"L",
		points[3].x,
		points[3].y
	]);
	path.push([
		"L",
		points[2].x,
		points[2].y
	]);
	path.push(arc1);
	path.push([
		"L",
		points[1].x,
		points[1].y
	]);
	path.push([
		"L",
		points[0].x,
		points[0].y
	]);
	path.push(["Z"]);
	return path;
}
registerShape("edge", "arc", {
	draw: function(cfg, container) {
		var style = getStyle(cfg, true, false, "lineWidth");
		var points = cfg.points;
		var type = points.length > 2 ? "weight" : "normal";
		var path;
		if (cfg.isInCircle) {
			var center$1 = {
				x: 0,
				y: 1
			};
			if (type === "normal") path = getArcShapePath(points[0], points[1], center$1);
			else {
				style.fill = style.stroke;
				path = getArcShapeWeightPath(points, center$1);
			}
			path = this.parsePath(path);
			return container.addShape("path", { attrs: __assign(__assign({}, style), { path }) });
		} else if (type === "normal") {
			points = this.parsePoints(points);
			path = getArcPath((points[1].x + points[0].x) / 2, points[0].y, Math.abs(points[1].x - points[0].x) / 2, Math.PI, Math.PI * 2);
			return container.addShape("path", { attrs: __assign(__assign({}, style), { path }) });
		} else {
			var c1 = getCPath(points[1], points[3]);
			var c2 = getCPath(points[2], points[0]);
			path = [
				[
					"M",
					points[0].x,
					points[0].y
				],
				[
					"L",
					points[1].x,
					points[1].y
				],
				c1,
				[
					"L",
					points[3].x,
					points[3].y
				],
				[
					"L",
					points[2].x,
					points[2].y
				],
				c2,
				["Z"]
			];
			path = this.parsePath(path);
			style.fill = style.stroke;
			return container.addShape("path", { attrs: __assign(__assign({}, style), { path }) });
		}
	},
	getMarker: function(markerCfg) {
		return {
			symbol: "circle",
			style: {
				r: 4.5,
				fill: markerCfg.color
			}
		};
	}
});

//#endregion
//#region node_modules/@antv/g2/esm/geometry/shape/edge/smooth.js
function getSmoothPath(from, to) {
	var sub$1 = getCPath(from, to);
	var path = [[
		"M",
		from.x,
		from.y
	]];
	path.push(sub$1);
	return path;
}
registerShape("edge", "smooth", {
	draw: function(cfg, container) {
		var style = getStyle(cfg, true, false, "lineWidth");
		var points = cfg.points;
		var path = this.parsePath(getSmoothPath(points[0], points[1]));
		return container.addShape("path", { attrs: __assign(__assign({}, style), { path }) });
	},
	getMarker: function(markerCfg) {
		return {
			symbol: "circle",
			style: {
				r: 4.5,
				fill: markerCfg.color
			}
		};
	}
});

//#endregion
//#region node_modules/@antv/g2/esm/geometry/shape/edge/vhv.js
var CORNER_PERCENT = 1 / 3;
function getVHVPath(from, to) {
	var points = [];
	points.push({
		x: from.x,
		y: from.y * (1 - CORNER_PERCENT) + to.y * CORNER_PERCENT
	});
	points.push({
		x: to.x,
		y: from.y * (1 - CORNER_PERCENT) + to.y * CORNER_PERCENT
	});
	points.push(to);
	var path = [[
		"M",
		from.x,
		from.y
	]];
	each_default(points, function(point$1) {
		path.push([
			"L",
			point$1.x,
			point$1.y
		]);
	});
	return path;
}
registerShape("edge", "vhv", {
	draw: function(cfg, container) {
		var style = getStyle(cfg, true, false, "lineWidth");
		var points = cfg.points;
		var path = this.parsePath(getVHVPath(points[0], points[1]));
		return container.addShape("path", { attrs: __assign(__assign({}, style), { path }) });
	},
	getMarker: function(markerCfg) {
		return {
			symbol: "circle",
			style: {
				r: 4.5,
				fill: markerCfg.color
			}
		};
	}
});

//#endregion
//#region node_modules/@antv/g2/esm/geometry/shape/interval/funnel.js
/** 漏斗图 */
registerShape("interval", "funnel", {
	getPoints: function(shapePoint) {
		shapePoint.size = shapePoint.size * 2;
		return getRectPoints$1(shapePoint);
	},
	draw: function(cfg, container) {
		var style = getStyle(cfg, false, true);
		var path = this.parsePath(getFunnelPath(cfg.points, cfg.nextPoints, false));
		return container.addShape("path", {
			attrs: __assign(__assign({}, style), { path }),
			name: "interval"
		});
	},
	getMarker: function(markerCfg) {
		return {
			symbol: "square",
			style: {
				r: 4,
				fill: markerCfg.color
			}
		};
	}
});

//#endregion
//#region node_modules/@antv/g2/esm/geometry/shape/interval/hollow-rect.js
/** 描边柱状图 */
registerShape("interval", "hollow-rect", {
	draw: function(cfg, container) {
		var style = getStyle(cfg, true, false);
		var group$1 = container;
		var backgroundCfg = cfg === null || cfg === void 0 ? void 0 : cfg.background;
		if (backgroundCfg) {
			group$1 = container.addGroup();
			var backgroundStyle = getBackgroundRectStyle(cfg);
			var backgroundPath = getBackgroundRectPath(cfg, this.parsePoints(cfg.points), this.coordinate);
			group$1.addShape("path", {
				attrs: __assign(__assign({}, backgroundStyle), { path: backgroundPath }),
				capture: false,
				zIndex: -1,
				name: BACKGROUND_SHAPE
			});
		}
		var path = this.parsePath(getRectPath$1(cfg.points));
		var shape = group$1.addShape("path", {
			attrs: __assign(__assign({}, style), { path }),
			name: "interval"
		});
		return backgroundCfg ? group$1 : shape;
	},
	getMarker: function(markerCfg) {
		var color$2 = markerCfg.color;
		if (markerCfg.isInPolar) return {
			symbol: "circle",
			style: {
				r: 4.5,
				stroke: color$2,
				fill: null
			}
		};
		return {
			symbol: "square",
			style: {
				r: 4,
				stroke: color$2,
				fill: null
			}
		};
	}
});

//#endregion
//#region node_modules/@antv/g2/esm/geometry/shape/interval/line.js
function getLinePoints(pointInfo) {
	var x = pointInfo.x, y = pointInfo.y, y0 = pointInfo.y0;
	if (is_array_default(y)) return y.map(function(yItem, idx) {
		return {
			x: is_array_default(x) ? x[idx] : x,
			y: yItem
		};
	});
	return [{
		x,
		y: y0
	}, {
		x,
		y
	}];
}
registerShape("interval", "line", {
	getPoints: function(shapePoint) {
		return getLinePoints(shapePoint);
	},
	draw: function(cfg, container) {
		var style = getStyle(cfg, true, false, "lineWidth");
		var newStyle = omit(__assign({}, style), ["fill"]);
		var path = this.parsePath(getRectPath$1(cfg.points, false));
		return container.addShape("path", {
			attrs: __assign(__assign({}, newStyle), { path }),
			name: "interval"
		});
	},
	getMarker: function(markerCfg) {
		return {
			symbol: function(x, y, r) {
				return [[
					"M",
					x,
					y - r
				], [
					"L",
					x,
					y + r
				]];
			},
			style: {
				r: 5,
				stroke: markerCfg.color
			}
		};
	}
});

//#endregion
//#region node_modules/@antv/g2/esm/geometry/shape/interval/pyramid.js
/** 金字塔图，尖底漏斗图 */
registerShape("interval", "pyramid", {
	getPoints: function(shapePoint) {
		shapePoint.size = shapePoint.size * 2;
		return getRectPoints$1(shapePoint);
	},
	draw: function(cfg, container) {
		var style = getStyle(cfg, false, true);
		var path = this.parsePath(getFunnelPath(cfg.points, cfg.nextPoints, true));
		return container.addShape("path", {
			attrs: __assign(__assign({}, style), { path }),
			name: "interval"
		});
	},
	getMarker: function(markerCfg) {
		return {
			symbol: "square",
			style: {
				r: 4,
				fill: markerCfg.color
			}
		};
	}
});

//#endregion
//#region node_modules/@antv/g2/esm/geometry/shape/interval/tick.js
function getTickPoints(pointInfo) {
	var _a$5;
	var x = pointInfo.x, y = pointInfo.y, y0 = pointInfo.y0, size$1 = pointInfo.size;
	var yMin;
	var yMax;
	if (is_array_default(y)) _a$5 = __read(y, 2), yMin = _a$5[0], yMax = _a$5[1];
	else {
		yMin = y0;
		yMax = y;
	}
	var xMax = x + size$1 / 2;
	var xMin = x - size$1 / 2;
	return [
		{
			x,
			y: yMin
		},
		{
			x,
			y: yMax
		},
		{
			x: xMin,
			y: yMin
		},
		{
			x: xMax,
			y: yMin
		},
		{
			x: xMin,
			y: yMax
		},
		{
			x: xMax,
			y: yMax
		}
	];
}
function getTickPath(points) {
	return [
		[
			"M",
			points[0].x,
			points[0].y
		],
		[
			"L",
			points[1].x,
			points[1].y
		],
		[
			"M",
			points[2].x,
			points[2].y
		],
		[
			"L",
			points[3].x,
			points[3].y
		],
		[
			"M",
			points[4].x,
			points[4].y
		],
		[
			"L",
			points[5].x,
			points[5].y
		]
	];
}
/** I 形状柱状图，常用于 error bar chart */
registerShape("interval", "tick", {
	getPoints: function(shapePoint) {
		return getTickPoints(shapePoint);
	},
	draw: function(cfg, container) {
		var style = getStyle(cfg, true, false);
		var path = this.parsePath(getTickPath(cfg.points));
		return container.addShape("path", {
			attrs: __assign(__assign({}, style), { path }),
			name: "interval"
		});
	},
	getMarker: function(markerCfg) {
		return {
			symbol: function(x, y, r) {
				return [
					[
						"M",
						x - r / 2,
						y - r
					],
					[
						"L",
						x + r / 2,
						y - r
					],
					[
						"M",
						x,
						y - r
					],
					[
						"L",
						x,
						y + r
					],
					[
						"M",
						x - r / 2,
						y + r
					],
					[
						"L",
						x + r / 2,
						y + r
					]
				];
			},
			style: {
				r: 5,
				stroke: markerCfg.color
			}
		};
	}
});

//#endregion
//#region node_modules/@antv/g2/esm/geometry/shape/line/step.js
var interpolateCallback = function(point$1, nextPoint, shapeType) {
	var x = point$1.x;
	var y = point$1.y;
	var nextX = nextPoint.x;
	var nextY = nextPoint.y;
	var result;
	switch (shapeType) {
		case "hv":
			result = [{
				x: nextX,
				y
			}];
			break;
		case "vh":
			result = [{
				x,
				y: nextY
			}];
			break;
		case "hvh":
			var middleX = (nextX + x) / 2;
			result = [{
				x: middleX,
				y
			}, {
				x: middleX,
				y: nextY
			}];
			break;
		case "vhv":
			var middleY = (y + nextY) / 2;
			result = [{
				x,
				y: middleY
			}, {
				x: nextX,
				y: middleY
			}];
			break;
		default: break;
	}
	return result;
};
function getInterpolatePoints(points, shapeType) {
	var result = [];
	each_default(points, function(point$1, index) {
		var nextPoint = points[index + 1];
		result.push(point$1);
		if (nextPoint) {
			var interpolatePoint = interpolateCallback(point$1, nextPoint, shapeType);
			result = result.concat(interpolatePoint);
		}
	});
	return result;
}
function getInterpolatePath(points) {
	return points.map(function(point$1, index) {
		return index === 0 ? [
			"M",
			point$1.x,
			point$1.y
		] : [
			"L",
			point$1.x,
			point$1.y
		];
	});
}
function getInterpolateShapeAttrs(cfg, shapeType) {
	var points = getPathPoints(cfg.points, cfg.connectNulls, cfg.showSinglePoint);
	var path = [];
	each_default(points, function(eachLinePoints) {
		var interpolatePoints = getInterpolatePoints(eachLinePoints, shapeType);
		path = path.concat(getInterpolatePath(interpolatePoints));
	});
	return __assign(__assign({}, getStyle(cfg, true, false, "lineWidth")), { path });
}
each_default([
	"hv",
	"vh",
	"hvh",
	"vhv"
], function(shapeType) {
	registerShape("line", shapeType, {
		draw: function(cfg, container) {
			var attrs = getInterpolateShapeAttrs(cfg, shapeType);
			return container.addShape({
				type: "path",
				attrs,
				name: "line"
			});
		},
		getMarker: function(markerCfg) {
			return getLineMarker(markerCfg, shapeType);
		}
	});
});

//#endregion
//#region node_modules/@antv/g2/esm/geometry/shape/point/hollow.js
each_default(HOLLOW_SHAPES, function(shapeName) {
	registerShape("point", shapeName, {
		draw: function(cfg, container) {
			return drawPoints(this, cfg, container, shapeName, true);
		},
		getMarker: function(markerCfg) {
			var color$2 = markerCfg.color;
			return {
				symbol: MarkerSymbols[shapeName],
				style: {
					r: 4.5,
					stroke: color$2,
					fill: null
				}
			};
		}
	});
});

//#endregion
//#region node_modules/@antv/g2/esm/geometry/shape/point/image.js
registerShape("point", "image", {
	draw: function(cfg, container) {
		var e_1, _a$5;
		var size$1 = getStyle(cfg, false, false, "r").r;
		var points = this.parsePoints(cfg.points);
		var pointPosition = points[0];
		if (cfg.isStack) pointPosition = points[1];
		else if (points.length > 1) {
			var group$1 = container.addGroup();
			try {
				for (var points_1 = __values(points), points_1_1 = points_1.next(); !points_1_1.done; points_1_1 = points_1.next()) {
					var point$1 = points_1_1.value;
					group$1.addShape("image", { attrs: {
						x: point$1.x - size$1 / 2,
						y: point$1.y - size$1,
						width: size$1,
						height: size$1,
						img: cfg.shape[1]
					} });
				}
			} catch (e_1_1) {
				e_1 = { error: e_1_1 };
			} finally {
				try {
					if (points_1_1 && !points_1_1.done && (_a$5 = points_1.return)) _a$5.call(points_1);
				} finally {
					if (e_1) throw e_1.error;
				}
			}
			return group$1;
		}
		return container.addShape("image", { attrs: {
			x: pointPosition.x - size$1 / 2,
			y: pointPosition.y - size$1,
			width: size$1,
			height: size$1,
			img: cfg.shape[1]
		} });
	},
	getMarker: function(markerCfg) {
		return {
			symbol: "circle",
			style: {
				r: 4.5,
				fill: markerCfg.color
			}
		};
	}
});

//#endregion
//#region node_modules/@antv/g2/esm/geometry/shape/point/solid.js
each_default(SHAPES, function(shapeName) {
	registerShape("point", shapeName, {
		draw: function(cfg, container) {
			return drawPoints(this, cfg, container, shapeName, false);
		},
		getMarker: function(markerCfg) {
			var color$2 = markerCfg.color;
			return {
				symbol: MarkerSymbols[shapeName] || shapeName,
				style: {
					r: 4.5,
					fill: color$2
				}
			};
		}
	});
});

//#endregion
//#region node_modules/@antv/g2/esm/geometry/shape/schema/box.js
function parseValue(value$1) {
	var array = !is_array_default(value$1) ? [value$1] : value$1;
	var min$2 = array[0];
	var max$2 = array[array.length - 1];
	var min1 = array.length > 1 ? array[1] : min$2;
	var max1 = array.length > 3 ? array[3] : max$2;
	var median = array.length > 2 ? array[2] : min1;
	return {
		min: min$2,
		max: max$2,
		min1,
		max1,
		median
	};
}
function getBoxPoints(x, y, size$1) {
	var halfSize = size$1 / 2;
	var pointsArray;
	if (is_array_default(y)) {
		var _a$5 = parseValue(y), min$2 = _a$5.min, max$2 = _a$5.max, median = _a$5.median, min1 = _a$5.min1, max1 = _a$5.max1;
		var minX = x - halfSize;
		var maxX = x + halfSize;
		pointsArray = [
			[minX, max$2],
			[maxX, max$2],
			[x, max$2],
			[x, max1],
			[minX, min1],
			[minX, max1],
			[maxX, max1],
			[maxX, min1],
			[x, min1],
			[x, min$2],
			[minX, min$2],
			[maxX, min$2],
			[minX, median],
			[maxX, median]
		];
	} else {
		y = is_nil_default(y) ? .5 : y;
		var _b = parseValue(x), min$2 = _b.min, max$2 = _b.max, median = _b.median, min1 = _b.min1, max1 = _b.max1;
		var minY = y - halfSize;
		var maxY$1 = y + halfSize;
		pointsArray = [
			[min$2, minY],
			[min$2, maxY$1],
			[min$2, y],
			[min1, y],
			[min1, minY],
			[min1, maxY$1],
			[max1, maxY$1],
			[max1, minY],
			[max1, y],
			[max$2, y],
			[max$2, minY],
			[max$2, maxY$1],
			[median, minY],
			[median, maxY$1]
		];
	}
	return pointsArray.map(function(arr) {
		return {
			x: arr[0],
			y: arr[1]
		};
	});
}
function getBoxPath(points) {
	return [
		[
			"M",
			points[0].x,
			points[0].y
		],
		[
			"L",
			points[1].x,
			points[1].y
		],
		[
			"M",
			points[2].x,
			points[2].y
		],
		[
			"L",
			points[3].x,
			points[3].y
		],
		[
			"M",
			points[4].x,
			points[4].y
		],
		[
			"L",
			points[5].x,
			points[5].y
		],
		[
			"L",
			points[6].x,
			points[6].y
		],
		[
			"L",
			points[7].x,
			points[7].y
		],
		[
			"L",
			points[4].x,
			points[4].y
		],
		["Z"],
		[
			"M",
			points[8].x,
			points[8].y
		],
		[
			"L",
			points[9].x,
			points[9].y
		],
		[
			"M",
			points[10].x,
			points[10].y
		],
		[
			"L",
			points[11].x,
			points[11].y
		],
		[
			"M",
			points[12].x,
			points[12].y
		],
		[
			"L",
			points[13].x,
			points[13].y
		]
	];
}
registerShape("schema", "box", {
	getPoints: function(shapePoint) {
		var x = shapePoint.x, y = shapePoint.y, size$1 = shapePoint.size;
		return getBoxPoints(x, y, size$1);
	},
	draw: function(cfg, container) {
		var style = getStyle(cfg, true, false);
		var path = this.parsePath(getBoxPath(cfg.points));
		return container.addShape("path", { attrs: __assign(__assign({}, style), {
			path,
			name: "schema"
		}) });
	},
	getMarker: function(markerCfg) {
		return {
			symbol: function(x, y, r) {
				var yValues = [
					y - 6,
					y - 3,
					y,
					y + 3,
					y + 6
				];
				var points = getBoxPoints(x, yValues, r);
				return [
					[
						"M",
						points[0].x + 1,
						points[0].y
					],
					[
						"L",
						points[1].x - 1,
						points[1].y
					],
					[
						"M",
						points[2].x,
						points[2].y
					],
					[
						"L",
						points[3].x,
						points[3].y
					],
					[
						"M",
						points[4].x,
						points[4].y
					],
					[
						"L",
						points[5].x,
						points[5].y
					],
					[
						"L",
						points[6].x,
						points[6].y
					],
					[
						"L",
						points[7].x,
						points[7].y
					],
					[
						"L",
						points[4].x,
						points[4].y
					],
					["Z"],
					[
						"M",
						points[8].x,
						points[8].y
					],
					[
						"L",
						points[9].x,
						points[9].y
					],
					[
						"M",
						points[10].x + 1,
						points[10].y
					],
					[
						"L",
						points[11].x - 1,
						points[11].y
					],
					[
						"M",
						points[12].x,
						points[12].y
					],
					[
						"L",
						points[13].x,
						points[13].y
					]
				];
			},
			style: {
				r: 6,
				lineWidth: 1,
				stroke: markerCfg.color
			}
		};
	}
});

//#endregion
//#region node_modules/@antv/g2/esm/geometry/shape/schema/candle.js
function getCandleYValues(value$1) {
	var sorted = (!is_array_default(value$1) ? [value$1] : value$1).sort(function(a, b) {
		return b - a;
	});
	return padEnd(sorted, 4, sorted[sorted.length - 1]);
}
function getCandlePoints(x, y, size$1) {
	var yValues = getCandleYValues(y);
	return [
		{
			x,
			y: yValues[0]
		},
		{
			x,
			y: yValues[1]
		},
		{
			x: x - size$1 / 2,
			y: yValues[2]
		},
		{
			x: x - size$1 / 2,
			y: yValues[1]
		},
		{
			x: x + size$1 / 2,
			y: yValues[1]
		},
		{
			x: x + size$1 / 2,
			y: yValues[2]
		},
		{
			x,
			y: yValues[2]
		},
		{
			x,
			y: yValues[3]
		}
	];
}
function getCandlePath(points) {
	return [
		[
			"M",
			points[0].x,
			points[0].y
		],
		[
			"L",
			points[1].x,
			points[1].y
		],
		[
			"M",
			points[2].x,
			points[2].y
		],
		[
			"L",
			points[3].x,
			points[3].y
		],
		[
			"L",
			points[4].x,
			points[4].y
		],
		[
			"L",
			points[5].x,
			points[5].y
		],
		["Z"],
		[
			"M",
			points[6].x,
			points[6].y
		],
		[
			"L",
			points[7].x,
			points[7].y
		]
	];
}
registerShape("schema", "candle", {
	getPoints: function(shapePoint) {
		var x = shapePoint.x, y = shapePoint.y, size$1 = shapePoint.size;
		return getCandlePoints(x, y, size$1);
	},
	draw: function(cfg, container) {
		var style = getStyle(cfg, true, true);
		var path = this.parsePath(getCandlePath(cfg.points));
		return container.addShape("path", { attrs: __assign(__assign({}, style), {
			path,
			name: "schema"
		}) });
	},
	getMarker: function(markerCfg) {
		var color$2 = markerCfg.color;
		return {
			symbol: function(x, y, r) {
				var yValues = [
					y + 7.5,
					y + 3,
					y - 3,
					y - 7.5
				];
				var points = getCandlePoints(x, yValues, r);
				return [
					[
						"M",
						points[0].x,
						points[0].y
					],
					[
						"L",
						points[1].x,
						points[1].y
					],
					[
						"M",
						points[2].x,
						points[2].y
					],
					[
						"L",
						points[3].x,
						points[3].y
					],
					[
						"L",
						points[4].x,
						points[4].y
					],
					[
						"L",
						points[5].x,
						points[5].y
					],
					["Z"],
					[
						"M",
						points[6].x,
						points[6].y
					],
					[
						"L",
						points[7].x,
						points[7].y
					]
				];
			},
			style: {
				lineWidth: 1,
				stroke: color$2,
				fill: color$2,
				r: 6
			}
		};
	}
});

//#endregion
//#region node_modules/@antv/g2/esm/geometry/shape/polygon/square.js
function getRectAttrs(points, size$1) {
	var width = Math.abs(points[0].x - points[2].x);
	var height = Math.abs(points[0].y - points[2].y);
	var len = Math.min(width, height);
	if (size$1) len = clamp_default(size$1, 0, Math.min(width, height));
	len = len / 2;
	var centerX = (points[0].x + points[2].x) / 2;
	var centerY = (points[0].y + points[2].y) / 2;
	return {
		x: centerX - len,
		y: centerY - len,
		width: len * 2,
		height: len * 2
	};
}
registerShape("polygon", "square", {
	draw: function(cfg, container) {
		if (!is_empty_default(cfg.points)) {
			var shapeAttrs = getStyle(cfg, true, true);
			var points = this.parsePoints(cfg.points);
			return container.addShape("rect", {
				attrs: __assign(__assign({}, shapeAttrs), getRectAttrs(points, cfg.size)),
				name: "polygon"
			});
		}
	},
	getMarker: function(markerCfg) {
		return {
			symbol: "square",
			style: {
				r: 4,
				fill: markerCfg.color
			}
		};
	}
});

//#endregion
//#region node_modules/@antv/g2/esm/geometry/shape/violin/smooth.js
/**
* 平滑边界的小提琴图
*/
registerShape("violin", "smooth", {
	draw: function(cfg, container) {
		var attrs = getStyle(cfg, true, true);
		var path = this.parsePath(getSmoothViolinPath(cfg.points));
		return container.addShape("path", { attrs: __assign(__assign({}, attrs), { path }) });
	},
	getMarker: function(markerCfg) {
		return {
			symbol: "circle",
			style: {
				stroke: null,
				r: 4,
				fill: markerCfg.color
			}
		};
	}
});

//#endregion
//#region node_modules/@antv/g2/esm/geometry/shape/violin/hollow.js
/**
* 空心小提琴图
*/
registerShape("violin", "hollow", {
	draw: function(cfg, container) {
		var attrs = getStyle(cfg, true, false);
		var path = this.parsePath(getViolinPath(cfg.points));
		return container.addShape("path", { attrs: __assign(__assign({}, attrs), { path }) });
	},
	getMarker: function(markerCfg) {
		return {
			symbol: "circle",
			style: {
				r: 4,
				fill: null,
				stroke: markerCfg.color
			}
		};
	}
});
/**
* 平滑边界的空心小提琴图
*/
registerShape("violin", "hollow-smooth", {
	draw: function(cfg, container) {
		var attrs = getStyle(cfg, true, false);
		var path = this.parsePath(getSmoothViolinPath(cfg.points));
		return container.addShape("path", { attrs: __assign(__assign({}, attrs), { path }) });
	},
	getMarker: function(markerCfg) {
		return {
			symbol: "circle",
			style: {
				r: 4,
				fill: null,
				stroke: markerCfg.color
			}
		};
	}
});

//#endregion
//#region node_modules/@antv/g2/esm/geometry/label/interval.js
/**
* 柱状图 label
*/
var IntervalLabel = function(_super) {
	__extends(IntervalLabel$1, _super);
	function IntervalLabel$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	/**
	* 获取 interval label 的方向，取决于 value 的值是正还是负
	* @param labelCfg
	*/
	IntervalLabel$1.prototype.getLabelValueDir = function(mappingData) {
		var dim = "y";
		var points = mappingData.points;
		return points[0][dim] <= points[2][dim] ? 1 : -1;
	};
	/**
	* 重载：根据 interval 值的正负来调整 label 偏移量
	* @param labelCfg
	* @param index
	* @param total
	*/
	IntervalLabel$1.prototype.getLabelOffsetPoint = function(labelCfg, index, total, position) {
		var _a$5;
		var point$1 = _super.prototype.getLabelOffsetPoint.call(this, labelCfg, index, total);
		var coordinate$10 = this.getCoordinate();
		var dim = coordinate$10.isTransposed ? "x" : "y";
		var dir = this.getLabelValueDir(labelCfg.mappingData);
		point$1 = __assign(__assign({}, point$1), (_a$5 = {}, _a$5[dim] = point$1[dim] * dir, _a$5));
		if (coordinate$10.isReflect("x")) point$1 = __assign(__assign({}, point$1), { x: point$1.x * -1 });
		if (coordinate$10.isReflect("y")) point$1 = __assign(__assign({}, point$1), { y: point$1.y * -1 });
		return point$1;
	};
	/**
	* 重载：定制 interval label 的默认主题配置
	* @param labelCfg
	*/
	IntervalLabel$1.prototype.getThemedLabelCfg = function(labelCfg) {
		var geometry$34 = this.geometry;
		var defaultLabelCfg = this.getDefaultLabelCfg();
		var theme$3 = geometry$34.theme;
		return deep_mix_default({}, defaultLabelCfg, theme$3.labels, labelCfg.position === "middle" ? { offset: 0 } : {}, labelCfg);
	};
	IntervalLabel$1.prototype.setLabelPosition = function(labelPointCfg, mappingData, index, position) {
		var coordinate$10 = this.getCoordinate();
		var transposed = coordinate$10.isTransposed;
		var shapePoints = mappingData.points;
		var point0 = coordinate$10.convert(shapePoints[0]);
		var point2 = coordinate$10.convert(shapePoints[2]);
		var dir = this.getLabelValueDir(mappingData);
		var top;
		var right$1;
		var bottom;
		var left$1;
		var shape = is_array_default(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;
		if (shape === "funnel" || shape === "pyramid") {
			var nextPoints = get_default(mappingData, "nextPoints");
			var points = get_default(mappingData, "points");
			if (nextPoints) {
				var p0 = coordinate$10.convert(points[0]);
				var p1 = coordinate$10.convert(points[1]);
				var nextP0 = coordinate$10.convert(nextPoints[0]);
				var nextP1 = coordinate$10.convert(nextPoints[1]);
				if (transposed) {
					top = Math.min(nextP0.y, p0.y);
					bottom = Math.max(nextP0.y, p0.y);
					right$1 = (p1.x + nextP1.x) / 2;
					left$1 = (p0.x + nextP0.x) / 2;
				} else {
					top = Math.min((p1.y + nextP1.y) / 2, (p0.y + nextP0.y) / 2);
					bottom = Math.max((p1.y + nextP1.y) / 2, (p0.y + nextP0.y) / 2);
					right$1 = nextP1.x;
					left$1 = p0.x;
				}
			} else {
				top = Math.min(point2.y, point0.y);
				bottom = Math.max(point2.y, point0.y);
				right$1 = point2.x;
				left$1 = point0.x;
			}
		} else {
			top = Math.min(point2.y, point0.y);
			bottom = Math.max(point2.y, point0.y);
			right$1 = point2.x;
			left$1 = point0.x;
		}
		switch (position) {
			case "right":
				labelPointCfg.x = right$1;
				labelPointCfg.y = (top + bottom) / 2;
				labelPointCfg.textAlign = get_default(labelPointCfg, "textAlign", dir > 0 ? "left" : "right");
				break;
			case "left":
				labelPointCfg.x = left$1;
				labelPointCfg.y = (top + bottom) / 2;
				labelPointCfg.textAlign = get_default(labelPointCfg, "textAlign", dir > 0 ? "left" : "right");
				break;
			case "bottom":
				if (transposed) labelPointCfg.x = (right$1 + left$1) / 2;
				labelPointCfg.y = bottom;
				labelPointCfg.textAlign = get_default(labelPointCfg, "textAlign", "center");
				labelPointCfg.textBaseline = get_default(labelPointCfg, "textBaseline", dir > 0 ? "bottom" : "top");
				break;
			case "middle":
				if (transposed) labelPointCfg.x = (right$1 + left$1) / 2;
				labelPointCfg.y = (top + bottom) / 2;
				labelPointCfg.textAlign = get_default(labelPointCfg, "textAlign", "center");
				labelPointCfg.textBaseline = get_default(labelPointCfg, "textBaseline", "middle");
				break;
			case "top":
				if (transposed) labelPointCfg.x = (right$1 + left$1) / 2;
				labelPointCfg.y = top;
				labelPointCfg.textAlign = get_default(labelPointCfg, "textAlign", "center");
				labelPointCfg.textBaseline = get_default(labelPointCfg, "textBaseline", dir > 0 ? "bottom" : "top");
				break;
			default: break;
		}
	};
	return IntervalLabel$1;
}(base_default);
var interval_default$1 = IntervalLabel;

//#endregion
//#region node_modules/@antv/g2/esm/geometry/label/polar.js
var HALF_PI = Math.PI / 2;
/**
* 极坐标下的图形 label
*/
var PolarLabel = function(_super) {
	__extends(PolarLabel$1, _super);
	function PolarLabel$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	/**
	* @override
	* @desc 获取 label offset
	* polar & theta coordinate support「string」type, should transform to 「number」
	*/
	PolarLabel$1.prototype.getLabelOffset = function(offset) {
		var coordinate$10 = this.getCoordinate();
		var actualOffset = 0;
		if (is_number_default(offset)) actualOffset = offset;
		else if (is_string_default(offset) && offset.indexOf("%") !== -1) {
			var r = coordinate$10.getRadius();
			if (coordinate$10.innerRadius > 0) r = r * (1 - coordinate$10.innerRadius);
			actualOffset = parseFloat(offset) * .01 * r;
		}
		return actualOffset;
	};
	/**
	* @override
	* 获取 labelItems, 增加切片 percent
	* @param mapppingArray
	*/
	PolarLabel$1.prototype.getLabelItems = function(mapppingArray) {
		var items = _super.prototype.getLabelItems.call(this, mapppingArray);
		var yScale = this.geometry.getYScale();
		return map_default(items, function(item) {
			if (item && yScale) {
				var percent$1 = yScale.scale(get_default(item.data, yScale.field));
				return __assign(__assign({}, item), { percent: percent$1 });
			}
			return item;
		});
	};
	/**
	* @override
	* 获取文本的对齐方式
	* @param point
	*/
	PolarLabel$1.prototype.getLabelAlign = function(point$1) {
		var coordinate$10 = this.getCoordinate();
		var align;
		if (point$1.labelEmit) align = point$1.angle <= Math.PI / 2 && point$1.angle >= -Math.PI / 2 ? "left" : "right";
		else if (!coordinate$10.isTransposed) align = "center";
		else {
			var center$1 = coordinate$10.getCenter();
			var offset = point$1.offset;
			if (Math.abs(point$1.x - center$1.x) < 1) align = "center";
			else if (point$1.angle > Math.PI || point$1.angle <= 0) align = offset > 0 ? "left" : "right";
			else align = offset > 0 ? "right" : "left";
		}
		return align;
	};
	/**
	* @override
	* 获取 label 的位置
	* @param labelCfg
	* @param mappingData
	* @param index
	*/
	PolarLabel$1.prototype.getLabelPoint = function(labelCfg, mappingData, index) {
		var factor = 1;
		var arcPoint;
		var content = labelCfg.content[index];
		if (this.isToMiddle(mappingData)) arcPoint = this.getMiddlePoint(mappingData.points);
		else {
			if (labelCfg.content.length === 1 && index === 0) index = 1;
			else if (index === 0) factor = -1;
			arcPoint = this.getArcPoint(mappingData, index);
		}
		var offset = labelCfg.offset * factor;
		var middleAngle = this.getPointAngle(arcPoint);
		var isLabelEmit = labelCfg.labelEmit;
		var labelPositionCfg = this.getCirclePoint(middleAngle, offset, arcPoint, isLabelEmit);
		if (labelPositionCfg.r === 0) labelPositionCfg.content = "";
		else {
			labelPositionCfg.content = content;
			labelPositionCfg.angle = middleAngle;
			labelPositionCfg.color = mappingData.color;
		}
		labelPositionCfg.rotate = labelCfg.autoRotate ? this.getLabelRotate(middleAngle, offset, isLabelEmit) : labelCfg.rotate;
		labelPositionCfg.start = {
			x: arcPoint.x,
			y: arcPoint.y
		};
		return labelPositionCfg;
	};
	/**
	* 获取圆弧的位置
	*/
	PolarLabel$1.prototype.getArcPoint = function(mappingData, index) {
		if (index === void 0) index = 0;
		if (!is_array_default(mappingData.x) && !is_array_default(mappingData.y)) return {
			x: mappingData.x,
			y: mappingData.y
		};
		return {
			x: is_array_default(mappingData.x) ? mappingData.x[index] : mappingData.x,
			y: is_array_default(mappingData.y) ? mappingData.y[index] : mappingData.y
		};
	};
	/**
	* 计算坐标线点在极坐标系下角度
	* @param point
	*/
	PolarLabel$1.prototype.getPointAngle = function(point$1) {
		return getAngleByPoint(this.getCoordinate(), point$1);
	};
	/**
	* 获取坐标点与圆心形成的圆的位置信息
	* @param angle
	* @param offset
	* @param point
	* @param isLabelEmit
	*/
	PolarLabel$1.prototype.getCirclePoint = function(angle$1, offset, point$1, isLabelEmit) {
		var coordinate$10 = this.getCoordinate();
		var center$1 = coordinate$10.getCenter();
		var r = getDistanceToCenter(coordinate$10, point$1);
		if (r === 0) return __assign(__assign({}, center$1), { r });
		var labelAngle = angle$1;
		if (coordinate$10.isTransposed && r > offset && !isLabelEmit) {
			var appendAngle = Math.asin(offset / (2 * r));
			labelAngle = angle$1 + appendAngle * 2;
		} else r = r + offset;
		return {
			x: center$1.x + r * Math.cos(labelAngle),
			y: center$1.y + r * Math.sin(labelAngle),
			r
		};
	};
	/**
	* 获取 label 的旋转角度
	* @param angle
	* @param offset
	* @param isLabelEmit
	*/
	PolarLabel$1.prototype.getLabelRotate = function(angle$1, offset, isLabelEmit) {
		var rotate$2 = angle$1 + HALF_PI;
		if (isLabelEmit) rotate$2 -= HALF_PI;
		if (rotate$2) {
			if (rotate$2 > HALF_PI) rotate$2 = rotate$2 - Math.PI;
			else if (rotate$2 < -HALF_PI) rotate$2 = rotate$2 + Math.PI;
		}
		return rotate$2;
	};
	PolarLabel$1.prototype.getMiddlePoint = function(points) {
		var coordinate$10 = this.getCoordinate();
		var count$1 = points.length;
		var middlePoint = {
			x: 0,
			y: 0
		};
		each_default(points, function(point$1) {
			middlePoint.x += point$1.x;
			middlePoint.y += point$1.y;
		});
		middlePoint.x /= count$1;
		middlePoint.y /= count$1;
		middlePoint = coordinate$10.convert(middlePoint);
		return middlePoint;
	};
	PolarLabel$1.prototype.isToMiddle = function(mappingData) {
		return mappingData.x.length > 2;
	};
	return PolarLabel$1;
}(base_default);
var polar_default = PolarLabel;

//#endregion
//#region node_modules/@antv/g2/esm/geometry/label/pie.js
/**
* 饼图 label
*/
var PieLabel = function(_super) {
	__extends(PieLabel$1, _super);
	function PieLabel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.defaultLayout = "distribute";
		return _this;
	}
	PieLabel$1.prototype.getDefaultLabelCfg = function(offset, position) {
		var cfg = _super.prototype.getDefaultLabelCfg.call(this, offset, position);
		return deep_mix_default({}, cfg, get_default(this.geometry.theme, "pieLabels", {}));
	};
	/** @override */
	PieLabel$1.prototype.getLabelOffset = function(offset) {
		return _super.prototype.getLabelOffset.call(this, offset) || 0;
	};
	PieLabel$1.prototype.getLabelRotate = function(angle$1, offset, isLabelLimit) {
		var rotate$2;
		if (offset < 0) {
			rotate$2 = angle$1;
			if (rotate$2 > Math.PI / 2) rotate$2 = rotate$2 - Math.PI;
			if (rotate$2 < -Math.PI / 2) rotate$2 = rotate$2 + Math.PI;
		}
		return rotate$2;
	};
	PieLabel$1.prototype.getLabelAlign = function(point$1) {
		var center$1 = this.getCoordinate().getCenter();
		var align;
		if (point$1.angle <= Math.PI / 2 && point$1.x >= center$1.x) align = "left";
		else align = "right";
		if (point$1.offset <= 0) if (align === "right") align = "left";
		else align = "right";
		return align;
	};
	PieLabel$1.prototype.getArcPoint = function(point$1) {
		return point$1;
	};
	PieLabel$1.prototype.getPointAngle = function(point$1) {
		var coordinate$10 = this.getCoordinate();
		var startPoint = {
			x: is_array_default(point$1.x) ? point$1.x[0] : point$1.x,
			y: point$1.y[0]
		};
		var endPoint = {
			x: is_array_default(point$1.x) ? point$1.x[1] : point$1.x,
			y: point$1.y[1]
		};
		var angle$1;
		var startAngle = getAngleByPoint(coordinate$10, startPoint);
		if (point$1.points && point$1.points[0].y === point$1.points[1].y) angle$1 = startAngle;
		else {
			var endAngle = getAngleByPoint(coordinate$10, endPoint);
			if (startAngle >= endAngle) endAngle = endAngle + Math.PI * 2;
			angle$1 = startAngle + (endAngle - startAngle) / 2;
		}
		return angle$1;
	};
	/** @override */
	PieLabel$1.prototype.getCirclePoint = function(angle$1, offset) {
		var coordinate$10 = this.getCoordinate();
		var center$1 = coordinate$10.getCenter();
		var r = coordinate$10.getRadius() + offset;
		return __assign(__assign({}, polarToCartesian(center$1.x, center$1.y, r, angle$1)), {
			angle: angle$1,
			r
		});
	};
	return PieLabel$1;
}(polar_default);
var pie_default = PieLabel;

//#endregion
//#region node_modules/@antv/g2/esm/geometry/label/layout/pie/distribute.js
/** label text和line距离 4px */
var MARGIN$1 = 4;
function antiCollision$1(labelShapes, labels, lineHeight, plotRange, center$1, isRight) {
	var e_1, _a$5;
	var overlapping = true;
	var start = plotRange.start;
	var end = plotRange.end;
	var startY = Math.min(start.y, end.y);
	var totalHeight = Math.abs(start.y - end.y);
	var i;
	var maxY$1 = 0;
	var minY = Number.MIN_VALUE;
	var boxes = labels.map(function(label$16) {
		if (label$16.y > maxY$1) maxY$1 = label$16.y;
		if (label$16.y < minY) minY = label$16.y;
		return {
			size: lineHeight,
			targets: [label$16.y - startY]
		};
	});
	minY -= startY;
	if (maxY$1 - startY > totalHeight) totalHeight = maxY$1 - startY;
	while (overlapping) {
		boxes.forEach(function(box$2) {
			var target = (Math.min.apply(minY, box$2.targets) + Math.max.apply(minY, box$2.targets)) / 2;
			box$2.pos = Math.min(Math.max(minY, target - box$2.size / 2), totalHeight - box$2.size);
		});
		overlapping = false;
		i = boxes.length;
		while (i--) if (i > 0) {
			var previousBox = boxes[i - 1];
			var box$1 = boxes[i];
			if (previousBox.pos + previousBox.size > box$1.pos) {
				previousBox.size += box$1.size;
				previousBox.targets = previousBox.targets.concat(box$1.targets);
				if (previousBox.pos + previousBox.size > totalHeight) previousBox.pos = totalHeight - previousBox.size;
				boxes.splice(i, 1);
				overlapping = true;
			}
		}
	}
	i = 0;
	boxes.forEach(function(b) {
		var posInCompositeBox = startY + lineHeight / 2;
		b.targets.forEach(function() {
			labels[i].y = b.pos + posInCompositeBox;
			posInCompositeBox += lineHeight;
			i++;
		});
	});
	var labelsMap = {};
	try {
		for (var labelShapes_1 = __values(labelShapes), labelShapes_1_1 = labelShapes_1.next(); !labelShapes_1_1.done; labelShapes_1_1 = labelShapes_1.next()) {
			var labelShape = labelShapes_1_1.value;
			labelsMap[labelShape.get("id")] = labelShape;
		}
	} catch (e_1_1) {
		e_1 = { error: e_1_1 };
	} finally {
		try {
			if (labelShapes_1_1 && !labelShapes_1_1.done && (_a$5 = labelShapes_1.return)) _a$5.call(labelShapes_1);
		} finally {
			if (e_1) throw e_1.error;
		}
	}
	labels.forEach(function(label$16) {
		var rPow2 = label$16.r * label$16.r;
		var dyPow2 = Math.pow(Math.abs(label$16.y - center$1.y), 2);
		if (rPow2 < dyPow2) label$16.x = center$1.x;
		else {
			var dx = Math.sqrt(rPow2 - dyPow2);
			if (!isRight) label$16.x = center$1.x - dx;
			else label$16.x = center$1.x + dx;
		}
		var labelShape$1 = labelsMap[label$16.id];
		labelShape$1.attr("x", label$16.x);
		labelShape$1.attr("y", label$16.y);
		var textShape = find_default(labelShape$1.getChildren(), function(ele) {
			return ele.get("type") === "text";
		});
		if (textShape) {
			textShape.attr("y", label$16.y);
			textShape.attr("x", label$16.x);
		}
	});
}
function distribute(items, labels, shapes, region) {
	if (!items.length || !labels.length) return;
	var offset = items[0] ? items[0].offset : 0;
	var coordinate$10 = labels[0].get("coordinate");
	var radius = coordinate$10.getRadius();
	var center$1 = coordinate$10.getCenter();
	if (offset > 0) {
		var lineHeight_1 = 14;
		var totalHeight_1 = (radius + offset) * 2 + lineHeight_1 * 2;
		var plotRange_1 = {
			start: coordinate$10.start,
			end: coordinate$10.end
		};
		var halves_1 = [[], []];
		items.forEach(function(labelItem) {
			if (!labelItem) return;
			if (labelItem.textAlign === "right") halves_1[0].push(labelItem);
			else halves_1[1].push(labelItem);
		});
		halves_1.forEach(function(half, index) {
			var maxLabelsCountForOneSide = totalHeight_1 / lineHeight_1;
			if (half.length > maxLabelsCountForOneSide) {
				half.sort(function(a, b) {
					return b["..percent"] - a["..percent"];
				});
				half.splice(maxLabelsCountForOneSide, half.length - maxLabelsCountForOneSide);
			}
			half.sort(function(a, b) {
				return a.y - b.y;
			});
			antiCollision$1(labels, half, lineHeight_1, plotRange_1, center$1, index);
		});
	}
	each_default(items, function(item) {
		if (item && item.labelLine) {
			var distance$7 = item.offset;
			var angle$1 = item.angle;
			var startPoint = polarToCartesian(center$1.x, center$1.y, radius, angle$1);
			var innerPoint = polarToCartesian(center$1.x, center$1.y, radius + distance$7 / 2, angle$1);
			var itemX = item.x + get_default(item, "offsetX", 0);
			var itemY = item.y + get_default(item, "offsetY", 0);
			var endPoint = {
				x: itemX - Math.cos(angle$1) * MARGIN$1,
				y: itemY - Math.sin(angle$1) * MARGIN$1
			};
			if (!is_object_default(item.labelLine)) item.labelLine = {};
			item.labelLine.path = [
				"M ".concat(startPoint.x),
				"".concat(startPoint.y, " Q").concat(innerPoint.x),
				"".concat(innerPoint.y, " ").concat(endPoint.x),
				endPoint.y
			].join(",");
		}
	});
}

//#endregion
//#region node_modules/@antv/g2/esm/geometry/label/layout/pie/util.js
/**
* 碰撞检测算法
*/
function antiCollision(items, labelHeight, plotRange) {
	var labels = items.filter(function(item) {
		return !item.invisible;
	});
	labels.sort(function(a, b) {
		return a.y - b.y;
	});
	var overlapping = true;
	var startY = plotRange.minY;
	var endY = plotRange.maxY;
	var totalHeight = Math.abs(startY - endY);
	var i;
	var maxY$1 = 0;
	var minY = Number.MIN_VALUE;
	var boxes = labels.map(function(label$16) {
		if (label$16.y > maxY$1) maxY$1 = label$16.y;
		if (label$16.y < minY) minY = label$16.y;
		return {
			content: label$16.content,
			size: labelHeight,
			targets: [label$16.y - startY],
			pos: null
		};
	});
	minY -= startY;
	if (maxY$1 - startY > totalHeight) totalHeight = maxY$1 - startY;
	while (overlapping) {
		boxes.forEach(function(box$2) {
			var target = (Math.min.apply(minY, box$2.targets) + Math.max.apply(minY, box$2.targets)) / 2;
			box$2.pos = Math.min(Math.max(minY, target - box$2.size / 2), totalHeight - box$2.size);
			box$2.pos = Math.max(0, box$2.pos);
		});
		overlapping = false;
		i = boxes.length;
		while (i--) if (i > 0) {
			var previousBox = boxes[i - 1];
			var box$1 = boxes[i];
			if (previousBox.pos + previousBox.size > box$1.pos) {
				previousBox.size += box$1.size;
				previousBox.targets = previousBox.targets.concat(box$1.targets);
				if (previousBox.pos + previousBox.size > totalHeight) previousBox.pos = totalHeight - previousBox.size;
				boxes.splice(i, 1);
				overlapping = true;
			}
		}
	}
	i = 0;
	boxes.forEach(function(b) {
		var posInCompositeBox = startY + labelHeight / 2;
		b.targets.forEach(function() {
			labels[i].y = b.pos + posInCompositeBox;
			posInCompositeBox += labelHeight;
			i++;
		});
	});
}

//#endregion
//#region node_modules/@antv/g2/esm/geometry/label/layout/pie/outer.js
/** label text和line距离 4px */
var MARGIN = 4;
/**
* 配置 labelline
* @param item PolarLabelItem
*/
function drawLabelline$1(item, coordinate$10) {
	/** 坐标圆心 */
	var center$1 = coordinate$10.getCenter();
	/** 圆半径 */
	var radius = coordinate$10.getRadius();
	if (item && item.labelLine) {
		var angle$1 = item.angle, labelOffset = item.offset;
		var startPoint = polarToCartesian(center$1.x, center$1.y, radius, angle$1);
		var itemX = item.x + get_default(item, "offsetX", 0) * (Math.cos(angle$1) > 0 ? 1 : -1);
		var itemY = item.y + get_default(item, "offsetY", 0) * (Math.sin(angle$1) > 0 ? 1 : -1);
		var endPoint = {
			x: itemX - Math.cos(angle$1) * MARGIN,
			y: itemY - Math.sin(angle$1) * MARGIN
		};
		var smoothConnector = item.labelLine.smooth;
		var path = [];
		var dx = endPoint.x - center$1.x;
		var dy = endPoint.y - center$1.y;
		var endAngle = Math.atan(dy / dx);
		if (dx < 0) endAngle += Math.PI;
		if (smoothConnector === false) {
			if (!is_object_default(item.labelLine)) item.labelLine = {};
			var sweepFlag = 0;
			if (angle$1 < 0 && angle$1 > -Math.PI / 2 || angle$1 > Math.PI * 1.5) {
				if (endPoint.y > startPoint.y) sweepFlag = 1;
			}
			if (angle$1 >= 0 && angle$1 < Math.PI / 2) {
				if (endPoint.y > startPoint.y) sweepFlag = 1;
			}
			if (angle$1 >= Math.PI / 2 && angle$1 < Math.PI) {
				if (startPoint.y > endPoint.y) sweepFlag = 1;
			}
			if (angle$1 < -Math.PI / 2 || angle$1 >= Math.PI && angle$1 < Math.PI * 1.5) {
				if (startPoint.y > endPoint.y) sweepFlag = 1;
			}
			var distance$7 = labelOffset / 2 > 4 ? 4 : Math.max(labelOffset / 2 - 1, 0);
			var breakPoint = polarToCartesian(center$1.x, center$1.y, radius + distance$7, angle$1);
			var breakPoint3 = polarToCartesian(center$1.x, center$1.y, radius + labelOffset / 2, endAngle);
			/**
			* @example
			* M 100 100 L100 90 A 50 50 0 0 0 150 50
			* 移动至 (100, 100), 连接到 (100, 90), 以 (50, 50) 为圆心，绘制圆弧至 (150, 50);
			* A 命令的第 4 个参数 large-arc-flag, 决定弧线是大于还是小于 180 度: 0 表示小角度弧，1 表示大角
			* 第 5 个参数: 是否顺时针绘制
			*/
			var largeArcFlag = 0;
			path.push("M ".concat(startPoint.x, " ").concat(startPoint.y));
			path.push("L ".concat(breakPoint.x, " ").concat(breakPoint.y));
			path.push("A ".concat(center$1.x, " ").concat(center$1.y, " 0 ").concat(largeArcFlag, " ").concat(sweepFlag, " ").concat(breakPoint3.x, " ").concat(breakPoint3.y));
			path.push("L ".concat(endPoint.x, " ").concat(endPoint.y));
		} else {
			var breakPoint = polarToCartesian(center$1.x, center$1.y, radius + (labelOffset / 2 > 4 ? 4 : Math.max(labelOffset / 2 - 1, 0)), angle$1);
			var xSign = startPoint.x < center$1.x ? 1 : -1;
			path.push("M ".concat(endPoint.x, " ").concat(endPoint.y));
			var slope1 = (startPoint.y - center$1.y) / (startPoint.x - center$1.x);
			var slope2 = (endPoint.y - center$1.y) / (endPoint.x - center$1.x);
			if (Math.abs(slope1 - slope2) > Math.pow(Math.E, -16)) path.push.apply(path, [
				"C",
				endPoint.x + xSign * 4,
				endPoint.y,
				2 * breakPoint.x - startPoint.x,
				2 * breakPoint.y - startPoint.y,
				startPoint.x,
				startPoint.y
			]);
			path.push("L ".concat(startPoint.x, " ").concat(startPoint.y));
		}
		item.labelLine.path = path.join(" ");
	}
}
/**
* 饼图 outer-label 布局, 适用于 type = pie 且 label offset > 0 的标签
*/
function pieOuterLabelLayout(originalItems, labels, shapes, region) {
	var e_1, _a$5;
	var items = filter_default(originalItems, function(item) {
		return !is_nil_default(item);
	});
	/** 坐标系 */
	var coordinate$10 = labels[0] && labels[0].get("coordinate");
	if (!coordinate$10) return;
	/** 坐标圆心 */
	var center$1 = coordinate$10.getCenter();
	/** 圆半径 */
	var radius = coordinate$10.getRadius();
	/** label shapes */
	var labelsMap = {};
	try {
		for (var labels_1 = __values(labels), labels_1_1 = labels_1.next(); !labels_1_1.done; labels_1_1 = labels_1.next()) {
			var labelShape = labels_1_1.value;
			labelsMap[labelShape.get("id")] = labelShape;
		}
	} catch (e_1_1) {
		e_1 = { error: e_1_1 };
	} finally {
		try {
			if (labels_1_1 && !labels_1_1.done && (_a$5 = labels_1.return)) _a$5.call(labels_1);
		} finally {
			if (e_1) throw e_1.error;
		}
	}
	var labelHeight = get_default(items[0], "labelHeight", 14);
	var labelOffset = get_default(items[0], "offset", 0);
	if (labelOffset <= 0) return;
	var LEFT_HALF_KEY = "left";
	var RIGHT_HALF_KEY = "right";
	var separateLabels = group_by_default(items, function(item) {
		return item.x < center$1.x ? LEFT_HALF_KEY : RIGHT_HALF_KEY;
	});
	var start = coordinate$10.start, end = coordinate$10.end;
	var totalHeight = Math.min((radius + labelOffset + labelHeight) * 2, coordinate$10.getHeight());
	var totalR = totalHeight / 2;
	/** labels 容器的范围(后续根据组件的布局设计进行调整) */
	var labelsContainerRange = {
		minX: start.x,
		maxX: end.x,
		minY: center$1.y - totalR,
		maxY: center$1.y + totalR
	};
	each_default(separateLabels, function(half, key) {
		var maxLabelsCountForOneSide = Math.floor(totalHeight / labelHeight);
		if (half.length > maxLabelsCountForOneSide) {
			half.sort(function(a, b) {
				return b.percent - a.percent;
			});
			each_default(half, function(labelItem, idx) {
				if (idx + 1 > maxLabelsCountForOneSide) {
					labelsMap[labelItem.id].set("visible", false);
					labelItem.invisible = true;
				}
			});
		}
		antiCollision(half, labelHeight, labelsContainerRange);
	});
	each_default(separateLabels, function(half, key) {
		each_default(half, function(item) {
			var isRight = key === RIGHT_HALF_KEY;
			var content = labelsMap[item.id].getChildByIndex(0);
			if (content) {
				var r = radius + labelOffset;
				var dy = item.y - center$1.y;
				var rPow2 = Math.pow(r, 2);
				var dyPow2 = Math.pow(dy, 2);
				var dxPow2 = rPow2 - dyPow2 > 0 ? rPow2 - dyPow2 : 0;
				var dx = Math.sqrt(dxPow2);
				var dx_offset = Math.abs(Math.cos(item.angle) * r);
				if (!isRight) item.x = center$1.x - Math.max(dx, dx_offset);
				else item.x = center$1.x + Math.max(dx, dx_offset);
			}
			if (content) {
				content.attr("y", item.y);
				content.attr("x", item.x);
			}
			drawLabelline$1(item, coordinate$10);
		});
	});
}

//#endregion
//#region node_modules/@antv/g2/esm/geometry/label/layout/pie/spider.js
/** 拐点偏移量, 暂不可配置 */
var INFLECTION_OFFSET = 4;
/** 标签偏移量, distance between label and edge: offsetX */
var LABEL_OFFSET_X = 4;
/** 标签与牵引线的偏移量 */
var LABEL_TEXT_LINE_OFFSET = 4;
function drawLabelline(item, coordinate$10, inRight) {
	/** 坐标圆心 */
	var center$1 = coordinate$10.getCenter();
	/** 圆半径 */
	var radius = coordinate$10.getRadius();
	var startPoint = {
		x: item.x - (inRight ? LABEL_TEXT_LINE_OFFSET : -LABEL_TEXT_LINE_OFFSET),
		y: item.y
	};
	var inflectionPoint = polarToCartesian(center$1.x, center$1.y, radius + INFLECTION_OFFSET, item.angle);
	var p1 = {
		x: startPoint.x,
		y: startPoint.y
	};
	var p2 = {
		x: inflectionPoint.x,
		y: inflectionPoint.y
	};
	var endPoint = polarToCartesian(center$1.x, center$1.y, radius, item.angle);
	var path = "";
	if (startPoint.y !== inflectionPoint.y) {
		var offset = inRight ? 4 : -4;
		p1.y = startPoint.y;
		/** 是否在第一象限 */
		if (item.angle < 0 && item.angle >= -Math.PI / 2) {
			p1.x = Math.max(inflectionPoint.x, startPoint.x - offset);
			if (startPoint.y < inflectionPoint.y) p2.y = p1.y;
			else {
				p2.y = inflectionPoint.y;
				p2.x = Math.max(p2.x, p1.x - offset);
			}
		}
		/** 是否在 第二象限 */
		if (item.angle > 0 && item.angle < Math.PI / 2) {
			p1.x = Math.max(inflectionPoint.x, startPoint.x - offset);
			if (startPoint.y > inflectionPoint.y) p2.y = p1.y;
			else {
				p2.y = inflectionPoint.y;
				p2.x = Math.max(p2.x, p1.x - offset);
			}
		}
		/** 是否在 第三象限 */
		if (item.angle > Math.PI / 2) {
			p1.x = Math.min(inflectionPoint.x, startPoint.x - offset);
			if (startPoint.y > inflectionPoint.y) p2.y = p1.y;
			else {
				p2.y = inflectionPoint.y;
				p2.x = Math.min(p2.x, p1.x - offset);
			}
		}
		/** 是否在 第四象限 */
		if (item.angle < -Math.PI / 2) {
			p1.x = Math.min(inflectionPoint.x, startPoint.x - offset);
			if (startPoint.y < inflectionPoint.y) p2.y = p1.y;
			else {
				p2.y = inflectionPoint.y;
				p2.x = Math.min(p2.x, p1.x - offset);
			}
		}
	}
	path = [
		"M ".concat(startPoint.x, ",").concat(startPoint.y),
		"L ".concat(p1.x, ",").concat(p1.y),
		"L ".concat(p2.x, ",").concat(p2.y),
		"L ".concat(inflectionPoint.x, ",").concat(inflectionPoint.y),
		"L ".concat(endPoint.x, ",").concat(endPoint.y)
	].join(" ");
	item.labelLine = deep_mix_default({}, item.labelLine, { path });
}
/**
* 饼图标签 spider 布局, 只适用于 pie-spider 的标签类型
* region 应该是 labelsRenderer 容器的范围限制(便于后续组件间布局)
*/
function pieSpiderLabelLayout(items, labels, shapes, region) {
	var e_1, _a$5;
	/** 坐标系 */
	var coordinate$10 = labels[0] && labels[0].get("coordinate");
	if (!coordinate$10) return;
	/** 坐标圆心 */
	var center$1 = coordinate$10.getCenter();
	/** 圆半径 */
	var radius = coordinate$10.getRadius();
	/** label shapes */
	var labelsMap = {};
	try {
		for (var labels_1 = __values(labels), labels_1_1 = labels_1.next(); !labels_1_1.done; labels_1_1 = labels_1.next()) {
			var labelShape = labels_1_1.value;
			labelsMap[labelShape.get("id")] = labelShape;
		}
	} catch (e_1_1) {
		e_1 = { error: e_1_1 };
	} finally {
		try {
			if (labels_1_1 && !labels_1_1.done && (_a$5 = labels_1.return)) _a$5.call(labels_1);
		} finally {
			if (e_1) throw e_1.error;
		}
	}
	var labelHeight = get_default(items[0], "labelHeight", 14);
	var labelOffset = Math.max(get_default(items[0], "offset", 0), INFLECTION_OFFSET);
	each_default(items, function(item) {
		if (!item) return;
		if (!get_default(labelsMap, [item.id])) return;
		var inRight = item.x > center$1.x || item.x === center$1.x && item.y > center$1.y;
		var offsetX = !is_nil_default(item.offsetX) ? item.offsetX : LABEL_OFFSET_X;
		var inflectionPoint = polarToCartesian(center$1.x, center$1.y, radius + INFLECTION_OFFSET, item.angle);
		var totalOffset = labelOffset + offsetX;
		item.x = center$1.x + (inRight ? 1 : -1) * (radius + totalOffset);
		item.y = inflectionPoint.y;
	});
	var start = coordinate$10.start, end = coordinate$10.end;
	var LEFT_HALF_KEY = "left";
	var RIGHT_HALF_KEY = "right";
	var separateLabels = group_by_default(items, function(item) {
		return item.x < center$1.x ? LEFT_HALF_KEY : RIGHT_HALF_KEY;
	});
	var totalHeight = (radius + labelOffset) * 2 + labelHeight;
	each_default(separateLabels, function(half) {
		var halfHeight = half.length * labelHeight;
		if (halfHeight > totalHeight) totalHeight = Math.min(halfHeight, Math.abs(start.y - end.y));
	});
	/** labels 容器的范围(后续根据组件的布局设计进行调整) */
	var labelsContainerRange = {
		minX: start.x,
		maxX: end.x,
		minY: center$1.y - totalHeight / 2,
		maxY: center$1.y + totalHeight / 2
	};
	each_default(separateLabels, function(half, key) {
		var maxLabelsCountForOneSide = totalHeight / labelHeight;
		if (half.length > maxLabelsCountForOneSide) {
			half.sort(function(a, b) {
				return b.percent - a.percent;
			});
			each_default(half, function(labelItem, idx) {
				if (idx > maxLabelsCountForOneSide) {
					labelsMap[labelItem.id].set("visible", false);
					labelItem.invisible = true;
				}
			});
		}
		antiCollision(half, labelHeight, labelsContainerRange);
	});
	var startY = labelsContainerRange.minY;
	var endY = labelsContainerRange.maxY;
	each_default(separateLabels, function(half, key) {
		var inRight = key === RIGHT_HALF_KEY;
		each_default(half, function(item) {
			var label$16 = get_default(labelsMap, item && [item.id]);
			if (!label$16) return;
			if (item.y < startY || item.y > endY) {
				label$16.set("visible", false);
				return;
			}
			var labelContent = label$16.getChildByIndex(0);
			var box$1 = labelContent.getCanvasBBox();
			var originalPos = {
				x: inRight ? box$1.x : box$1.maxX,
				y: box$1.y + box$1.height / 2
			};
			translate(labelContent, item.x - originalPos.x, item.y - originalPos.y);
			if (item.labelLine) drawLabelline(item, coordinate$10, inRight);
		});
	});
}

//#endregion
//#region node_modules/@antv/g2/esm/geometry/label/layout/limit-in-canvas.js
/**
* @ignore
* 将 label 限制在画布范围内，简单得将超出画布的 label 往画布内调整
* @param labels
* @param cfg
*/
function limitInCanvas(items, labels, shapes, region) {
	each_default(labels, function(label$16) {
		var regionMinX = region.minX, regionMinY = region.minY, regionMaxX = region.maxX, regionMaxY = region.maxY;
		var _a$5 = label$16.getCanvasBBox(), minX = _a$5.minX, minY = _a$5.minY, maxX = _a$5.maxX, maxY$1 = _a$5.maxY, x = _a$5.x, y = _a$5.y, width = _a$5.width, height = _a$5.height;
		var finalX = x;
		var finalY = y;
		if (minX < regionMinX || maxX < regionMinX) finalX = regionMinX;
		if (minY < regionMinY || maxY$1 < regionMinY) finalY = regionMinY;
		if (minX > regionMaxX) finalX = regionMaxX - width;
		else if (maxX > regionMaxX) finalX = finalX - (maxX - regionMaxX);
		if (minY > regionMaxY) finalY = regionMaxY - height;
		else if (maxY$1 > regionMaxY) finalY = finalY - (maxY$1 - regionMaxY);
		if (finalX !== x || finalY !== y) translate(label$16, finalX - x, finalY - y);
	});
}

//#endregion
//#region node_modules/@antv/g2/esm/geometry/label/layout/limit-in-shape.js
/**
* @ignore
* 根据图形元素以及 label 的 bbox 进行调整，如果 label 超出了 shape 的 bbox 则不展示
*/
function limitInShape(items, labels, shapes, region) {
	each_default(labels, function(label$16, index) {
		var labelBBox = label$16.getCanvasBBox();
		var shapeBBox = shapes[index].getBBox();
		if (labelBBox.minX < shapeBBox.minX || labelBBox.minY < shapeBBox.minY || labelBBox.maxX > shapeBBox.maxX || labelBBox.maxY > shapeBBox.maxY) label$16.remove(true);
	});
}

//#endregion
//#region node_modules/@antv/g2/esm/geometry/label/layout/overlap.js
var MAX_TIMES = 100;
/**
* @ignore
* Greedy 贪婪算法
*/
var Greedy = function() {
	function Greedy$1(cfg) {
		if (cfg === void 0) cfg = {};
		this.bitmap = {};
		var _a$5 = cfg.xGap, xGap = _a$5 === void 0 ? 1 : _a$5, _b = cfg.yGap, yGap = _b === void 0 ? 8 : _b;
		this.xGap = xGap;
		this.yGap = yGap;
	}
	Greedy$1.prototype.hasGap = function(bbox) {
		var hasGap = true;
		var bitmap = this.bitmap;
		var minX = Math.round(bbox.minX);
		var maxX = Math.round(bbox.maxX);
		var minY = Math.round(bbox.minY);
		var maxY$1 = Math.round(bbox.maxY);
		for (var i = minX; i <= maxX; i += 1) {
			if (!bitmap[i]) {
				bitmap[i] = {};
				continue;
			}
			if (i === minX || i === maxX) {
				for (var j = minY; j <= maxY$1; j++) if (bitmap[i][j]) {
					hasGap = false;
					break;
				}
			} else if (bitmap[i][minY] || bitmap[i][maxY$1]) {
				hasGap = false;
				break;
			}
		}
		return hasGap;
	};
	Greedy$1.prototype.fillGap = function(bbox) {
		var bitmap = this.bitmap;
		var minX = Math.round(bbox.minX);
		var maxX = Math.round(bbox.maxX);
		var minY = Math.round(bbox.minY);
		var maxY$1 = Math.round(bbox.maxY);
		for (var i = minX; i <= maxX; i += 1) if (!bitmap[i]) bitmap[i] = {};
		for (var i = minX; i <= maxX; i += this.xGap) {
			for (var j = minY; j <= maxY$1; j += this.yGap) bitmap[i][j] = true;
			bitmap[i][maxY$1] = true;
		}
		if (this.yGap !== 1) for (var i = minY; i <= maxY$1; i += 1) {
			bitmap[minX][i] = true;
			bitmap[maxX][i] = true;
		}
		if (this.xGap !== 1) for (var i = minX; i <= maxX; i += 1) {
			bitmap[i][minY] = true;
			bitmap[i][maxY$1] = true;
		}
	};
	Greedy$1.prototype.destroy = function() {
		this.bitmap = {};
	};
	return Greedy$1;
}();
function spiralFill(label$16, greedy, maxTimes) {
	if (maxTimes === void 0) maxTimes = MAX_TIMES;
	var dt = -1;
	var _a$5 = label$16.attr(), x = _a$5.x, y = _a$5.y;
	var bbox = label$16.getCanvasBBox();
	var maxDelta = Math.sqrt(bbox.width * bbox.width + bbox.height * bbox.height);
	var dxdy;
	var t = -dt;
	var dx = 0;
	var dy = 0;
	var f = function(param) {
		var nt = param * .1;
		return [nt * Math.cos(nt), nt * Math.sin(nt)];
	};
	if (greedy.hasGap(bbox)) {
		greedy.fillGap(bbox);
		return true;
	}
	var canFill = false;
	var times = 0;
	var accessedCache = {};
	while (Math.min(Math.abs(dx), Math.abs(dy)) < maxDelta && times < maxTimes) {
		dxdy = f(t += dt);
		dx = ~~dxdy[0];
		dy = ~~dxdy[1];
		if (!dx && !dy || accessedCache["".concat(dx, "-").concat(dy)]) continue;
		label$16.attr({
			x: x + dx,
			y: y + dy
		});
		if (dx + dy < 0) label$16.attr("textAlign", "right");
		times++;
		if (greedy.hasGap(label$16.getCanvasBBox())) {
			greedy.fillGap(label$16.getCanvasBBox());
			canFill = true;
			accessedCache["".concat(dx, "-").concat(dy)] = true;
			break;
		}
	}
	return canFill;
}
function adjustLabelPosition(label$16, x, y, index) {
	var _a$5 = label$16.getCanvasBBox(), width = _a$5.width, height = _a$5.height;
	var attrs = {
		x,
		y,
		textAlign: "center"
	};
	switch (index) {
		case 0:
			attrs.y -= height + 1;
			attrs.x += 1;
			attrs.textAlign = "left";
			break;
		case 1:
			attrs.y -= height + 1;
			attrs.x -= 1;
			attrs.textAlign = "right";
			break;
		case 2:
			attrs.y += height + 1;
			attrs.x -= 1;
			attrs.textAlign = "right";
			break;
		case 3:
			attrs.y += height + 1;
			attrs.x += 1;
			attrs.textAlign = "left";
			break;
		case 5:
			attrs.y -= height * 2 + 2;
			break;
		case 6:
			attrs.y += height * 2 + 2;
			break;
		case 7:
			attrs.x += width + 1;
			attrs.textAlign = "left";
			break;
		case 8:
			attrs.x -= width + 1;
			attrs.textAlign = "right";
			break;
		default: break;
	}
	label$16.attr(attrs);
	return label$16.getCanvasBBox();
}
/**
* @ignore
* label 防遮挡布局：在不改变 label 位置的情况下对相互重叠的 label 进行调整。
* 不同于 'overlap' 类型的布局，该布局不会对 label 的位置进行偏移调整。
* @param labels 参与布局调整的 label 数组集合
*/
function fixedOverlap(items, labels, shapes, region) {
	var greedy = new Greedy();
	each_default(labels, function(label$16) {
		var labelShape = label$16.find(function(shape) {
			return shape.get("type") === "text";
		});
		if (!spiralFill(labelShape, greedy)) label$16.remove(true);
	});
	greedy.destroy();
}
/**
* @ignore
* label 防遮挡布局：为了防止 label 之间相互覆盖同时保证尽可能多 的 label 展示，通过尝试将 label 向**四周偏移**来剔除放不下的 label
* @param labels 参与布局调整的 label 数组集合
*/
function overlap(items, labels, shapes, region) {
	var greedy = new Greedy();
	each_default(labels, function(label$16) {
		var labelShape = label$16.find(function(shape) {
			return shape.get("type") === "text";
		});
		var _a$5 = labelShape.attr(), x = _a$5.x, y = _a$5.y;
		var canFill = false;
		for (var i = 0; i <= 8; i++) {
			var bbox = adjustLabelPosition(labelShape, x, y, i);
			if (greedy.hasGap(bbox)) {
				greedy.fillGap(bbox);
				canFill = true;
				break;
			}
		}
		if (!canFill) label$16.remove(true);
	});
	greedy.destroy();
}

//#endregion
//#region node_modules/@antv/g2/esm/util/collision-detect.js
function dot$1(a, b) {
	return (a[0] || 0) * (b[0] || 0) + (a[1] || 0) * (b[1] || 0) + (a[2] || 0) * (b[2] || 0);
}
/**
* @private
* 1. 获取投影轴
*/
function getAxes(points) {
	if (points.length > 4) return [];
	var vector = function(start, end) {
		return [end.x - start.x, end.y - start.y];
	};
	var AB = vector(points[0], points[1]);
	var BC = vector(points[1], points[2]);
	return [AB, BC];
}
/**
* @private
* 绕指定点顺时针旋转后的点坐标
* 默认绕原点旋转
*/
function rotateAtPoint(point$1, deg, origin) {
	if (deg === void 0) deg = 0;
	if (origin === void 0) origin = {
		x: 0,
		y: 0
	};
	var x = point$1.x, y = point$1.y;
	return {
		x: (x - origin.x) * Math.cos(-deg) + (y - origin.y) * Math.sin(-deg) + origin.x,
		y: (origin.x - x) * Math.sin(-deg) + (y - origin.y) * Math.cos(-deg) + origin.y
	};
}
/**
* @private
* 转化为顶点坐标数组
*
* @param {Object} box
*/
function getRectPoints(box$1) {
	var points = [
		{
			x: box$1.x,
			y: box$1.y
		},
		{
			x: box$1.x + box$1.width,
			y: box$1.y
		},
		{
			x: box$1.x + box$1.width,
			y: box$1.y + box$1.height
		},
		{
			x: box$1.x,
			y: box$1.y + box$1.height
		}
	];
	var rotation = box$1.rotation;
	if (rotation) return [
		rotateAtPoint(points[0], rotation, points[0]),
		rotateAtPoint(points[1], rotation, points[0]),
		rotateAtPoint(points[2], rotation, points[0]),
		rotateAtPoint(points[3], rotation, points[0])
	];
	return points;
}
/**
* @private
* 2. 获取多边形在投影轴上的投影
*
* 向量的点积的其中一个几何含义是：一个向量在平行于另一个向量方向上的投影的数值乘积。
* 由于投影轴是单位向量（长度为1），投影的长度为 x1 * x2 + y1 * y2
*/
function getProjection(points, axis$21) {
	if (points.length > 4) return {
		min: 0,
		max: 0
	};
	var scalars = [];
	points.forEach(function(point$1) {
		scalars.push(dot$1([point$1.x, point$1.y], axis$21));
	});
	return {
		min: Math.min.apply(Math, __spreadArray([], __read(scalars), false)),
		max: Math.max.apply(Math, __spreadArray([], __read(scalars), false))
	};
}
function isProjectionOverlap(projection1, projection2) {
	return projection1.max > projection2.min && projection1.min < projection2.max;
}
function isValidNumber(d) {
	return typeof d === "number" && !Number.isNaN(d) && d !== Infinity && d !== -Infinity;
}
function isValidBox(box$1) {
	return [
		"x",
		"y",
		"width",
		"height"
	].every(function(attr) {
		return isValidNumber(box$1[attr]);
	});
}
/**
* 快速判断两个无旋转矩形是否遮挡
*/
function isIntersectRect(box1, box2, margin) {
	if (margin === void 0) margin = 0;
	return !(box2.x > box1.x + box1.width + margin || box2.x + box2.width < box1.x - margin || box2.y > box1.y + box1.height + margin || box2.y + box2.height < box1.y - margin);
}
/**
* detect whether two shape is intersected, useful when shape is been rotated
* 判断两个矩形是否重叠（相交和包含, 是否旋转）
*
* - 原理: 分离轴定律
*/
function intersect(box1, box2, margin) {
	if (margin === void 0) margin = 0;
	if (!isValidBox(box1) || !isValidBox(box2)) return false;
	if (!box1.rotation && !box2.rotation) return isIntersectRect(box1, box2, margin);
	var rect1Points = getRectPoints(box1);
	var rect2Points = getRectPoints(box2);
	var axes = getAxes(rect1Points).concat(getAxes(rect2Points));
	for (var i = 0; i < axes.length; i++) {
		var axis$21 = axes[i];
		var projection1 = getProjection(rect1Points, axis$21);
		var projection2 = getProjection(rect2Points, axis$21);
		if (!isProjectionOverlap(projection1, projection2)) return false;
	}
	return true;
}

//#endregion
//#region node_modules/@antv/g2/esm/geometry/label/util/createWorker.js
var MyWorker = function() {
	function MyWorker$1(url) {
		var _this = this;
		this.queue = [];
		this.worker = new Worker(url);
		this.worker.onmessage = function(e) {
			var _a$5;
			(_a$5 = _this.queue.shift()) === null || _a$5 === void 0 || _a$5.resolve(e);
		};
		this.worker.onmessageerror = function(e) {
			var _a$5;
			console.warn("[AntV G2] Web worker is not available");
			(_a$5 = _this.queue.shift()) === null || _a$5 === void 0 || _a$5.reject(e);
		};
	}
	MyWorker$1.prototype.post = function(params, onError) {
		var _this = this;
		return new Promise(function(resolve, reject) {
			_this.queue.push({
				resolve,
				reject
			});
			try {
				_this.worker.postMessage(params);
			} catch (e) {
				console.warn("[AntV G2] Web worker is not available");
				is_function_default(onError) && onError();
			}
		});
	};
	MyWorker$1.prototype.destroy = function() {
		this.worker.terminate();
	};
	return MyWorker$1;
}();
function createWorker(f) {
	if (typeof window === "undefined") return;
	var blob;
	try {
		blob = new Blob([f.toString()], { type: "application/javascript" });
	} catch (e) {
		blob = new window.BlobBuilder();
		blob.append(f.toString());
		blob = blob.getBlob();
	}
	return new MyWorker(URL.createObjectURL(blob));
}

//#endregion
//#region node_modules/@antv/g2/esm/geometry/label/layout/worker/hide-overlap.js
var onmessage = function(e) {
	function generateUtils() {
		function dot$3(a, b) {
			return (a[0] || 0) * (b[0] || 0) + (a[1] || 0) * (b[1] || 0) + (a[2] || 0) * (b[2] || 0);
		}
		/**
		* 1. 获取投影轴
		*/
		function getAxes$1(points) {
			if (points.length > 4) return [];
			var vector = function(start, end) {
				return [end.x - start.x, end.y - start.y];
			};
			var AB = vector(points[0], points[1]);
			var BC = vector(points[1], points[2]);
			return [AB, BC];
		}
		/**
		* 绕指定点顺时针旋转后的点坐标
		* 默认绕原点旋转
		*/
		function rotateAtPoint$1(point$1, deg, origin) {
			if (deg === void 0) deg = 0;
			if (origin === void 0) origin = {
				x: 0,
				y: 0
			};
			var x = point$1.x, y = point$1.y;
			return {
				x: (x - origin.x) * Math.cos(-deg) + (y - origin.y) * Math.sin(-deg) + origin.x,
				y: (origin.x - x) * Math.sin(-deg) + (y - origin.y) * Math.cos(-deg) + origin.y
			};
		}
		/**
		* @private
		* 转化为顶点坐标数组
		*
		* @param {Object} box
		*/
		function getRectPoints$2(box$1) {
			var points = [
				{
					x: box$1.x,
					y: box$1.y
				},
				{
					x: box$1.x + box$1.width,
					y: box$1.y
				},
				{
					x: box$1.x + box$1.width,
					y: box$1.y + box$1.height
				},
				{
					x: box$1.x,
					y: box$1.y + box$1.height
				}
			];
			var rotation = box$1.rotation;
			if (rotation) return [
				rotateAtPoint$1(points[0], rotation, points[0]),
				rotateAtPoint$1(points[1], rotation, points[0]),
				rotateAtPoint$1(points[2], rotation, points[0]),
				rotateAtPoint$1(points[3], rotation, points[0])
			];
			return points;
		}
		/**
		* 2. 获取多边形在投影轴上的投影
		*
		* 向量的点积的其中一个几何含义是：一个向量在平行于另一个向量方向上的投影的数值乘积。
		* 由于投影轴是单位向量（长度为1），投影的长度为 x1 * x2 + y1 * y2
		*/
		function getProjection$1(points, axis$21) {
			if (points.length > 4) return {
				min: 0,
				max: 0
			};
			var scalars = [];
			points.forEach(function(point$1) {
				scalars.push(dot$3([point$1.x, point$1.y], axis$21));
			});
			return {
				min: Math.min.apply(null, scalars),
				max: Math.max.apply(null, scalars)
			};
		}
		function isProjectionOverlap$1(projection1, projection2) {
			return projection1.max > projection2.min && projection1.min < projection2.max;
		}
		function isValidNumber$1(d) {
			return typeof d === "number" && !Number.isNaN(d) && d !== Infinity && d !== -Infinity;
		}
		function isValidBox$1(box$1) {
			return [
				"x",
				"y",
				"width",
				"height"
			].every(function(attr) {
				return isValidNumber$1(box$1[attr]);
			});
		}
		function isIntersectRect$1(box1, box2, margin) {
			if (margin === void 0) margin = 0;
			return !(box2.x > box1.x + box1.width + margin || box2.x + box2.width < box1.x - margin || box2.y > box1.y + box1.height + margin || box2.y + box2.height < box1.y - margin);
		}
		function intersect$3(box1, box2, margin) {
			if (margin === void 0) margin = 0;
			if (!isValidBox$1(box1) || !isValidBox$1(box2)) return false;
			if (!box1.rotation && !box2.rotation) return isIntersectRect$1(box1, box2, margin);
			var rect1Points = getRectPoints$2(box1);
			var rect2Points = getRectPoints$2(box2);
			var axes = getAxes$1(rect1Points).concat(getAxes$1(rect2Points));
			for (var i = 0; i < axes.length; i++) {
				var axis$21 = axes[i];
				var projection1 = getProjection$1(rect1Points, axis$21);
				var projection2 = getProjection$1(rect2Points, axis$21);
				if (!isProjectionOverlap$1(projection1, projection2)) return false;
			}
			return true;
		}
		return { intersect: intersect$3 };
	}
	var intersect$2 = generateUtils().intersect;
	function hideOverlap$1(items$1) {
		var boxes = items$1.slice();
		for (var i = 0; i < boxes.length; i++) {
			var box1 = boxes[i];
			if (box1.visible) for (var j = i + 1; j < boxes.length; j++) {
				var box2 = boxes[j];
				if (box1 !== box2 && box2.visible) {
					if (intersect$2(box1, box2)) box2.visible = false;
				}
			}
		}
		return boxes;
	}
	var methods = { "hide-overlap": hideOverlap$1 };
	try {
		var eventData = JSON.parse(e.data);
		if (!eventData || !eventData.type || !methods[eventData.type]) return;
		var type = eventData.type, items = eventData.items;
		var result = methods[type](items);
		self.postMessage(result);
	} catch (e$1) {
		throw e$1;
	}
};
var code = "\n   self.onmessage = ".concat(onmessage.toString(), "\n");

//#endregion
//#region node_modules/@antv/g2/esm/geometry/label/layout/hide-overlap.js
var layout = function(items) {
	var boxes = items.slice();
	for (var i = 0; i < boxes.length; i++) {
		var box1 = boxes[i];
		if (box1.visible) for (var j = i + 1; j < boxes.length; j++) {
			var box2 = boxes[j];
			if (box1 !== box2 && box2.visible) {
				if (intersect(box1, box2)) box2.visible = false;
			}
		}
	}
	return boxes;
};
var cache = /* @__PURE__ */ new Map();
var worker = createWorker(code);
/**
* label 防遮挡布局：在不改变 label 位置的情况下对相互重叠的 label 进行隐藏（非移除）
* 不同于 'overlap' 类型的布局，该布局不会对 label 的位置进行偏移调整。
* @param labels 参与布局调整的 label 数组集合
*/
function hideOverlap(labelItems, labels, shapes, region) {
	return __awaiter(this, void 0, void 0, function() {
		var boxes, memoKey, cb, params, res, e_1;
		return __generator(this, function(_a$5) {
			switch (_a$5.label) {
				case 0:
					boxes = labels.map(function(d, idx) {
						return __assign(__assign({}, getLabelBackgroundInfo(d, labelItems[idx], get_default(labelItems[idx], "background.padding"))), { visible: true });
					});
					memoKey = JSON.stringify(boxes);
					cb = function(items) {
						cache.set(memoKey, items);
						each_default(items, function(_a$6, idx) {
							var visible = _a$6.visible;
							var labelShape = labels[idx];
							if (visible) labelShape === null || labelShape === void 0 || labelShape.show();
							else labelShape === null || labelShape === void 0 || labelShape.hide();
						});
						return items;
					};
					if (!cache.get(memoKey)) return [3, 1];
					cb(cache.get(memoKey));
					return [3, 7];
				case 1:
					if (!worker) return [3, 6];
					_a$5.label = 2;
				case 2:
					_a$5.trys.push([
						2,
						4,
						,
						5
					]);
					params = JSON.stringify({
						type: "hide-overlap",
						items: boxes
					});
					return [4, worker.post(params, function() {
						return cb(layout(boxes));
					})];
				case 3:
					res = _a$5.sent();
					cb(Array.isArray(res.data) ? res.data : []);
					return [3, 5];
				case 4:
					e_1 = _a$5.sent();
					console.error(e_1);
					cb(layout(boxes));
					return [3, 5];
				case 5: return [3, 7];
				case 6:
					cb(layout(boxes));
					_a$5.label = 7;
				case 7: return [2];
			}
		});
	});
}

//#endregion
//#region node_modules/@antv/g2/esm/util/color.js
var preset = { "#5B8FF9": true };
var isContrastColorWhite = function(color$2) {
	var rgb$1 = esm_default.toRGB(color$2).toUpperCase();
	if (preset[rgb$1]) return preset[rgb$1];
	var _a$5 = __read(esm_default.rgb2arr(rgb$1), 3), r = _a$5[0], g = _a$5[1], b = _a$5[2];
	return (r * 299 + g * 587 + b * 114) / 1e3 < 128;
};

//#endregion
//#region node_modules/@antv/g2/esm/geometry/label/layout/adjust-color.js
function adjustColor(items, labels, shapes) {
	if (shapes.length === 0) return;
	var theme$3 = shapes[0].get("element").geometry.theme;
	var _a$5 = theme$3.labels || {}, fillColorLight = _a$5.fillColorLight, fillColorDark = _a$5.fillColorDark;
	shapes.forEach(function(shape, index) {
		var textShape = labels[index].find(function(el) {
			return el.get("type") === "text";
		});
		var shapeBBox = BBox.fromObject(shape.getBBox());
		var textBBox = BBox.fromObject(textShape.getCanvasBBox());
		var overflow = !shapeBBox.contains(textBBox);
		var bgColor = shape.attr("fill");
		var fillWhite = isContrastColorWhite(bgColor);
		if (!overflow) {
			if (fillWhite) {
				if (fillColorLight) textShape.attr("fill", fillColorLight);
			} else if (fillColorDark) textShape.attr("fill", fillColorDark);
		} else textShape.attr(theme$3.overflowLabels.style);
	});
}

//#endregion
//#region node_modules/@antv/g2/esm/geometry/label/layout/interval/adjust-position.js
function shouldInShapeSingle(geometry$34, label$16, shape) {
	var coordinate$10 = geometry$34.coordinate;
	var textShape = findLabelTextShape(label$16);
	var textBBox = BBox.fromObject(textShape.getCanvasBBox());
	var shapeBBox = BBox.fromObject(shape.getBBox());
	return coordinate$10.isTransposed ? shapeBBox.height >= textBBox.height : shapeBBox.width >= textBBox.width;
}
function shouldInShape(geometry$34, labels, shapes) {
	return !!geometry$34.getAdjust("stack") || labels.every(function(label$16, index) {
		var shape = shapes[index];
		return shouldInShapeSingle(geometry$34, label$16, shape);
	});
}
function moveInShape(geometry$34, label$16, shape) {
	var coordinate$10 = geometry$34.coordinate;
	var shapeBBox = BBox.fromObject(shape.getBBox());
	var textShape = findLabelTextShape(label$16);
	if (coordinate$10.isTransposed) textShape.attr({
		x: shapeBBox.minX + shapeBBox.width / 2,
		textAlign: "center"
	});
	else textShape.attr({
		y: shapeBBox.minY + shapeBBox.height / 2,
		textBaseline: "middle"
	});
}
/**
* 适用于 interval geometry 的数据标签位置自动调整布局方法
* @param items
* @param labels
* @param shapes
*/
function intervalAdjustPosition(items, labels, shapes) {
	var _a$5;
	if (shapes.length === 0) return;
	var element = (_a$5 = shapes[0]) === null || _a$5 === void 0 ? void 0 : _a$5.get("element");
	var geometry$34 = element === null || element === void 0 ? void 0 : element.geometry;
	if (!geometry$34 || geometry$34.type !== "interval") return;
	if (shouldInShape(geometry$34, labels, shapes)) shapes.forEach(function(shape, index) {
		var label$16 = labels[index];
		moveInShape(geometry$34, label$16, shape);
	});
}

//#endregion
//#region node_modules/@antv/g2/esm/geometry/label/layout/interval/hide-overlap.js
function filterLabel(labels) {
	var MAX_CNT = 500;
	var filteredLabels = [];
	var pages = Math.max(Math.floor(labels.length / MAX_CNT), 1);
	each_default(labels, function(label$16, idx) {
		if (idx % pages === 0) filteredLabels.push(label$16);
		else label$16.set("visible", false);
	});
	return filteredLabels;
}
/**
* 为 interval geometry 定制的数据标签重叠自动隐藏布局方法
* @param items
* @param labels
* @param shapes
*/
function intervalHideOverlap(items, labels, shapes) {
	var _a$5;
	if (shapes.length === 0) return;
	var element = (_a$5 = shapes[0]) === null || _a$5 === void 0 ? void 0 : _a$5.get("element");
	var geometry$34 = element === null || element === void 0 ? void 0 : element.geometry;
	if (!geometry$34 || geometry$34.type !== "interval") return;
	var filteredLabels = filterLabel(labels);
	var _b = __read(geometry$34.getXYFields(), 1), xField = _b[0];
	var dones = [];
	var todo = [];
	var groupedLabels = group_by_default(filteredLabels, function(label$16) {
		return label$16.get("data")[xField];
	});
	var xValues = uniq(map_default(filteredLabels, function(label$16) {
		return label$16.get("data")[xField];
	}));
	var xValue;
	filteredLabels.forEach(function(label$16) {
		label$16.set("visible", true);
	});
	var addCurrentGroup = function(curItems) {
		if (curItems) {
			if (curItems.length) todo.push(curItems.pop());
			todo.push.apply(todo, __spreadArray([], __read(curItems), false));
		}
	};
	if (size(xValues) > 0) {
		xValue = xValues.shift();
		addCurrentGroup(groupedLabels[xValue]);
	}
	if (size(xValues) > 0) {
		xValue = xValues.pop();
		addCurrentGroup(groupedLabels[xValue]);
	}
	each_default(xValues.reverse(), function(val) {
		addCurrentGroup(groupedLabels[val]);
	});
	while (todo.length > 0) {
		var cur = todo.shift();
		if (cur.get("visible")) if (checkShapeOverlap$2(cur, dones)) cur.set("visible", false);
		else dones.push(cur);
	}
}

//#endregion
//#region node_modules/@antv/g2/esm/geometry/label/layout/point/adjust-position.js
/**
* 对同一组(相同 xField )的 Label 进行排序：第一个、最后一个、其他...
* @param geometry
* @param labels
*/
function sortLabels$1(geometry$34, labels) {
	var yField = geometry$34.getXYFields()[1];
	var result = [];
	var sortedLabels = labels.sort(function(left$1, right$1) {
		return left$1.get("data")[yField] - left$1.get("data")[yField];
	});
	if (sortedLabels.length > 0) result.push(sortedLabels.shift());
	if (sortedLabels.length > 0) result.push(sortedLabels.pop());
	result.push.apply(result, __spreadArray([], __read(sortedLabels), false));
	return result;
}
function hasSome$1(dones, current, compare$1) {
	return dones.some(function(done) {
		return compare$1(done, current);
	});
}
/**
* 计算两个矩形之间的堆叠区域面积
*/
function getOverlapArea$1(a, b, margin) {
	if (margin === void 0) margin = 0;
	var xOverlap = Math.max(0, Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin));
	var yOverlap = Math.max(0, Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin));
	return xOverlap * yOverlap;
}
/**
* 判断新添加的 Label 是否和已存在的发生重叠
* @param dones
* @param current
*/
function checkShapeOverlap$1(dones, current) {
	return hasSome$1(dones, current, function(left$1, right$1) {
		var leftText = findLabelTextShape(left$1);
		var rightText = findLabelTextShape(right$1);
		return getOverlapArea$1(leftText.getCanvasBBox(), rightText.getCanvasBBox(), 2) > 0;
	});
}
/**
* 适用于 point geometry 的数据标签位置自动调整布局方法
* @param items
* @param labels
* @param shapes
* @param region
* @param cfg
*/
function pointAdjustPosition(items, labels, shapes, region, cfg) {
	var _a$5, _b;
	if (shapes.length === 0) return;
	var element = (_a$5 = shapes[0]) === null || _a$5 === void 0 ? void 0 : _a$5.get("element");
	var geometry$34 = element === null || element === void 0 ? void 0 : element.geometry;
	if (!geometry$34 || geometry$34.type !== "point") return;
	var _c = __read(geometry$34.getXYFields(), 2), xField = _c[0], yField = _c[1];
	var groupedLabels = group_by_default(labels, function(label$16) {
		return label$16.get("data")[xField];
	});
	var dones = [];
	var offset = cfg && cfg.offset || ((_b = items[0]) === null || _b === void 0 ? void 0 : _b.offset) || 12;
	map_default(keys_default(groupedLabels).reverse(), function(xValue) {
		var sortedCollections = sortLabels$1(geometry$34, groupedLabels[xValue]);
		while (sortedCollections.length) {
			var current = sortedCollections.shift();
			var textShape = findLabelTextShape(current);
			if (hasSome$1(dones, current, function(left$1, right$1) {
				return left$1.get("data")[xField] === right$1.get("data")[xField] && left$1.get("data")[yField] === right$1.get("data")[yField];
			})) {
				textShape.set("visible", false);
				continue;
			}
			var upFail = checkShapeOverlap$1(dones, current);
			var downFail = false;
			if (upFail) {
				textShape.attr("y", textShape.attr("y") + 2 * offset);
				downFail = checkShapeOverlap$1(dones, current);
			}
			if (downFail) {
				textShape.set("visible", false);
				continue;
			}
			dones.push(current);
		}
	});
}

//#endregion
//#region node_modules/@antv/g2/esm/geometry/label/layout/path/adjust-position.js
/**
* 对同一组(相同 xField )的 Label 进行排序：第一个、最后一个、其他...
* @param geometry
* @param labels
*/
function sortLabels(geometry$34, labels) {
	var yField = geometry$34.getXYFields()[1];
	var result = [];
	var sortedLabels = labels.sort(function(left$1, right$1) {
		return left$1.get("data")[yField] - left$1.get("data")[yField];
	});
	if (sortedLabels.length > 0) result.push(sortedLabels.shift());
	if (sortedLabels.length > 0) result.push(sortedLabels.pop());
	result.push.apply(result, __spreadArray([], __read(sortedLabels), false));
	return result;
}
function hasSome(dones, current, compare$1) {
	return dones.some(function(done) {
		return compare$1(done, current);
	});
}
/**
* 计算两个矩形之间的堆叠区域面积
*/
function getOverlapArea(a, b, margin) {
	if (margin === void 0) margin = 0;
	var xOverlap = Math.max(0, Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin));
	var yOverlap = Math.max(0, Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin));
	return xOverlap * yOverlap;
}
/**
* 判断新添加的 Label 是否和已存在的发生重叠
* @param dones
* @param current
*/
function checkShapeOverlap(dones, current) {
	return hasSome(dones, current, function(left$1, right$1) {
		var leftText = findLabelTextShape(left$1);
		var rightText = findLabelTextShape(right$1);
		return getOverlapArea(leftText.getCanvasBBox(), rightText.getCanvasBBox(), 2) > 0;
	});
}
/**
* 适用于 point geometry 的数据标签位置自动调整布局方法
* @param items
* @param labels
* @param shapes
* @param region
* @param cfg
*/
function pathAdjustPosition(items, labels, shapes, region, cfg) {
	var _a$5, _b;
	if (shapes.length === 0) return;
	var element = (_a$5 = shapes[0]) === null || _a$5 === void 0 ? void 0 : _a$5.get("element");
	var geometry$34 = element === null || element === void 0 ? void 0 : element.geometry;
	if (!geometry$34 || [
		"path",
		"line",
		"area"
	].indexOf(geometry$34.type) < 0) return;
	var _c = __read(geometry$34.getXYFields(), 2), xField = _c[0], yField = _c[1];
	var groupedLabels = group_by_default(labels, function(label$16) {
		return label$16.get("data")[xField];
	});
	var dones = [];
	var offset = cfg && cfg.offset || ((_b = items[0]) === null || _b === void 0 ? void 0 : _b.offset) || 12;
	map_default(keys_default(groupedLabels).reverse(), function(xValue) {
		var sortedCollections = sortLabels(geometry$34, groupedLabels[xValue]);
		while (sortedCollections.length) {
			var current = sortedCollections.shift();
			var textShape = findLabelTextShape(current);
			if (hasSome(dones, current, function(left$1, right$1) {
				return left$1.get("data")[xField] === right$1.get("data")[xField] && left$1.get("data")[yField] === right$1.get("data")[yField];
			})) {
				textShape.set("visible", false);
				continue;
			}
			var upFail = checkShapeOverlap(dones, current);
			var downFail = false;
			if (upFail) {
				textShape.attr("y", textShape.attr("y") + 2 * offset);
				downFail = checkShapeOverlap(dones, current);
			}
			if (downFail) {
				textShape.set("visible", false);
				continue;
			}
			dones.push(current);
		}
	});
}

//#endregion
//#region node_modules/@antv/g2/esm/util/context.js
var ctx$1;
/**
* 获取 canvas context
*/
function getCanvasContext$1() {
	if (!ctx$1) ctx$1 = document.createElement("canvas").getContext("2d");
	return ctx$1;
}

//#endregion
//#region node_modules/@antv/g2/esm/util/text.js
/**
* 计算文本在画布中的宽度
*/
var measureTextWidth$1 = memoize_default(function(text, font) {
	if (font === void 0) font = {};
	var fontSize = font.fontSize, fontFamily = font.fontFamily, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
	var ctx$3 = getCanvasContext$1();
	ctx$3.font = [
		fontStyle,
		fontVariant,
		fontWeight,
		"".concat(fontSize, "px"),
		fontFamily
	].join(" ");
	return ctx$3.measureText(is_string_default(text) ? text : "").width;
}, function(text, font) {
	if (font === void 0) font = {};
	return __spreadArray([text], __read(values_default(font)), false).join("");
});
/**
* 获取文本的 ... 文本。
* 算法（减少每次 measureText 的长度，measureText 的性能跟字符串时间相关）：
* 1. 先通过 STEP 逐步计算，找到最后一个小于 maxWidth 的字符串
* 2. 然后对最后这个字符串二分计算
* @param text 需要计算的文本, 由于历史原因 除了支持string，还支持空值,number和数组等
* @param maxWidth
* @param font
*/
var getEllipsisText = function(text, maxWidth, font) {
	var STEP = 16;
	var DOT_WIDTH = measureTextWidth$1("...", font);
	var leftText;
	if (!is_string_default(text)) leftText = to_string_default(text);
	else leftText = text;
	var leftWidth = maxWidth;
	var r = [];
	var currentText;
	var currentWidth;
	if (measureTextWidth$1(text, font) <= maxWidth) return text;
	while (true) {
		currentText = leftText.substr(0, STEP);
		currentWidth = measureTextWidth$1(currentText, font);
		if (currentWidth + DOT_WIDTH > leftWidth) {
			if (currentWidth > leftWidth) break;
		}
		r.push(currentText);
		leftWidth -= currentWidth;
		leftText = leftText.substr(STEP);
		if (!leftText) return r.join("");
	}
	while (true) {
		currentText = leftText.substr(0, 1);
		currentWidth = measureTextWidth$1(currentText, font);
		if (currentWidth + DOT_WIDTH > leftWidth) break;
		r.push(currentText);
		leftWidth -= currentWidth;
		leftText = leftText.substr(1);
		if (!leftText) return r.join("");
	}
	return "".concat(r.join(""), "...");
};

//#endregion
//#region node_modules/@antv/g2/esm/geometry/label/layout/limit-in-plot.js
/**
* @ignore
* 将 label 限制在 Plot 范围内，将超出 Plot 范围的 label 可选择进行隐藏或者移动位置
* @param labels
* @param cfg
*/
function limitInPlot$3(items, labels, shapes, region, cfg) {
	if (labels.length <= 0) return;
	var direction$1 = (cfg === null || cfg === void 0 ? void 0 : cfg.direction) || [
		"top",
		"right",
		"bottom",
		"left"
	];
	var action = (cfg === null || cfg === void 0 ? void 0 : cfg.action) || "translate";
	var margin = (cfg === null || cfg === void 0 ? void 0 : cfg.margin) || 0;
	var coordinate$10 = labels[0].get("coordinate");
	if (!coordinate$10) return;
	var _a$5 = getCoordinateBBox(coordinate$10, margin), regionMinX = _a$5.minX, regionMinY = _a$5.minY, regionMaxX = _a$5.maxX, regionMaxY = _a$5.maxY;
	each_default(labels, function(label$16) {
		var _a$6 = label$16.getCanvasBBox(), minX = _a$6.minX, minY = _a$6.minY, maxX = _a$6.maxX, maxY$1 = _a$6.maxY, x = _a$6.x, y = _a$6.y, width = _a$6.width, height = _a$6.height;
		var finalX = x;
		var finalY = y;
		if (direction$1.indexOf("left") >= 0 && (minX < regionMinX || maxX < regionMinX)) finalX = regionMinX;
		if (direction$1.indexOf("top") >= 0 && (minY < regionMinY || maxY$1 < regionMinY)) finalY = regionMinY;
		if (direction$1.indexOf("right") >= 0) {
			if (minX > regionMaxX) finalX = regionMaxX - width;
			else if (maxX > regionMaxX) finalX = finalX - (maxX - regionMaxX);
		}
		if (direction$1.indexOf("bottom") >= 0) {
			if (minY > regionMaxY) finalY = regionMaxY - height;
			else if (maxY$1 > regionMaxY) finalY = finalY - (maxY$1 - regionMaxY);
		}
		if (finalX !== x || finalY !== y) {
			var translateX_1 = finalX - x;
			if (action === "translate") translate(label$16, translateX_1, finalY - y);
			else if (action === "ellipsis") label$16.findAll(function(shape) {
				return shape.get("type") === "text";
			}).forEach(function(textShape) {
				var style = pick_default(textShape.attr(), [
					"fontSize",
					"fontFamily",
					"fontWeight",
					"fontStyle",
					"fontVariant"
				]);
				var textBox = textShape.getCanvasBBox();
				var text = getEllipsisText(textShape.attr("text"), textBox.width - Math.abs(translateX_1), style);
				textShape.attr("text", text);
			});
			else label$16.hide();
		}
	});
}

//#endregion
//#region node_modules/@antv/g2/esm/animate/animation/fade.js
/**
* @ignore
* 单个 shape 动画
* 渐现动画
* @param shape 执行动画的图形元素
* @param animateCfg 动画配置
* @param cfg 额外信息
*/
function fadeIn(shape, animateCfg, cfg) {
	var endState = {
		fillOpacity: is_nil_default(shape.attr("fillOpacity")) ? 1 : shape.attr("fillOpacity"),
		strokeOpacity: is_nil_default(shape.attr("strokeOpacity")) ? 1 : shape.attr("strokeOpacity"),
		opacity: is_nil_default(shape.attr("opacity")) ? 1 : shape.attr("opacity")
	};
	shape.attr({
		fillOpacity: 0,
		strokeOpacity: 0,
		opacity: 0
	});
	shape.animate(endState, animateCfg);
}
/**
* @ignore
* 单个 shape 动画
* 渐隐动画
* @param shape 执行动画的图形元素
* @param animateCfg 动画配置
* @param cfg 额外信息
*/
function fadeOut(shape, animateCfg, cfg) {
	var endState = {
		fillOpacity: 0,
		strokeOpacity: 0,
		opacity: 0
	};
	var easing = animateCfg.easing, duration = animateCfg.duration, delay = animateCfg.delay;
	shape.animate(endState, duration, easing, function() {
		shape.remove(true);
	}, delay);
}

//#endregion
//#region node_modules/@antv/g2/esm/animate/animation/util.js
/**
* @ignore
* 对图形元素进行矩阵变换，同时返回变换前的图形矩阵
* @param shape 进行矩阵变换的图形
* @param vector 矩阵变换的中心点
* @param direct 矩阵变换的类型
*/
function transformShape(shape, vector, direct) {
	var scaledMatrix;
	var _a$5 = __read(vector, 2), x = _a$5[0], y = _a$5[1];
	shape.applyToMatrix([
		x,
		y,
		1
	]);
	if (direct === "x") {
		shape.setMatrix(transform$6(shape.getMatrix(), [
			[
				"t",
				-x,
				-y
			],
			[
				"s",
				.01,
				1
			],
			[
				"t",
				x,
				y
			]
		]));
		scaledMatrix = transform$6(shape.getMatrix(), [
			[
				"t",
				-x,
				-y
			],
			[
				"s",
				100,
				1
			],
			[
				"t",
				x,
				y
			]
		]);
	} else if (direct === "y") {
		shape.setMatrix(transform$6(shape.getMatrix(), [
			[
				"t",
				-x,
				-y
			],
			[
				"s",
				1,
				.01
			],
			[
				"t",
				x,
				y
			]
		]));
		scaledMatrix = transform$6(shape.getMatrix(), [
			[
				"t",
				-x,
				-y
			],
			[
				"s",
				1,
				100
			],
			[
				"t",
				x,
				y
			]
		]);
	} else if (direct === "xy") {
		shape.setMatrix(transform$6(shape.getMatrix(), [
			[
				"t",
				-x,
				-y
			],
			[
				"s",
				.01,
				.01
			],
			[
				"t",
				x,
				y
			]
		]));
		scaledMatrix = transform$6(shape.getMatrix(), [
			[
				"t",
				-x,
				-y
			],
			[
				"s",
				100,
				100
			],
			[
				"t",
				x,
				y
			]
		]);
	}
	return scaledMatrix;
}
/**
* 对图形元素进行剪切动画
* @param element 进行动画的图形元素
* @param animateCfg 动画配置
* @param coordinate 当前坐标系
* @param yMinPoint y 轴的最小值对应的图形坐标点
* @param type 剪切动画的类型
*/
function doScaleAnimate(element, animateCfg, coordinate$10, yMinPoint, type) {
	var start = coordinate$10.start, end = coordinate$10.end;
	var width = coordinate$10.getWidth();
	var height = coordinate$10.getHeight();
	var x;
	var y;
	if (type === "y") {
		x = start.x + width / 2;
		y = yMinPoint.y < start.y ? yMinPoint.y : start.y;
	} else if (type === "x") {
		x = yMinPoint.x > start.x ? yMinPoint.x : start.x;
		y = start.y + height / 2;
	} else if (type === "xy") if (coordinate$10.isPolar) {
		x = coordinate$10.getCenter().x;
		y = coordinate$10.getCenter().y;
	} else {
		x = (start.x + end.x) / 2;
		y = (start.y + end.y) / 2;
	}
	var endMatrix = transformShape(element, [x, y], type);
	element.animate({ matrix: endMatrix }, animateCfg);
}

//#endregion
//#region node_modules/@antv/g2/esm/animate/animation/grow-in.js
/**
* @ignore
* 入场动画
* x 方向的生长
* @param element 执行动画的元素
* @param animateCfg 动画配置
* @param cfg 额外信息
*/
function growInX(element, animateCfg, cfg) {
	var coordinate$10 = cfg.coordinate, minYPoint = cfg.minYPoint;
	doScaleAnimate(element, animateCfg, coordinate$10, minYPoint, "x");
}
/**
* @ignore
* 入场动画
* y 轴方向上的生长
* @param element 执行动画的元素
* @param animateCfg 动画配置
* @param cfg 额外信息
*/
function growInY(element, animateCfg, cfg) {
	var coordinate$10 = cfg.coordinate, minYPoint = cfg.minYPoint;
	doScaleAnimate(element, animateCfg, coordinate$10, minYPoint, "y");
}
/**
* @ignore
* 入场
* 中心点的向四周的生长动画
* @param element 执行动画的元素
* @param animateCfg 动画配置
* @param cfg 额外信息
*/
function growInXY(element, animateCfg, cfg) {
	var coordinate$10 = cfg.coordinate, minYPoint = cfg.minYPoint;
	doScaleAnimate(element, animateCfg, coordinate$10, minYPoint, "xy");
}

//#endregion
//#region node_modules/@antv/g2/esm/animate/animation/path-in.js
/**
* @ignore
* 入场动画
* path 的入场动画
* @param element 执行动画的元素
* @param animateCfg 动画配置
* @param cfg 额外信息
*/
function pathIn(element, animateCfg, cfg) {
	var length$1 = element.getTotalLength();
	element.attr("lineDash", [length$1]);
	element.animate(function(ratio) {
		return { lineDashOffset: (1 - ratio) * length$1 };
	}, animateCfg);
}

//#endregion
//#region node_modules/@antv/g2/esm/animate/animation/position-update.js
/**
* @ignore
* 坐标移动动画
* @param shape 图形
* @param animateCfg
* @param cfg
*/
function positionUpdate(shape, animateCfg, cfg) {
	var toAttrs = cfg.toAttrs;
	var x = toAttrs.x;
	var y = toAttrs.y;
	delete toAttrs.x;
	delete toAttrs.y;
	shape.attr(toAttrs);
	shape.animate({
		x,
		y
	}, animateCfg);
}

//#endregion
//#region node_modules/@antv/g2/esm/animate/animation/scale-in.js
/**
* @ignore
* 沿着 x 方向放大的动画
* @param shape
* @param animateCfg
* @param shapeModel
*/
function scaleInX(shape, animateCfg, cfg) {
	var box$1 = shape.getBBox();
	var points = shape.get("origin").mappingData.points;
	var x = points[0].y - points[1].y > 0 ? box$1.maxX : box$1.minX;
	var y = (box$1.minY + box$1.maxY) / 2;
	shape.applyToMatrix([
		x,
		y,
		1
	]);
	var matrix = transform$6(shape.getMatrix(), [
		[
			"t",
			-x,
			-y
		],
		[
			"s",
			.01,
			1
		],
		[
			"t",
			x,
			y
		]
	]);
	shape.setMatrix(matrix);
	shape.animate({ matrix: transform$6(shape.getMatrix(), [
		[
			"t",
			-x,
			-y
		],
		[
			"s",
			100,
			1
		],
		[
			"t",
			x,
			y
		]
	]) }, animateCfg);
}
/**
* @ignore
* 沿着 y 方向放大的动画
* @param shape
* @param animateCfg
* @param shapeModel
*/
function scaleInY(shape, animateCfg, cfg) {
	var box$1 = shape.getBBox();
	var mappingData = shape.get("origin").mappingData;
	var x = (box$1.minX + box$1.maxX) / 2;
	var points = mappingData.points;
	var y = points[0].y - points[1].y <= 0 ? box$1.maxY : box$1.minY;
	shape.applyToMatrix([
		x,
		y,
		1
	]);
	var matrix = transform$6(shape.getMatrix(), [
		[
			"t",
			-x,
			-y
		],
		[
			"s",
			1,
			.01
		],
		[
			"t",
			x,
			y
		]
	]);
	shape.setMatrix(matrix);
	shape.animate({ matrix: transform$6(shape.getMatrix(), [
		[
			"t",
			-x,
			-y
		],
		[
			"s",
			1,
			100
		],
		[
			"t",
			x,
			y
		]
	]) }, animateCfg);
}

//#endregion
//#region node_modules/@antv/g2/esm/animate/animation/sector-path-update.js
function getAngle$1(startPoint, arcPath) {
	var _a$5;
	var _b = getArcParams(startPoint, arcPath), startAngle = _b.startAngle, endAngle = _b.endAngle;
	if (!isNumberEqual(startAngle, -Math.PI * .5) && startAngle < -Math.PI * .5) startAngle += Math.PI * 2;
	if (!isNumberEqual(endAngle, -Math.PI * .5) && endAngle < -Math.PI * .5) endAngle += Math.PI * 2;
	if (arcPath[5] === 0) _a$5 = __read([endAngle, startAngle], 2), startAngle = _a$5[0], endAngle = _a$5[1];
	if (isNumberEqual(startAngle, Math.PI * 1.5)) startAngle = Math.PI * -.5;
	if (isNumberEqual(endAngle, Math.PI * -.5) && !isNumberEqual(startAngle, endAngle)) endAngle = Math.PI * 1.5;
	return {
		startAngle,
		endAngle
	};
}
function getArcStartPoint(path) {
	var startPoint;
	if (path[0] === "M" || path[0] === "L") startPoint = [path[1], path[2]];
	else if (path[0] === "a" || path[0] === "A" || path[0] === "C") startPoint = [path[path.length - 2], path[path.length - 1]];
	return startPoint;
}
/**
* path 存在以下情况
* 1. 饼图不为整圆的 path，命令为 M, L, A, L, Z
* 2. 饼图为整圆的 path，命令为 M, M, A, A, M, Z
* 3. 环图不为整圆的 path，命令为 M, A, L, A, L, Z
* 4. 环图为整圆的 path，命令为 M, A, A, M, A, A, M, Z
* 5. radial-line, 不为整圆时的 path, 命令为 M, A, A, Z
* 6. radial-line, 为整圆时的 path，命令为 M, A, A, A, A, Z
* @param path theta 坐标系下圆弧的 path 命令
*/
function getArcInfo(path) {
	var _a$5;
	var startAngle;
	var endAngle;
	var arcPaths = path.filter(function(command) {
		return command[0] === "A" || command[0] === "a";
	});
	if (arcPaths.length === 0) return {
		startAngle: 0,
		endAngle: 0,
		radius: 0,
		innerRadius: 0
	};
	var firstArcPathCommand = arcPaths[0];
	var lastArcPathCommand = arcPaths.length > 1 ? arcPaths[1] : arcPaths[0];
	var firstIndex = path.indexOf(firstArcPathCommand);
	var lastIndex = path.indexOf(lastArcPathCommand);
	var firstStartPoint = getArcStartPoint(path[firstIndex - 1]);
	var lastStartPoint = getArcStartPoint(path[lastIndex - 1]);
	var _b = getAngle$1(firstStartPoint, firstArcPathCommand), firstStartAngle = _b.startAngle, firstEndAngle = _b.endAngle;
	var _c = getAngle$1(lastStartPoint, lastArcPathCommand), lastStartAngle = _c.startAngle, lastEndAngle = _c.endAngle;
	if (isNumberEqual(firstStartAngle, lastStartAngle) && isNumberEqual(firstEndAngle, lastEndAngle)) {
		startAngle = firstStartAngle;
		endAngle = firstEndAngle;
	} else {
		startAngle = Math.min(firstStartAngle, lastStartAngle);
		endAngle = Math.max(firstEndAngle, lastEndAngle);
	}
	var radius = firstArcPathCommand[1];
	var innerRadius = arcPaths[arcPaths.length - 1][1];
	if (radius < innerRadius) _a$5 = __read([innerRadius, radius], 2), radius = _a$5[0], innerRadius = _a$5[1];
	else if (radius === innerRadius) innerRadius = 0;
	return {
		startAngle,
		endAngle,
		radius,
		innerRadius
	};
}
/**
* @ignore
* 饼图更新动画
* @param shape 文本图形
* @param animateCfg
* @param cfg
*/
function sectorPathUpdate(shape, animateCfg, cfg) {
	var toAttrs = cfg.toAttrs, coordinate$10 = cfg.coordinate;
	var path = toAttrs.path || [];
	var pathCommands = path.map(function(command) {
		return command[0];
	});
	if (path.length < 1) return;
	var _a$5 = getArcInfo(path), curStartAngle = _a$5.startAngle, curEndAngle = _a$5.endAngle, radius = _a$5.radius, innerRadius = _a$5.innerRadius;
	var _b = getArcInfo(shape.attr("path")), preStartAngle = _b.startAngle, preEndAngle = _b.endAngle;
	var center$1 = coordinate$10.getCenter();
	var diffStartAngle = curStartAngle - preStartAngle;
	var diffEndAngle = curEndAngle - preEndAngle;
	if (diffStartAngle === 0 && diffEndAngle === 0) {
		shape.attr(toAttrs);
		return;
	}
	shape.animate(function(ratio) {
		var onFrameStartAngle = preStartAngle + ratio * diffStartAngle;
		var onFrameEndAngle = preEndAngle + ratio * diffEndAngle;
		return __assign(__assign({}, toAttrs), { path: is_equal_default(pathCommands, [
			"M",
			"A",
			"A",
			"Z"
		]) ? getArcPath(center$1.x, center$1.y, radius, onFrameStartAngle, onFrameEndAngle) : getSectorPath(center$1.x, center$1.y, radius, onFrameStartAngle, onFrameEndAngle, innerRadius) });
	}, __assign(__assign({}, animateCfg), { callback: function() {
		shape.attr("path", path);
		is_function_default(animateCfg.callback) && animateCfg.callback();
	} }));
}

//#endregion
//#region node_modules/@antv/g2/esm/animate/animation/wave-in.js
/**
* @ignore
* 整体动画
* 划入入场动画效果
* @todo 放两张直角坐标系和极坐标系的图
* @param element 参与动画的图形元素
* @param animateCfg 动画配置
* @param cfg 额外信息
*/
function waveIn(element, animateCfg, cfg) {
	var _a$5 = getCoordinateClipCfg(cfg.coordinate, 20), type = _a$5.type, startState = _a$5.startState, endState = _a$5.endState;
	var clipShape = element.setClip({
		type,
		attrs: startState
	});
	if (cfg.toAttrs) element.attr(cfg.toAttrs);
	clipShape.animate(endState, __assign(__assign({}, animateCfg), { callback: function() {
		if (element && !element.get("destroyed")) element.set("clipShape", null);
		clipShape.remove(true);
		is_function_default(animateCfg.callback) && animateCfg.callback();
	} }));
}

//#endregion
//#region node_modules/@antv/g2/esm/animate/animation/zoom.js
function doShapeZoom(shape, animateCfg, type) {
	if (shape.isGroup()) each_default(shape.getChildren(), function(child) {
		doShapeZoom(child, animateCfg, type);
	});
	else {
		var bbox = shape.getBBox();
		var x = (bbox.minX + bbox.maxX) / 2;
		var y = (bbox.minY + bbox.maxY) / 2;
		shape.applyToMatrix([
			x,
			y,
			1
		]);
		if (type === "zoomIn") {
			var matrix = transform$6(shape.getMatrix(), [
				[
					"t",
					-x,
					-y
				],
				[
					"s",
					.01,
					.01
				],
				[
					"t",
					x,
					y
				]
			]);
			shape.setMatrix(matrix);
			shape.animate({ matrix: transform$6(shape.getMatrix(), [
				[
					"t",
					-x,
					-y
				],
				[
					"s",
					100,
					100
				],
				[
					"t",
					x,
					y
				]
			]) }, animateCfg);
		} else shape.animate({ matrix: transform$6(shape.getMatrix(), [
			[
				"t",
				-x,
				-y
			],
			[
				"s",
				.01,
				.01
			],
			[
				"t",
				x,
				y
			]
		]) }, __assign(__assign({}, animateCfg), { callback: function() {
			shape.remove(true);
			is_function_default(animateCfg.callback) && animateCfg.callback();
		} }));
	}
}
/**
* @ignore
* 单个 shape 动画
* shape 以自身中心点逐渐放大的进入动画
* @param shape 参与动画的图形元素
* @param animateCfg 动画配置
* @param cfg 额外信息
*/
function zoomIn(shape, animateCfg, cfg) {
	doShapeZoom(shape, animateCfg, "zoomIn");
}
/**
* @ignore
* 单个 shape 动画
* 消失动画，shape 以自身为中心点的逐渐缩小
* @param shape 参与动画的图形元素
* @param animateCfg 动画配置
* @param cfg 额外信息
*/
function zoomOut(shape, animateCfg, cfg) {
	doShapeZoom(shape, animateCfg, "zoomOut");
}

//#endregion
//#region node_modules/@antv/g2/esm/util/facet.js
/**
* @ignore
* 获取 facet title 的最佳默认配置，防止
*/
function getFactTitleConfig(direction$1) {
	if ([DIRECTION.TOP, DIRECTION.BOTTOM].includes(direction$1)) return {
		offsetX: 0,
		offsetY: direction$1 === DIRECTION.TOP ? -8 : 8,
		style: {
			textAlign: "center",
			textBaseline: direction$1 === DIRECTION.TOP ? "bottom" : "top"
		}
	};
	if ([DIRECTION.LEFT, DIRECTION.RIGHT].includes(direction$1)) return {
		offsetX: direction$1 === DIRECTION.LEFT ? -8 : 8,
		offsetY: 0,
		style: {
			textAlign: direction$1 === DIRECTION.LEFT ? "right" : "left",
			textBaseline: "middle",
			rotate: Math.PI / 2
		}
	};
	return {};
}
/**
* @ignore
* 根据角度，获取 ○ 上的点
* @param center
* @param r
* @param angle
*/
function getAnglePoint(center$1, r, angle$1) {
	return {
		x: center$1.x + r * Math.cos(angle$1),
		y: center$1.y + r * Math.sin(angle$1)
	};
}

//#endregion
//#region node_modules/@antv/g2/esm/facet/circle.js
/**
* @ignore
* 镜像分面
*/
var Circle = function(_super) {
	__extends(Circle$5, _super);
	function Circle$5() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	Circle$5.prototype.getDefaultCfg = function() {
		return deep_mix_default({}, _super.prototype.getDefaultCfg.call(this), {
			type: "circle",
			showTitle: true,
			title: _super.prototype.getDefaultTitleCfg.call(this)
		});
	};
	Circle$5.prototype.render = function() {
		_super.prototype.render.call(this);
		if (this.cfg.showTitle) this.renderTitle();
	};
	/**
	* 根据总数和当前索引，计算分面的 region
	* @param count
	* @param index
	*/
	Circle$5.prototype.getRegion = function(count$1, index) {
		var r = 1 / 2;
		var center$1 = {
			x: .5,
			y: .5
		};
		var avgAngle = Math.PI * 2 / count$1;
		var angle$1 = -1 * Math.PI / 2 + avgAngle * index;
		var facetR = r / (1 + 1 / Math.sin(avgAngle / 2));
		var middle = getAnglePoint(center$1, r - facetR, angle$1);
		var startAngle = Math.PI * 5 / 4;
		var endAngle = Math.PI * 1 / 4;
		return {
			start: getAnglePoint(middle, facetR, startAngle),
			end: getAnglePoint(middle, facetR, endAngle)
		};
	};
	Circle$5.prototype.afterEachView = function(view, facet) {
		this.processAxis(view, facet);
	};
	Circle$5.prototype.beforeEachView = function(view, facet) {};
	Circle$5.prototype.generateFacets = function(data$2) {
		var _this = this;
		var _a$5 = this.cfg, fields = _a$5.fields, type = _a$5.type;
		var _b = __read(fields, 1), field$5 = _b[0];
		if (!field$5) throw new Error("No `fields` specified!");
		var values$1 = this.getFieldValues(data$2, field$5);
		var count$1 = values$1.length;
		var rst = [];
		values$1.forEach(function(value$1, index) {
			var conditions = [{
				field: field$5,
				value: value$1,
				values: values$1
			}];
			var facetData = filter_default(data$2, _this.getFacetDataFilter(conditions));
			var facet = {
				type,
				data: facetData,
				region: _this.getRegion(count$1, index),
				columnValue: value$1,
				columnField: field$5,
				columnIndex: index,
				columnValuesLength: count$1,
				rowValue: null,
				rowField: null,
				rowIndex: 0,
				rowValuesLength: 1
			};
			rst.push(facet);
		});
		return rst;
	};
	Circle$5.prototype.getXAxisOption = function(x, axes, option, facet) {
		return option;
	};
	/**
	* 设置 y 坐标轴的文本、title 是否显示
	* @param y
	* @param axes
	* @param option
	* @param facet
	*/
	Circle$5.prototype.getYAxisOption = function(y, axes, option, facet) {
		return option;
	};
	/**
	* facet title
	*/
	Circle$5.prototype.renderTitle = function() {
		var _this = this;
		each_default(this.facets, function(facet) {
			var columnValue = facet.columnValue, view = facet.view;
			var formatter = get_default(_this.cfg.title, "formatter");
			var config = deep_mix_default({
				position: ["50%", "0%"],
				content: formatter ? formatter(columnValue) : columnValue
			}, getFactTitleConfig(DIRECTION.TOP), _this.cfg.title);
			view.annotation().text(config);
		});
	};
	return Circle$5;
}(Facet$1);
var circle_default = Circle;

//#endregion
//#region node_modules/@antv/g2/esm/facet/list.js
/**
* @ignore
* 镜像分面
*/
var List = function(_super) {
	__extends(List$1, _super);
	function List$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	List$1.prototype.getDefaultCfg = function() {
		return deep_mix_default({}, _super.prototype.getDefaultCfg.call(this), {
			type: "list",
			cols: null,
			showTitle: true,
			title: _super.prototype.getDefaultTitleCfg.call(this)
		});
	};
	List$1.prototype.render = function() {
		_super.prototype.render.call(this);
		if (this.cfg.showTitle) this.renderTitle();
	};
	List$1.prototype.afterEachView = function(view, facet) {
		this.processAxis(view, facet);
	};
	List$1.prototype.beforeEachView = function(view, facet) {};
	List$1.prototype.generateFacets = function(data$2) {
		var _this = this;
		var fields = this.cfg.fields;
		var cols = this.cfg.cols;
		var _a$5 = __read(fields, 1), columnField = _a$5[0];
		if (!columnField) throw new Error("No `fields` specified!");
		var colValues = this.getFieldValues(data$2, columnField);
		var count$1 = colValues.length;
		cols = cols || count$1;
		var rows = this.getPageCount(count$1, cols);
		var rst = [];
		colValues.forEach(function(val, index) {
			var _a$6 = _this.getRowCol(index, cols), row = _a$6.row, col = _a$6.col;
			var conditions = [{
				field: columnField,
				value: val,
				values: colValues
			}];
			var facetData = filter_default(data$2, _this.getFacetDataFilter(conditions));
			var facet = {
				type: _this.cfg.type,
				data: facetData,
				region: _this.getRegion(rows, cols, col, row),
				columnValue: val,
				rowValue: val,
				columnField,
				rowField: null,
				columnIndex: col,
				rowIndex: row,
				columnValuesLength: cols,
				rowValuesLength: rows,
				total: count$1
			};
			rst.push(facet);
		});
		return rst;
	};
	/**
	* 设置 x 坐标轴的文本、title 是否显示
	* @param x
	* @param axes
	* @param option
	* @param facet
	*/
	List$1.prototype.getXAxisOption = function(x, axes, option, facet) {
		if (facet.rowIndex !== facet.rowValuesLength - 1 && facet.columnValuesLength * facet.rowIndex + facet.columnIndex + 1 + facet.columnValuesLength <= facet.total) return __assign(__assign({}, option), {
			label: null,
			title: null
		});
		return option;
	};
	/**
	* 设置 y 坐标轴的文本、title 是否显示
	* @param y
	* @param axes
	* @param option
	* @param facet
	*/
	List$1.prototype.getYAxisOption = function(y, axes, option, facet) {
		if (facet.columnIndex !== 0) return __assign(__assign({}, option), {
			title: null,
			label: null
		});
		return option;
	};
	/**
	* facet title
	*/
	List$1.prototype.renderTitle = function() {
		var _this = this;
		each_default(this.facets, function(facet) {
			var columnValue = facet.columnValue, view = facet.view;
			var formatter = get_default(_this.cfg.title, "formatter");
			var config = deep_mix_default({
				position: ["50%", "0%"],
				content: formatter ? formatter(columnValue) : columnValue
			}, getFactTitleConfig(DIRECTION.TOP), _this.cfg.title);
			view.annotation().text(config);
		});
	};
	/**
	* 计算分页数
	* @param total
	* @param pageSize
	*/
	List$1.prototype.getPageCount = function(total, pageSize) {
		return Math.floor((total + pageSize - 1) / pageSize);
	};
	/**
	* 索引值在哪一页
	* @param index
	* @param pageSize
	*/
	List$1.prototype.getRowCol = function(index, pageSize) {
		var row = Math.floor(index / pageSize);
		var col = index % pageSize;
		return {
			row,
			col
		};
	};
	return List$1;
}(Facet$1);
var list_default = List;

//#endregion
//#region node_modules/@antv/g2/esm/facet/matrix.js
/**
* @ignore
* 镜像分面
*/
var Matrix = function(_super) {
	__extends(Matrix$1, _super);
	function Matrix$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	Matrix$1.prototype.getDefaultCfg = function() {
		return deep_mix_default({}, _super.prototype.getDefaultCfg.call(this), {
			type: "matrix",
			showTitle: false,
			columnTitle: __assign({}, _super.prototype.getDefaultTitleCfg.call(this)),
			rowTitle: __assign({}, _super.prototype.getDefaultTitleCfg.call(this))
		});
	};
	Matrix$1.prototype.render = function() {
		_super.prototype.render.call(this);
		if (this.cfg.showTitle) this.renderTitle();
	};
	Matrix$1.prototype.afterEachView = function(view, facet) {
		this.processAxis(view, facet);
	};
	Matrix$1.prototype.beforeEachView = function(view, facet) {};
	Matrix$1.prototype.generateFacets = function(data$2) {
		var _a$5 = this.cfg, fields = _a$5.fields, type = _a$5.type;
		var rowValuesLength = fields.length;
		var columnValuesLength = rowValuesLength;
		var rst = [];
		for (var i = 0; i < columnValuesLength; i++) {
			var columnField = fields[i];
			for (var j = 0; j < rowValuesLength; j++) {
				var rowField = fields[j];
				var facet = {
					type,
					data: data$2,
					region: this.getRegion(rowValuesLength, columnValuesLength, i, j),
					columnValue: columnField,
					rowValue: rowField,
					columnField,
					rowField,
					columnIndex: i,
					rowIndex: j,
					columnValuesLength,
					rowValuesLength
				};
				rst.push(facet);
			}
		}
		return rst;
	};
	/**
	* 设置 x 坐标轴的文本、title 是否显示
	* @param x
	* @param axes
	* @param option
	* @param facet
	*/
	Matrix$1.prototype.getXAxisOption = function(x, axes, option, facet) {
		if (facet.rowIndex !== facet.rowValuesLength - 1) return __assign(__assign({}, option), {
			label: null,
			title: null
		});
		return option;
	};
	/**
	* 设置 y 坐标轴的文本、title 是否显示
	* @param y
	* @param axes
	* @param option
	* @param facet
	*/
	Matrix$1.prototype.getYAxisOption = function(y, axes, option, facet) {
		if (facet.columnIndex !== 0) return __assign(__assign({}, option), {
			title: null,
			label: null
		});
		return option;
	};
	/**
	* facet title
	*/
	Matrix$1.prototype.renderTitle = function() {
		var _this = this;
		each_default(this.facets, function(facet, facetIndex) {
			var columnIndex = facet.columnIndex, rowIndex = facet.rowIndex, columnValuesLength = facet.columnValuesLength;
			facet.rowValuesLength;
			var columnValue = facet.columnValue, rowValue = facet.rowValue, view = facet.view;
			if (rowIndex === 0) {
				var formatter = get_default(_this.cfg.columnTitle, "formatter");
				var config = deep_mix_default({
					position: ["50%", "0%"],
					content: formatter ? formatter(columnValue) : columnValue
				}, getFactTitleConfig(DIRECTION.TOP), _this.cfg.columnTitle);
				view.annotation().text(config);
			}
			if (columnIndex === columnValuesLength - 1) {
				var formatter = get_default(_this.cfg.rowTitle, "formatter");
				var config = deep_mix_default({
					position: ["100%", "50%"],
					content: formatter ? formatter(rowValue) : rowValue
				}, getFactTitleConfig(DIRECTION.RIGHT), _this.cfg.rowTitle);
				view.annotation().text(config);
			}
		});
	};
	return Matrix$1;
}(Facet$1);
var matrix_default = Matrix;

//#endregion
//#region node_modules/@antv/g2/esm/facet/mirror.js
/**
* @ignore
* 镜像分面
*/
var Mirror = function(_super) {
	__extends(Mirror$1, _super);
	function Mirror$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	Mirror$1.prototype.getDefaultCfg = function() {
		return deep_mix_default({}, _super.prototype.getDefaultCfg.call(this), {
			type: "mirror",
			showTitle: true,
			title: _super.prototype.getDefaultTitleCfg.call(this),
			transpose: false
		});
	};
	Mirror$1.prototype.render = function() {
		_super.prototype.render.call(this);
		if (this.cfg.showTitle) this.renderTitle();
	};
	Mirror$1.prototype.beforeEachView = function(view, facet) {
		if (this.cfg.transpose) if (facet.columnIndex % 2 === 0) view.coordinate().transpose().reflect("x");
		else view.coordinate().transpose();
		else if (facet.rowIndex % 2 !== 0) view.coordinate().reflect("y");
	};
	Mirror$1.prototype.afterEachView = function(view, facet) {
		this.processAxis(view, facet);
	};
	Mirror$1.prototype.generateFacets = function(data$2) {
		var _this = this;
		var _a$5 = __read(this.cfg.fields, 1), f = _a$5[0];
		var rst = [];
		var columnValuesLength = 1;
		var rowValuesLength = 1;
		var columnValues = [""];
		var rowValues = [""];
		var columnField;
		var rowField;
		if (this.cfg.transpose) {
			columnField = f;
			columnValues = this.getFieldValues(data$2, columnField).slice(0, 2);
			columnValuesLength = columnValues.length;
		} else {
			rowField = f;
			rowValues = this.getFieldValues(data$2, rowField).slice(0, 2);
			rowValuesLength = rowValues.length;
		}
		columnValues.forEach(function(xVal, xIndex) {
			rowValues.forEach(function(yVal, yIndex) {
				var conditions = [{
					field: columnField,
					value: xVal,
					values: columnValues
				}, {
					field: rowField,
					value: yVal,
					values: rowValues
				}];
				var facetData = filter_default(data$2, _this.getFacetDataFilter(conditions));
				var facet = {
					type: _this.cfg.type,
					data: facetData,
					region: _this.getRegion(rowValuesLength, columnValuesLength, xIndex, yIndex),
					columnValue: xVal,
					rowValue: yVal,
					columnField,
					rowField,
					columnIndex: xIndex,
					rowIndex: yIndex,
					columnValuesLength,
					rowValuesLength
				};
				rst.push(facet);
			});
		});
		return rst;
	};
	/**
	* 设置 x 坐标轴的文本、title 是否显示
	* @param x
	* @param axes
	* @param option
	* @param facet
	*/
	Mirror$1.prototype.getXAxisOption = function(x, axes, option, facet) {
		if (facet.columnIndex === 1 || facet.rowIndex === 1) return __assign(__assign({}, option), {
			label: null,
			title: null
		});
		return option;
	};
	/**
	* 设置 y 坐标轴的文本、title 是否显示
	* @param y
	* @param axes
	* @param option
	* @param facet
	*/
	Mirror$1.prototype.getYAxisOption = function(y, axes, option, facet) {
		return option;
	};
	Mirror$1.prototype.renderTitle = function() {
		var _this = this;
		each_default(this.facets, function(facet, facetIndex) {
			var columnValue = facet.columnValue, rowValue = facet.rowValue, view = facet.view;
			var formatter = get_default(_this.cfg.title, "formatter");
			if (_this.cfg.transpose) {
				var config = deep_mix_default({
					position: ["50%", "0%"],
					content: formatter ? formatter(columnValue) : columnValue
				}, getFactTitleConfig(DIRECTION.TOP), _this.cfg.title);
				view.annotation().text(config);
			} else {
				var config = deep_mix_default({
					position: ["100%", "50%"],
					content: formatter ? formatter(rowValue) : rowValue
				}, getFactTitleConfig(DIRECTION.RIGHT), _this.cfg.title);
				view.annotation().text(config);
			}
		});
	};
	return Mirror$1;
}(Facet$1);
var mirror_default = Mirror;

//#endregion
//#region node_modules/@antv/g2/esm/facet/rect.js
/**
* @ignore
* 矩阵分面
*/
var Rect = function(_super) {
	__extends(Rect$3, _super);
	function Rect$3() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	Rect$3.prototype.afterEachView = function(view, facet) {
		this.processAxis(view, facet);
	};
	Rect$3.prototype.beforeEachView = function(view, facet) {};
	Rect$3.prototype.getDefaultCfg = function() {
		return deep_mix_default({}, _super.prototype.getDefaultCfg.call(this), {
			type: "rect",
			columnTitle: __assign({}, _super.prototype.getDefaultTitleCfg.call(this)),
			rowTitle: __assign({}, _super.prototype.getDefaultTitleCfg.call(this))
		});
	};
	Rect$3.prototype.render = function() {
		_super.prototype.render.call(this);
		if (this.cfg.showTitle) this.renderTitle();
	};
	/**
	* 生成矩阵分面的分面数据
	* @param data
	*/
	Rect$3.prototype.generateFacets = function(data$2) {
		var _this = this;
		var _a$5 = __read(this.cfg.fields, 2), columnField = _a$5[0], rowField = _a$5[1];
		var rst = [];
		var columnValuesLength = 1;
		var rowValuesLength = 1;
		var columnValues = [""];
		var rowValues = [""];
		if (columnField) {
			columnValues = this.getFieldValues(data$2, columnField);
			columnValuesLength = columnValues.length;
		}
		if (rowField) {
			rowValues = this.getFieldValues(data$2, rowField);
			rowValuesLength = rowValues.length;
		}
		columnValues.forEach(function(xVal, xIndex) {
			rowValues.forEach(function(yVal, yIndex) {
				var conditions = [{
					field: columnField,
					value: xVal,
					values: columnValues
				}, {
					field: rowField,
					value: yVal,
					values: rowValues
				}];
				var facetData = filter_default(data$2, _this.getFacetDataFilter(conditions));
				var facet = {
					type: _this.cfg.type,
					data: facetData,
					region: _this.getRegion(rowValuesLength, columnValuesLength, xIndex, yIndex),
					columnValue: xVal,
					rowValue: yVal,
					columnField,
					rowField,
					columnIndex: xIndex,
					rowIndex: yIndex,
					columnValuesLength,
					rowValuesLength
				};
				rst.push(facet);
			});
		});
		return rst;
	};
	Rect$3.prototype.renderTitle = function() {
		var _this = this;
		each_default(this.facets, function(facet, facetIndex) {
			var columnIndex = facet.columnIndex, rowIndex = facet.rowIndex, columnValuesLength = facet.columnValuesLength, columnValue = facet.columnValue, rowValue = facet.rowValue, view = facet.view;
			if (rowIndex === 0) {
				var formatter = get_default(_this.cfg.columnTitle, "formatter");
				var config = deep_mix_default({
					position: ["50%", "0%"],
					content: formatter ? formatter(columnValue) : columnValue
				}, getFactTitleConfig(DIRECTION.TOP), _this.cfg.columnTitle);
				view.annotation().text(config);
			}
			if (columnIndex === columnValuesLength - 1) {
				var formatter = get_default(_this.cfg.rowTitle, "formatter");
				var config = deep_mix_default({
					position: ["100%", "50%"],
					content: formatter ? formatter(rowValue) : rowValue
				}, getFactTitleConfig(DIRECTION.RIGHT), _this.cfg.rowTitle);
				view.annotation().text(config);
			}
		});
	};
	/**
	* 设置 x 坐标轴的文本、title 是否显示
	* @param x
	* @param axes
	* @param option
	* @param facet
	*/
	Rect$3.prototype.getXAxisOption = function(x, axes, option, facet) {
		if (facet.rowIndex !== facet.rowValuesLength - 1) return __assign(__assign({}, option), {
			title: null,
			label: null
		});
		else if (facet.columnIndex !== Math.floor((facet.columnValuesLength - 1) / 2)) return __assign(__assign({}, option), { title: null });
		return option;
	};
	/**
	* 设置 y 坐标轴的文本、title 是否显示
	* @param y
	* @param axes
	* @param option
	* @param facet
	*/
	Rect$3.prototype.getYAxisOption = function(y, axes, option, facet) {
		if (facet.columnIndex !== 0) return __assign(__assign({}, option), {
			title: null,
			label: null
		});
		else if (facet.rowIndex !== Math.floor((facet.rowValuesLength - 1) / 2)) return __assign(__assign({}, option), { title: null });
		return option;
	};
	return Rect$3;
}(Facet$1);
var rect_default = Rect;

//#endregion
//#region node_modules/@antv/g2/esm/facet/tree.js
/**
* @ignore
* Tree Facet
*/
var Tree = function(_super) {
	__extends(Tree$1, _super);
	function Tree$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.afterChartRender = function() {
			if (_this.facets && _this.cfg.line) {
				_this.container.clear();
				_this.drawLines(_this.facets);
			}
		};
		return _this;
	}
	Tree$1.prototype.afterEachView = function(view, facet) {
		this.processAxis(view, facet);
	};
	Tree$1.prototype.beforeEachView = function(view, facet) {};
	Tree$1.prototype.init = function() {
		_super.prototype.init.call(this);
		this.view.on(VIEW_LIFE_CIRCLE.AFTER_RENDER, this.afterChartRender);
	};
	Tree$1.prototype.getDefaultCfg = function() {
		return deep_mix_default({}, _super.prototype.getDefaultCfg.call(this), {
			type: "tree",
			line: {
				style: {
					lineWidth: 1,
					stroke: "#ddd"
				},
				smooth: false
			},
			showTitle: true,
			title: _super.prototype.getDefaultTitleCfg.call(this)
		});
	};
	Tree$1.prototype.generateFacets = function(data$2) {
		if (!this.cfg.fields.length) throw new Error("Please specify for the fields for rootFacet!");
		var rst = [];
		var rootFacet = {
			type: this.cfg.type,
			data: data$2,
			region: null,
			rowValuesLength: this.getRows(),
			columnValuesLength: 1,
			rowIndex: 0,
			columnIndex: 0,
			rowField: "",
			columnField: "",
			rowValue: "",
			columnValue: ""
		};
		rst.push(rootFacet);
		rootFacet.children = this.getChildFacets(data$2, 1, rst);
		this.setRegion(rst);
		return rst;
	};
	Tree$1.prototype.setRegion = function(facets) {
		var _this = this;
		this.forceColIndex(facets);
		facets.forEach(function(facet) {
			facet.region = _this.getRegion(facet.rowValuesLength, facet.columnValuesLength, facet.columnIndex, facet.rowIndex);
		});
	};
	Tree$1.prototype.getRegion = function(rows, cols, xIndex, yIndex) {
		var xWidth = 1 / cols;
		var yWidth = 1 / rows;
		var start = {
			x: xWidth * xIndex,
			y: yWidth * yIndex
		};
		var end = {
			x: start.x + xWidth,
			y: start.y + yWidth * 2 / 3
		};
		return {
			start,
			end
		};
	};
	Tree$1.prototype.forceColIndex = function(facets) {
		var e_1, _a$5;
		var _this = this;
		var leafs = [];
		var index = 0;
		facets.forEach(function(facet$1) {
			if (_this.isLeaf(facet$1)) {
				leafs.push(facet$1);
				facet$1.columnIndex = index;
				index++;
			}
		});
		leafs.forEach(function(facet$1) {
			facet$1.columnValuesLength = leafs.length;
		});
		for (var i = this.cfg.fields.length - 1; i >= 0; i--) {
			var levelFacets = this.getFacetsByLevel(facets, i);
			try {
				for (var levelFacets_1 = (e_1 = void 0, __values(levelFacets)), levelFacets_1_1 = levelFacets_1.next(); !levelFacets_1_1.done; levelFacets_1_1 = levelFacets_1.next()) {
					var facet = levelFacets_1_1.value;
					if (!this.isLeaf(facet)) {
						facet.originColIndex = facet.columnIndex;
						facet.columnIndex = this.getRegionIndex(facet.children);
						facet.columnValuesLength = leafs.length;
					}
				}
			} catch (e_1_1) {
				e_1 = { error: e_1_1 };
			} finally {
				try {
					if (levelFacets_1_1 && !levelFacets_1_1.done && (_a$5 = levelFacets_1.return)) _a$5.call(levelFacets_1);
				} finally {
					if (e_1) throw e_1.error;
				}
			}
		}
	};
	Tree$1.prototype.getFacetsByLevel = function(facets, level) {
		var rst = [];
		facets.forEach(function(facet) {
			if (facet.rowIndex === level) rst.push(facet);
		});
		return rst;
	};
	Tree$1.prototype.getRegionIndex = function(children) {
		var first = children[0];
		return (children[children.length - 1].columnIndex - first.columnIndex) / 2 + first.columnIndex;
	};
	Tree$1.prototype.isLeaf = function(facet) {
		return !facet.children || !facet.children.length;
	};
	Tree$1.prototype.getRows = function() {
		return this.cfg.fields.length + 1;
	};
	Tree$1.prototype.getChildFacets = function(data$2, level, arr) {
		var _this = this;
		var fields = this.cfg.fields;
		if (fields.length < level) return;
		var rst = [];
		var field$5 = fields[level - 1];
		var values$1 = this.getFieldValues(data$2, field$5);
		values$1.forEach(function(value$1, index) {
			var conditions = [{
				field: field$5,
				value: value$1,
				values: values$1
			}];
			var subData = data$2.filter(_this.getFacetDataFilter(conditions));
			if (subData.length) {
				var facet = {
					type: _this.cfg.type,
					data: subData,
					region: null,
					columnValue: value$1,
					rowValue: "",
					columnField: field$5,
					rowField: "",
					columnIndex: index,
					rowValuesLength: _this.getRows(),
					columnValuesLength: 1,
					rowIndex: level,
					children: _this.getChildFacets(subData, level + 1, arr)
				};
				rst.push(facet);
				arr.push(facet);
			}
		});
		return rst;
	};
	Tree$1.prototype.render = function() {
		_super.prototype.render.call(this);
		if (this.cfg.showTitle) this.renderTitle();
	};
	Tree$1.prototype.renderTitle = function() {
		var _this = this;
		each_default(this.facets, function(facet) {
			var columnValue = facet.columnValue, view = facet.view;
			var formatter = get_default(_this.cfg.title, "formatter");
			var config = deep_mix_default({
				position: ["50%", "0%"],
				content: formatter ? formatter(columnValue) : columnValue
			}, getFactTitleConfig(DIRECTION.TOP), _this.cfg.title);
			view.annotation().text(config);
		});
	};
	Tree$1.prototype.drawLines = function(facets) {
		var _this = this;
		facets.forEach(function(facet) {
			if (!_this.isLeaf(facet)) {
				var children = facet.children;
				_this.addFacetLines(facet, children);
			}
		});
	};
	Tree$1.prototype.addFacetLines = function(facet, children) {
		var _this = this;
		var region = facet.view.coordinateBBox;
		var start = {
			x: region.x + region.width / 2,
			y: region.y + region.height
		};
		children.forEach(function(subFacet) {
			var subRegion = subFacet.view.coordinateBBox;
			var end = {
				x: subRegion.bl.x + (subRegion.tr.x - subRegion.bl.x) / 2,
				y: subRegion.tr.y
			};
			var middle1 = {
				x: start.x,
				y: start.y + (end.y - start.y) / 2
			};
			var middle2 = {
				x: end.x,
				y: middle1.y
			};
			_this.drawLine([
				start,
				middle1,
				middle2,
				end
			]);
		});
	};
	Tree$1.prototype.getPath = function(points) {
		var path = [];
		if (this.cfg.line.smooth) {
			path.push([
				"M",
				points[0].x,
				points[0].y
			]);
			path.push([
				"C",
				points[1].x,
				points[1].y,
				points[2].x,
				points[2].y,
				points[3].x,
				points[3].y
			]);
		} else points.forEach(function(point$1, index) {
			if (index === 0) path.push([
				"M",
				point$1.x,
				point$1.y
			]);
			else path.push([
				"L",
				point$1.x,
				point$1.y
			]);
		});
		return path;
	};
	Tree$1.prototype.drawLine = function(points) {
		var path = this.getPath(points);
		var line$1 = this.cfg.line.style;
		this.container.addShape("path", { attrs: mix({ path }, line$1) });
	};
	Tree$1.prototype.getXAxisOption = function(x, axes, option, facet) {
		if (facet.rowIndex !== facet.rowValuesLength - 1) return __assign(__assign({}, option), {
			title: null,
			label: null
		});
		return option;
	};
	Tree$1.prototype.getYAxisOption = function(y, axes, option, facet) {
		if (facet.originColIndex !== 0 && facet.columnIndex !== 0) return __assign(__assign({}, option), {
			title: null,
			label: null
		});
		return option;
	};
	return Tree$1;
}(Facet$1);
var tree_default$1 = Tree;

//#endregion
//#region node_modules/@antv/g2/esm/util/stat.js
/**
* 获得中位数
* @param array
*/
function getMedian(array) {
	var arr = __spreadArray([], __read(array), false);
	arr.sort(function(a, b) {
		return a - b;
	});
	var len = arr.length;
	if (len === 0) return 0;
	if (len % 2 === 1) return arr[(len - 1) / 2];
	return (arr[len / 2] + arr[len / 2 - 1]) / 2;
}
/**
* 获得平均值
* @param array
*/
function getMean(array) {
	var sum = reduce_default(array, function(r, num) {
		return r += isNaN(num) || !is_number_default(num) ? 0 : num;
	}, 0);
	return array.length === 0 ? 0 : sum / array.length;
}

//#endregion
//#region node_modules/@antv/g2/esm/util/annotation.js
/**
* parse the value position
* @param val
* @param scale
*/
function getNormalizedValue(val, scale$4) {
	if (!scale$4) return null;
	var scaled;
	switch (val) {
		case "start": return 0;
		case "center": return .5;
		case "end": return 1;
		case "median":
			scaled = scale$4.isCategory ? getMedian(scale$4.values.map(function(_, idx) {
				return idx;
			})) : getMedian(scale$4.values);
			break;
		case "mean":
			scaled = scale$4.isCategory ? (scale$4.values.length - 1) / 2 : getMean(scale$4.values);
			break;
		case "min":
			scaled = scale$4.isCategory ? 0 : scale$4[val];
			break;
		case "max":
			scaled = scale$4.isCategory ? scale$4.values.length - 1 : scale$4[val];
			break;
		default:
			scaled = val;
			break;
	}
	return scale$4.scale(scaled);
}

//#endregion
//#region node_modules/@antv/g2/esm/chart/controller/annotation.js
/** 需要在图形绘制完成后才渲染的辅助组件类型列表 */
var ANNOTATIONS_AFTER_RENDER = ["regionFilter", "shape"];
/**
* Annotation controller, 主要作用:
* 1. 创建 Annotation: line、text、arc ...
* 2. 生命周期: init、layout、render、clear、destroy
*/
var Annotation = function(_super) {
	__extends(Annotation$1, _super);
	function Annotation$1(view) {
		var _this = _super.call(this, view) || this;
		_this.cache = /* @__PURE__ */ new Map();
		_this.foregroundContainer = _this.view.getLayer(LAYER.FORE).addGroup();
		_this.backgroundContainer = _this.view.getLayer(LAYER.BG).addGroup();
		_this.option = [];
		return _this;
	}
	Object.defineProperty(Annotation$1.prototype, "name", {
		get: function() {
			return "annotation";
		},
		enumerable: false,
		configurable: true
	});
	Annotation$1.prototype.init = function() {};
	/**
	* 因为 annotation 需要依赖坐标系信息，所以 render 阶段为空方法，实际的创建逻辑都在 layout 中
	*/
	Annotation$1.prototype.layout = function() {
		this.update();
	};
	Annotation$1.prototype.render = function() {};
	/**
	* 更新
	*/
	Annotation$1.prototype.update = function() {
		var _this = this;
		this.onAfterRender(function() {
			var updated = /* @__PURE__ */ new Map();
			each_default(_this.option, function(option) {
				if (contains_default(ANNOTATIONS_AFTER_RENDER, option.type)) {
					var co = _this.updateOrCreate(option);
					if (co) updated.set(_this.getCacheKey(option), co);
				}
			});
			_this.cache = _this.syncCache(updated);
		});
		var updateCache = /* @__PURE__ */ new Map();
		each_default(this.option, function(option) {
			if (!contains_default(ANNOTATIONS_AFTER_RENDER, option.type)) {
				var co = _this.updateOrCreate(option);
				if (co) updateCache.set(_this.getCacheKey(option), co);
			}
		});
		this.cache = this.syncCache(updateCache);
	};
	/**
	* 清空
	* @param includeOption 是否清空 option 配置项
	*/
	Annotation$1.prototype.clear = function(includeOption) {
		if (includeOption === void 0) includeOption = false;
		_super.prototype.clear.call(this);
		this.clearComponents();
		this.foregroundContainer.clear();
		this.backgroundContainer.clear();
		if (includeOption) this.option = [];
	};
	Annotation$1.prototype.destroy = function() {
		this.clear(true);
		this.foregroundContainer.remove(true);
		this.backgroundContainer.remove(true);
	};
	/**
	* 复写基类的方法
	*/
	Annotation$1.prototype.getComponents = function() {
		var co = [];
		this.cache.forEach(function(value$1) {
			co.push(value$1);
		});
		return co;
	};
	/**
	* 清除当前的组件
	*/
	Annotation$1.prototype.clearComponents = function() {
		this.getComponents().forEach(function(co) {
			co.component.destroy();
		});
		this.cache.clear();
	};
	/**
	* region filter 比较特殊的渲染时机
	* @param doWhat
	*/
	Annotation$1.prototype.onAfterRender = function(doWhat) {
		var done = false;
		if (this.view.getOptions().animate) this.view.geometries.forEach(function(g) {
			if (g.animateOption) {
				g.once(GEOMETRY_LIFE_CIRCLE.AFTER_DRAW_ANIMATE, function() {
					doWhat();
				});
				done = true;
			}
		});
		if (!done) this.view.getRootView().once(VIEW_LIFE_CIRCLE.AFTER_RENDER, function() {
			doWhat();
		});
	};
	Annotation$1.prototype.createAnnotation = function(option) {
		var type = option.type;
		var Ctor = annotation_exports[upper_first_default(type)];
		if (Ctor) {
			var theme$3 = this.getAnnotationTheme(type);
			var cfg = this.getAnnotationCfg(type, option, theme$3);
			if (!cfg) return null;
			return {
				component: new Ctor(cfg),
				layer: this.isTop(cfg) ? LAYER.FORE : LAYER.BG,
				direction: DIRECTION.NONE,
				type: COMPONENT_TYPE.ANNOTATION,
				extra: option
			};
		}
	};
	Annotation$1.prototype.annotation = function(option) {
		this.option.push(option);
	};
	/**
	* 创建 Arc
	* @param option
	* @returns AnnotationController
	*/
	Annotation$1.prototype.arc = function(option) {
		this.annotation(__assign({ type: "arc" }, option));
		return this;
	};
	/**
	* 创建 image
	* @param option
	* @returns AnnotationController
	*/
	Annotation$1.prototype.image = function(option) {
		this.annotation(__assign({ type: "image" }, option));
		return this;
	};
	/**
	* 创建 Line
	* @param option
	* @returns AnnotationController
	*/
	Annotation$1.prototype.line = function(option) {
		this.annotation(__assign({ type: "line" }, option));
		return this;
	};
	/**
	* 创建 Region
	* @param option
	* @returns AnnotationController
	*/
	Annotation$1.prototype.region = function(option) {
		this.annotation(__assign({ type: "region" }, option));
		return this;
	};
	/**
	* 创建 Text
	* @param option
	* @returns AnnotationController
	*/
	Annotation$1.prototype.text = function(option) {
		this.annotation(__assign({ type: "text" }, option));
		return this;
	};
	/**
	* 创建 DataMarker
	* @param option
	* @returns AnnotationController
	*/
	Annotation$1.prototype.dataMarker = function(option) {
		this.annotation(__assign({ type: "dataMarker" }, option));
		return this;
	};
	/**
	* 创建 DataRegion
	* @param option
	* @returns AnnotationController
	*/
	Annotation$1.prototype.dataRegion = function(option) {
		this.annotation(__assign({ type: "dataRegion" }, option));
	};
	/**
	* 创建 RegionFilter
	* @param option
	* @returns AnnotationController
	*/
	Annotation$1.prototype.regionFilter = function(option) {
		this.annotation(__assign({ type: "regionFilter" }, option));
	};
	/**
	* 创建 ShapeAnnotation
	* @param option
	*/
	Annotation$1.prototype.shape = function(option) {
		this.annotation(__assign({ type: "shape" }, option));
	};
	/**
	* 创建 HtmlAnnotation
	* @param option
	*/
	Annotation$1.prototype.html = function(option) {
		this.annotation(__assign({ type: "html" }, option));
	};
	/**
	* parse the point position to [x, y]
	* @param p Position
	* @returns { x, y }
	*/
	Annotation$1.prototype.parsePosition = function(p) {
		var e_1, _a$5;
		var xScale = this.view.getXScale();
		var yScales = this.view.getScalesByDim("y");
		var position = is_function_default(p) ? p.call(null, xScale, yScales) : p;
		var x = 0;
		var y = 0;
		if (is_array_default(position)) {
			var _b = __read(position, 2), xPos = _b[0], yPos = _b[1];
			if (is_string_default(xPos) && xPos.indexOf("%") !== -1 && !isNaN(xPos.slice(0, -1))) return this.parsePercentPosition(position);
			x = getNormalizedValue(xPos, xScale);
			y = getNormalizedValue(yPos, Object.values(yScales)[0]);
		} else if (!is_nil_default(position)) try {
			for (var _c = __values(keys_default(position)), _d = _c.next(); !_d.done; _d = _c.next()) {
				var key = _d.value;
				var value$1 = position[key];
				if (key === xScale.field) x = getNormalizedValue(value$1, xScale);
				if (yScales[key]) y = getNormalizedValue(value$1, yScales[key]);
			}
		} catch (e_1_1) {
			e_1 = { error: e_1_1 };
		} finally {
			try {
				if (_d && !_d.done && (_a$5 = _c.return)) _a$5.call(_c);
			} finally {
				if (e_1) throw e_1.error;
			}
		}
		if (isNaN(x) || isNaN(y)) return null;
		return this.view.getCoordinate().convert({
			x,
			y
		});
	};
	/**
	* parse all the points between start and end
	* @param start
	* @param end
	* @return Point[]
	*/
	Annotation$1.prototype.getRegionPoints = function(start, end) {
		var _this = this;
		var xScale = this.view.getXScale();
		var yScales = this.view.getScalesByDim("y");
		var yScale = Object.values(yScales)[0];
		var xField = xScale.field;
		var viewData = this.view.getData();
		var startXValue = is_array_default(start) ? start[0] : start[xField];
		var endXValue = is_array_default(end) ? end[0] : end[xField];
		var arr = [];
		var startIndex;
		each_default(viewData, function(item, idx) {
			if (item[xField] === startXValue) startIndex = idx;
			if (idx >= startIndex) {
				var point$1 = _this.parsePosition([item[xField], item[yScale.field]]);
				if (point$1) arr.push(point$1);
			}
			if (item[xField] === endXValue) return false;
		});
		return arr;
	};
	/**
	* parse percent position
	* @param position
	*/
	Annotation$1.prototype.parsePercentPosition = function(position) {
		var xPercent = parseFloat(position[0]) / 100;
		var yPercent = parseFloat(position[1]) / 100;
		var coordinate$10 = this.view.getCoordinate();
		var start = coordinate$10.start, end = coordinate$10.end;
		var topLeft = {
			x: Math.min(start.x, end.x),
			y: Math.min(start.y, end.y)
		};
		var x = coordinate$10.getWidth() * xPercent + topLeft.x;
		var y = coordinate$10.getHeight() * yPercent + topLeft.y;
		return {
			x,
			y
		};
	};
	/**
	* get coordinate bbox
	*/
	Annotation$1.prototype.getCoordinateBBox = function() {
		var coordinate$10 = this.view.getCoordinate();
		var start = coordinate$10.start, end = coordinate$10.end;
		var width = coordinate$10.getWidth();
		var height = coordinate$10.getHeight();
		var topLeft = {
			x: Math.min(start.x, end.x),
			y: Math.min(start.y, end.y)
		};
		return {
			x: topLeft.x,
			y: topLeft.y,
			minX: topLeft.x,
			minY: topLeft.y,
			maxX: topLeft.x + width,
			maxY: topLeft.y + height,
			width,
			height
		};
	};
	/**
	* get annotation component config by different type
	* @param type
	* @param option 用户的配置
	* @param theme
	*/
	Annotation$1.prototype.getAnnotationCfg = function(type, option, theme$3) {
		var _this = this;
		var coordinate$10 = this.view.getCoordinate();
		var canvas = this.view.getCanvas();
		var o = {};
		if (is_nil_default(option)) return null;
		var start = option.start, end = option.end, position = option.position;
		var sp = this.parsePosition(start);
		var ep = this.parsePosition(end);
		var textPoint = this.parsePosition(position);
		if ([
			"arc",
			"image",
			"line",
			"region",
			"regionFilter"
		].includes(type) && (!sp || !ep)) return null;
		else if ([
			"text",
			"dataMarker",
			"html"
		].includes(type) && !textPoint) return null;
		if (type === "arc") {
			var _a$5 = option;
			_a$5.start;
			_a$5.end;
			var rest = __rest(_a$5, ["start", "end"]);
			var startAngle = getAngleByPoint(coordinate$10, sp);
			var endAngle = getAngleByPoint(coordinate$10, ep);
			if (startAngle > endAngle) endAngle = Math.PI * 2 + endAngle;
			o = __assign(__assign({}, rest), {
				center: coordinate$10.getCenter(),
				radius: getDistanceToCenter(coordinate$10, sp),
				startAngle,
				endAngle
			});
		} else if (type === "image") {
			var _b = option;
			_b.start;
			_b.end;
			var rest = __rest(_b, ["start", "end"]);
			o = __assign(__assign({}, rest), {
				start: sp,
				end: ep,
				src: option.src
			});
		} else if (type === "line") {
			var _c = option;
			_c.start;
			_c.end;
			var rest = __rest(_c, ["start", "end"]);
			o = __assign(__assign({}, rest), {
				start: sp,
				end: ep,
				text: get_default(option, "text", null)
			});
		} else if (type === "region") {
			var _d = option;
			_d.start;
			_d.end;
			var rest = __rest(_d, ["start", "end"]);
			o = __assign(__assign({}, rest), {
				start: sp,
				end: ep
			});
		} else if (type === "text") {
			var filteredData = this.view.getData(), _e = option;
			_e.position;
			var content = _e.content, rest = __rest(_e, ["position", "content"]);
			var textContent = content;
			if (is_function_default(content)) textContent = content(filteredData);
			o = __assign(__assign(__assign({}, textPoint), rest), { content: textContent });
		} else if (type === "dataMarker") {
			var _f = option;
			_f.position;
			var point$1 = _f.point, line$1 = _f.line, text = _f.text, autoAdjust = _f.autoAdjust, direction$1 = _f.direction, rest = __rest(_f, [
				"position",
				"point",
				"line",
				"text",
				"autoAdjust",
				"direction"
			]);
			o = __assign(__assign(__assign({}, rest), textPoint), {
				coordinateBBox: this.getCoordinateBBox(),
				point: point$1,
				line: line$1,
				text,
				autoAdjust,
				direction: direction$1
			});
		} else if (type === "dataRegion") {
			var _g = option, start_5 = _g.start, end_5 = _g.end, region = _g.region, text = _g.text, lineLength = _g.lineLength, rest = __rest(_g, [
				"start",
				"end",
				"region",
				"text",
				"lineLength"
			]);
			o = __assign(__assign({}, rest), {
				points: this.getRegionPoints(start_5, end_5),
				region,
				text,
				lineLength
			});
		} else if (type === "regionFilter") {
			var _h = option;
			_h.start;
			_h.end;
			var apply_1 = _h.apply, color$2 = _h.color, rest = __rest(_h, [
				"start",
				"end",
				"apply",
				"color"
			]);
			var geometries = this.view.geometries;
			var shapes_1 = [];
			var addShapes_1 = function(item) {
				if (!item) return;
				if (item.isGroup()) item.getChildren().forEach(function(child) {
					return addShapes_1(child);
				});
				else shapes_1.push(item);
			};
			each_default(geometries, function(geom) {
				if (apply_1) {
					if (contains_default(apply_1, geom.type)) each_default(geom.elements, function(elem) {
						addShapes_1(elem.shape);
					});
				} else each_default(geom.elements, function(elem) {
					addShapes_1(elem.shape);
				});
			});
			o = __assign(__assign({}, rest), {
				color: color$2,
				shapes: shapes_1,
				start: sp,
				end: ep
			});
		} else if (type === "shape") {
			var _j = option, render_1 = _j.render, restOptions = __rest(_j, ["render"]);
			var wrappedRender = function(container) {
				if (is_function_default(option.render)) return render_1(container, _this.view, { parsePosition: _this.parsePosition.bind(_this) });
			};
			o = __assign(__assign({}, restOptions), { render: wrappedRender });
		} else if (type === "html") {
			var _k = option, html_1 = _k.html;
			_k.position;
			var restOptions = __rest(_k, ["html", "position"]);
			var wrappedHtml = function(container) {
				if (is_function_default(html_1)) return html_1(container, _this.view);
				return html_1;
			};
			o = __assign(__assign(__assign({}, restOptions), textPoint), {
				parent: canvas.get("el").parentNode,
				html: wrappedHtml
			});
		}
		var cfg = deep_mix_default({}, theme$3, __assign(__assign({}, o), {
			top: option.top,
			style: option.style,
			offsetX: option.offsetX,
			offsetY: option.offsetY
		}));
		if (type !== "html") cfg.container = this.getComponentContainer(cfg);
		cfg.animate = this.view.getOptions().animate && cfg.animate && get_default(option, "animate", cfg.animate);
		cfg.animateOption = deep_mix_default({}, DEFAULT_ANIMATE_CFG, cfg.animateOption, option.animateOption);
		return cfg;
	};
	/**
	* is annotation render on top
	* @param option
	* @return whethe on top
	*/
	Annotation$1.prototype.isTop = function(option) {
		return get_default(option, "top", true);
	};
	/**
	* get the container by option.top
	* default is on top
	* @param option
	* @returns the container
	*/
	Annotation$1.prototype.getComponentContainer = function(option) {
		return this.isTop(option) ? this.foregroundContainer : this.backgroundContainer;
	};
	Annotation$1.prototype.getAnnotationTheme = function(type) {
		return get_default(this.view.getTheme(), [
			"components",
			"annotation",
			type
		], {});
	};
	/**
	* 创建或者更新 annotation
	* @param option
	*/
	Annotation$1.prototype.updateOrCreate = function(option) {
		var co = this.cache.get(this.getCacheKey(option));
		if (co) {
			var type = option.type;
			var theme$3 = this.getAnnotationTheme(type);
			var cfg = this.getAnnotationCfg(type, option, theme$3);
			if (cfg) omit(cfg, ["container"]);
			co.component.update(__assign(__assign({}, cfg || {}), { visible: !!cfg }));
			if (contains_default(ANNOTATIONS_AFTER_RENDER, option.type)) co.component.render();
		} else {
			co = this.createAnnotation(option);
			if (co) {
				co.component.init();
				if (contains_default(ANNOTATIONS_AFTER_RENDER, option.type)) co.component.render();
			}
		}
		return co;
	};
	/**
	* 更新缓存，以及销毁组件
	* @param updated 更新或者创建的组件
	*/
	Annotation$1.prototype.syncCache = function(updated) {
		var _this = this;
		var newCache = new Map(this.cache);
		updated.forEach(function(co, key) {
			newCache.set(key, co);
		});
		newCache.forEach(function(co, key) {
			if (!find_default(_this.option, function(option) {
				return key === _this.getCacheKey(option);
			})) {
				co.component.destroy();
				newCache.delete(key);
			}
		});
		return newCache;
	};
	/**
	* 获得缓存组件的 key
	* @param option
	*/
	Annotation$1.prototype.getCacheKey = function(option) {
		return option;
	};
	return Annotation$1;
}(Controller);
var annotation_default = Annotation;

//#endregion
//#region node_modules/@antv/g2/esm/util/grid.js
/**
* @ignore
* get the grid theme by type, will mix the common cfg of axis
* @param theme
* @param direction
* @returns theme object
*/
function getGridThemeCfg(theme$3, direction$1) {
	var axisTheme = deep_mix_default({}, get_default(theme$3, [
		"components",
		"axis",
		"common"
	]), get_default(theme$3, [
		"components",
		"axis",
		direction$1
	]));
	return get_default(axisTheme, ["grid"], {});
}
/**
* @ignore
* get axis grid items
* @param coordinate
* @param scale
* @param dim
* @return items
*/
function getLineGridItems(coordinate$10, scale$4, dim, alignTick) {
	var items = [];
	var ticks = scale$4.getTicks();
	if (coordinate$10.isPolar) ticks.push({
		value: 1,
		text: "",
		tickValue: ""
	});
	ticks.reduce(function(preTick, currentTick, currentIndex) {
		var currentValue = currentTick.value;
		if (alignTick) items.push({ points: [coordinate$10.convert(dim === "y" ? {
			x: 0,
			y: currentValue
		} : {
			x: currentValue,
			y: 0
		}), coordinate$10.convert(dim === "y" ? {
			x: 1,
			y: currentValue
		} : {
			x: currentValue,
			y: 1
		})] });
		else if (currentIndex) {
			var middleValue = (preTick.value + currentValue) / 2;
			items.push({ points: [coordinate$10.convert(dim === "y" ? {
				x: 0,
				y: middleValue
			} : {
				x: middleValue,
				y: 0
			}), coordinate$10.convert(dim === "y" ? {
				x: 1,
				y: middleValue
			} : {
				x: middleValue,
				y: 1
			})] });
		}
		return currentTick;
	}, ticks[0]);
	return items;
}
/**
* @ignore
* get
* @param coordinate
* @param xScale
* @param yScale
* @param dim
* @returns items
*/
function getCircleGridItems(coordinate$10, xScale, yScale, alignTick, dim) {
	var count$1 = xScale.values.length;
	var items = [];
	var ticks = yScale.getTicks();
	ticks.reduce(function(preTick, currentTick) {
		var preValue = preTick ? preTick.value : currentTick.value;
		var currentValue = currentTick.value;
		var middleValue = (preValue + currentValue) / 2;
		if (dim === "x") items.push({ points: [coordinate$10.convert({
			x: alignTick ? currentValue : middleValue,
			y: 0
		}), coordinate$10.convert({
			x: alignTick ? currentValue : middleValue,
			y: 1
		})] });
		else items.push({ points: map_default(Array(count$1 + 1), function(__, idx) {
			return coordinate$10.convert({
				x: idx / count$1,
				y: alignTick ? currentValue : middleValue
			});
		}) });
		return currentTick;
	}, ticks[0]);
	return items;
}
/**
* @ignore
* show grid or not
* @param axisTheme
* @param axisOption
*/
function showGrid(axisTheme, axisOption) {
	var userGrid = get_default(axisOption, "grid");
	if (userGrid === null) return false;
	var themeGrid = get_default(axisTheme, "grid");
	return !(userGrid === void 0 && themeGrid === null);
}

//#endregion
//#region node_modules/@antv/g2/esm/chart/controller/axis.js
var OMIT_CFG = ["container"];
var AXIS_DEFAULT_ANIMATE_CFG = __assign(__assign({}, DEFAULT_ANIMATE_CFG), { appear: null });
/**
* @ignore
* G2 Axis controller, will:
*  - create component
*    - axis
*    - grid
*  - life circle
*/
var Axis = function(_super) {
	__extends(Axis$1, _super);
	function Axis$1(view) {
		var _this = _super.call(this, view) || this;
		/** 使用 object 存储组件 */
		_this.cache = /* @__PURE__ */ new Map();
		_this.gridContainer = _this.view.getLayer(LAYER.BG).addGroup();
		_this.gridForeContainer = _this.view.getLayer(LAYER.FORE).addGroup();
		_this.axisContainer = _this.view.getLayer(LAYER.BG).addGroup();
		_this.axisForeContainer = _this.view.getLayer(LAYER.FORE).addGroup();
		return _this;
	}
	Object.defineProperty(Axis$1.prototype, "name", {
		get: function() {
			return "axis";
		},
		enumerable: false,
		configurable: true
	});
	Axis$1.prototype.init = function() {};
	Axis$1.prototype.render = function() {
		this.update();
	};
	/**
	* 更新组件布局，位置大小
	*/
	Axis$1.prototype.layout = function() {
		var _this = this;
		var coordinate$10 = this.view.getCoordinate();
		each_default(this.getComponents(), function(co) {
			var component$1 = co.component, direction$1 = co.direction, type = co.type, extra = co.extra;
			var dim = extra.dim, scale$4 = extra.scale, alignTick = extra.alignTick;
			var updated;
			if (type === COMPONENT_TYPE.AXIS) if (coordinate$10.isPolar) {
				if (dim === "x") updated = coordinate$10.isTransposed ? getAxisRegion(coordinate$10, direction$1) : getCircleAxisCenterRadius(coordinate$10);
				else if (dim === "y") updated = coordinate$10.isTransposed ? getCircleAxisCenterRadius(coordinate$10) : getAxisRegion(coordinate$10, direction$1);
			} else updated = getAxisRegion(coordinate$10, direction$1);
			else if (type === COMPONENT_TYPE.GRID) if (coordinate$10.isPolar) {
				var items = void 0;
				if (coordinate$10.isTransposed) items = dim === "x" ? getCircleGridItems(coordinate$10, _this.view.getYScales()[0], scale$4, alignTick, dim) : getLineGridItems(coordinate$10, scale$4, dim, alignTick);
				else items = dim === "x" ? getLineGridItems(coordinate$10, scale$4, dim, alignTick) : getCircleGridItems(coordinate$10, _this.view.getXScale(), scale$4, alignTick, dim);
				updated = {
					items,
					center: _this.view.getCoordinate().getCenter()
				};
			} else updated = { items: getLineGridItems(coordinate$10, scale$4, dim, alignTick) };
			component$1.update(updated);
		});
	};
	/**
	* 更新 axis 组件
	*/
	Axis$1.prototype.update = function() {
		this.option = this.view.getOptions().axes;
		var updatedCache = /* @__PURE__ */ new Map();
		this.updateXAxes(updatedCache);
		this.updateYAxes(updatedCache);
		var newCache = /* @__PURE__ */ new Map();
		this.cache.forEach(function(co, key) {
			if (updatedCache.has(key)) newCache.set(key, co);
			else co.component.destroy();
		});
		this.cache = newCache;
	};
	Axis$1.prototype.clear = function() {
		_super.prototype.clear.call(this);
		this.cache.clear();
		this.gridContainer.clear();
		this.gridForeContainer.clear();
		this.axisContainer.clear();
		this.axisForeContainer.clear();
	};
	Axis$1.prototype.destroy = function() {
		_super.prototype.destroy.call(this);
		this.gridContainer.remove(true);
		this.gridForeContainer.remove(true);
		this.axisContainer.remove(true);
		this.axisForeContainer.remove(true);
	};
	/**
	* @override
	*/
	Axis$1.prototype.getComponents = function() {
		var co = [];
		this.cache.forEach(function(value$1) {
			co.push(value$1);
		});
		return co;
	};
	/**
	* 更新 x axis
	* @param updatedCache
	*/
	Axis$1.prototype.updateXAxes = function(updatedCache) {
		var scale$4 = this.view.getXScale();
		if (!scale$4 || scale$4.isIdentity) return;
		var xAxisOption = getAxisOption(this.option, scale$4.field);
		if (xAxisOption === false) return;
		var direction$1 = getAxisDirection(xAxisOption, DIRECTION.BOTTOM);
		var layer = LAYER.BG;
		var dim = "x";
		var coordinate$10 = this.view.getCoordinate();
		var axisId = this.getId("axis", scale$4.field);
		var gridId = this.getId("grid", scale$4.field);
		if (coordinate$10.isRect) {
			var axis$21 = this.cache.get(axisId);
			if (axis$21) {
				var cfg = this.getLineAxisCfg(scale$4, xAxisOption, direction$1);
				omit(cfg, OMIT_CFG);
				axis$21.component.update(cfg);
				updatedCache.set(axisId, axis$21);
			} else {
				axis$21 = this.createLineAxis(scale$4, xAxisOption, layer, direction$1, dim);
				this.cache.set(axisId, axis$21);
				updatedCache.set(axisId, axis$21);
			}
			var grid = this.cache.get(gridId);
			if (grid) {
				var cfg = this.getLineGridCfg(scale$4, xAxisOption, direction$1, dim);
				omit(cfg, OMIT_CFG);
				grid.component.update(cfg);
				updatedCache.set(gridId, grid);
			} else {
				grid = this.createLineGrid(scale$4, xAxisOption, layer, direction$1, dim);
				if (grid) {
					this.cache.set(gridId, grid);
					updatedCache.set(gridId, grid);
				}
			}
		} else if (coordinate$10.isPolar) {
			var axis$21 = this.cache.get(axisId);
			if (axis$21) {
				var cfg = coordinate$10.isTransposed ? this.getLineAxisCfg(scale$4, xAxisOption, DIRECTION.RADIUS) : this.getCircleAxisCfg(scale$4, xAxisOption, direction$1);
				omit(cfg, OMIT_CFG);
				axis$21.component.update(cfg);
				updatedCache.set(axisId, axis$21);
			} else {
				if (coordinate$10.isTransposed) if (is_undefined_default(xAxisOption)) return;
				else axis$21 = this.createLineAxis(scale$4, xAxisOption, layer, DIRECTION.RADIUS, dim);
				else axis$21 = this.createCircleAxis(scale$4, xAxisOption, layer, direction$1, dim);
				this.cache.set(axisId, axis$21);
				updatedCache.set(axisId, axis$21);
			}
			var grid = this.cache.get(gridId);
			if (grid) {
				var cfg = coordinate$10.isTransposed ? this.getCircleGridCfg(scale$4, xAxisOption, DIRECTION.RADIUS, dim) : this.getLineGridCfg(scale$4, xAxisOption, DIRECTION.CIRCLE, dim);
				omit(cfg, OMIT_CFG);
				grid.component.update(cfg);
				updatedCache.set(gridId, grid);
			} else {
				if (coordinate$10.isTransposed) if (is_undefined_default(xAxisOption)) return;
				else grid = this.createCircleGrid(scale$4, xAxisOption, layer, DIRECTION.RADIUS, dim);
				else grid = this.createLineGrid(scale$4, xAxisOption, layer, DIRECTION.CIRCLE, dim);
				if (grid) {
					this.cache.set(gridId, grid);
					updatedCache.set(gridId, grid);
				}
			}
		}
	};
	Axis$1.prototype.updateYAxes = function(updatedCache) {
		var _this = this;
		var yScales = this.view.getYScales();
		each_default(yScales, function(scale$4, idx) {
			if (!scale$4 || scale$4.isIdentity) return;
			var field$5 = scale$4.field;
			var yAxisOption = getAxisOption(_this.option, field$5);
			if (yAxisOption !== false) {
				var layer = LAYER.BG;
				var dim = "y";
				var axisId = _this.getId("axis", field$5);
				var gridId = _this.getId("grid", field$5);
				var coordinate$10 = _this.view.getCoordinate();
				if (coordinate$10.isRect) {
					var direction$1 = getAxisDirection(yAxisOption, idx === 0 ? DIRECTION.LEFT : DIRECTION.RIGHT);
					var axis$21 = _this.cache.get(axisId);
					if (axis$21) {
						var cfg = _this.getLineAxisCfg(scale$4, yAxisOption, direction$1);
						omit(cfg, OMIT_CFG);
						axis$21.component.update(cfg);
						updatedCache.set(axisId, axis$21);
					} else {
						axis$21 = _this.createLineAxis(scale$4, yAxisOption, layer, direction$1, dim);
						_this.cache.set(axisId, axis$21);
						updatedCache.set(axisId, axis$21);
					}
					var grid = _this.cache.get(gridId);
					if (grid) {
						var cfg = _this.getLineGridCfg(scale$4, yAxisOption, direction$1, dim);
						omit(cfg, OMIT_CFG);
						grid.component.update(cfg);
						updatedCache.set(gridId, grid);
					} else {
						grid = _this.createLineGrid(scale$4, yAxisOption, layer, direction$1, dim);
						if (grid) {
							_this.cache.set(gridId, grid);
							updatedCache.set(gridId, grid);
						}
					}
				} else if (coordinate$10.isPolar) {
					var axis$21 = _this.cache.get(axisId);
					if (axis$21) {
						var cfg = coordinate$10.isTransposed ? _this.getCircleAxisCfg(scale$4, yAxisOption, DIRECTION.CIRCLE) : _this.getLineAxisCfg(scale$4, yAxisOption, DIRECTION.RADIUS);
						omit(cfg, OMIT_CFG);
						axis$21.component.update(cfg);
						updatedCache.set(axisId, axis$21);
					} else {
						if (coordinate$10.isTransposed) if (is_undefined_default(yAxisOption)) return;
						else axis$21 = _this.createCircleAxis(scale$4, yAxisOption, layer, DIRECTION.CIRCLE, dim);
						else axis$21 = _this.createLineAxis(scale$4, yAxisOption, layer, DIRECTION.RADIUS, dim);
						_this.cache.set(axisId, axis$21);
						updatedCache.set(axisId, axis$21);
					}
					var grid = _this.cache.get(gridId);
					if (grid) {
						var cfg = coordinate$10.isTransposed ? _this.getLineGridCfg(scale$4, yAxisOption, DIRECTION.CIRCLE, dim) : _this.getCircleGridCfg(scale$4, yAxisOption, DIRECTION.RADIUS, dim);
						omit(cfg, OMIT_CFG);
						grid.component.update(cfg);
						updatedCache.set(gridId, grid);
					} else {
						if (coordinate$10.isTransposed) if (is_undefined_default(yAxisOption)) return;
						else grid = _this.createLineGrid(scale$4, yAxisOption, layer, DIRECTION.CIRCLE, dim);
						else grid = _this.createCircleGrid(scale$4, yAxisOption, layer, DIRECTION.RADIUS, dim);
						if (grid) {
							_this.cache.set(gridId, grid);
							updatedCache.set(gridId, grid);
						}
					}
				}
			}
		});
	};
	/**
	* 创建 line axis
	* @param scale
	* @param option
	* @param layer
	* @param direction
	* @param dim
	*/
	Axis$1.prototype.createLineAxis = function(scale$4, option, layer, direction$1, dim) {
		var axis$21 = {
			component: new LineAxis(this.getLineAxisCfg(scale$4, option, direction$1)),
			layer,
			direction: direction$1 === DIRECTION.RADIUS ? DIRECTION.NONE : direction$1,
			type: COMPONENT_TYPE.AXIS,
			extra: {
				dim,
				scale: scale$4
			}
		};
		axis$21.component.set("field", scale$4.field);
		axis$21.component.init();
		return axis$21;
	};
	Axis$1.prototype.createLineGrid = function(scale$4, option, layer, direction$1, dim) {
		var cfg = this.getLineGridCfg(scale$4, option, direction$1, dim);
		if (cfg) {
			var grid = {
				component: new LineGrid(cfg),
				layer,
				direction: DIRECTION.NONE,
				type: COMPONENT_TYPE.GRID,
				extra: {
					dim,
					scale: scale$4,
					alignTick: get_default(cfg, "alignTick", true)
				}
			};
			grid.component.init();
			return grid;
		}
	};
	Axis$1.prototype.createCircleAxis = function(scale$4, option, layer, direction$1, dim) {
		var axis$21 = {
			component: new CircleAxis(this.getCircleAxisCfg(scale$4, option, direction$1)),
			layer,
			direction: direction$1,
			type: COMPONENT_TYPE.AXIS,
			extra: {
				dim,
				scale: scale$4
			}
		};
		axis$21.component.set("field", scale$4.field);
		axis$21.component.init();
		return axis$21;
	};
	Axis$1.prototype.createCircleGrid = function(scale$4, option, layer, direction$1, dim) {
		var cfg = this.getCircleGridCfg(scale$4, option, direction$1, dim);
		if (cfg) {
			var grid = {
				component: new CircleGrid(cfg),
				layer,
				direction: DIRECTION.NONE,
				type: COMPONENT_TYPE.GRID,
				extra: {
					dim,
					scale: scale$4,
					alignTick: get_default(cfg, "alignTick", true)
				}
			};
			grid.component.init();
			return grid;
		}
	};
	/**
	* generate line axis cfg
	* @param scale
	* @param axisOption
	* @param direction
	* @return line axis cfg
	*/
	Axis$1.prototype.getLineAxisCfg = function(scale$4, axisOption, direction$1) {
		var container = get_default(axisOption, ["top"]) ? this.axisForeContainer : this.axisContainer;
		var coordinate$10 = this.view.getCoordinate();
		var region = getAxisRegion(coordinate$10, direction$1);
		var titleText = getAxisTitleText(scale$4, axisOption);
		var axisThemeCfg = getAxisThemeCfg(this.view.getTheme(), direction$1);
		var optionWithTitle = get_default(axisOption, ["title"]) ? deep_mix_default({ title: { style: { text: titleText } } }, { title: getAxisTitleOptions(this.view.getTheme(), direction$1, axisOption.title) }, axisOption) : axisOption;
		var cfg = deep_mix_default(__assign(__assign({ container }, region), {
			ticks: scale$4.getTicks().map(function(tick) {
				return {
					id: "".concat(tick.tickValue),
					name: tick.text,
					value: tick.value
				};
			}),
			verticalFactor: coordinate$10.isPolar ? getAxisFactorByRegion(region, coordinate$10.getCenter()) * -1 : getAxisFactorByRegion(region, coordinate$10.getCenter()),
			theme: axisThemeCfg
		}), axisThemeCfg, optionWithTitle);
		var _a$5 = this.getAnimateCfg(cfg), animate = _a$5.animate;
		cfg.animateOption = _a$5.animateOption;
		cfg.animate = animate;
		var isAxisVertical = isVertical(region);
		var verticalLimitLength = get_default(cfg, "verticalLimitLength", isAxisVertical ? 1 / 3 : 1 / 2);
		if (verticalLimitLength <= 1) {
			var canvasWidth = this.view.getCanvas().get("width");
			var canvasHeight = this.view.getCanvas().get("height");
			cfg.verticalLimitLength = verticalLimitLength * (isAxisVertical ? canvasWidth : canvasHeight);
		}
		return cfg;
	};
	/**
	* generate line grid cfg
	* @param scale
	* @param axisOption
	* @param direction
	* @param dim
	* @return line grid cfg
	*/
	Axis$1.prototype.getLineGridCfg = function(scale$4, axisOption, direction$1, dim) {
		if (!showGrid(getAxisThemeCfg(this.view.getTheme(), direction$1), axisOption)) return;
		var gridThemeCfg = getGridThemeCfg(this.view.getTheme(), direction$1);
		var gridCfg = deep_mix_default({ container: get_default(axisOption, ["top"]) ? this.gridForeContainer : this.gridContainer }, gridThemeCfg, get_default(axisOption, "grid"), this.getAnimateCfg(axisOption));
		gridCfg.items = getLineGridItems(this.view.getCoordinate(), scale$4, dim, get_default(gridCfg, "alignTick", true));
		return gridCfg;
	};
	/**
	* generate circle axis cfg
	* @param scale
	* @param axisOption
	* @param direction
	* @return circle axis cfg
	*/
	Axis$1.prototype.getCircleAxisCfg = function(scale$4, axisOption, direction$1) {
		var container = get_default(axisOption, ["top"]) ? this.axisForeContainer : this.axisContainer;
		var coordinate$10 = this.view.getCoordinate();
		var ticks = scale$4.getTicks().map(function(tick) {
			return {
				id: "".concat(tick.tickValue),
				name: tick.text,
				value: tick.value
			};
		});
		if (!scale$4.isCategory && Math.abs(coordinate$10.endAngle - coordinate$10.startAngle) === Math.PI * 2) {
			if (ticks.length) ticks[ticks.length - 1].name = "";
		}
		var titleText = getAxisTitleText(scale$4, axisOption);
		var axisThemeCfg = getAxisThemeCfg(this.view.getTheme(), DIRECTION.CIRCLE);
		var optionWithTitle = get_default(axisOption, ["title"]) ? deep_mix_default({ title: { style: { text: titleText } } }, { title: getAxisTitleOptions(this.view.getTheme(), direction$1, axisOption.title) }, axisOption) : axisOption;
		var cfg = deep_mix_default(__assign(__assign({ container }, getCircleAxisCenterRadius(this.view.getCoordinate())), {
			ticks,
			verticalFactor: 1,
			theme: axisThemeCfg
		}), axisThemeCfg, optionWithTitle);
		var _a$5 = this.getAnimateCfg(cfg), animate = _a$5.animate, animateOption = _a$5.animateOption;
		cfg.animate = animate;
		cfg.animateOption = animateOption;
		return cfg;
	};
	/**
	* generate circle grid cfg
	* @param scale
	* @param axisOption
	* @param direction
	* @return circle grid cfg
	*/
	Axis$1.prototype.getCircleGridCfg = function(scale$4, axisOption, direction$1, dim) {
		if (!showGrid(getAxisThemeCfg(this.view.getTheme(), direction$1), axisOption)) return;
		var gridThemeCfg = getGridThemeCfg(this.view.getTheme(), DIRECTION.RADIUS);
		var gridCfg = deep_mix_default({
			container: get_default(axisOption, ["top"]) ? this.gridForeContainer : this.gridContainer,
			center: this.view.getCoordinate().getCenter()
		}, gridThemeCfg, get_default(axisOption, "grid"), this.getAnimateCfg(axisOption));
		var alignTick = get_default(gridCfg, "alignTick", true);
		var verticalScale = dim === "x" ? this.view.getYScales()[0] : this.view.getXScale();
		gridCfg.items = getCircleGridItems(this.view.getCoordinate(), verticalScale, scale$4, alignTick, dim);
		return gridCfg;
	};
	Axis$1.prototype.getId = function(name, key) {
		var coordinate$10 = this.view.getCoordinate();
		return "".concat(name, "-").concat(key, "-").concat(coordinate$10.type);
	};
	Axis$1.prototype.getAnimateCfg = function(cfg) {
		return {
			animate: this.view.getOptions().animate && get_default(cfg, "animate"),
			animateOption: cfg && cfg.animateOption ? deep_mix_default({}, AXIS_DEFAULT_ANIMATE_CFG, cfg.animateOption) : AXIS_DEFAULT_ANIMATE_CFG
		};
	};
	return Axis$1;
}(Controller);
var axis_default = Axis;

//#endregion
//#region node_modules/@antv/g2/esm/util/direction.js
/**
* @ignore
* 方位常量转实际的 bbox 位置大小
* @param parentBBox
* @param bbox
* @param direction
*/
function directionToPosition(parentBBox, bbox, direction$1) {
	if (direction$1 === DIRECTION.TOP) return [parentBBox.minX + parentBBox.width / 2 - bbox.width / 2, parentBBox.minY];
	if (direction$1 === DIRECTION.BOTTOM) return [parentBBox.minX + parentBBox.width / 2 - bbox.width / 2, parentBBox.maxY - bbox.height];
	if (direction$1 === DIRECTION.LEFT) return [parentBBox.minX, parentBBox.minY + parentBBox.height / 2 - bbox.height / 2];
	if (direction$1 === DIRECTION.RIGHT) return [parentBBox.maxX - bbox.width, parentBBox.minY + parentBBox.height / 2 - bbox.height / 2];
	if (direction$1 === DIRECTION.TOP_LEFT || direction$1 === DIRECTION.LEFT_TOP) return [parentBBox.tl.x, parentBBox.tl.y];
	if (direction$1 === DIRECTION.TOP_RIGHT || direction$1 === DIRECTION.RIGHT_TOP) return [parentBBox.tr.x - bbox.width, parentBBox.tr.y];
	if (direction$1 === DIRECTION.BOTTOM_LEFT || direction$1 === DIRECTION.LEFT_BOTTOM) return [parentBBox.bl.x, parentBBox.bl.y - bbox.height];
	if (direction$1 === DIRECTION.BOTTOM_RIGHT || direction$1 === DIRECTION.RIGHT_BOTTOM) return [parentBBox.br.x - bbox.width, parentBBox.br.y - bbox.height];
	return [0, 0];
}

//#endregion
//#region node_modules/@antv/g2/esm/chart/controller/legend.js
/**
* 从配置中获取单个字段的 legend 配置
* @param legends
* @param field
* @returns the option of one legend field
*/
function getLegendOption(legends, field$5) {
	if (is_boolean_default(legends)) return legends === false ? false : {};
	return get_default(legends, [field$5], legends);
}
function getDirection(legendOption) {
	return get_default(legendOption, "position", DIRECTION.BOTTOM);
}
/**
* @ignore
* legend Controller
*/
var Legend = function(_super) {
	__extends(Legend$1, _super);
	function Legend$1(view) {
		var _this = _super.call(this, view) || this;
		_this.container = _this.view.getLayer(LAYER.FORE).addGroup();
		return _this;
	}
	Object.defineProperty(Legend$1.prototype, "name", {
		get: function() {
			return "legend";
		},
		enumerable: false,
		configurable: true
	});
	Legend$1.prototype.init = function() {};
	/**
	* render the legend component by legend options
	*/
	Legend$1.prototype.render = function() {
		this.update();
	};
	/**
	* layout legend
	* 计算出 legend 的 direction 位置 x, y
	*/
	Legend$1.prototype.layout = function() {
		var _this = this;
		this.layoutBBox = this.view.viewBBox;
		each_default(this.components, function(co) {
			var component$1 = co.component, direction$1 = co.direction;
			var layout$1 = getLegendLayout(direction$1);
			var maxWidthRatio = component$1.get("maxWidthRatio");
			var maxHeightRatio = component$1.get("maxHeightRatio");
			var maxSize = _this.getCategoryLegendSizeCfg(layout$1, maxWidthRatio, maxHeightRatio);
			var maxWidth = component$1.get("maxWidth");
			var maxHeight = component$1.get("maxHeight");
			component$1.update({
				maxWidth: Math.min(maxSize.maxWidth, maxWidth || 0),
				maxHeight: Math.min(maxSize.maxHeight, maxHeight || 0)
			});
			var padding$2 = component$1.get("padding");
			var bboxObject = component$1.getLayoutBBox();
			var bbox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height).expand(padding$2);
			var _a$5 = __read(directionToPosition(_this.view.viewBBox, bbox, direction$1), 2), x1 = _a$5[0], y1 = _a$5[1];
			var _b = __read(directionToPosition(_this.layoutBBox, bbox, direction$1), 2), x2 = _b[0], y2 = _b[1];
			var x = 0;
			var y = 0;
			if (direction$1.startsWith("top") || direction$1.startsWith("bottom")) {
				x = x1;
				y = y2;
			} else {
				x = x2;
				y = y1;
			}
			component$1.setLocation({
				x: x + padding$2[3],
				y: y + padding$2[0]
			});
			_this.layoutBBox = _this.layoutBBox.cut(bbox, direction$1);
		});
	};
	/**
	* legend 的更新逻辑
	*/
	Legend$1.prototype.update = function() {
		var _this = this;
		this.option = this.view.getOptions().legends;
		var updated = {};
		var eachLegend = function(geometry$34, attr, scale$4) {
			var id$2 = _this.getId(scale$4.field);
			var existCo$1 = _this.getComponentById(id$2);
			if (existCo$1) {
				var cfg = void 0;
				var legendOption = getLegendOption(_this.option, scale$4.field);
				if (legendOption !== false) {
					if (get_default(legendOption, "custom")) cfg = _this.getCategoryCfg(geometry$34, attr, scale$4, legendOption, true);
					else if (scale$4.isLinear) cfg = _this.getContinuousCfg(geometry$34, attr, scale$4, legendOption);
					else if (scale$4.isCategory) cfg = _this.getCategoryCfg(geometry$34, attr, scale$4, legendOption);
				}
				if (cfg) {
					omit(cfg, ["container"]);
					existCo$1.direction = getDirection(legendOption);
					existCo$1.component.update(cfg);
					updated[id$2] = true;
				}
			} else {
				var legend$17 = _this.createFieldLegend(geometry$34, attr, scale$4);
				if (legend$17) {
					legend$17.component.init();
					_this.components.push(legend$17);
					updated[id$2] = true;
				}
			}
		};
		if (get_default(this.option, "custom")) {
			var id$1 = "global-custom";
			var existCo = this.getComponentById(id$1);
			if (existCo) {
				var customCfg = this.getCategoryCfg(void 0, void 0, void 0, this.option, true);
				omit(customCfg, ["container"]);
				existCo.component.update(customCfg);
				updated[id$1] = true;
			} else {
				var component$1 = this.createCustomLegend(void 0, void 0, void 0, this.option);
				if (component$1) {
					component$1.init();
					var layer = LAYER.FORE;
					var direction$1 = getDirection(this.option);
					this.components.push({
						id: id$1,
						component: component$1,
						layer,
						direction: direction$1,
						type: COMPONENT_TYPE.LEGEND,
						extra: void 0
					});
					updated[id$1] = true;
				}
			}
		} else this.loopLegends(eachLegend);
		var components = [];
		each_default(this.getComponents(), function(co) {
			if (updated[co.id]) components.push(co);
			else co.component.destroy();
		});
		this.components = components;
	};
	Legend$1.prototype.clear = function() {
		_super.prototype.clear.call(this);
		this.container.clear();
	};
	Legend$1.prototype.destroy = function() {
		_super.prototype.destroy.call(this);
		this.container.remove(true);
	};
	/**
	* 递归获取所有的 Geometry
	*/
	Legend$1.prototype.getGeometries = function(view) {
		var _this = this;
		var geometries = view.geometries;
		each_default(view.views, function(v) {
			geometries = geometries.concat(_this.getGeometries(v));
		});
		return geometries;
	};
	/**
	* 遍历 Geometry，处理 legend 逻辑
	* @param doEach 每个 loop 中的处理方法
	*/
	Legend$1.prototype.loopLegends = function(doEach) {
		if (!(this.view.getRootView() === this.view)) return;
		var geometries = this.getGeometries(this.view);
		var looped = {};
		each_default(geometries, function(geometry$34) {
			var attributes = geometry$34.getGroupAttributes();
			each_default(attributes, function(attr) {
				var scale$4 = attr.getScale(attr.type);
				if (!scale$4 || scale$4.type === "identity" || looped[scale$4.field]) return;
				doEach(geometry$34, attr, scale$4);
				looped[scale$4.field] = true;
			});
		});
	};
	/**
	* 创建一个 legend
	* @param geometry
	* @param attr
	* @param scale
	*/
	Legend$1.prototype.createFieldLegend = function(geometry$34, attr, scale$4) {
		var component$1;
		var legendOption = getLegendOption(this.option, scale$4.field);
		var layer = LAYER.FORE;
		var direction$1 = getDirection(legendOption);
		if (legendOption !== false) {
			if (get_default(legendOption, "custom")) component$1 = this.createCustomLegend(geometry$34, attr, scale$4, legendOption);
			else if (scale$4.isLinear) component$1 = this.createContinuousLegend(geometry$34, attr, scale$4, legendOption);
			else if (scale$4.isCategory) component$1 = this.createCategoryLegend(geometry$34, attr, scale$4, legendOption);
		}
		if (component$1) {
			component$1.set("field", scale$4.field);
			return {
				id: this.getId(scale$4.field),
				component: component$1,
				layer,
				direction: direction$1,
				type: COMPONENT_TYPE.LEGEND,
				extra: { scale: scale$4 }
			};
		}
	};
	/**
	* 自定义图例使用 category 图例去渲染
	* @param geometry
	* @param attr
	* @param scale
	* @param legendOption
	*/
	Legend$1.prototype.createCustomLegend = function(geometry$34, attr, scale$4, legendOption) {
		var cfg = this.getCategoryCfg(geometry$34, attr, scale$4, legendOption, true);
		return new CategoryLegend(cfg);
	};
	/**
	* 创建连续图例
	* @param geometry
	* @param attr
	* @param scale
	* @param legendOption
	*/
	Legend$1.prototype.createContinuousLegend = function(geometry$34, attr, scale$4, legendOption) {
		var cfg = this.getContinuousCfg(geometry$34, attr, scale$4, omit(legendOption, ["value"]));
		return new ContinuousLegend(cfg);
	};
	/**
	* 创建分类图例
	* @param geometry
	* @param attr
	* @param scale
	* @param legendOption
	*/
	Legend$1.prototype.createCategoryLegend = function(geometry$34, attr, scale$4, legendOption) {
		var cfg = this.getCategoryCfg(geometry$34, attr, scale$4, legendOption);
		return new CategoryLegend(cfg);
	};
	/**
	* 获得连续图例的配置
	* @param geometry
	* @param attr
	* @param scale
	* @param legendOption
	*/
	Legend$1.prototype.getContinuousCfg = function(geometry$34, attr, scale$4, legendOption) {
		var ticks = scale$4.getTicks();
		var containMin = find_default(ticks, function(tick) {
			return tick.value === 0;
		});
		var containMax = find_default(ticks, function(tick) {
			return tick.value === 1;
		});
		var items = ticks.map(function(tick) {
			var value$1 = tick.value, tickValue = tick.tickValue;
			var attrValue = attr.mapping(scale$4.invert(value$1)).join("");
			return {
				value: tickValue,
				attrValue,
				color: attrValue,
				scaleValue: value$1
			};
		});
		if (!containMin) items.push({
			value: scale$4.min,
			attrValue: attr.mapping(scale$4.invert(0)).join(""),
			color: attr.mapping(scale$4.invert(0)).join(""),
			scaleValue: 0
		});
		if (!containMax) items.push({
			value: scale$4.max,
			attrValue: attr.mapping(scale$4.invert(1)).join(""),
			color: attr.mapping(scale$4.invert(1)).join(""),
			scaleValue: 1
		});
		items.sort(function(a, b) {
			return a.value - b.value;
		});
		var attrLegendCfg = {
			min: head(items).value,
			max: last(items).value,
			colors: [],
			rail: { type: attr.type },
			track: {}
		};
		if (attr.type === "size") attrLegendCfg.track = { style: { fill: attr.type === "size" ? this.view.getTheme().defaultColor : void 0 } };
		if (attr.type === "color") attrLegendCfg.colors = items.map(function(item) {
			return item.attrValue;
		});
		var container = this.container;
		var direction$1 = getDirection(legendOption);
		var layout$1 = getLegendLayout(direction$1);
		var title = get_default(legendOption, "title");
		if (title) title = deep_mix_default({ text: getName(scale$4) }, title);
		attrLegendCfg.container = container;
		attrLegendCfg.layout = layout$1;
		attrLegendCfg.title = title;
		attrLegendCfg.animateOption = DEFAULT_ANIMATE_CFG;
		return this.mergeLegendCfg(attrLegendCfg, legendOption, "continuous");
	};
	/**
	* 获取分类图例的配置项
	* @param geometry
	* @param attr
	* @param scale
	* @param custom
	* @param legendOption
	*/
	Legend$1.prototype.getCategoryCfg = function(geometry$34, attr, scale$4, legendOption, custom) {
		var container = this.container;
		var direction$1 = get_default(legendOption, "position", DIRECTION.BOTTOM);
		var legendTheme = getLegendThemeCfg(this.view.getTheme(), direction$1);
		var themeMarker = get_default(legendTheme, ["marker"]);
		var userMarker = get_default(legendOption, "marker");
		var layout$1 = getLegendLayout(direction$1);
		var themePageNavigator = get_default(legendTheme, ["pageNavigator"]);
		var userPageNavigator = get_default(legendOption, "pageNavigator");
		var items = custom ? getCustomLegendItems(themeMarker, userMarker, legendOption.items) : getLegendItems(this.view, geometry$34, attr, themeMarker, userMarker);
		var title = get_default(legendOption, "title");
		if (title) title = deep_mix_default({ text: scale$4 ? getName(scale$4) : "" }, title);
		var maxWidthRatio = get_default(legendOption, "maxWidthRatio");
		var maxHeightRatio = get_default(legendOption, "maxHeightRatio");
		var baseCfg = this.getCategoryLegendSizeCfg(layout$1, maxWidthRatio, maxHeightRatio);
		baseCfg.container = container;
		baseCfg.layout = layout$1;
		baseCfg.items = items;
		baseCfg.title = title;
		baseCfg.animateOption = DEFAULT_ANIMATE_CFG;
		baseCfg.pageNavigator = deep_mix_default({}, themePageNavigator, userPageNavigator);
		var categoryCfg = this.mergeLegendCfg(baseCfg, legendOption, direction$1);
		if (categoryCfg.reversed) categoryCfg.items.reverse();
		var maxItemWidth = get_default(categoryCfg, "maxItemWidth");
		if (maxItemWidth && maxItemWidth <= 1) categoryCfg.maxItemWidth = this.view.viewBBox.width * maxItemWidth;
		return categoryCfg;
	};
	/**
	* get legend config, use option > suggestion > theme
	* @param baseCfg
	* @param legendOption
	* @param direction
	*/
	Legend$1.prototype.mergeLegendCfg = function(baseCfg, legendOption, direction$1) {
		var position = direction$1.split("-")[0];
		var themeObject = getLegendThemeCfg(this.view.getTheme(), position);
		return deep_mix_default({}, themeObject, baseCfg, legendOption);
	};
	/**
	* 生成 id
	* @param key
	*/
	Legend$1.prototype.getId = function(key) {
		return "".concat(this.name, "-").concat(key);
	};
	/**
	* 根据 id 来获取组件
	* @param id
	*/
	Legend$1.prototype.getComponentById = function(id$1) {
		return find_default(this.components, function(co) {
			return co.id === id$1;
		});
	};
	Legend$1.prototype.getCategoryLegendSizeCfg = function(layout$1, maxWidthRatio, maxHeightRatio) {
		if (maxWidthRatio === void 0) maxWidthRatio = COMPONENT_MAX_VIEW_PERCENTAGE;
		if (maxHeightRatio === void 0) maxHeightRatio = COMPONENT_MAX_VIEW_PERCENTAGE;
		var _a$5 = this.view.viewBBox, vw = _a$5.width, vh = _a$5.height;
		return layout$1 === "vertical" ? {
			maxWidth: vw * maxWidthRatio,
			maxHeight: vh
		} : {
			maxWidth: vw,
			maxHeight: vh * maxHeightRatio
		};
	};
	return Legend$1;
}(Controller);
var legend_default = Legend;

//#endregion
//#region node_modules/@antv/g2/esm/chart/controller/slider.js
/**
* @ignore
* slider Controller
*/
var Slider$1 = function(_super) {
	__extends(Slider$2, _super);
	function Slider$2(view) {
		var _this = _super.call(this, view) || this;
		_this.onChangeFn = noop_default;
		/**
		* 清除测量
		*/
		_this.resetMeasure = function() {
			_this.clear();
		};
		/**
		* 滑块滑动的时候出发
		* @param v
		*/
		_this.onValueChange = function(v) {
			var _a$5 = __read(v, 2), min$2 = _a$5[0], max$2 = _a$5[1];
			_this.start = min$2;
			_this.end = max$2;
			_this.changeViewData(min$2, max$2);
		};
		_this.container = _this.view.getLayer(LAYER.FORE).addGroup();
		_this.onChangeFn = throttle_default(_this.onValueChange, 20, { leading: true });
		_this.width = 0;
		_this.view.on(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, _this.resetMeasure);
		_this.view.on(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, _this.resetMeasure);
		return _this;
	}
	Object.defineProperty(Slider$2.prototype, "name", {
		get: function() {
			return "slider";
		},
		enumerable: false,
		configurable: true
	});
	Slider$2.prototype.destroy = function() {
		_super.prototype.destroy.call(this);
		this.view.off(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, this.resetMeasure);
		this.view.off(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, this.resetMeasure);
	};
	/**
	* 初始化
	*/
	Slider$2.prototype.init = function() {};
	/**
	* 渲染
	*/
	Slider$2.prototype.render = function() {
		this.option = this.view.getOptions().slider;
		var _a$5 = this.getSliderCfg(), start = _a$5.start, end = _a$5.end;
		if (is_nil_default(this.start)) {
			this.start = start;
			this.end = end;
		}
		var viewData = this.view.getOptions().data;
		if (this.option && !is_empty_default(viewData)) if (this.slider) this.slider = this.updateSlider();
		else {
			this.slider = this.createSlider();
			this.slider.component.on("sliderchange", this.onChangeFn);
		}
		else if (this.slider) {
			this.slider.component.destroy();
			this.slider = void 0;
		}
	};
	/**
	* 布局
	*/
	Slider$2.prototype.layout = function() {
		var _this = this;
		if (this.option && !this.width) {
			this.measureSlider();
			setTimeout(function() {
				if (!_this.view.destroyed) _this.changeViewData(_this.start, _this.end);
			}, 0);
		}
		if (this.slider) {
			var width = this.view.coordinateBBox.width;
			var padding$2 = this.slider.component.get("padding"), _a$5 = __read(padding$2, 4), paddingTop = _a$5[0];
			_a$5[1];
			_a$5[2];
			var paddingLeft = _a$5[3];
			var bboxObject = this.slider.component.getLayoutBBox();
			var bbox = new BBox(bboxObject.x, bboxObject.y, Math.min(bboxObject.width, width), bboxObject.height).expand(padding$2);
			var _b = this.getMinMaxText(this.start, this.end), minText = _b.minText, maxText = _b.maxText, _c = __read(directionToPosition(this.view.viewBBox, bbox, DIRECTION.BOTTOM), 2);
			_c[0];
			var y1 = _c[1], _d = __read(directionToPosition(this.view.coordinateBBox, bbox, DIRECTION.BOTTOM), 2), x2 = _d[0];
			_d[1];
			this.slider.component.update(__assign(__assign({}, this.getSliderCfg()), {
				x: x2 + paddingLeft,
				y: y1 + paddingTop,
				width: this.width,
				start: this.start,
				end: this.end,
				minText,
				maxText
			}));
			this.view.viewBBox = this.view.viewBBox.cut(bbox, DIRECTION.BOTTOM);
		}
	};
	/**
	* 更新
	*/
	Slider$2.prototype.update = function() {
		this.render();
	};
	/**
	* 创建 slider 组件
	*/
	Slider$2.prototype.createSlider = function() {
		var cfg = this.getSliderCfg();
		var component$1 = new Slider(__assign({ container: this.container }, cfg));
		component$1.init();
		return {
			component: component$1,
			layer: LAYER.FORE,
			direction: DIRECTION.BOTTOM,
			type: COMPONENT_TYPE.SLIDER
		};
	};
	/**
	* 更新配置
	*/
	Slider$2.prototype.updateSlider = function() {
		var cfg = this.getSliderCfg();
		if (this.width) {
			var _a$5 = this.getMinMaxText(this.start, this.end), minText = _a$5.minText, maxText = _a$5.maxText;
			cfg = __assign(__assign({}, cfg), {
				width: this.width,
				start: this.start,
				end: this.end,
				minText,
				maxText
			});
		}
		this.slider.component.update(cfg);
		return this.slider;
	};
	/**
	* 进行测量操作
	*/
	Slider$2.prototype.measureSlider = function() {
		this.width = this.getSliderCfg().width;
	};
	/**
	* 生成 slider 配置
	*/
	Slider$2.prototype.getSliderCfg = function() {
		var cfg = {
			height: 16,
			start: 0,
			end: 1,
			minText: "",
			maxText: "",
			x: 0,
			y: 0,
			width: this.view.coordinateBBox.width
		};
		if (is_object_default(this.option)) {
			var trendCfg = __assign({ data: this.getData() }, get_default(this.option, "trendCfg", {}));
			cfg = deep_mix_default({}, cfg, this.getThemeOptions(), this.option);
			cfg = __assign(__assign({}, cfg), { trendCfg });
		}
		cfg.start = clamp_default(Math.min(is_nil_default(cfg.start) ? 0 : cfg.start, is_nil_default(cfg.end) ? 1 : cfg.end), 0, 1);
		cfg.end = clamp_default(Math.max(is_nil_default(cfg.start) ? 0 : cfg.start, is_nil_default(cfg.end) ? 1 : cfg.end), 0, 1);
		return cfg;
	};
	/**
	* 从 view 中获取数据，缩略轴使用全量的数据
	*/
	Slider$2.prototype.getData = function() {
		var data$2 = this.view.getOptions().data;
		var _a$5 = __read(this.view.getYScales(), 1), yScale = _a$5[0];
		var groupScales = this.view.getGroupScales();
		if (groupScales.length) {
			var _b = groupScales[0], field_1 = _b.field, ticks_1 = _b.ticks;
			return data$2.reduce(function(pre, cur) {
				if (cur[field_1] === ticks_1[0]) pre.push(cur[yScale.field]);
				return pre;
			}, []);
		}
		return data$2.map(function(datum) {
			return datum[yScale.field] || 0;
		});
	};
	/**
	* 获取 slider 的主题配置
	*/
	Slider$2.prototype.getThemeOptions = function() {
		var theme$3 = this.view.getTheme();
		return get_default(theme$3, [
			"components",
			"slider",
			"common"
		], {});
	};
	/**
	* 根据 start/end 和当前数据计算出当前的 minText/maxText
	* @param min
	* @param max
	*/
	Slider$2.prototype.getMinMaxText = function(min$2, max$2) {
		var data$2 = this.view.getOptions().data;
		var xScale = this.view.getXScale();
		var isHorizontal$1 = true;
		var values$1 = values_of_key_default(data$2, xScale.field);
		if (xScale.isLinear) values$1 = values$1.sort();
		var xValues = isHorizontal$1 ? values$1 : values$1.reverse();
		var dataSize = size(data$2);
		if (!xScale || !dataSize) return {};
		var xTickCount = size(xValues);
		var minIndex = Math.round(min$2 * (xTickCount - 1));
		var maxIndex = Math.round(max$2 * (xTickCount - 1));
		var minText = get_default(xValues, [minIndex]);
		var maxText = get_default(xValues, [maxIndex]);
		var formatter = this.getSliderCfg().formatter;
		if (formatter) {
			minText = formatter(minText, data$2[minIndex], minIndex);
			maxText = formatter(maxText, data$2[maxIndex], maxIndex);
		}
		return {
			minText,
			maxText
		};
	};
	/**
	* 更新 view 过滤数据
	* @param min
	* @param max
	*/
	Slider$2.prototype.changeViewData = function(min$2, max$2) {
		var data$2 = this.view.getOptions().data;
		var xScale = this.view.getXScale();
		var dataSize = size(data$2);
		if (!xScale || !dataSize) return;
		var isHorizontal$1 = true;
		var values$1 = values_of_key_default(data$2, xScale.field);
		var xScaleValues = this.view.getXScale().isLinear ? values$1.sort(function(a, b) {
			return Number(a) - Number(b);
		}) : values$1;
		var xValues = isHorizontal$1 ? xScaleValues : xScaleValues.reverse();
		var xTickCount = size(xValues);
		var minIndex = Math.round(min$2 * (xTickCount - 1));
		var maxIndex = Math.round(max$2 * (xTickCount - 1));
		this.view.filter(xScale.field, function(value$1, datum) {
			var idx = xValues.indexOf(value$1);
			return idx > -1 ? isBetween$1(idx, minIndex, maxIndex) : true;
		});
		this.view.render(true);
	};
	/**
	* 覆写父类方法
	*/
	Slider$2.prototype.getComponents = function() {
		return this.slider ? [this.slider] : [];
	};
	/**
	* 覆盖父类
	*/
	Slider$2.prototype.clear = function() {
		if (this.slider) {
			this.slider.component.destroy();
			this.slider = void 0;
		}
		this.width = 0;
		this.start = void 0;
		this.end = void 0;
	};
	return Slider$2;
}(Controller);
var slider_default = Slider$1;

//#endregion
//#region node_modules/@antv/g2/esm/chart/controller/scrollbar.js
var DEFAULT_PADDING = 0;
var DEFAULT_SIZE$1 = 8;
var DEFAULT_CATEGORY_SIZE = 32;
var MIN_THUMB_LENGTH = 20;
var Scrollbar$1 = function(_super) {
	__extends(Scrollbar$2, _super);
	function Scrollbar$2(view) {
		var _this = _super.call(this, view) || this;
		_this.onChangeFn = noop_default;
		_this.resetMeasure = function() {
			_this.clear();
		};
		_this.onValueChange = function(_a$5) {
			var ratio = _a$5.ratio;
			var animate = _this.getValidScrollbarCfg().animate;
			_this.ratio = clamp_default(ratio, 0, 1);
			var originalAnimate = _this.view.getOptions().animate;
			if (!animate) _this.view.animate(false);
			_this.changeViewData(_this.getScrollRange(), true);
			_this.view.animate(originalAnimate);
		};
		_this.container = _this.view.getLayer(LAYER.FORE).addGroup();
		_this.onChangeFn = throttle_default(_this.onValueChange, 20, { leading: true });
		_this.trackLen = 0;
		_this.thumbLen = 0;
		_this.ratio = 0;
		_this.view.on(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, _this.resetMeasure);
		_this.view.on(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, _this.resetMeasure);
		return _this;
	}
	Object.defineProperty(Scrollbar$2.prototype, "name", {
		get: function() {
			return "scrollbar";
		},
		enumerable: false,
		configurable: true
	});
	Scrollbar$2.prototype.destroy = function() {
		_super.prototype.destroy.call(this);
		this.view.off(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, this.resetMeasure);
		this.view.off(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, this.resetMeasure);
	};
	Scrollbar$2.prototype.init = function() {};
	/**
	* 渲染
	*/
	Scrollbar$2.prototype.render = function() {
		this.option = this.view.getOptions().scrollbar;
		if (this.option) if (this.scrollbar) this.scrollbar = this.updateScrollbar();
		else {
			this.scrollbar = this.createScrollbar();
			this.scrollbar.component.on("scrollchange", this.onChangeFn);
		}
		else if (this.scrollbar) {
			this.scrollbar.component.destroy();
			this.scrollbar = void 0;
		}
	};
	/**
	* 布局
	*/
	Scrollbar$2.prototype.layout = function() {
		var _this = this;
		if (this.option && !this.trackLen) {
			this.measureScrollbar();
			setTimeout(function() {
				if (!_this.view.destroyed) _this.changeViewData(_this.getScrollRange(), true);
			});
		}
		if (this.scrollbar) {
			var width = this.view.coordinateBBox.width;
			var padding$2 = this.scrollbar.component.get("padding");
			var bboxObject = this.scrollbar.component.getLayoutBBox();
			var bbox = new BBox(bboxObject.x, bboxObject.y, Math.min(bboxObject.width, width), bboxObject.height).expand(padding$2);
			var cfg = this.getScrollbarComponentCfg();
			var x = void 0;
			var y = void 0;
			if (cfg.isHorizontal) {
				var _a$5 = __read(directionToPosition(this.view.viewBBox, bbox, DIRECTION.BOTTOM), 2);
				_a$5[0];
				var y1 = _a$5[1], _b = __read(directionToPosition(this.view.coordinateBBox, bbox, DIRECTION.BOTTOM), 2), x2 = _b[0];
				_b[1];
				x = x2;
				y = y1;
			} else {
				var _c = __read(directionToPosition(this.view.viewBBox, bbox, DIRECTION.RIGHT), 2);
				_c[0];
				var y1 = _c[1], _d = __read(directionToPosition(this.view.viewBBox, bbox, DIRECTION.RIGHT), 2), x2 = _d[0];
				_d[1];
				x = x2;
				y = y1;
			}
			x += padding$2[3];
			y += padding$2[0];
			if (this.trackLen) this.scrollbar.component.update(__assign(__assign({}, cfg), {
				x,
				y,
				trackLen: this.trackLen,
				thumbLen: this.thumbLen,
				thumbOffset: (this.trackLen - this.thumbLen) * this.ratio
			}));
			else this.scrollbar.component.update(__assign(__assign({}, cfg), {
				x,
				y
			}));
			this.view.viewBBox = this.view.viewBBox.cut(bbox, cfg.isHorizontal ? DIRECTION.BOTTOM : DIRECTION.RIGHT);
		}
	};
	/**
	* 更新
	*/
	Scrollbar$2.prototype.update = function() {
		this.render();
	};
	Scrollbar$2.prototype.getComponents = function() {
		return this.scrollbar ? [this.scrollbar] : [];
	};
	Scrollbar$2.prototype.clear = function() {
		if (this.scrollbar) {
			this.scrollbar.component.destroy();
			this.scrollbar = void 0;
		}
		this.trackLen = 0;
		this.thumbLen = 0;
		this.ratio = 0;
		this.cnt = 0;
		this.step = 0;
		this.data = void 0;
		this.xScaleCfg = void 0;
		this.yScalesCfg = [];
	};
	/** 设置滚动条位置  */
	Scrollbar$2.prototype.setValue = function(ratio) {
		this.onValueChange({ ratio });
	};
	/** 获得滚动条位置  */
	Scrollbar$2.prototype.getValue = function() {
		return this.ratio;
	};
	/**
	* 获取 scrollbar 的主题配置
	*/
	Scrollbar$2.prototype.getThemeOptions = function() {
		var theme$3 = this.view.getTheme();
		return get_default(theme$3, [
			"components",
			"scrollbar",
			"common"
		], {});
	};
	/**
	* 获取 scrollbar 组件的主题样式
	*/
	Scrollbar$2.prototype.getScrollbarTheme = function(style) {
		var theme$3 = get_default(this.view.getTheme(), ["components", "scrollbar"]);
		var _a$5 = style || {}, thumbHighlightColor = _a$5.thumbHighlightColor, restStyles = __rest(_a$5, ["thumbHighlightColor"]);
		return {
			default: deep_mix_default({}, get_default(theme$3, ["default", "style"], {}), restStyles),
			hover: deep_mix_default({}, get_default(theme$3, ["hover", "style"], {}), { thumbColor: thumbHighlightColor })
		};
	};
	Scrollbar$2.prototype.measureScrollbar = function() {
		var xScale = this.view.getXScale();
		var yScales = this.view.getYScales().slice();
		this.data = this.getScrollbarData();
		this.step = this.getStep();
		this.cnt = this.getCnt();
		var _a$5 = this.getScrollbarComponentCfg(), trackLen = _a$5.trackLen, thumbLen = _a$5.thumbLen;
		this.trackLen = trackLen;
		this.thumbLen = thumbLen;
		this.xScaleCfg = {
			field: xScale.field,
			values: xScale.values || []
		};
		this.yScalesCfg = yScales;
	};
	Scrollbar$2.prototype.getScrollRange = function() {
		var startIdx = Math.floor((this.cnt - this.step) * clamp_default(this.ratio, 0, 1));
		var endIdx = Math.min(startIdx + this.step - 1, this.cnt - 1);
		return [startIdx, endIdx];
	};
	Scrollbar$2.prototype.changeViewData = function(_a$5, render) {
		var _this = this;
		var _b = __read(_a$5, 2), startIdx = _b[0], endIdx = _b[1];
		var isHorizontal$1 = this.getValidScrollbarCfg().type !== "vertical";
		var values$1 = values_of_key_default(this.data, this.xScaleCfg.field);
		var xScaleValues = this.view.getXScale().isLinear ? values$1.sort(function(a, b) {
			return Number(a) - Number(b);
		}) : values$1;
		var xValues = isHorizontal$1 ? xScaleValues : xScaleValues.reverse();
		this.yScalesCfg.forEach(function(cfg) {
			_this.view.scale(cfg.field, {
				formatter: cfg.formatter,
				type: cfg.type,
				min: cfg.min,
				max: cfg.max,
				tickMethod: cfg.tickMethod
			});
		});
		this.view.filter(this.xScaleCfg.field, function(val) {
			var idx = xValues.indexOf(val);
			return idx > -1 ? isBetween$1(idx, startIdx, endIdx) : true;
		});
		this.view.render(true);
	};
	Scrollbar$2.prototype.createScrollbar = function() {
		var isHorizontal$1 = this.getValidScrollbarCfg().type !== "vertical";
		var component$1 = new Scrollbar(__assign(__assign({ container: this.container }, this.getScrollbarComponentCfg()), {
			x: 0,
			y: 0
		}));
		component$1.init();
		return {
			component: component$1,
			layer: LAYER.FORE,
			direction: isHorizontal$1 ? DIRECTION.BOTTOM : DIRECTION.RIGHT,
			type: COMPONENT_TYPE.SCROLLBAR
		};
	};
	Scrollbar$2.prototype.updateScrollbar = function() {
		var config = this.getScrollbarComponentCfg();
		var realConfig = this.trackLen ? __assign(__assign({}, config), {
			trackLen: this.trackLen,
			thumbLen: this.thumbLen,
			thumbOffset: (this.trackLen - this.thumbLen) * this.ratio
		}) : __assign({}, config);
		this.scrollbar.component.update(realConfig);
		return this.scrollbar;
	};
	Scrollbar$2.prototype.getStep = function() {
		if (this.step) return this.step;
		var coordinateBBox = this.view.coordinateBBox;
		var _a$5 = this.getValidScrollbarCfg(), type = _a$5.type, categorySize = _a$5.categorySize;
		var isHorizontal$1 = type !== "vertical";
		return Math.floor((isHorizontal$1 ? coordinateBBox.width : coordinateBBox.height) / categorySize);
	};
	Scrollbar$2.prototype.getCnt = function() {
		if (this.cnt) return this.cnt;
		var xScale = this.view.getXScale();
		var data$2 = this.getScrollbarData();
		var values$1 = values_of_key_default(data$2, xScale.field);
		return size(values$1);
	};
	Scrollbar$2.prototype.getScrollbarComponentCfg = function() {
		var _a$5 = this.view, coordinateBBox = _a$5.coordinateBBox, viewBBox = _a$5.viewBBox;
		var _b = this.getValidScrollbarCfg(), type = _b.type, padding$2 = _b.padding, width = _b.width, height = _b.height, style = _b.style;
		var isHorizontal$1 = type !== "vertical";
		var _c = __read(padding$2, 4), paddingTop = _c[0], paddingRight = _c[1], paddingBottom = _c[2], paddingLeft = _c[3];
		var position = isHorizontal$1 ? {
			x: coordinateBBox.minX + paddingLeft,
			y: viewBBox.maxY - height - paddingBottom
		} : {
			x: viewBBox.maxX - width - paddingRight,
			y: coordinateBBox.minY + paddingTop
		};
		var step = this.getStep();
		var cnt = this.getCnt();
		var trackLen = isHorizontal$1 ? coordinateBBox.width - paddingLeft - paddingRight : coordinateBBox.height - paddingTop - paddingBottom;
		var thumbLen = Math.max(trackLen * clamp_default(step / cnt, 0, 1), MIN_THUMB_LENGTH);
		return __assign(__assign({}, this.getThemeOptions()), {
			x: position.x,
			y: position.y,
			size: isHorizontal$1 ? height : width,
			isHorizontal: isHorizontal$1,
			trackLen,
			thumbLen,
			thumbOffset: 0,
			theme: this.getScrollbarTheme(style)
		});
	};
	/**
	* 填充一些默认的配置项目
	*/
	Scrollbar$2.prototype.getValidScrollbarCfg = function() {
		var cfg = {
			type: "horizontal",
			categorySize: DEFAULT_CATEGORY_SIZE,
			width: DEFAULT_SIZE$1,
			height: DEFAULT_SIZE$1,
			padding: [
				0,
				0,
				0,
				0
			],
			animate: true,
			style: {}
		};
		if (is_object_default(this.option)) cfg = __assign(__assign({}, cfg), this.option);
		if (!is_object_default(this.option) || !this.option.padding) cfg.padding = cfg.type === "horizontal" ? [
			DEFAULT_PADDING,
			0,
			DEFAULT_PADDING,
			0
		] : [
			0,
			DEFAULT_PADDING,
			0,
			DEFAULT_PADDING
		];
		return cfg;
	};
	/**
	* 获取数据
	*/
	Scrollbar$2.prototype.getScrollbarData = function() {
		var coordinate$10 = this.view.getCoordinate();
		var cfg = this.getValidScrollbarCfg();
		var data$2 = this.view.getOptions().data || [];
		if (coordinate$10.isReflect("y") && cfg.type === "vertical") data$2 = __spreadArray([], __read(data$2), false).reverse();
		return data$2;
	};
	return Scrollbar$2;
}(Controller);
var scrollbar_default = Scrollbar$1;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/active-region.js
var DEFAULT_REGION_PATH_STYLE = {
	fill: "#CCD6EC",
	opacity: .3
};
function getItemsOfView(view, point$1, tooltipCfg) {
	var e_1, _a$5, e_2, _b, e_3, _c;
	var items = findItemsFromViewRecurisive(view, point$1, tooltipCfg);
	if (items.length) {
		items = flatten_default(items);
		try {
			for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
				var itemArr = items_1_1.value;
				try {
					for (var itemArr_1 = (e_2 = void 0, __values(itemArr)), itemArr_1_1 = itemArr_1.next(); !itemArr_1_1.done; itemArr_1_1 = itemArr_1.next()) {
						var item = itemArr_1_1.value;
						var _d = item.mappingData, x = _d.x, y = _d.y;
						item.x = is_array_default(x) ? x[x.length - 1] : x;
						item.y = is_array_default(y) ? y[y.length - 1] : y;
					}
				} catch (e_2_1) {
					e_2 = { error: e_2_1 };
				} finally {
					try {
						if (itemArr_1_1 && !itemArr_1_1.done && (_b = itemArr_1.return)) _b.call(itemArr_1);
					} finally {
						if (e_2) throw e_2.error;
					}
				}
			}
		} catch (e_1_1) {
			e_1 = { error: e_1_1 };
		} finally {
			try {
				if (items_1_1 && !items_1_1.done && (_a$5 = items_1.return)) _a$5.call(items_1);
			} finally {
				if (e_1) throw e_1.error;
			}
		}
		if (tooltipCfg.shared === false && items.length > 1) {
			var snapItem = items[0];
			var min$2 = Math.abs(point$1.y - snapItem[0].y);
			try {
				for (var items_2 = __values(items), items_2_1 = items_2.next(); !items_2_1.done; items_2_1 = items_2.next()) {
					var aItem = items_2_1.value;
					var yDistance = Math.abs(point$1.y - aItem[0].y);
					if (yDistance <= min$2) {
						snapItem = aItem;
						min$2 = yDistance;
					}
				}
			} catch (e_3_1) {
				e_3 = { error: e_3_1 };
			} finally {
				try {
					if (items_2_1 && !items_2_1.done && (_c = items_2.return)) _c.call(items_2);
				} finally {
					if (e_3) throw e_3.error;
				}
			}
			items = [snapItem];
		}
		return uniq(flatten_default(items));
	}
	return [];
}
/**
* 背景框的 Action. 只作用于 interval 和 schema geometry
* @ignore
*/
var ActiveRegion = function(_super) {
	__extends(ActiveRegion$1, _super);
	function ActiveRegion$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	/**
	* 显示
	* @param {ShapeAttrs} style region-path 的样式
	* @param {number} appendRatio 适用于笛卡尔坐标系. 对于 x 轴非 linear 类型: 默认：0.25, x 轴 linear 类型: 默认 0
	* @param {number} appendWidth  适用于笛卡尔坐标系. 像素级别，优先级 > appendRatio
	*/
	ActiveRegion$1.prototype.show = function(args) {
		var view = this.context.view;
		var ev = this.context.event;
		var tooltipCfg = view.getController("tooltip").getTooltipCfg();
		var tooltipItems = getItemsOfView(view, {
			x: ev.x,
			y: ev.y
		}, tooltipCfg);
		if (is_equal_default(tooltipItems, this.items)) return;
		this.items = tooltipItems;
		if (tooltipItems.length) {
			var xField_1 = view.getXScale().field;
			var xValue_1 = tooltipItems[0].data[xField_1];
			var elements_1 = [];
			var geometries = view.geometries;
			each_default(geometries, function(geometry$34) {
				if (geometry$34.type === "interval" || geometry$34.type === "schema") {
					var result = geometry$34.getElementsBy(function(ele) {
						return ele.getData()[xField_1] === xValue_1;
					});
					elements_1 = elements_1.concat(result);
				}
			});
			if (elements_1.length) {
				var coordinate_1 = view.getCoordinate();
				var firstBBox_1 = elements_1[0].shape.getCanvasBBox();
				var lastBBox_1 = elements_1[0].shape.getCanvasBBox();
				var groupBBox_1 = firstBBox_1;
				each_default(elements_1, function(ele) {
					var bbox = ele.shape.getCanvasBBox();
					if (coordinate_1.isTransposed) {
						if (bbox.minY < firstBBox_1.minY) firstBBox_1 = bbox;
						if (bbox.maxY > lastBBox_1.maxY) lastBBox_1 = bbox;
					} else {
						if (bbox.minX < firstBBox_1.minX) firstBBox_1 = bbox;
						if (bbox.maxX > lastBBox_1.maxX) lastBBox_1 = bbox;
					}
					groupBBox_1.x = Math.min(bbox.minX, groupBBox_1.minX);
					groupBBox_1.y = Math.min(bbox.minY, groupBBox_1.minY);
					groupBBox_1.width = Math.max(bbox.maxX, groupBBox_1.maxX) - groupBBox_1.x;
					groupBBox_1.height = Math.max(bbox.maxY, groupBBox_1.maxY) - groupBBox_1.y;
				});
				var backgroundGroup = view.backgroundGroup, coordinateBBox = view.coordinateBBox;
				var path = void 0;
				if (coordinate_1.isRect) {
					var xScale = view.getXScale();
					var _a$5 = args || {}, appendRatio = _a$5.appendRatio, appendWidth = _a$5.appendWidth;
					if (is_nil_default(appendWidth)) {
						appendRatio = is_nil_default(appendRatio) ? xScale.isLinear ? 0 : .25 : appendRatio;
						appendWidth = coordinate_1.isTransposed ? appendRatio * lastBBox_1.height : appendRatio * firstBBox_1.width;
					}
					var minX = void 0;
					var minY = void 0;
					var width = void 0;
					var height = void 0;
					if (coordinate_1.isTransposed) {
						minX = coordinateBBox.minX;
						minY = Math.min(lastBBox_1.minY, firstBBox_1.minY) - appendWidth;
						width = coordinateBBox.width;
						height = groupBBox_1.height + appendWidth * 2;
					} else {
						minX = Math.min(firstBBox_1.minX, lastBBox_1.minX) - appendWidth;
						minY = coordinateBBox.minY;
						width = groupBBox_1.width + appendWidth * 2;
						height = coordinateBBox.height;
					}
					path = [
						[
							"M",
							minX,
							minY
						],
						[
							"L",
							minX + width,
							minY
						],
						[
							"L",
							minX + width,
							minY + height
						],
						[
							"L",
							minX,
							minY + height
						],
						["Z"]
					];
				} else {
					var firstElement = head(elements_1);
					var lastElement = last(elements_1);
					var startAngle = getAngle(firstElement.getModel(), coordinate_1).startAngle;
					var endAngle = getAngle(lastElement.getModel(), coordinate_1).endAngle;
					var center$1 = coordinate_1.getCenter();
					var radius = coordinate_1.getRadius();
					var innterRadius = coordinate_1.innerRadius * radius;
					path = getSectorPath(center$1.x, center$1.y, radius, startAngle, endAngle, innterRadius);
				}
				if (this.regionPath) {
					this.regionPath.attr("path", path);
					this.regionPath.show();
				} else {
					var style = get_default(args, "style", DEFAULT_REGION_PATH_STYLE);
					this.regionPath = backgroundGroup.addShape({
						type: "path",
						name: "active-region",
						capture: false,
						attrs: __assign(__assign({}, style), { path })
					});
				}
			}
		}
	};
	/**
	* 隐藏
	*/
	ActiveRegion$1.prototype.hide = function() {
		if (this.regionPath) this.regionPath.hide();
		this.items = null;
	};
	/**
	* 销毁
	*/
	ActiveRegion$1.prototype.destroy = function() {
		this.hide();
		if (this.regionPath) this.regionPath.remove(true);
		_super.prototype.destroy.call(this);
	};
	return ActiveRegion$1;
}(base_default$1);
var active_region_default = ActiveRegion;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/component/tooltip/geometry.js
/**
* Tooltip 展示隐藏的 Action
* @ignore
*/
var TooltipAction = function(_super) {
	__extends(TooltipAction$1, _super);
	function TooltipAction$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.timeStamp = 0;
		return _this;
	}
	/**
	* 显示 Tooltip
	* @returns
	*/
	TooltipAction$1.prototype.show = function() {
		var context = this.context;
		var ev = context.event;
		var view = context.view;
		if (view.isTooltipLocked()) return;
		var lastTimeStamp = this.timeStamp;
		var timeStamp = +/* @__PURE__ */ new Date();
		var showDelay = get_default(context.view.getOptions(), "tooltip.showDelay", 16);
		if (timeStamp - lastTimeStamp > showDelay) {
			var preLoc = this.location;
			var curLoc = {
				x: ev.x,
				y: ev.y
			};
			if (!preLoc || !is_equal_default(preLoc, curLoc)) this.showTooltip(view, curLoc);
			this.timeStamp = timeStamp;
			this.location = curLoc;
		}
	};
	/**
	* 隐藏 Tooltip。
	* @returns
	*/
	TooltipAction$1.prototype.hide = function() {
		var view = this.context.view;
		var tooltip$10 = view.getController("tooltip");
		var _a$5 = this.context.event, clientX = _a$5.clientX, clientY = _a$5.clientY;
		if (tooltip$10.isCursorEntered({
			x: clientX,
			y: clientY
		})) return;
		if (view.isTooltipLocked()) return;
		this.hideTooltip(view);
		this.location = null;
	};
	TooltipAction$1.prototype.showTooltip = function(view, point$1) {
		view.showTooltip(point$1);
	};
	TooltipAction$1.prototype.hideTooltip = function(view) {
		view.hideTooltip();
	};
	return TooltipAction$1;
}(base_default$1);
var geometry_default = TooltipAction;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/component/tooltip/sibling.js
/**
* 存在多个 view 时，控制其他 view 上的 tooltip 显示
* @ignore
*/
var SiblingTooltip = function(_super) {
	__extends(SiblingTooltip$1, _super);
	function SiblingTooltip$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	/**
	* 所有同一层级的 tooltip 显示
	* @param view
	* @param point
	*/
	SiblingTooltip$1.prototype.showTooltip = function(view, point$1) {
		var siblings = getSilbings(view);
		each_default(siblings, function(sibling) {
			var siblingPoint = getSiblingPoint(view, sibling, point$1);
			sibling.showTooltip(siblingPoint);
		});
	};
	/**
	* 隐藏同一层级的 tooltip
	* @param view
	*/
	SiblingTooltip$1.prototype.hideTooltip = function(view) {
		var siblings = getSilbings(view);
		each_default(siblings, function(sibling) {
			sibling.hideTooltip();
		});
	};
	return SiblingTooltip$1;
}(geometry_default);
var sibling_default = SiblingTooltip;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/component/tooltip/ellipsis-text.js
/**
* 用于组件文本省略后需要展示完整信息的 Tooltip Action
* @ignore
*/
var EllipsisText = function(_super) {
	__extends(EllipsisText$1, _super);
	function EllipsisText$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.timeStamp = 0;
		return _this;
	}
	EllipsisText$1.prototype.destroy = function() {
		_super.prototype.destroy.call(this);
		this.tooltip && this.tooltip.destroy();
	};
	/**
	* 显示 Tooltip
	* @returns
	*/
	EllipsisText$1.prototype.show = function() {
		var ev = this.context.event;
		var lastTimeStamp = this.timeStamp;
		var timeStamp = +/* @__PURE__ */ new Date();
		if (timeStamp - lastTimeStamp > 16) {
			var preLoc = this.location;
			var curLoc = {
				x: ev.x,
				y: ev.y
			};
			if (!preLoc || !is_equal_default(preLoc, curLoc)) this.showTooltip(curLoc);
			this.timeStamp = timeStamp;
			this.location = curLoc;
		}
	};
	/**
	* 隐藏 Tooltip。
	* @returns
	*/
	EllipsisText$1.prototype.hide = function() {
		this.hideTooltip();
		this.location = null;
	};
	EllipsisText$1.prototype.showTooltip = function(curLoc) {
		var context = this.context;
		var target = context.event.target;
		if (target && target.get("tip")) {
			if (!this.tooltip) this.renderTooltip();
			else {
				var canvas = context.view.canvas;
				var region = {
					start: {
						x: 0,
						y: 0
					},
					end: {
						x: canvas.get("width"),
						y: canvas.get("height")
					}
				};
				this.tooltip.set("region", region);
			}
			var tipContent = target.get("tip");
			this.tooltip.update(__assign({ title: tipContent }, curLoc));
			this.tooltip.show();
		}
	};
	EllipsisText$1.prototype.hideTooltip = function() {
		this.tooltip && this.tooltip.hide();
	};
	EllipsisText$1.prototype.renderTooltip = function() {
		var _a$5;
		var view = this.context.view;
		var canvas = view.canvas;
		var region = {
			start: {
				x: 0,
				y: 0
			},
			end: {
				x: canvas.get("width"),
				y: canvas.get("height")
			}
		};
		var theme$3 = view.getTheme();
		var tooltipStyles = get_default(theme$3, [
			"components",
			"tooltip",
			"domStyles"
		], {});
		var tooltip$10 = new HtmlTooltip({
			parent: canvas.get("el").parentNode,
			region,
			visible: false,
			crosshairs: null,
			domStyles: __assign({}, deep_mix_default({}, tooltipStyles, (_a$5 = {}, _a$5[CONTAINER_CLASS] = { "max-width": "50%" }, _a$5[TITLE_CLASS] = { "word-break": "break-all" }, _a$5)))
		});
		tooltip$10.init();
		tooltip$10.setCapture(false);
		this.tooltip = tooltip$10;
	};
	return EllipsisText$1;
}(base_default$1);
var ellipsis_text_default = EllipsisText;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/element/state-base.js
/**
* 状态量 Action 的基类
* @abstract
* @class
* @ignore
*/
var StateBase = function(_super) {
	__extends(StateBase$1, _super);
	function StateBase$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		/**
		* 状态名称
		*/
		_this.stateName = "";
		return _this;
	}
	/**
	* 是否具有某个状态
	* @param element 图表 Element 元素
	*/
	StateBase$1.prototype.hasState = function(element) {
		return element.hasState(this.stateName);
	};
	/**
	* 设置状态激活
	* @param enable 状态值
	*/
	StateBase$1.prototype.setElementState = function(element, enable) {
		element.setState(this.stateName, enable);
	};
	/**
	* 设置状态
	*/
	StateBase$1.prototype.setState = function() {
		this.setStateEnable(true);
	};
	/**
	* 清除所有 Element 的状态
	*/
	StateBase$1.prototype.clear = function() {
		var view = this.context.view;
		this.clearViewState(view);
	};
	StateBase$1.prototype.clearViewState = function(view) {
		var _this = this;
		var elements = getElementsByState(view, this.stateName);
		each_default(elements, function(el) {
			_this.setElementState(el, false);
		});
	};
	return StateBase$1;
}(base_default$1);
var state_base_default = StateBase;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/element/state.js
function getItem(shape) {
	return get_default(shape.get("delegateObject"), "item");
}
/**
* 状态量 Action 的基类，允许多个 Element 同时拥有某个状态
* @class
* @ignore
*/
var ElementState = function(_super) {
	__extends(ElementState$1, _super);
	function ElementState$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.ignoreListItemStates = ["unchecked"];
		return _this;
	}
	ElementState$1.prototype.isItemIgnore = function(item, list) {
		return !!this.ignoreListItemStates.filter(function(state$1) {
			return list.hasState(item, state$1);
		}).length;
	};
	ElementState$1.prototype.setStateByComponent = function(component$1, item, enable) {
		var view = this.context.view;
		var field$5 = component$1.get("field");
		var elements = getElements(view);
		this.setElementsStateByItem(elements, field$5, item, enable);
	};
	ElementState$1.prototype.setStateByElement = function(element, enable) {
		this.setElementState(element, enable);
	};
	/** 组件的选项是否同 element 匹配 */
	ElementState$1.prototype.isMathItem = function(element, field$5, item) {
		var view = this.context.view;
		var scale$4 = getScaleByField(view, field$5);
		var value$1 = getElementValue$1(element, field$5);
		return !is_nil_default(value$1) && item.name === scale$4.getText(value$1);
	};
	ElementState$1.prototype.setElementsStateByItem = function(elements, field$5, item, enable) {
		var _this = this;
		each_default(elements, function(el) {
			if (_this.isMathItem(el, field$5, item)) el.setState(_this.stateName, enable);
		});
	};
	/** 设置状态是否激活 */
	ElementState$1.prototype.setStateEnable = function(enable) {
		var element = getCurrentElement$1(this.context);
		if (element) {
			if (isElementChange(this.context)) this.setStateByElement(element, enable);
		} else {
			var delegateObject = getDelegationObject(this.context);
			if (isList(delegateObject)) {
				var item = delegateObject.item, component$1 = delegateObject.component;
				if (item && component$1 && !this.isItemIgnore(item, component$1)) {
					var event_1 = this.context.event.gEvent;
					if (event_1 && event_1.fromShape && event_1.toShape && getItem(event_1.fromShape) === getItem(event_1.toShape)) return;
					this.setStateByComponent(component$1, item, enable);
				}
			}
		}
	};
	/**
	* 切换状态
	*/
	ElementState$1.prototype.toggle = function() {
		var element = getCurrentElement$1(this.context);
		if (element) {
			var hasState = element.hasState(this.stateName);
			this.setElementState(element, !hasState);
		}
	};
	/**
	* 取消当前时间影响的状态
	*/
	ElementState$1.prototype.reset = function() {
		this.setStateEnable(false);
	};
	return ElementState$1;
}(state_base_default);
var state_default = ElementState;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/element/active.js
/**
* 元素 active 的 Action，允许多个元素同时 active
* @class
* @ignore
*/
var ElementActive = function(_super) {
	__extends(ElementActive$1, _super);
	function ElementActive$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.stateName = "active";
		return _this;
	}
	/**
	* Active Element
	*/
	ElementActive$1.prototype.active = function() {
		this.setState();
	};
	return ElementActive$1;
}(state_default);
var active_default = ElementActive;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/element/link-by-color.js
/**
* Link Elements by color
*
* public 方法是对外可用的反馈交互。使用方式，如：element-link-by-color:link, element-link-by-color:unlink, element-link-by-color:clear
*/
var LinkByColor = function(_super) {
	__extends(LinkByColor$1, _super);
	function LinkByColor$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.cache = {};
		return _this;
	}
	LinkByColor$1.prototype.getColorScale = function(view, element) {
		var colorAttr = element.geometry.getAttribute("color");
		if (!colorAttr) return null;
		return view.getScaleByField(colorAttr.getFields()[0]);
	};
	LinkByColor$1.prototype.getLinkPath = function(element, nextElement) {
		var isTransposed = this.context.view.getCoordinate().isTransposed;
		var bbox = element.shape.getCanvasBBox();
		var nextBBox = nextElement.shape.getCanvasBBox();
		return isTransposed ? [
			[
				"M",
				bbox.minX,
				bbox.minY
			],
			[
				"L",
				nextBBox.minX,
				nextBBox.maxY
			],
			[
				"L",
				nextBBox.maxX,
				nextBBox.maxY
			],
			[
				"L",
				bbox.maxX,
				bbox.minY
			],
			["Z"]
		] : [
			[
				"M",
				bbox.maxX,
				bbox.minY
			],
			[
				"L",
				nextBBox.minX,
				nextBBox.minY
			],
			[
				"L",
				nextBBox.minX,
				nextBBox.maxY
			],
			[
				"L",
				bbox.maxX,
				bbox.maxY
			],
			["Z"]
		];
	};
	LinkByColor$1.prototype.addLinkShape = function(group$1, element, nextElement, activeStyle) {
		var style = {
			opacity: .4,
			fill: element.shape.attr("fill")
		};
		group$1.addShape({
			type: "path",
			attrs: __assign(__assign({}, deep_mix_default({}, style, is_function_default(activeStyle) ? activeStyle(style, element) : activeStyle)), { path: this.getLinkPath(element, nextElement) })
		});
	};
	LinkByColor$1.prototype.linkByElement = function(element, activeStyle) {
		var _this = this;
		var view = this.context.view;
		var scale$4 = this.getColorScale(view, element);
		if (!scale$4) return;
		var value$1 = getElementValue$1(element, scale$4.field);
		if (!this.cache[value$1]) {
			var elements_1 = getElementsByField(view, scale$4.field, value$1);
			var group_1 = this.linkGroup.addGroup();
			this.cache[value$1] = group_1;
			var count_1 = elements_1.length;
			each_default(elements_1, function(el, index) {
				if (index < count_1 - 1) {
					var nextEl = elements_1[index + 1];
					_this.addLinkShape(group_1, el, nextEl, activeStyle);
				}
			});
		}
	};
	LinkByColor$1.prototype.removeLink = function(element) {
		var scale$4 = this.getColorScale(this.context.view, element);
		if (!scale$4) return;
		var value$1 = getElementValue$1(element, scale$4.field);
		if (this.cache[value$1]) {
			this.cache[value$1].remove();
			this.cache[value$1] = null;
		}
	};
	/**
	* 连接 elements
	*
	* @usage
	* registerInteraction('xxx', {
	*   start: [
	*    {
	*      trigger: 'interval:mouseenter',
	*      action: 'element-link-by-color:link',
	*      arg: {
	*        // style: { fill: 'red' }
	*        style: (style, element) => ({ fill: 'red' })
	*     },
	*   },
	*  ],
	* });
	*/
	LinkByColor$1.prototype.link = function(args) {
		var context = this.context;
		if (!this.linkGroup) this.linkGroup = context.view.foregroundGroup.addGroup({
			id: "link-by-color-group",
			capture: false
		});
		var element = getCurrentElement$1(context);
		if (element) this.linkByElement(element, args === null || args === void 0 ? void 0 : args.style);
	};
	/**
	* 取消连接 elements
	*/
	LinkByColor$1.prototype.unlink = function() {
		var element = getCurrentElement$1(this.context);
		if (element) this.removeLink(element);
	};
	/**
	* 清除所有连接
	*/
	LinkByColor$1.prototype.clear = function() {
		if (this.linkGroup) this.linkGroup.clear();
		this.cache = {};
	};
	/**
	* 销毁
	*/
	LinkByColor$1.prototype.destroy = function() {
		_super.prototype.destroy.call(this);
		if (this.linkGroup) this.linkGroup.remove();
	};
	return LinkByColor$1;
}(base_default$1);
var link_by_color_default = LinkByColor;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/element/range-state.js
/**
* @ignore
* 区域设置状态的基础 Action
*/
var ElementRangeState = function(_super) {
	__extends(ElementRangeState$1, _super);
	function ElementRangeState$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.startPoint = null;
		_this.endPoint = null;
		_this.isStarted = false;
		/**
		* 是否作用于当前 view 的 siblings，默认是 false 仅作用于自己
		*/
		_this.effectSiblings = false;
		/**
		* 是否受 element 的数据影响，还是受包围盒的影响
		*/
		_this.effectByRecord = false;
		return _this;
	}
	ElementRangeState$1.prototype.getCurrentPoint = function() {
		var event = this.context.event;
		return {
			x: event.x,
			y: event.y
		};
	};
	/**
	* 开始，记录开始选中的位置
	*/
	ElementRangeState$1.prototype.start = function() {
		this.clear();
		this.startPoint = this.getCurrentPoint();
		this.isStarted = true;
	};
	ElementRangeState$1.prototype.getIntersectElements = function() {
		var elements = null;
		if (isMask(this.context)) elements = getMaskedElements(this.context, 10);
		else {
			var startPoint = this.startPoint;
			var endPoint = this.isStarted ? this.getCurrentPoint() : this.endPoint;
			if (!startPoint || !endPoint) return;
			var box$1 = {
				minX: Math.min(startPoint.x, endPoint.x),
				minY: Math.min(startPoint.y, endPoint.y),
				maxX: Math.max(startPoint.x, endPoint.x),
				maxY: Math.max(startPoint.y, endPoint.y)
			};
			var view = this.context.view;
			elements = getIntersectElements(view, box$1);
		}
		return elements;
	};
	/**
	* 选中
	*/
	ElementRangeState$1.prototype.setStateEnable = function(enable) {
		if (this.effectSiblings && !this.effectByRecord) this.setSiblingsState(enable);
		else {
			var allElements = getElements(this.context.view);
			var elements = this.getIntersectElements();
			if (elements && elements.length) if (this.effectByRecord) this.setSiblingsStateByRecord(elements, enable);
			else this.setElementsState(elements, enable, allElements);
			else this.clear();
		}
	};
	ElementRangeState$1.prototype.setSiblingsStateByRecord = function(elements, enable) {
		var _this = this;
		var view = this.context.view;
		var siblings = getSilbings(view);
		var records = elements.map(function(el) {
			return el.getModel().data;
		});
		var xFiled = view.getXScale().field;
		var yField = view.getYScales()[0].field;
		each_default(siblings, function(sibling) {
			var allElements = getElements(sibling);
			var effectElements = allElements.filter(function(el) {
				var record = el.getModel().data;
				return isInRecords(records, record, xFiled, yField);
			});
			_this.setElementsState(effectElements, enable, allElements);
		});
	};
	ElementRangeState$1.prototype.setSiblingsState = function(enable) {
		var _this = this;
		var view = this.context.view;
		var siblings = getSilbings(view);
		if (isMask(this.context)) each_default(siblings, function(sibling) {
			var allElements = getElements(sibling);
			var effectElements = getSiblingMaskElements(_this.context, sibling, 10);
			if (effectElements && effectElements.length) _this.setElementsState(effectElements, enable, allElements);
			else _this.clearViewState(sibling);
		});
	};
	ElementRangeState$1.prototype.setElementsState = function(elements, enable, allElements) {
		var _this = this;
		each_default(allElements, function(el) {
			if (!elements.includes(el)) _this.setElementState(el, false);
			else _this.setElementState(el, enable);
		});
	};
	/**
	* 结束
	*/
	ElementRangeState$1.prototype.end = function() {
		this.isStarted = false;
		this.endPoint = this.getCurrentPoint();
	};
	ElementRangeState$1.prototype.clear = function() {
		var _this = this;
		var view = this.context.view;
		if (this.effectSiblings) {
			var siblings = getSilbings(view);
			each_default(siblings, function(sibling) {
				_this.clearViewState(sibling);
			});
		} else this.clearViewState(view);
	};
	return ElementRangeState$1;
}(state_base_default);
var range_state_default = ElementRangeState;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/element/range-active.js
/**
* @ignore
* 图表元素区域 Active 的 Action
*/
var ElementRangeActive = function(_super) {
	__extends(ElementRangeActive$1, _super);
	function ElementRangeActive$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.stateName = "active";
		return _this;
	}
	/**
	* 图表元素 Active
	*/
	ElementRangeActive$1.prototype.active = function() {
		this.setState();
	};
	return ElementRangeActive$1;
}(range_state_default);
var range_active_default = ElementRangeActive;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/element/single-state.js
/**
* 单状态量的 Action 基类
* @class
* @ignore
*/
var ElementSingleState = function(_super) {
	__extends(ElementSingleState$1, _super);
	function ElementSingleState$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	ElementSingleState$1.prototype.setStateEnable = function(enable) {
		var element = getCurrentElement$1(this.context);
		if (element) {
			if (!isElementChange(this.context)) return;
			if (enable) {
				this.clear();
				this.setElementState(element, true);
			} else if (this.hasState(element)) this.setElementState(element, false);
		}
	};
	/**
	* 切换选中，只允许选中一个
	*/
	ElementSingleState$1.prototype.toggle = function() {
		var element = getCurrentElement$1(this.context);
		if (element) {
			var hasState = this.hasState(element);
			if (!hasState) this.clear();
			this.setElementState(element, !hasState);
		}
	};
	/**
	* 取消当前时间影响的状态
	*/
	ElementSingleState$1.prototype.reset = function() {
		this.setStateEnable(false);
	};
	return ElementSingleState$1;
}(state_base_default);
var single_state_default = ElementSingleState;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/element/single-active.js
/**
* @ignore
* 仅允许单个 Element Active 的 Action
*/
var ElementSingleActive = function(_super) {
	__extends(ElementSingleActive$1, _super);
	function ElementSingleActive$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.stateName = "active";
		return _this;
	}
	/**
	* 当前事件相关的 Element Active
	*/
	ElementSingleActive$1.prototype.active = function() {
		this.setState();
	};
	return ElementSingleActive$1;
}(single_state_default);
var single_active_default = ElementSingleActive;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/element/highlight-util.js
var STATUS_UNACTIVE$3 = "inactive";
var STATUS_ACTIVE$3 = "active";
/**
* @ignore
* 清理 highlight 效果
* @param view View 或者 Chart
*/
function clearHighlight$1(view) {
	var elements = getElements(view);
	each_default(elements, function(el) {
		if (el.hasState(STATUS_ACTIVE$3)) el.setState(STATUS_ACTIVE$3, false);
		if (el.hasState(STATUS_UNACTIVE$3)) el.setState(STATUS_UNACTIVE$3, false);
	});
}
/**
* @ignore
* 设置多个元素的 highlight
* @param elements 元素集合
* @param callback 设置回调函数
* @param enable 设置或者取消
*/
function setHighlightBy(elements, callback, enable) {
	each_default(elements, function(el) {
		if (callback(el)) {
			if (el.hasState(STATUS_UNACTIVE$3)) el.setState(STATUS_UNACTIVE$3, false);
			el.setState(STATUS_ACTIVE$3, enable);
		} else {
			if (el.hasState(STATUS_ACTIVE$3)) el.setState(STATUS_ACTIVE$3, false);
			el.setState(STATUS_UNACTIVE$3, enable);
		}
	});
}

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/element/highlight.js
var STATUS_UNACTIVE$2 = ELEMENT_STATE.INACTIVE;
var STATUS_ACTIVE$2 = ELEMENT_STATE.ACTIVE;
/**
* @ignore
* highlight，指定图形高亮，其他图形变暗
*/
var ElementHighlight = function(_super) {
	__extends(ElementHighlight$1, _super);
	function ElementHighlight$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.stateName = STATUS_ACTIVE$2;
		return _this;
	}
	ElementHighlight$1.prototype.setElementsStateByItem = function(elements, field$5, item, enable) {
		var _this = this;
		var callback = function(el) {
			return _this.isMathItem(el, field$5, item);
		};
		this.setHighlightBy(elements, callback, enable);
	};
	ElementHighlight$1.prototype.setElementHighlight = function(el, callback) {
		if (callback(el)) {
			if (el.hasState(STATUS_UNACTIVE$2)) el.setState(STATUS_UNACTIVE$2, false);
			el.setState(STATUS_ACTIVE$2, true);
		} else if (!el.hasState(STATUS_ACTIVE$2)) el.setState(STATUS_UNACTIVE$2, true);
	};
	ElementHighlight$1.prototype.setHighlightBy = function(elements, callback, enable) {
		var _this = this;
		if (enable) each_default(elements, function(el) {
			_this.setElementHighlight(el, callback);
		});
		else {
			var activeElements = getElementsByState(this.context.view, STATUS_ACTIVE$2);
			var allCancel_1 = true;
			each_default(activeElements, function(el) {
				if (!callback(el)) {
					allCancel_1 = false;
					return false;
				}
			});
			if (allCancel_1) this.clear();
			else each_default(elements, function(el) {
				if (callback(el)) {
					if (el.hasState(STATUS_ACTIVE$2)) el.setState(STATUS_ACTIVE$2, false);
					el.setState(STATUS_UNACTIVE$2, true);
				}
			});
		}
	};
	ElementHighlight$1.prototype.setElementState = function(element, enable) {
		var view = this.context.view;
		var elements = getElements(view);
		this.setHighlightBy(elements, function(el) {
			return element === el;
		}, enable);
	};
	ElementHighlight$1.prototype.highlight = function() {
		this.setState();
	};
	ElementHighlight$1.prototype.clear = function() {
		var view = this.context.view;
		clearHighlight$1(view);
	};
	return ElementHighlight$1;
}(state_default);
var highlight_default = ElementHighlight;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/element/highlight-by-color.js
/**
* Highlight color
* @ignore
*/
var HighlightColor = function(_super) {
	__extends(HighlightColor$1, _super);
	function HighlightColor$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	HighlightColor$1.prototype.setStateByElement = function(element, enable) {
		var view = this.context.view;
		var colorAttr = element.geometry.getAttribute("color");
		if (!colorAttr) return;
		var scale$4 = view.getScaleByField(colorAttr.getFields()[0]);
		var value$1 = getElementValue$1(element, scale$4.field);
		var elements = getElements(view);
		var highlightElements = elements.filter(function(el) {
			return getElementValue$1(el, scale$4.field) === value$1;
		});
		this.setHighlightBy(elements, function(el) {
			return highlightElements.includes(el);
		}, enable);
	};
	return HighlightColor$1;
}(highlight_default);
var highlight_by_color_default = HighlightColor;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/element/highlight-by-x.js
/**
* Highlight x
* @ignore
*/
var HighlightX = function(_super) {
	__extends(HighlightX$1, _super);
	function HighlightX$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	HighlightX$1.prototype.setElementHighlight = function(el, callback) {
		if (callback(el)) {
			if (el.hasState(STATUS_UNACTIVE$2)) el.setState(STATUS_UNACTIVE$2, false);
			el.setState(STATUS_ACTIVE$2, true);
		} else {
			el.setState(STATUS_UNACTIVE$2, true);
			if (el.hasState(STATUS_ACTIVE$2)) el.setState(STATUS_ACTIVE$2, false);
		}
	};
	HighlightX$1.prototype.setStateByElement = function(element, enable) {
		var view = this.context.view;
		var scale$4 = view.getXScale();
		var value$1 = getElementValue$1(element, scale$4.field);
		var elements = getElements(view);
		var highlightElements = elements.filter(function(el) {
			return getElementValue$1(el, scale$4.field) === value$1;
		});
		this.setHighlightBy(elements, function(el) {
			return highlightElements.includes(el);
		}, enable);
	};
	/**
	* 切换状态
	*/
	HighlightX$1.prototype.toggle = function() {
		var element = getCurrentElement$1(this.context);
		if (element) {
			var hasState = element.hasState(this.stateName);
			this.setStateByElement(element, !hasState);
		}
	};
	return HighlightX$1;
}(highlight_default);
var highlight_by_x_default = HighlightX;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/element/range-highlight.js
var EVENTS$1;
(function(EVENTS$3) {
	EVENTS$3["BEFORE_HIGHLIGHT"] = "element-range-highlight:beforehighlight";
	EVENTS$3["AFTER_HIGHLIGHT"] = "element-range-highlight:afterhighlight";
	EVENTS$3["BEFORE_CLEAR"] = "element-range-highlight:beforeclear";
	EVENTS$3["AFTER_CLEAR"] = "element-range-highlight:afterclear";
})(EVENTS$1 || (EVENTS$1 = {}));
/**
* @ignore
* 区域 highlight 的 Action
*/
var ElementRangeHighlight = function(_super) {
	__extends(ElementRangeHighlight$1, _super);
	function ElementRangeHighlight$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.stateName = "active";
		return _this;
	}
	ElementRangeHighlight$1.prototype.clearViewState = function(view) {
		clearHighlight$1(view);
	};
	/**
	* 设置 highlight
	*/
	ElementRangeHighlight$1.prototype.highlight = function() {
		var _a$5 = this.context, view = _a$5.view, event = _a$5.event;
		var elements = this.getIntersectElements();
		var payload = {
			view,
			event,
			highlightElements: elements
		};
		view.emit(EVENTS$1.BEFORE_HIGHLIGHT, event_default.fromData(view, EVENTS$1.BEFORE_HIGHLIGHT, payload));
		this.setState();
		view.emit(EVENTS$1.AFTER_HIGHLIGHT, event_default.fromData(view, EVENTS$1.AFTER_HIGHLIGHT, payload));
	};
	/**
	* @overrider 添加事件
	*/
	ElementRangeHighlight$1.prototype.clear = function() {
		var view = this.context.view;
		view.emit(EVENTS$1.BEFORE_CLEAR, event_default.fromData(view, EVENTS$1.BEFORE_CLEAR, {}));
		_super.prototype.clear.call(this);
		view.emit(EVENTS$1.AFTER_CLEAR, event_default.fromData(view, EVENTS$1.AFTER_CLEAR, {}));
	};
	ElementRangeHighlight$1.prototype.setElementsState = function(elements, enable, allElements) {
		setHighlightBy(allElements, function(el) {
			return elements.indexOf(el) >= 0;
		}, enable);
	};
	return ElementRangeHighlight$1;
}(range_state_default);
var range_highlight_default = ElementRangeHighlight;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/element/single-highlight.js
/**
* @ignore
* 单个 Element Highlight 的 Action
*/
var ElementSingleHighlight = function(_super) {
	__extends(ElementSingleHighlight$1, _super);
	function ElementSingleHighlight$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.stateName = "active";
		return _this;
	}
	/**
	* Element Highlight
	*/
	ElementSingleHighlight$1.prototype.highlight = function() {
		this.setState();
	};
	ElementSingleHighlight$1.prototype.setElementState = function(element, enable) {
		var view = this.context.view;
		var elements = getElements(view);
		setHighlightBy(elements, function(el) {
			return element === el;
		}, enable);
	};
	ElementSingleHighlight$1.prototype.clear = function() {
		var view = this.context.view;
		clearHighlight$1(view);
	};
	return ElementSingleHighlight$1;
}(single_state_default);
var single_highlight_default = ElementSingleHighlight;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/element/range-selected.js
/**
* @ignore
* 区域选中的 Action
*/
var ElementRangeSelected = function(_super) {
	__extends(ElementRangeSelected$1, _super);
	function ElementRangeSelected$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.stateName = "selected";
		return _this;
	}
	/**
	* 选中
	*/
	ElementRangeSelected$1.prototype.selected = function() {
		this.setState();
	};
	return ElementRangeSelected$1;
}(range_state_default);
var range_selected_default = ElementRangeSelected;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/element/selected.js
/**
* @ignore
* 允许多选的 Action
* @class
*/
var ElementMultipleSelected = function(_super) {
	__extends(ElementMultipleSelected$1, _super);
	function ElementMultipleSelected$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.stateName = "selected";
		return _this;
	}
	/**
	* 选中节点，允许多选
	*/
	ElementMultipleSelected$1.prototype.selected = function() {
		this.setState();
	};
	return ElementMultipleSelected$1;
}(state_default);
var selected_default = ElementMultipleSelected;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/element/single-selected.js
/**
* @ignore
* 单选的 Action
*/
var ElementSingleSelected = function(_super) {
	__extends(ElementSingleSelected$1, _super);
	function ElementSingleSelected$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.stateName = "selected";
		return _this;
	}
	/**
	* 选中
	*/
	ElementSingleSelected$1.prototype.selected = function() {
		this.setState();
	};
	return ElementSingleSelected$1;
}(single_state_default);
var single_selected_default = ElementSingleSelected;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/component/list-state.js
/**
* 列表项状态 Action 的基础类
* @class
* @ignore
*/
var ListState = function(_super) {
	__extends(ListState$1, _super);
	function ListState$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.stateName = "";
		_this.ignoreItemStates = [];
		return _this;
	}
	/** 获取触发的列表组件 */
	ListState$1.prototype.getTriggerListInfo = function() {
		var delegateObject = getDelegationObject(this.context);
		var info = null;
		if (isList(delegateObject)) info = {
			item: delegateObject.item,
			list: delegateObject.component
		};
		return info;
	};
	ListState$1.prototype.getAllowComponents = function() {
		var _this = this;
		var view = this.context.view;
		var components = getComponents(view);
		var rst = [];
		each_default(components, function(component$1) {
			if (component$1.isList() && _this.allowSetStateByElement(component$1)) rst.push(component$1);
		});
		return rst;
	};
	/** 是否存在指定的状态 */
	ListState$1.prototype.hasState = function(list, item) {
		return list.hasState(item, this.stateName);
	};
	/** 清理组件的状态 */
	ListState$1.prototype.clearAllComponentsState = function() {
		var _this = this;
		var components = this.getAllowComponents();
		each_default(components, function(component$1) {
			component$1.clearItemsState(_this.stateName);
		});
	};
	ListState$1.prototype.allowSetStateByElement = function(component$1) {
		var field$5 = component$1.get("field");
		if (!field$5) return false;
		if (this.cfg && this.cfg.componentNames) {
			var name_1 = component$1.get("name");
			if (this.cfg.componentNames.indexOf(name_1) === -1) return false;
		}
		var view = this.context.view;
		var scale$4 = getScaleByField(view, field$5);
		return scale$4 && scale$4.isCategory;
	};
	ListState$1.prototype.allowSetStateByItem = function(item, list) {
		var ignoreStates = this.ignoreItemStates;
		if (ignoreStates.length) return ignoreStates.filter(function(state$1) {
			return list.hasState(item, state$1);
		}).length === 0;
		return true;
	};
	ListState$1.prototype.setStateByElement = function(component$1, element, enable) {
		var field$5 = component$1.get("field");
		var view = this.context.view;
		var scale$4 = getScaleByField(view, field$5);
		var value$1 = getElementValue$1(element, field$5);
		var text = scale$4.getText(value$1);
		this.setItemsState(component$1, text, enable);
	};
	ListState$1.prototype.setStateEnable = function(enable) {
		var _this = this;
		var element = getCurrentElement$1(this.context);
		if (element) {
			var components = this.getAllowComponents();
			each_default(components, function(component$2) {
				_this.setStateByElement(component$2, element, enable);
			});
		} else {
			var delegateObject = getDelegationObject(this.context);
			if (isList(delegateObject)) {
				var item = delegateObject.item, component$1 = delegateObject.component;
				if (this.allowSetStateByElement(component$1) && this.allowSetStateByItem(item, component$1)) this.setItemState(component$1, item, enable);
			}
		}
	};
	ListState$1.prototype.setItemsState = function(list, name, enable) {
		var _this = this;
		var items = list.getItems();
		each_default(items, function(item) {
			if (item.name === name) _this.setItemState(list, item, enable);
		});
	};
	ListState$1.prototype.setItemState = function(list, item, enable) {
		list.setItemState(item, this.stateName, enable);
	};
	/**
	* 设置状态
	*/
	ListState$1.prototype.setState = function() {
		this.setStateEnable(true);
	};
	/**
	* 取消状态
	*/
	ListState$1.prototype.reset = function() {
		this.setStateEnable(false);
	};
	/**
	* 切换状态
	*/
	ListState$1.prototype.toggle = function() {
		var triggerInfo = this.getTriggerListInfo();
		if (triggerInfo && triggerInfo.item) {
			var list = triggerInfo.list, item = triggerInfo.item;
			var enable = this.hasState(list, item);
			this.setItemState(list, item, !enable);
		}
	};
	/**
	* 取消状态
	*/
	ListState$1.prototype.clear = function() {
		var triggerInfo = this.getTriggerListInfo();
		if (triggerInfo) triggerInfo.list.clearItemsState(this.stateName);
		else this.clearAllComponentsState();
	};
	return ListState$1;
}(base_default$1);
var list_state_default = ListState;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/component/list-active.js
/**
* 列表项（图例项、坐标轴文本）激活的 Action
* @class
* @ignore
*/
var ListActive = function(_super) {
	__extends(ListActive$1, _super);
	function ListActive$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.stateName = "active";
		return _this;
	}
	/**
	* 激活选项
	*/
	ListActive$1.prototype.active = function() {
		this.setState();
	};
	return ListActive$1;
}(list_state_default);
var list_active_default = ListActive;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/component/list-highlight-util.js
var STATUS_UNACTIVE$1 = "inactive";
var STATUS_ACTIVE$1 = "active";
/**
* 清理图例的 Highlight 效果
* @param list 列表组件，图例或者坐标轴
* @ignore
*/
function clearList(list) {
	var items = list.getItems();
	each_default(items, function(item) {
		if (list.hasState(item, STATUS_ACTIVE$1)) list.setItemState(item, STATUS_ACTIVE$1, false);
		if (list.hasState(item, STATUS_UNACTIVE$1)) list.setItemState(item, STATUS_UNACTIVE$1, false);
	});
}

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/component/list-highlight.js
var STATUS_UNACTIVE = "inactive";
var STATUS_ACTIVE = "active";
/**
* highlight Action 的效果是 active 和 inactive 两个状态的组合
* @class
* @ignore
*/
var ListHighlight = function(_super) {
	__extends(ListHighlight$1, _super);
	function ListHighlight$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.stateName = STATUS_ACTIVE;
		_this.ignoreItemStates = ["unchecked"];
		return _this;
	}
	ListHighlight$1.prototype.setItemsState = function(list, name, enable) {
		this.setHighlightBy(list, function(item) {
			return item.name === name;
		}, enable);
	};
	ListHighlight$1.prototype.setItemState = function(list, item, enable) {
		list.getItems();
		this.setHighlightBy(list, function(el) {
			return el === item;
		}, enable);
	};
	ListHighlight$1.prototype.setHighlightBy = function(list, callback, enable) {
		var items = list.getItems();
		if (enable) each_default(items, function(item) {
			if (callback(item)) {
				if (list.hasState(item, STATUS_UNACTIVE)) list.setItemState(item, STATUS_UNACTIVE, false);
				list.setItemState(item, STATUS_ACTIVE, true);
			} else if (!list.hasState(item, STATUS_ACTIVE)) list.setItemState(item, STATUS_UNACTIVE, true);
		});
		else {
			var activeItems = list.getItemsByState(STATUS_ACTIVE);
			var allCancel_1 = true;
			each_default(activeItems, function(item) {
				if (!callback(item)) {
					allCancel_1 = false;
					return false;
				}
			});
			if (allCancel_1) this.clear();
			else each_default(items, function(item) {
				if (callback(item)) {
					if (list.hasState(item, STATUS_ACTIVE)) list.setItemState(item, STATUS_ACTIVE, false);
					list.setItemState(item, STATUS_UNACTIVE, true);
				}
			});
		}
	};
	/**
	* highlight 图例项（坐标轴文本）
	*/
	ListHighlight$1.prototype.highlight = function() {
		this.setState();
	};
	ListHighlight$1.prototype.clear = function() {
		var triggerInfo = this.getTriggerListInfo();
		if (triggerInfo) clearList(triggerInfo.list);
		else {
			var components = this.getAllowComponents();
			each_default(components, function(component$1) {
				component$1.clearItemsState(STATUS_ACTIVE);
				component$1.clearItemsState(STATUS_UNACTIVE);
			});
		}
	};
	return ListHighlight$1;
}(list_state_default);
var list_highlight_default = ListHighlight;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/component/list-selected.js
/**
* 图例项和坐标轴文本选中的 Action
* @ignore
*/
var ListSelected = function(_super) {
	__extends(ListSelected$1, _super);
	function ListSelected$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.stateName = "selected";
		return _this;
	}
	ListSelected$1.prototype.selected = function() {
		this.setState();
	};
	return ListSelected$1;
}(list_state_default);
var list_selected_default = ListSelected;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/component/list-unchecked.js
/**
* 图例项取消勾选的 Action
* @ignore
*/
var ListUnchecked = function(_super) {
	__extends(ListUnchecked$1, _super);
	function ListUnchecked$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.stateName = "unchecked";
		return _this;
	}
	/**
	* 取消勾选
	*/
	ListUnchecked$1.prototype.unchecked = function() {
		this.setState();
	};
	return ListUnchecked$1;
}(list_state_default);
var list_unchecked_default = ListUnchecked;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/component/list-checked.js
var STATUS_UNCHECKED$1 = "unchecked";
var STATUS_CHECKED = "checked";
/**
* checked Action
* 提供三个对外方法
* 1. toggle 切换状态
* 2. checked 选中
* 3. reset 清除重置
*/
var ListChecked = function(_super) {
	__extends(ListChecked$1, _super);
	function ListChecked$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.stateName = STATUS_CHECKED;
		return _this;
	}
	ListChecked$1.prototype.setItemState = function(list, item, enable) {
		this.setCheckedBy(list, function(el) {
			return el === item;
		}, enable);
	};
	ListChecked$1.prototype.setCheckedBy = function(list, callback, enable) {
		var items = list.getItems();
		if (enable) each_default(items, function(item) {
			if (callback(item)) {
				if (list.hasState(item, STATUS_UNCHECKED$1)) list.setItemState(item, STATUS_UNCHECKED$1, false);
				list.setItemState(item, STATUS_CHECKED, true);
			} else if (!list.hasState(item, STATUS_CHECKED)) list.setItemState(item, STATUS_UNCHECKED$1, true);
		});
	};
	/**
	* 切换状态.
	* 1. 当全部选中的时候 或者 当前 item 未选中时，进行激活操作
	* 2. 否则，重置
	* @override
	*/
	ListChecked$1.prototype.toggle = function() {
		var triggerInfo = this.getTriggerListInfo();
		if (triggerInfo && triggerInfo.item) {
			var list_1 = triggerInfo.list, item = triggerInfo.item;
			if (!some_default(list_1.getItems(), function(t) {
				return list_1.hasState(t, STATUS_UNCHECKED$1);
			}) || list_1.hasState(item, STATUS_UNCHECKED$1)) this.setItemState(list_1, item, true);
			else this.reset();
		}
	};
	/**
	* checked 图例项
	*/
	ListChecked$1.prototype.checked = function() {
		this.setState();
	};
	/**
	* 重置，需要全部清理 checked 和 unchecked
	*/
	ListChecked$1.prototype.reset = function() {
		var components = this.getAllowComponents();
		each_default(components, function(component$1) {
			component$1.clearItemsState(STATUS_CHECKED);
			component$1.clearItemsState(STATUS_UNCHECKED$1);
		});
	};
	return ListChecked$1;
}(list_state_default);
var list_checked_default = ListChecked;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/component/list-focus.js
var STATUS_UNCHECKED = "unchecked";
var ListFocus = function(_super) {
	__extends(ListFocus$1, _super);
	function ListFocus$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	ListFocus$1.prototype.toggle = function() {
		var e_1, _a$5, e_2, _b, e_3, _c, e_4, _d;
		var triggerInfo = this.getTriggerListInfo();
		if (triggerInfo === null || triggerInfo === void 0 ? void 0 : triggerInfo.item) {
			var list_1 = triggerInfo.list, clickedItem = triggerInfo.item;
			var items = list_1.getItems();
			var checkedItems = items.filter(function(t) {
				return !list_1.hasState(t, STATUS_UNCHECKED);
			});
			var uncheckedItems = items.filter(function(t) {
				return list_1.hasState(t, STATUS_UNCHECKED);
			});
			var checkedItem = checkedItems[0];
			/**
			* 1. 初始化，全部 checked。此时，点击 radio, clickItem 进入聚焦
			* 2. 当前只选中一个
			*    2.1 且选中 item 等于 clickItem，退出聚焦，全部重新选中
			*    2.2 替换聚焦的 item
			* 3. 其它，同 2.2
			*/
			if (items.length === checkedItems.length) try {
				for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
					var item = items_1_1.value;
					list_1.setItemState(item, STATUS_UNCHECKED, item.id !== clickedItem.id);
				}
			} catch (e_1_1) {
				e_1 = { error: e_1_1 };
			} finally {
				try {
					if (items_1_1 && !items_1_1.done && (_a$5 = items_1.return)) _a$5.call(items_1);
				} finally {
					if (e_1) throw e_1.error;
				}
			}
			else if (items.length - uncheckedItems.length === 1) if (checkedItem.id === clickedItem.id) try {
				for (var items_2 = __values(items), items_2_1 = items_2.next(); !items_2_1.done; items_2_1 = items_2.next()) {
					var item = items_2_1.value;
					list_1.setItemState(item, STATUS_UNCHECKED, false);
				}
			} catch (e_2_1) {
				e_2 = { error: e_2_1 };
			} finally {
				try {
					if (items_2_1 && !items_2_1.done && (_b = items_2.return)) _b.call(items_2);
				} finally {
					if (e_2) throw e_2.error;
				}
			}
			else try {
				for (var items_3 = __values(items), items_3_1 = items_3.next(); !items_3_1.done; items_3_1 = items_3.next()) {
					var item = items_3_1.value;
					list_1.setItemState(item, STATUS_UNCHECKED, item.id !== clickedItem.id);
				}
			} catch (e_3_1) {
				e_3 = { error: e_3_1 };
			} finally {
				try {
					if (items_3_1 && !items_3_1.done && (_c = items_3.return)) _c.call(items_3);
				} finally {
					if (e_3) throw e_3.error;
				}
			}
			else try {
				for (var items_4 = __values(items), items_4_1 = items_4.next(); !items_4_1.done; items_4_1 = items_4.next()) {
					var item = items_4_1.value;
					list_1.setItemState(item, STATUS_UNCHECKED, item.id !== clickedItem.id);
				}
			} catch (e_4_1) {
				e_4 = { error: e_4_1 };
			} finally {
				try {
					if (items_4_1 && !items_4_1.done && (_d = items_4.return)) _d.call(items_4);
				} finally {
					if (e_4) throw e_4.error;
				}
			}
		}
	};
	return ListFocus$1;
}(list_state_default);
var list_focus_default = ListFocus;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/component/list-radio.js
var STATUS_SHOW = "showRadio";
var TIP_ID = "legend-radio-tip";
var ListRadio = function(_super) {
	__extends(ListRadio$1, _super);
	function ListRadio$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.timeStamp = 0;
		return _this;
	}
	ListRadio$1.prototype.show = function() {
		var triggerInfo = this.getTriggerListInfo();
		if (triggerInfo === null || triggerInfo === void 0 ? void 0 : triggerInfo.item) {
			var list = triggerInfo.list, item = triggerInfo.item;
			list.setItemState(item, STATUS_SHOW, true);
		}
	};
	ListRadio$1.prototype.hide = function() {
		var triggerInfo = this.getTriggerListInfo();
		if (triggerInfo === null || triggerInfo === void 0 ? void 0 : triggerInfo.item) {
			var list = triggerInfo.list, item = triggerInfo.item;
			list.setItemState(item, STATUS_SHOW, false);
		}
	};
	ListRadio$1.prototype.destroy = function() {
		_super.prototype.destroy.call(this);
		this.tooltip && this.tooltip.destroy();
	};
	/**
	* 显示 Tooltip (展示在上方)
	* @returns
	*/
	ListRadio$1.prototype.showTip = function() {
		var ev = this.context.event;
		var lastTimeStamp = this.timeStamp;
		var timeStamp = +/* @__PURE__ */ new Date();
		var target = this.context.event.target;
		if (timeStamp - lastTimeStamp > 16 && target.get("name") === "legend-item-radio") {
			var preLoc = this.location;
			var curLoc = {
				x: ev.x,
				y: ev.y
			};
			this.timeStamp = timeStamp;
			this.location = curLoc;
			if (!preLoc || !is_equal_default(preLoc, curLoc)) this.showTooltip(curLoc);
		}
	};
	/**
	* 隐藏 Tooltip。
	* @returns
	*/
	ListRadio$1.prototype.hideTip = function() {
		this.hideTooltip();
		this.location = null;
	};
	ListRadio$1.prototype.showTooltip = function(curLoc) {
		var context = this.context;
		var target = context.event.target;
		if (target && target.get("tip")) {
			if (!this.tooltip) this.renderTooltip();
			var _a$5 = context.view.getCanvas().get("el").getBoundingClientRect(), offsetX = _a$5.x, offsetY = _a$5.y;
			this.tooltip.update(__assign(__assign({ title: target.get("tip") }, curLoc), {
				x: curLoc.x + offsetX,
				y: curLoc.y + offsetY
			}));
			this.tooltip.show();
		}
	};
	ListRadio$1.prototype.hideTooltip = function() {
		this.tooltip && this.tooltip.hide();
	};
	ListRadio$1.prototype.renderTooltip = function() {
		var _a$5;
		var tooltipStyles = (_a$5 = {}, _a$5[CONTAINER_CLASS] = {
			padding: "6px 8px",
			transform: "translate(-50%, -80%)",
			background: "rgba(0,0,0,0.75)",
			color: "#fff",
			"border-radius": "2px",
			"z-index": 100
		}, _a$5[TITLE_CLASS] = {
			"font-size": "12px",
			"line-height": "14px",
			"margin-bottom": 0,
			"word-break": "break-all"
		}, _a$5);
		if (document.getElementById(TIP_ID)) document.body.removeChild(document.getElementById(TIP_ID));
		var tooltip$10 = new HtmlTooltip({
			parent: document.body,
			region: null,
			visible: false,
			crosshairs: null,
			domStyles: tooltipStyles,
			containerId: TIP_ID
		});
		tooltip$10.init();
		tooltip$10.setCapture(false);
		this.tooltip = tooltip$10;
	};
	return ListRadio$1;
}(list_state_default);
var list_radio_default = ListRadio;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/mask/base.js
/**
* @ignore
* 辅助框 Action 的基类
*/
var MaskBase = function(_super) {
	__extends(MaskBase$1, _super);
	function MaskBase$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.maskShape = null;
		_this.points = [];
		_this.starting = false;
		_this.moving = false;
		_this.preMovePoint = null;
		_this.shapeType = "path";
		return _this;
	}
	MaskBase$1.prototype.getCurrentPoint = function() {
		var event = this.context.event;
		return {
			x: event.x,
			y: event.y
		};
	};
	MaskBase$1.prototype.emitEvent = function(type) {
		var eventName = "mask:".concat(type);
		var view = this.context.view;
		var event = this.context.event;
		view.emit(eventName, {
			target: this.maskShape,
			shape: this.maskShape,
			points: this.points,
			x: event.x,
			y: event.y
		});
	};
	MaskBase$1.prototype.createMask = function() {
		var view = this.context.view;
		var maskAttrs = this.getMaskAttrs();
		return view.foregroundGroup.addShape({
			type: this.shapeType,
			name: "mask",
			draggable: true,
			attrs: __assign({
				fill: "#C5D4EB",
				opacity: .3
			}, maskAttrs)
		});
	};
	MaskBase$1.prototype.getMaskPath = function() {
		return [];
	};
	/**
	* 显示
	*/
	MaskBase$1.prototype.show = function() {
		if (this.maskShape) {
			this.maskShape.show();
			this.emitEvent("show");
		}
	};
	/**
	* 开始
	*/
	MaskBase$1.prototype.start = function(arg) {
		this.starting = true;
		this.moving = false;
		this.points = [this.getCurrentPoint()];
		if (!this.maskShape) {
			this.maskShape = this.createMask();
			this.maskShape.set("capture", false);
		}
		this.updateMask(arg === null || arg === void 0 ? void 0 : arg.maskStyle);
		this.emitEvent("start");
	};
	/**
	* 开始移动
	*/
	MaskBase$1.prototype.moveStart = function() {
		this.moving = true;
		this.preMovePoint = this.getCurrentPoint();
	};
	/**
	* 移动 mask
	*/
	MaskBase$1.prototype.move = function() {
		if (!this.moving || !this.maskShape) return;
		var currentPoint = this.getCurrentPoint();
		var preMovePoint = this.preMovePoint;
		var dx = currentPoint.x - preMovePoint.x;
		var dy = currentPoint.y - preMovePoint.y;
		var points = this.points;
		each_default(points, function(point$1) {
			point$1.x += dx;
			point$1.y += dy;
		});
		this.updateMask();
		this.emitEvent("change");
		this.preMovePoint = currentPoint;
	};
	MaskBase$1.prototype.updateMask = function(maskStyle) {
		var attrs = deep_mix_default({}, this.getMaskAttrs(), maskStyle);
		this.maskShape.attr(attrs);
	};
	/**
	* 结束移动
	*/
	MaskBase$1.prototype.moveEnd = function() {
		this.moving = false;
		this.preMovePoint = null;
	};
	/**
	* 结束
	*/
	MaskBase$1.prototype.end = function() {
		this.starting = false;
		this.emitEvent("end");
		if (this.maskShape) this.maskShape.set("capture", true);
	};
	/**
	* 隐藏
	*/
	MaskBase$1.prototype.hide = function() {
		if (this.maskShape) {
			this.maskShape.hide();
			this.emitEvent("hide");
		}
	};
	/**
	* 大小变化
	*/
	MaskBase$1.prototype.resize = function() {
		if (this.starting && this.maskShape) {
			this.points.push(this.getCurrentPoint());
			this.updateMask();
			this.emitEvent("change");
		}
	};
	/**
	* 销毁
	*/
	MaskBase$1.prototype.destroy = function() {
		this.points = [];
		if (this.maskShape) this.maskShape.remove();
		this.maskShape = null;
		this.preMovePoint = null;
		_super.prototype.destroy.call(this);
	};
	return MaskBase$1;
}(base_default$1);
var base_default$3 = MaskBase;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/mask/circle.js
function getMaskAttrs$2(points) {
	var currentPoint = last(points);
	var r = 0;
	var x = 0;
	var y = 0;
	if (points.length) {
		var first = points[0];
		r = distance$1(first, currentPoint) / 2;
		x = (currentPoint.x + first.x) / 2;
		y = (currentPoint.y + first.y) / 2;
	}
	return {
		x,
		y,
		r
	};
}
/**
* @ignore
* 圆形辅助框 Action
*/
var CircleMask = function(_super) {
	__extends(CircleMask$1, _super);
	function CircleMask$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.shapeType = "circle";
		return _this;
	}
	CircleMask$1.prototype.getMaskAttrs = function() {
		return getMaskAttrs$2(this.points);
	};
	return CircleMask$1;
}(base_default$3);
var circle_default$1 = CircleMask;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/mask/rect.js
function getRegion$1(points) {
	return {
		start: head(points),
		end: last(points)
	};
}
/**
* 添加图形
* @param points
* @returns
*/
function getMaskAttrs$3(start, end) {
	var x = Math.min(start.x, end.x);
	var y = Math.min(start.y, end.y);
	var width = Math.abs(end.x - start.x);
	var height = Math.abs(end.y - start.y);
	return {
		x,
		y,
		width,
		height
	};
}
/**
* @ignore
* 矩形的辅助框 Action
*/
var RectMask = function(_super) {
	__extends(RectMask$1, _super);
	function RectMask$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.shapeType = "rect";
		return _this;
	}
	RectMask$1.prototype.getRegion = function() {
		return getRegion$1(this.points);
	};
	RectMask$1.prototype.getMaskAttrs = function() {
		var _a$5 = this.getRegion(), start = _a$5.start, end = _a$5.end;
		return getMaskAttrs$3(start, end);
	};
	return RectMask$1;
}(base_default$3);
var rect_default$1 = RectMask;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/mask/dim-rect.js
function clampPoint(point$1) {
	point$1.x = clamp_default(point$1.x, 0, 1);
	point$1.y = clamp_default(point$1.y, 0, 1);
}
function getRegion(points, dim, inPlot, coord$1) {
	var start = null;
	var end = null;
	var normalStart = coord$1.invert(head(points));
	var normalEnd = coord$1.invert(last(points));
	if (inPlot) {
		clampPoint(normalStart);
		clampPoint(normalEnd);
	}
	if (dim === "x") {
		start = coord$1.convert({
			x: normalStart.x,
			y: 0
		});
		end = coord$1.convert({
			x: normalEnd.x,
			y: 1
		});
	} else {
		start = coord$1.convert({
			x: 0,
			y: normalStart.y
		});
		end = coord$1.convert({
			x: 1,
			y: normalEnd.y
		});
	}
	return {
		start,
		end
	};
}
/**
* @ignore
*/
var DimRect = function(_super) {
	__extends(DimRect$1, _super);
	function DimRect$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.dim = "x";
		_this.inPlot = true;
		return _this;
	}
	DimRect$1.prototype.getRegion = function() {
		var coord$1 = this.context.view.getCoordinate();
		return getRegion(this.points, this.dim, this.inPlot, coord$1);
	};
	return DimRect$1;
}(rect_default$1);
var dim_rect_default = DimRect;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/mask/path.js
/**
* 生成 mask 的路径
* @param points
* @returns
*/
function getMaskPath$1(points) {
	var path = [];
	if (points.length) {
		each_default(points, function(point$1, index) {
			if (index === 0) path.push([
				"M",
				point$1.x,
				point$1.y
			]);
			else path.push([
				"L",
				point$1.x,
				point$1.y
			]);
		});
		path.push([
			"L",
			points[0].x,
			points[0].y
		]);
	}
	return path;
}
function getMaskAttrs$1(points) {
	return { path: getMaskPath$1(points) };
}
/**
* @ignore
* 多个点构成的 Path 辅助框 Action
*/
var PathMask = function(_super) {
	__extends(PathMask$1, _super);
	function PathMask$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	PathMask$1.prototype.getMaskPath = function() {
		return getMaskPath$1(this.points);
	};
	PathMask$1.prototype.getMaskAttrs = function() {
		return getMaskAttrs$1(this.points);
	};
	/**
	* 添加一个点
	*/
	PathMask$1.prototype.addPoint = function() {
		this.resize();
	};
	return PathMask$1;
}(base_default$3);
var path_default$2 = PathMask;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/mask/smooth-path.js
/**
* 生成 mask 的路径
* @param points
* @returns
*/
function getMaskPath(points) {
	return getSpline(points, true);
}
function getMaskAttrs(points) {
	return { path: getMaskPath(points) };
}
/**
* Smooth path mask
* @ignore
*/
var SmoothPathMask = function(_super) {
	__extends(SmoothPathMask$1, _super);
	function SmoothPathMask$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	SmoothPathMask$1.prototype.getMaskPath = function() {
		return getMaskPath(this.points);
	};
	SmoothPathMask$1.prototype.getMaskAttrs = function() {
		return getMaskAttrs(this.points);
	};
	return SmoothPathMask$1;
}(path_default$2);
var smooth_path_default = SmoothPathMask;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/mask/multiple/base.js
/**
* @ignore
* 辅助框 Action 的基类
*/
var MultipleMaskBase = function(_super) {
	__extends(MultipleMaskBase$1, _super);
	function MultipleMaskBase$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.maskShapes = [];
		_this.starting = false;
		_this.moving = false;
		_this.recordPoints = null;
		_this.preMovePoint = null;
		_this.shapeType = "path";
		_this.maskType = "multi-mask";
		return _this;
	}
	/**
	* 获取当前的位置
	*/
	MultipleMaskBase$1.prototype.getCurrentPoint = function() {
		var event = this.context.event;
		return {
			x: event.x,
			y: event.y
		};
	};
	/**
	* 触发 mask 的事件
	* @param type
	*/
	MultipleMaskBase$1.prototype.emitEvent = function(type) {
		var eventName = "".concat(this.maskType, ":").concat(type);
		var view = this.context.view;
		var event = this.context.event;
		var target = {
			type: this.shapeType,
			name: this.maskType,
			get: function(key) {
				return target.hasOwnProperty(key) ? target[key] : void 0;
			}
		};
		view.emit(eventName, {
			target,
			maskShapes: this.maskShapes,
			multiPoints: this.recordPoints,
			x: event.x,
			y: event.y
		});
	};
	/**
	* 创建 mask
	* @param index
	*/
	MultipleMaskBase$1.prototype.createMask = function(index) {
		var view = this.context.view;
		var points = this.recordPoints[index];
		var maskAttrs = this.getMaskAttrs(points);
		var maskShape = view.foregroundGroup.addShape({
			type: this.shapeType,
			name: "mask",
			draggable: true,
			attrs: __assign({
				fill: "#C5D4EB",
				opacity: .3
			}, maskAttrs)
		});
		this.maskShapes.push(maskShape);
	};
	/**
	* 生成 mask 的路径
	*/
	MultipleMaskBase$1.prototype.getMaskPath = function(points) {
		return [];
	};
	/**
	* 显示
	*/
	MultipleMaskBase$1.prototype.show = function() {
		if (this.maskShapes.length > 0) {
			this.maskShapes.forEach(function(maskShape) {
				return maskShape.show();
			});
			this.emitEvent("show");
		}
	};
	/**
	* 开始
	*/
	MultipleMaskBase$1.prototype.start = function(arg) {
		this.recordPointStart();
		this.starting = true;
		this.moving = false;
		var index = this.recordPoints.length - 1;
		this.createMask(index);
		this.updateShapesCapture(false);
		this.updateMask(arg === null || arg === void 0 ? void 0 : arg.maskStyle);
		this.emitEvent("start");
	};
	/**
	* 开始移动
	*/
	MultipleMaskBase$1.prototype.moveStart = function() {
		this.moving = true;
		this.preMovePoint = this.getCurrentPoint();
		this.updateShapesCapture(false);
	};
	/**
	* 移动 mask
	*/
	MultipleMaskBase$1.prototype.move = function() {
		if (!this.moving || this.maskShapes.length === 0) return;
		var currentPoint = this.getCurrentPoint();
		var preMovePoint = this.preMovePoint;
		var dx = currentPoint.x - preMovePoint.x;
		var dy = currentPoint.y - preMovePoint.y;
		var index = this.getCurMaskShapeIndex();
		if (index > -1) {
			this.recordPoints[index].forEach(function(point$1) {
				point$1.x += dx;
				point$1.y += dy;
			});
			this.updateMask();
			this.emitEvent("change");
			this.preMovePoint = currentPoint;
		}
	};
	/**
	* 更新
	* @param maskStyle
	*/
	MultipleMaskBase$1.prototype.updateMask = function(maskStyle) {
		var _this = this;
		this.recordPoints.forEach(function(points, index) {
			var attrs = deep_mix_default({}, _this.getMaskAttrs(points), maskStyle);
			_this.maskShapes[index].attr(attrs);
		});
	};
	/**
	* 大小变化
	*/
	MultipleMaskBase$1.prototype.resize = function() {
		if (this.starting && this.maskShapes.length > 0) {
			this.recordPointContinue();
			this.updateMask();
			this.emitEvent("change");
		}
	};
	/**
	* 结束移动
	*/
	MultipleMaskBase$1.prototype.moveEnd = function() {
		this.moving = false;
		this.preMovePoint = null;
		this.updateShapesCapture(true);
	};
	/**
	* 结束
	*/
	MultipleMaskBase$1.prototype.end = function() {
		this.starting = false;
		this.emitEvent("end");
		this.updateShapesCapture(true);
	};
	/**
	* 隐藏
	*/
	MultipleMaskBase$1.prototype.hide = function() {
		if (this.maskShapes.length > 0) {
			this.maskShapes.forEach(function(maskShape) {
				return maskShape.hide();
			});
			this.emitEvent("hide");
		}
	};
	/**
	* 清除某个 mask
	*/
	MultipleMaskBase$1.prototype.remove = function() {
		var index = this.getCurMaskShapeIndex();
		if (index > -1) {
			this.recordPoints.splice(index, 1);
			this.maskShapes[index].remove();
			this.maskShapes.splice(index, 1);
			this.preMovePoint = null;
			this.updateShapesCapture(true);
			this.emitEvent("change");
		}
	};
	/**
	* 清除全部 mask
	*/
	MultipleMaskBase$1.prototype.clearAll = function() {
		this.recordPointClear();
		this.maskShapes.forEach(function(maskShape) {
			return maskShape.remove();
		});
		this.maskShapes = [];
		this.preMovePoint = null;
	};
	/**
	* 清除
	*/
	MultipleMaskBase$1.prototype.clear = function() {
		var index = this.getCurMaskShapeIndex();
		if (index === -1) {
			this.recordPointClear();
			this.maskShapes.forEach(function(maskShape) {
				return maskShape.remove();
			});
			this.maskShapes = [];
			this.emitEvent("clearAll");
		} else {
			this.recordPoints.splice(index, 1);
			this.maskShapes[index].remove();
			this.maskShapes.splice(index, 1);
			this.preMovePoint = null;
			this.emitEvent("clearSingle");
		}
		this.preMovePoint = null;
	};
	/**
	* 销毁
	*/
	MultipleMaskBase$1.prototype.destroy = function() {
		this.clear();
		_super.prototype.destroy.call(this);
	};
	/**
	* 获取 mask 节点记录
	*/
	MultipleMaskBase$1.prototype.getRecordPoints = function() {
		var _a$5;
		return __spreadArray([], __read((_a$5 = this.recordPoints) !== null && _a$5 !== void 0 ? _a$5 : []), false);
	};
	/**
	* 创建 mask 节点记录
	*/
	MultipleMaskBase$1.prototype.recordPointStart = function() {
		var recordPoints = this.getRecordPoints();
		var currentPoint = this.getCurrentPoint();
		this.recordPoints = __spreadArray(__spreadArray([], __read(recordPoints), false), [[currentPoint]], false);
	};
	/**
	* 持续记录 mask 节点
	*/
	MultipleMaskBase$1.prototype.recordPointContinue = function() {
		var recordPoints = this.getRecordPoints();
		var currentPoint = this.getCurrentPoint();
		var lastPoints = recordPoints.splice(-1, 1)[0] || [];
		lastPoints.push(currentPoint);
		this.recordPoints = __spreadArray(__spreadArray([], __read(recordPoints), false), [lastPoints], false);
	};
	/**
	* 清除 mask 节点 记录
	*/
	MultipleMaskBase$1.prototype.recordPointClear = function() {
		this.recordPoints = [];
	};
	/**
	* 设置 capture
	* false: 避免创建、resize 时触发事件
	* true: 正常触发其它事件
	* @param isCapture
	*/
	MultipleMaskBase$1.prototype.updateShapesCapture = function(isCapture) {
		this.maskShapes.forEach(function(maskShape) {
			return maskShape.set("capture", isCapture);
		});
	};
	/**
	*
	* @returns 获取当前 event (x, y) 所在 maskShape 的 index
	*/
	MultipleMaskBase$1.prototype.getCurMaskShapeIndex = function() {
		var currentPoint = this.getCurrentPoint();
		return this.maskShapes.findIndex(function(maskShape) {
			var _a$5 = maskShape.attrs, width = _a$5.width, height = _a$5.height, r = _a$5.r;
			return !(width === 0 || height === 0 || r === 0) && maskShape.isHit(currentPoint.x, currentPoint.y);
		});
	};
	return MultipleMaskBase$1;
}(base_default$1);
var base_default$2 = MultipleMaskBase;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/mask/multiple/rect.js
/**
* @ignore
* 矩形的辅助框 Action
*/
var RectMultiMask = function(_super) {
	__extends(RectMultiMask$1, _super);
	function RectMultiMask$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.shapeType = "rect";
		return _this;
	}
	RectMultiMask$1.prototype.getRegion = function(points) {
		return getRegion$1(points);
	};
	RectMultiMask$1.prototype.getMaskAttrs = function(points) {
		var _a$5 = this.getRegion(points), start = _a$5.start, end = _a$5.end;
		return getMaskAttrs$3(start, end);
	};
	return RectMultiMask$1;
}(base_default$2);
var rect_default$2 = RectMultiMask;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/mask/multiple/dim-rect.js
/**
* @ignore
*/
var DimRectMultiMask = function(_super) {
	__extends(DimRectMultiMask$1, _super);
	function DimRectMultiMask$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.dim = "x";
		_this.inPlot = true;
		return _this;
	}
	DimRectMultiMask$1.prototype.getRegion = function(points) {
		var coord$1 = this.context.view.getCoordinate();
		return getRegion(points, this.dim, this.inPlot, coord$1);
	};
	return DimRectMultiMask$1;
}(rect_default$2);
var dim_rect_default$1 = DimRectMultiMask;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/mask/multiple/circle.js
/**
* @ignore
* 圆形辅助框 Action
*/
var CircleMultiMask = function(_super) {
	__extends(CircleMultiMask$1, _super);
	function CircleMultiMask$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.shapeType = "circle";
		_this.getMaskAttrs = getMaskAttrs$2;
		return _this;
	}
	return CircleMultiMask$1;
}(base_default$2);
var circle_default$2 = CircleMultiMask;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/mask/multiple/path.js
/**
* @ignore
* 多个点构成的 Path 辅助框 Action
*/
var PathMultiMask = function(_super) {
	__extends(PathMultiMask$1, _super);
	function PathMultiMask$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.getMaskPath = getMaskPath$1;
		_this.getMaskAttrs = getMaskAttrs$1;
		return _this;
	}
	PathMultiMask$1.prototype.addPoint = function() {
		this.resize();
	};
	return PathMultiMask$1;
}(base_default$2);
var path_default$3 = PathMultiMask;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/mask/multiple/smooth-path.js
/**
* Smooth path mask
* @ignore
*/
var SmoothPathMultiMask = function(_super) {
	__extends(SmoothPathMultiMask$1, _super);
	function SmoothPathMultiMask$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.getMaskPath = getMaskPath;
		_this.getMaskAttrs = getMaskAttrs;
		return _this;
	}
	return SmoothPathMultiMask$1;
}(path_default$3);
var smooth_path_default$1 = SmoothPathMultiMask;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/cursor.js
/**
* 鼠标形状的 Action
* @ignore
*/
var CursorAction = function(_super) {
	__extends(CursorAction$1, _super);
	function CursorAction$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	CursorAction$1.prototype.setCursor = function(cursor) {
		this.context.view.getCanvas().setCursor(cursor);
	};
	/**
	* 默认光标（通常是一个箭头）
	*/
	CursorAction$1.prototype.default = function() {
		this.setCursor("default");
	};
	/** 光标呈现为指示链接的指针（一只手） */
	CursorAction$1.prototype.pointer = function() {
		this.setCursor("pointer");
	};
	/** 此光标指示某对象可被移动。 */
	CursorAction$1.prototype.move = function() {
		this.setCursor("move");
	};
	/** 光标呈现为十字线。 */
	CursorAction$1.prototype.crosshair = function() {
		this.setCursor("crosshair");
	};
	/** 此光标指示程序正忙（通常是一只表或沙漏）。 */
	CursorAction$1.prototype.wait = function() {
		this.setCursor("wait");
	};
	/** 此光标指示可用的帮助（通常是一个问号或一个气球）。 */
	CursorAction$1.prototype.help = function() {
		this.setCursor("help");
	};
	/** 此光标指示文本。 */
	CursorAction$1.prototype.text = function() {
		this.setCursor("text");
	};
	/**
	* 此光标指示矩形框的边缘可被向右（东）移动。
	*/
	CursorAction$1.prototype.eResize = function() {
		this.setCursor("e-resize");
	};
	/**
	* 此光标指示矩形框的边缘可被向左（西）移动。
	*/
	CursorAction$1.prototype.wResize = function() {
		this.setCursor("w-resize");
	};
	/**
	* 此光标指示矩形框的边缘可被向上（北）移动。
	*/
	CursorAction$1.prototype.nResize = function() {
		this.setCursor("n-resize");
	};
	/**
	* 此光标指示矩形框的边缘可被向下（南）移动。
	*/
	CursorAction$1.prototype.sResize = function() {
		this.setCursor("s-resize");
	};
	/**
	* 光标指示可移动的方向 右上方（东北）
	*/
	CursorAction$1.prototype.neResize = function() {
		this.setCursor("ne-resize");
	};
	/**
	* 光标指示可移动的方向 左上方（西北）
	*/
	CursorAction$1.prototype.nwResize = function() {
		this.setCursor("nw-resize");
	};
	/**
	* 光标指示可移动的方向右下方（东南）
	*/
	CursorAction$1.prototype.seResize = function() {
		this.setCursor("se-resize");
	};
	/**
	* 光标指示可移动的方向左下方（西南）
	*/
	CursorAction$1.prototype.swResize = function() {
		this.setCursor("sw-resize");
	};
	/**
	* 光标指示可以在上下方向移动
	*/
	CursorAction$1.prototype.nsResize = function() {
		this.setCursor("ns-resize");
	};
	/**
	* 光标指示可以在左右方向移动
	*/
	CursorAction$1.prototype.ewResize = function() {
		this.setCursor("ew-resize");
	};
	/**
	* 光标显示可以被放大
	*/
	CursorAction$1.prototype.zoomIn = function() {
		this.setCursor("zoom-in");
	};
	/**
	* 光标显示可以缩小尺寸
	*/
	CursorAction$1.prototype.zoomOut = function() {
		this.setCursor("zoom-out");
	};
	return CursorAction$1;
}(base_default$1);
var cursor_default = CursorAction;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/data/filter.js
/**
* 数据过滤。
* @ignore
*/
var DataFilter = function(_super) {
	__extends(DataFilter$1, _super);
	function DataFilter$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	DataFilter$1.prototype.filterView = function(view, field$5, filter$1) {
		var _this = this;
		if (view.getScaleByField(field$5)) view.filter(field$5, filter$1);
		if (view.views && view.views.length) each_default(view.views, function(subView) {
			_this.filterView(subView, field$5, filter$1);
		});
	};
	/**
	* 过滤数据
	*/
	DataFilter$1.prototype.filter = function() {
		var delegateObject = getDelegationObject(this.context);
		if (delegateObject) {
			var view = this.context.view;
			var component$1 = delegateObject.component;
			var field$5 = component$1.get("field");
			if (isList(delegateObject)) {
				if (field$5) {
					var unCheckedItems = component$1.getItemsByState("unchecked");
					var scale_1 = getScaleByField(view, field$5);
					var names_1 = unCheckedItems.map(function(item) {
						return item.name;
					});
					if (names_1.length) this.filterView(view, field$5, function(value$1) {
						var text = scale_1.getText(value$1);
						return !names_1.includes(text);
					});
					else this.filterView(view, field$5, null);
					view.render(true);
				}
			} else if (isSlider(delegateObject)) {
				var range = component$1.getValue();
				var _a$5 = __read(range, 2), min_1 = _a$5[0], max_1 = _a$5[1];
				this.filterView(view, field$5, function(value$1) {
					return value$1 >= min_1 && value$1 <= max_1;
				});
				view.render(true);
			}
		}
	};
	return DataFilter$1;
}(base_default$1);
var filter_default$1 = DataFilter;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/data/range-filter.js
function getFilter(scale$4, dim, point1, point2) {
	var min$2 = Math.min(point1[dim], point2[dim]);
	var max$2 = Math.max(point1[dim], point2[dim]);
	var _a$5 = __read(scale$4.range, 2), rangeMin = _a$5[0], rangeMax = _a$5[1];
	if (min$2 < rangeMin) min$2 = rangeMin;
	if (max$2 > rangeMax) max$2 = rangeMax;
	if (min$2 === rangeMax && max$2 === rangeMax) return null;
	var minValue = scale$4.invert(min$2);
	var maxValue = scale$4.invert(max$2);
	if (scale$4.isCategory) {
		var minIndex = scale$4.values.indexOf(minValue);
		var maxIndex = scale$4.values.indexOf(maxValue);
		var arr_1 = scale$4.values.slice(minIndex, maxIndex + 1);
		return function(value$1) {
			return arr_1.includes(value$1);
		};
	} else return function(value$1) {
		return value$1 >= minValue && value$1 <= maxValue;
	};
}
/** range-filter 只用于：brush-filter, brush-x-filter, brush-y-filter */
var EVENTS;
(function(EVENTS$3) {
	EVENTS$3["FILTER"] = "brush-filter-processing";
	EVENTS$3["RESET"] = "brush-filter-reset";
	EVENTS$3["BEFORE_FILTER"] = "brush-filter:beforefilter";
	EVENTS$3["AFTER_FILTER"] = "brush-filter:afterfilter";
	EVENTS$3["BEFORE_RESET"] = "brush-filter:beforereset";
	EVENTS$3["AFTER_RESET"] = "brush-filter:afterreset";
})(EVENTS || (EVENTS = {}));
/**
* 范围过滤的 Action
* @ignore
*/
var RangeFilter = function(_super) {
	__extends(RangeFilter$1, _super);
	function RangeFilter$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		/**
		* 范围过滤生效的字段/维度，可以是 x, y
		*/
		_this.dims = ["x", "y"];
		/** 起始点 */
		_this.startPoint = null;
		_this.isStarted = false;
		return _this;
	}
	RangeFilter$1.prototype.hasDim = function(dim) {
		return this.dims.includes(dim);
	};
	/**
	* 开始范围过滤，记录范围过滤的起点
	*/
	RangeFilter$1.prototype.start = function() {
		var context = this.context;
		this.isStarted = true;
		this.startPoint = context.getCurrentPoint();
	};
	/**
	* 过滤，以开始的点和当前点对数据进行过滤
	*/
	RangeFilter$1.prototype.filter = function() {
		var startPoint;
		var currentPoint;
		if (isMask(this.context)) {
			var bbox = this.context.event.target.getCanvasBBox();
			startPoint = {
				x: bbox.x,
				y: bbox.y
			};
			currentPoint = {
				x: bbox.maxX,
				y: bbox.maxY
			};
		} else {
			if (!this.isStarted) return;
			startPoint = this.startPoint;
			currentPoint = this.context.getCurrentPoint();
		}
		if (Math.abs(startPoint.x - currentPoint.x) < 5 || Math.abs(startPoint.x - currentPoint.y) < 5) return;
		var _a$5 = this.context, view = _a$5.view, event = _a$5.event;
		var payload = {
			view,
			event,
			dims: this.dims
		};
		view.emit(EVENTS.BEFORE_FILTER, event_default.fromData(view, EVENTS.BEFORE_FILTER, payload));
		var coord$1 = view.getCoordinate();
		var normalCurrent = coord$1.invert(currentPoint);
		var normalStart = coord$1.invert(startPoint);
		if (this.hasDim("x")) {
			var xScale = view.getXScale();
			var filter$1 = getFilter(xScale, "x", normalCurrent, normalStart);
			this.filterView(view, xScale.field, filter$1);
		}
		if (this.hasDim("y")) {
			var yScale = view.getYScales()[0];
			var filter$1 = getFilter(yScale, "y", normalCurrent, normalStart);
			this.filterView(view, yScale.field, filter$1);
		}
		this.reRender(view, { source: EVENTS.FILTER });
		view.emit(EVENTS.AFTER_FILTER, event_default.fromData(view, EVENTS.AFTER_FILTER, payload));
	};
	/**
	* 结束
	*/
	RangeFilter$1.prototype.end = function() {
		this.isStarted = false;
	};
	/**
	* 取消同当前 Action 相关的过滤，指定的 x,y
	*/
	RangeFilter$1.prototype.reset = function() {
		var view = this.context.view;
		view.emit(EVENTS.BEFORE_RESET, event_default.fromData(view, EVENTS.BEFORE_RESET, {}));
		this.isStarted = false;
		if (this.hasDim("x")) {
			var xScale = view.getXScale();
			this.filterView(view, xScale.field, null);
		}
		if (this.hasDim("y")) {
			var yScale = view.getYScales()[0];
			this.filterView(view, yScale.field, null);
		}
		this.reRender(view, { source: EVENTS.RESET });
		view.emit(EVENTS.AFTER_RESET, event_default.fromData(view, EVENTS.AFTER_RESET, {}));
	};
	/**
	* 对 view 进行过滤
	*/
	RangeFilter$1.prototype.filterView = function(view, field$5, filter$1) {
		view.filter(field$5, filter$1);
	};
	/**
	* 重新渲染
	* @param view
	*/
	RangeFilter$1.prototype.reRender = function(view, payload) {
		view.render(true, payload);
	};
	return RangeFilter$1;
}(base_default$1);
var range_filter_default = RangeFilter;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/data/sibling-filter.js
/**
* 数据范围过滤，但不在当前的 view 上生效，而在当前的 view 同一层级的其他 views 上生效，用于实现联动过滤。
* @ignore
*/
var SiblingFilter$1 = function(_super) {
	__extends(SiblingFilter$2, _super);
	function SiblingFilter$2() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	/**
	* 对 view 进行过滤
	* @param view
	* @param field
	* @param filter
	*/
	SiblingFilter$2.prototype.filterView = function(view, field$5, filter$1) {
		var siblings = getSilbings(view);
		each_default(siblings, function(sibling) {
			sibling.filter(field$5, filter$1);
		});
	};
	/**
	* 重新渲染
	* @param view
	*/
	SiblingFilter$2.prototype.reRender = function(view) {
		var siblings = getSilbings(view);
		each_default(siblings, function(sibling) {
			sibling.render(true);
		});
	};
	return SiblingFilter$2;
}(range_filter_default);
var sibling_filter_default = SiblingFilter$1;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/element/filter.js
/**
* 元素过滤的 Action，控制元素的显示隐藏
* @ignore
*/
var ElementFilter = function(_super) {
	__extends(ElementFilter$1, _super);
	function ElementFilter$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	/**
	* 过滤
	*/
	ElementFilter$1.prototype.filter = function() {
		var delegateObject = getDelegationObject(this.context);
		var view = this.context.view;
		var elements = getElements(view);
		if (isMask(this.context)) {
			var maskElements_1 = getMaskedElements(this.context, 10);
			if (maskElements_1) each_default(elements, function(el) {
				if (maskElements_1.includes(el)) el.show();
				else el.hide();
			});
		} else if (delegateObject) {
			var component$1 = delegateObject.component;
			var field_1 = component$1.get("field");
			if (isList(delegateObject)) {
				if (field_1) {
					var unCheckedItems = component$1.getItemsByState("unchecked");
					var scale_1 = getScaleByField(view, field_1);
					var names_1 = unCheckedItems.map(function(item) {
						return item.name;
					});
					each_default(elements, function(el) {
						var value$1 = getElementValue$1(el, field_1);
						var text = scale_1.getText(value$1);
						if (names_1.indexOf(text) >= 0) el.hide();
						else el.show();
					});
				}
			} else if (isSlider(delegateObject)) {
				var range = component$1.getValue();
				var _a$5 = __read(range, 2), min_1 = _a$5[0], max_1 = _a$5[1];
				each_default(elements, function(el) {
					var value$1 = getElementValue$1(el, field_1);
					if (value$1 >= min_1 && value$1 <= max_1) el.show();
					else el.hide();
				});
			}
		}
	};
	/**
	* 清除过滤
	*/
	ElementFilter$1.prototype.clear = function() {
		var elements = getElements(this.context.view);
		each_default(elements, function(el) {
			el.show();
		});
	};
	/**
	* 恢复发生的过滤，保持同 data-filter 命名的一致
	*/
	ElementFilter$1.prototype.reset = function() {
		this.clear();
	};
	return ElementFilter$1;
}(base_default$1);
var filter_default$2 = ElementFilter;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/element/sibling-filter.js
/**
* Sibling filter
* @ignore
*/
var SiblingFilter = function(_super) {
	__extends(SiblingFilter$2, _super);
	function SiblingFilter$2() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.byRecord = false;
		return _this;
	}
	/**
	* 过滤隐藏图形
	*/
	SiblingFilter$2.prototype.filter = function() {
		if (isMask(this.context)) if (this.byRecord) this.filterByRecord();
		else this.filterByBBox();
	};
	SiblingFilter$2.prototype.filterByRecord = function() {
		var view = this.context.view;
		var maskElements = getMaskedElements(this.context, 10);
		if (!maskElements) return;
		var xFiled = view.getXScale().field;
		var yField = view.getYScales()[0].field;
		var records = maskElements.map(function(el) {
			return el.getModel().data;
		});
		var siblings = getSilbings(view);
		each_default(siblings, function(sibling) {
			var elements = getElements(sibling);
			each_default(elements, function(el) {
				var record = el.getModel().data;
				if (isInRecords(records, record, xFiled, yField)) el.show();
				else el.hide();
			});
		});
	};
	SiblingFilter$2.prototype.filterByBBox = function() {
		var _this = this;
		var view = this.context.view;
		var siblings = getSilbings(view);
		each_default(siblings, function(sibling) {
			var maskElements = getSiblingMaskElements(_this.context, sibling, 10);
			var elements = getElements(sibling);
			if (maskElements) each_default(elements, function(el) {
				if (maskElements.includes(el)) el.show();
				else el.hide();
			});
		});
	};
	/**
	* 清理所有隐藏的图形
	*/
	SiblingFilter$2.prototype.reset = function() {
		var siblings = getSilbings(this.context.view);
		each_default(siblings, function(sibling) {
			var elements = getElements(sibling);
			each_default(elements, function(el) {
				el.show();
			});
		});
	};
	return SiblingFilter$2;
}(base_default$1);
var sibling_filter_default$1 = SiblingFilter;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/view/button.js
var PADDING_RIGHT$1 = 10;
var PADDING_TOP$2 = 5;
/**
* Button action
* @ignore
*/
var ButtonAction$1 = function(_super) {
	__extends(ButtonAction$2, _super);
	function ButtonAction$2() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.buttonGroup = null;
		_this.buttonCfg = {
			name: "button",
			text: "button",
			textStyle: {
				x: 0,
				y: 0,
				fontSize: 12,
				fill: "#333333",
				cursor: "pointer"
			},
			padding: [8, 10],
			style: {
				fill: "#f7f7f7",
				stroke: "#cccccc",
				cursor: "pointer"
			},
			activeStyle: { fill: "#e6e6e6" }
		};
		return _this;
	}
	ButtonAction$2.prototype.getButtonCfg = function() {
		return deep_mix_default(this.buttonCfg, this.cfg);
	};
	ButtonAction$2.prototype.drawButton = function() {
		var config = this.getButtonCfg();
		var group$1 = this.context.view.foregroundGroup.addGroup({ name: config.name });
		var textBBox = group$1.addShape({
			type: "text",
			name: "button-text",
			attrs: __assign({ text: config.text }, config.textStyle)
		}).getBBox();
		var padding$2 = parsePadding(config.padding);
		var buttonShape = group$1.addShape({
			type: "rect",
			name: "button-rect",
			attrs: __assign({
				x: textBBox.x - padding$2[3],
				y: textBBox.y - padding$2[0],
				width: textBBox.width + padding$2[1] + padding$2[3],
				height: textBBox.height + padding$2[0] + padding$2[2]
			}, config.style)
		});
		buttonShape.toBack();
		group$1.on("mouseenter", function() {
			buttonShape.attr(config.activeStyle);
		});
		group$1.on("mouseleave", function() {
			buttonShape.attr(config.style);
		});
		this.buttonGroup = group$1;
	};
	ButtonAction$2.prototype.resetPosition = function() {
		var point$1 = this.context.view.getCoordinate().convert({
			x: 1,
			y: 1
		});
		var buttonGroup = this.buttonGroup;
		var bbox = buttonGroup.getBBox();
		var matrix = transform$6(null, [[
			"t",
			point$1.x - bbox.width - PADDING_RIGHT$1,
			point$1.y + bbox.height + PADDING_TOP$2
		]]);
		buttonGroup.setMatrix(matrix);
	};
	/**
	* 显示
	*/
	ButtonAction$2.prototype.show = function() {
		if (!this.buttonGroup) this.drawButton();
		this.resetPosition();
		this.buttonGroup.show();
	};
	/**
	* 隐藏
	*/
	ButtonAction$2.prototype.hide = function() {
		if (this.buttonGroup) this.buttonGroup.hide();
	};
	/**
	* 销毁
	*/
	ButtonAction$2.prototype.destroy = function() {
		var buttonGroup = this.buttonGroup;
		if (buttonGroup) buttonGroup.remove();
		_super.prototype.destroy.call(this);
	};
	return ButtonAction$2;
}(base_default$1);
var button_default = ButtonAction$1;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/view/drag.js
var DISTANCE = 4;
/**
* @ignore
* View 支持 Drag 的 Action
*/
var Drag = function(_super) {
	__extends(Drag$1, _super);
	function Drag$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.starting = false;
		_this.dragStart = false;
		return _this;
	}
	/**
	* 开始
	*/
	Drag$1.prototype.start = function() {
		this.starting = true;
		this.startPoint = this.context.getCurrentPoint();
	};
	/**
	* 拖拽
	*/
	Drag$1.prototype.drag = function() {
		if (!this.startPoint) return;
		var current = this.context.getCurrentPoint();
		var view = this.context.view;
		var event = this.context.event;
		if (!this.dragStart) {
			if (distance$1(current, this.startPoint) > DISTANCE) {
				view.emit("dragstart", {
					target: event.target,
					x: event.x,
					y: event.y
				});
				this.dragStart = true;
			}
		} else view.emit("drag", {
			target: event.target,
			x: event.x,
			y: event.y
		});
	};
	/**
	* 结束
	*/
	Drag$1.prototype.end = function() {
		if (this.dragStart) {
			var view = this.context.view;
			var event_1 = this.context.event;
			view.emit("dragend", {
				target: event_1.target,
				x: event_1.x,
				y: event_1.y
			});
		}
		this.starting = false;
		this.dragStart = false;
	};
	return Drag$1;
}(base_default$1);
var drag_default = Drag;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/view/move.js
var MIN_DISTANCE = 5;
/**
* @ignore
* View 移动的 Action
*/
var Move = function(_super) {
	__extends(Move$1, _super);
	function Move$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.starting = false;
		_this.isMoving = false;
		_this.startPoint = null;
		_this.startMatrix = null;
		return _this;
	}
	/**
	* 开始移动
	*/
	Move$1.prototype.start = function() {
		this.starting = true;
		this.startPoint = this.context.getCurrentPoint();
		this.startMatrix = this.context.view.middleGroup.getMatrix();
	};
	/**
	* 移动
	*/
	Move$1.prototype.move = function() {
		if (!this.starting) return;
		var startPoint = this.startPoint;
		var currentPoint = this.context.getCurrentPoint();
		if (distance$1(startPoint, currentPoint) > MIN_DISTANCE && !this.isMoving) this.isMoving = true;
		if (this.isMoving) {
			var view = this.context.view;
			var matrix = transform$6(this.startMatrix, [[
				"t",
				currentPoint.x - startPoint.x,
				currentPoint.y - startPoint.y
			]]);
			view.backgroundGroup.setMatrix(matrix);
			view.foregroundGroup.setMatrix(matrix);
			view.middleGroup.setMatrix(matrix);
		}
	};
	/**
	* 结束移动
	*/
	Move$1.prototype.end = function() {
		if (this.isMoving) this.isMoving = false;
		this.startMatrix = null;
		this.starting = false;
		this.startPoint = null;
	};
	/**
	* 回滚
	*/
	Move$1.prototype.reset = function() {
		this.starting = false;
		this.startPoint = null;
		this.isMoving = false;
		var view = this.context.view;
		view.backgroundGroup.resetMatrix();
		view.foregroundGroup.resetMatrix();
		view.middleGroup.resetMatrix();
		this.isMoving = false;
	};
	return Move$1;
}(base_default$1);
var move_default = Move;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/view/scale-transform.js
var DIM_X = "x";
var DIM_Y = "y";
/**
* Scale translate
* @ignore
*/
var ScaleTranslate$2 = function(_super) {
	__extends(ScaleTranslate$3, _super);
	function ScaleTranslate$3() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.dims = [DIM_X, DIM_Y];
		_this.cfgFields = ["dims"];
		_this.cacheScaleDefs = {};
		return _this;
	}
	ScaleTranslate$3.prototype.hasDim = function(dim) {
		return this.dims.includes(dim);
	};
	ScaleTranslate$3.prototype.getScale = function(dim) {
		var view = this.context.view;
		if (dim === "x") return view.getXScale();
		else return view.getYScales()[0];
	};
	ScaleTranslate$3.prototype.resetDim = function(dim) {
		var view = this.context.view;
		if (this.hasDim(dim) && this.cacheScaleDefs[dim]) {
			var scale$4 = this.getScale(dim);
			view.scale(scale$4.field, this.cacheScaleDefs[dim]);
			this.cacheScaleDefs[dim] = null;
		}
	};
	/**
	* 回滚
	*/
	ScaleTranslate$3.prototype.reset = function() {
		this.resetDim(DIM_X);
		this.resetDim(DIM_Y);
		this.context.view.render(true);
	};
	return ScaleTranslate$3;
}(base_default$1);
var scale_transform_default = ScaleTranslate$2;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/view/scale-translate.js
/**
* 拖拽 Scale 的 Action
* @ignore
*/
var ScaleTranslate$1 = function(_super) {
	__extends(ScaleTranslate$3, _super);
	function ScaleTranslate$3() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.startPoint = null;
		_this.starting = false;
		_this.startCache = {};
		return _this;
	}
	/**
	* 开始
	*/
	ScaleTranslate$3.prototype.start = function() {
		var _this = this;
		this.startPoint = this.context.getCurrentPoint();
		this.starting = true;
		var dims = this.dims;
		each_default(dims, function(dim) {
			var scale$4 = _this.getScale(dim);
			var min$2 = scale$4.min, max$2 = scale$4.max, values$1 = scale$4.values;
			_this.startCache[dim] = {
				min: min$2,
				max: max$2,
				values: values$1
			};
		});
	};
	/**
	* 结束
	*/
	ScaleTranslate$3.prototype.end = function() {
		this.startPoint = null;
		this.starting = false;
		this.startCache = {};
	};
	/**
	* 平移
	*/
	ScaleTranslate$3.prototype.translate = function() {
		var _this = this;
		if (!this.starting) return;
		var startPoint = this.startPoint;
		var coord$1 = this.context.view.getCoordinate();
		var currentPoint = this.context.getCurrentPoint();
		var normalStart = coord$1.invert(startPoint);
		var noramlCurrent = coord$1.invert(currentPoint);
		var dx = noramlCurrent.x - normalStart.x;
		var dy = noramlCurrent.y - normalStart.y;
		var view = this.context.view;
		var dims = this.dims;
		each_default(dims, function(dim) {
			_this.translateDim(dim, {
				x: dx * -1,
				y: dy * -1
			});
		});
		view.render(true);
	};
	ScaleTranslate$3.prototype.translateDim = function(dim, normalPoint) {
		if (this.hasDim(dim)) {
			var scale$4 = this.getScale(dim);
			if (scale$4.isLinear) this.translateLinear(dim, scale$4, normalPoint);
		}
	};
	ScaleTranslate$3.prototype.translateLinear = function(dim, scale$4, normalPoint) {
		var view = this.context.view;
		var _a$5 = this.startCache[dim], min$2 = _a$5.min, max$2 = _a$5.max;
		var range = max$2 - min$2;
		var d = normalPoint[dim] * range;
		if (!this.cacheScaleDefs[dim]) this.cacheScaleDefs[dim] = {
			nice: scale$4.nice,
			min: min$2,
			max: max$2
		};
		view.scale(scale$4.field, {
			nice: false,
			min: min$2 + d,
			max: max$2 + d
		});
	};
	/**
	* 回滚
	*/
	ScaleTranslate$3.prototype.reset = function() {
		_super.prototype.reset.call(this);
		this.startPoint = null;
		this.starting = false;
	};
	return ScaleTranslate$3;
}(scale_transform_default);
var scale_translate_default = ScaleTranslate$1;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/view/scale-zoom.js
/**
* 缩放 Scale 的 Action
* @ignore
*/
var ScaleTranslate = function(_super) {
	__extends(ScaleTranslate$3, _super);
	function ScaleTranslate$3() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.zoomRatio = .05;
		return _this;
	}
	/**
	* 缩小
	*/
	ScaleTranslate$3.prototype.zoomIn = function() {
		this.zoom(this.zoomRatio);
	};
	ScaleTranslate$3.prototype.zoom = function(scale$4) {
		var _this = this;
		var dims = this.dims;
		each_default(dims, function(dim) {
			_this.zoomDim(dim, scale$4);
		});
		this.context.view.render(true);
	};
	/**
	* 放大
	*/
	ScaleTranslate$3.prototype.zoomOut = function() {
		this.zoom(-1 * this.zoomRatio);
	};
	ScaleTranslate$3.prototype.zoomDim = function(dim, dRatio) {
		if (this.hasDim(dim)) {
			var scale$4 = this.getScale(dim);
			if (scale$4.isLinear) this.zoomLinear(dim, scale$4, dRatio);
		}
	};
	ScaleTranslate$3.prototype.zoomLinear = function(dim, scale$4, dRatio) {
		var view = this.context.view;
		if (!this.cacheScaleDefs[dim]) this.cacheScaleDefs[dim] = {
			nice: scale$4.nice,
			min: scale$4.min,
			max: scale$4.max
		};
		var scaleDef = this.cacheScaleDefs[dim];
		var range = scaleDef.max - scaleDef.min;
		var min$2 = scale$4.min, max$2 = scale$4.max;
		var d = dRatio * range;
		var toMin = min$2 - d;
		var toMax = max$2 + d;
		var scaled = (toMax - toMin) / range;
		if (toMax > toMin && scaled < 100 && scaled > .01) view.scale(scale$4.field, {
			nice: false,
			min: min$2 - d,
			max: max$2 + d
		});
	};
	return ScaleTranslate$3;
}(scale_transform_default);
var scale_zoom_default = ScaleTranslate;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/view/mousewheel-scroll.js
function isWheelDown$1(event) {
	return event.gEvent.originalEvent.deltaY > 0;
}
var DEFAULT_WHEELDELTA = 1;
var MousewheelScroll = function(_super) {
	__extends(MousewheelScroll$1, _super);
	function MousewheelScroll$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	MousewheelScroll$1.prototype.scroll = function(arg) {
		var _a$5 = this.context, view = _a$5.view, event = _a$5.event;
		if (!view.getOptions().scrollbar) return;
		var wheelDelta = (arg === null || arg === void 0 ? void 0 : arg.wheelDelta) || DEFAULT_WHEELDELTA;
		var scrollbarController = view.getController("scrollbar");
		var xScale = view.getXScale();
		var data$2 = view.getOptions().data;
		var dataSize = size(values_of_key_default(data$2, xScale.field));
		var step = size(xScale.values);
		var currentRatio = scrollbarController.getValue();
		var nextStart = Math.floor((dataSize - step) * currentRatio) + (isWheelDown$1(event) ? wheelDelta : -wheelDelta);
		var correction = wheelDelta / (dataSize - step) / 1e4;
		var nextRatio = clamp_default(nextStart / (dataSize - step) + correction, 0, 1);
		scrollbarController.setValue(nextRatio);
	};
	return MousewheelScroll$1;
}(base_default$1);
var mousewheel_scroll_default = MousewheelScroll;

//#endregion
//#region node_modules/@antv/g2/esm/interaction/action/component/axis/axis-description.js
var AXIS_DESCRIPTION_TOOLTIP = "aixs-description-tooltip";
var AxisDescription = function(_super) {
	__extends(AxisDescription$1, _super);
	function AxisDescription$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	AxisDescription$1.prototype.show = function() {
		var context = this.context;
		var _a$5 = getDelegationObject(context).axis.cfg.title, description = _a$5.description, text = _a$5.text, descriptionTooltipStyle = _a$5.descriptionTooltipStyle;
		var _b = context.event, x = _b.x, y = _b.y;
		if (!this.tooltip) this.renderTooltip();
		this.tooltip.update({
			title: text || "",
			customContent: function() {
				return "\n          <div class=\"".concat(CONTAINER_CLASS, "\" style={").concat(descriptionTooltipStyle, "}>\n            <div class=\"").concat(TITLE_CLASS, "\">\n              字段说明：").concat(description, "\n            </div>\n          </div>\n        ");
			},
			x,
			y
		});
		this.tooltip.show();
	};
	AxisDescription$1.prototype.destroy = function() {
		_super.prototype.destroy.call(this);
		this.tooltip && this.tooltip.destroy();
	};
	AxisDescription$1.prototype.hide = function() {
		this.tooltip && this.tooltip.hide();
	};
	AxisDescription$1.prototype.renderTooltip = function() {
		var _a$5;
		var canvas = this.context.view.canvas;
		var region = {
			start: {
				x: 0,
				y: 0
			},
			end: {
				x: canvas.get("width"),
				y: canvas.get("height")
			}
		};
		var tooltip$10 = new HtmlTooltip({
			parent: canvas.get("el").parentNode,
			region,
			visible: false,
			containerId: AXIS_DESCRIPTION_TOOLTIP,
			domStyles: __assign({}, deep_mix_default({}, (_a$5 = {}, _a$5[CONTAINER_CLASS] = {
				"max-width": "50%",
				padding: "10px",
				"line-height": "15px",
				"font-size": "12px",
				color: "rgba(0, 0, 0, .65)"
			}, _a$5[TITLE_CLASS] = {
				"word-break": "break-all",
				"margin-bottom": "3px"
			}, _a$5)))
		});
		tooltip$10.init();
		tooltip$10.setCapture(false);
		this.tooltip = tooltip$10;
	};
	return AxisDescription$1;
}(base_default$1);
var axis_description_default = AxisDescription;

//#endregion
//#region node_modules/@antv/g2/esm/index.js
var esm_exports = /* @__PURE__ */ __export({
	Action: () => base_default$1,
	BRUSH_FILTER_EVENTS: () => EVENTS,
	Chart: () => chart_default,
	ComponentController: () => Controller,
	Coordinate: () => base_default$7,
	DIRECTION: () => DIRECTION,
	ELEMENT_RANGE_HIGHLIGHT_EVENTS: () => EVENTS$1,
	Element: () => element_default,
	Event: () => event_default,
	Facet: () => Facet$1,
	Geometry: () => base_default$4,
	GeometryLabel: () => base_default,
	Interaction: () => interaction_default,
	InteractionAction: () => base_default$1,
	LAYER: () => LAYER,
	Scale: () => base_default$8,
	TooltipController: () => tooltip_default,
	Util: () => Util,
	VERSION: () => VERSION,
	VIEW_LIFE_CIRCLE: () => VIEW_LIFE_CIRCLE,
	View: () => view_default,
	getActionClass: () => getActionClass,
	getAnimation: () => getAnimation,
	getEngine: () => getEngine,
	getFacet: () => getFacet,
	getGeometryLabel: () => getGeometryLabel,
	getGeometryLabelLayout: () => getGeometryLabelLayout,
	getInteraction: () => getInteraction,
	getShapeFactory: () => getShapeFactory,
	getTheme: () => getTheme,
	registerAction: () => registerAction,
	registerAnimation: () => registerAnimation,
	registerComponentController: () => registerComponentController,
	registerEngine: () => registerEngine,
	registerFacet: () => registerFacet,
	registerGeometry: () => registerGeometry,
	registerGeometryLabel: () => registerGeometryLabel,
	registerGeometryLabelLayout: () => registerGeometryLabelLayout,
	registerInteraction: () => registerInteraction,
	registerShape: () => registerShape,
	registerShapeFactory: () => registerShapeFactory,
	registerTheme: () => registerTheme
});
registerTheme("dark", createThemeByStyleSheet(antvDark));
registerEngine("canvas", esm_exports$1);
registerEngine("svg", esm_exports$2);
registerGeometry("Polygon", polygon_default);
registerGeometry("Interval", interval_default);
registerGeometry("Schema", schema_default);
registerGeometry("Path", path_default$1);
registerGeometry("Point", point_default);
registerGeometry("Line", line_default);
registerGeometry("Area", area_default);
registerGeometry("Edge", edge_default);
registerGeometry("Heatmap", heatmap_default);
registerGeometry("Violin", violin_default);
registerGeometryLabel("base", base_default);
registerGeometryLabel("interval", interval_default$1);
registerGeometryLabel("pie", pie_default);
registerGeometryLabel("polar", polar_default);
registerGeometryLabelLayout("overlap", overlap);
registerGeometryLabelLayout("distribute", distribute);
registerGeometryLabelLayout("fixed-overlap", fixedOverlap);
registerGeometryLabelLayout("hide-overlap", hideOverlap);
registerGeometryLabelLayout("limit-in-shape", limitInShape);
registerGeometryLabelLayout("limit-in-canvas", limitInCanvas);
registerGeometryLabelLayout("limit-in-plot", limitInPlot$3);
registerGeometryLabelLayout("pie-outer", pieOuterLabelLayout);
registerGeometryLabelLayout("adjust-color", adjustColor);
registerGeometryLabelLayout("interval-adjust-position", intervalAdjustPosition);
registerGeometryLabelLayout("interval-hide-overlap", intervalHideOverlap);
registerGeometryLabelLayout("point-adjust-position", pointAdjustPosition);
registerGeometryLabelLayout("pie-spider", pieSpiderLabelLayout);
registerGeometryLabelLayout("path-adjust-position", pathAdjustPosition);
registerAnimation("fade-in", fadeIn);
registerAnimation("fade-out", fadeOut);
registerAnimation("grow-in-x", growInX);
registerAnimation("grow-in-xy", growInXY);
registerAnimation("grow-in-y", growInY);
registerAnimation("scale-in-x", scaleInX);
registerAnimation("scale-in-y", scaleInY);
registerAnimation("wave-in", waveIn);
registerAnimation("zoom-in", zoomIn);
registerAnimation("zoom-out", zoomOut);
registerAnimation("position-update", positionUpdate);
registerAnimation("sector-path-update", sectorPathUpdate);
registerAnimation("path-in", pathIn);
registerFacet("rect", rect_default);
registerFacet("mirror", mirror_default);
registerFacet("list", list_default);
registerFacet("matrix", matrix_default);
registerFacet("circle", circle_default);
registerFacet("tree", tree_default$1);
registerComponentController("axis", axis_default);
registerComponentController("legend", legend_default);
registerComponentController("tooltip", tooltip_default);
registerComponentController("annotation", annotation_default);
registerComponentController("slider", slider_default);
registerComponentController("scrollbar", scrollbar_default);
registerAction("tooltip", geometry_default);
registerAction("sibling-tooltip", sibling_default);
registerAction("ellipsis-text", ellipsis_text_default);
registerAction("element-active", active_default);
registerAction("element-single-active", single_active_default);
registerAction("element-range-active", range_active_default);
registerAction("element-highlight", highlight_default);
registerAction("element-highlight-by-x", highlight_by_x_default);
registerAction("element-highlight-by-color", highlight_by_color_default);
registerAction("element-single-highlight", single_highlight_default);
registerAction("element-range-highlight", range_highlight_default);
registerAction("element-sibling-highlight", range_highlight_default, {
	effectSiblings: true,
	effectByRecord: true
});
registerAction("element-selected", selected_default);
registerAction("element-single-selected", single_selected_default);
registerAction("element-range-selected", range_selected_default);
registerAction("element-link-by-color", link_by_color_default);
registerAction("active-region", active_region_default);
registerAction("list-active", list_active_default);
registerAction("list-selected", list_selected_default);
registerAction("list-highlight", list_highlight_default);
registerAction("list-unchecked", list_unchecked_default);
registerAction("list-checked", list_checked_default);
registerAction("list-focus", list_focus_default);
registerAction("list-radio", list_radio_default);
registerAction("legend-item-highlight", list_highlight_default, { componentNames: ["legend"] });
registerAction("axis-label-highlight", list_highlight_default, { componentNames: ["axis"] });
registerAction("axis-description", axis_description_default);
registerAction("rect-mask", rect_default$1);
registerAction("x-rect-mask", dim_rect_default, { dim: "x" });
registerAction("y-rect-mask", dim_rect_default, { dim: "y" });
registerAction("circle-mask", circle_default$1);
registerAction("path-mask", path_default$2);
registerAction("smooth-path-mask", smooth_path_default);
registerAction("rect-multi-mask", rect_default$2);
registerAction("x-rect-multi-mask", dim_rect_default$1, { dim: "x" });
registerAction("y-rect-multi-mask", dim_rect_default$1, { dim: "y" });
registerAction("circle-multi-mask", circle_default$2);
registerAction("path-multi-mask", path_default$3);
registerAction("smooth-path-multi-mask", smooth_path_default$1);
registerAction("cursor", cursor_default);
registerAction("data-filter", filter_default$1);
registerAction("brush", range_filter_default);
registerAction("brush-x", range_filter_default, { dims: ["x"] });
registerAction("brush-y", range_filter_default, { dims: ["y"] });
registerAction("sibling-filter", sibling_filter_default);
registerAction("sibling-x-filter", sibling_filter_default, { dims: "x" });
registerAction("sibling-y-filter", sibling_filter_default, { dims: "y" });
registerAction("element-filter", filter_default$2);
registerAction("element-sibling-filter", sibling_filter_default$1);
registerAction("element-sibling-filter-record", sibling_filter_default$1, { byRecord: true });
registerAction("view-drag", drag_default);
registerAction("view-move", move_default);
registerAction("scale-translate", scale_translate_default);
registerAction("scale-zoom", scale_zoom_default);
registerAction("reset-button", button_default, {
	name: "reset-button",
	text: "reset"
});
registerAction("mousewheel-scroll", mousewheel_scroll_default);
function isPointInView$1(context) {
	return context.isInPlot();
}
registerInteraction("tooltip", {
	start: [{
		trigger: "plot:mousemove",
		action: "tooltip:show",
		throttle: {
			wait: 50,
			leading: true,
			trailing: false
		}
	}, {
		trigger: "plot:touchmove",
		action: "tooltip:show",
		throttle: {
			wait: 50,
			leading: true,
			trailing: false
		}
	}],
	end: [
		{
			trigger: "plot:mouseleave",
			action: "tooltip:hide"
		},
		{
			trigger: "plot:leave",
			action: "tooltip:hide"
		},
		{
			trigger: "plot:touchend",
			action: "tooltip:hide"
		}
	]
});
registerInteraction("ellipsis-text", {
	start: [
		{
			trigger: "legend-item-name:mousemove",
			action: "ellipsis-text:show",
			throttle: {
				wait: 50,
				leading: true,
				trailing: false
			}
		},
		{
			trigger: "legend-item-name:touchstart",
			action: "ellipsis-text:show",
			throttle: {
				wait: 50,
				leading: true,
				trailing: false
			}
		},
		{
			trigger: "axis-label:mousemove",
			action: "ellipsis-text:show",
			throttle: {
				wait: 50,
				leading: true,
				trailing: false
			}
		},
		{
			trigger: "axis-label:touchstart",
			action: "ellipsis-text:show",
			throttle: {
				wait: 50,
				leading: true,
				trailing: false
			}
		}
	],
	end: [
		{
			trigger: "legend-item-name:mouseleave",
			action: "ellipsis-text:hide"
		},
		{
			trigger: "legend-item-name:touchend",
			action: "ellipsis-text:hide"
		},
		{
			trigger: "axis-label:mouseleave",
			action: "ellipsis-text:hide"
		},
		{
			trigger: "axis-label:mouseout",
			action: "ellipsis-text:hide"
		},
		{
			trigger: "axis-label:touchend",
			action: "ellipsis-text:hide"
		}
	]
});
registerInteraction("element-active", {
	start: [{
		trigger: "element:mouseenter",
		action: "element-active:active"
	}],
	end: [{
		trigger: "element:mouseleave",
		action: "element-active:reset"
	}]
});
registerInteraction("element-selected", { start: [{
	trigger: "element:click",
	action: "element-selected:toggle"
}] });
registerInteraction("element-highlight", {
	start: [{
		trigger: "element:mouseenter",
		action: "element-highlight:highlight"
	}],
	end: [{
		trigger: "element:mouseleave",
		action: "element-highlight:reset"
	}]
});
registerInteraction("element-highlight-by-x", {
	start: [{
		trigger: "element:mouseenter",
		action: "element-highlight-by-x:highlight"
	}],
	end: [{
		trigger: "element:mouseleave",
		action: "element-highlight-by-x:reset"
	}]
});
registerInteraction("element-highlight-by-color", {
	start: [{
		trigger: "element:mouseenter",
		action: "element-highlight-by-color:highlight"
	}],
	end: [{
		trigger: "element:mouseleave",
		action: "element-highlight-by-color:reset"
	}]
});
registerInteraction("legend-active", {
	start: [{
		trigger: "legend-item:mouseenter",
		action: ["list-active:active", "element-active:active"]
	}],
	end: [{
		trigger: "legend-item:mouseleave",
		action: ["list-active:reset", "element-active:reset"]
	}]
});
registerInteraction("legend-highlight", {
	start: [{
		trigger: "legend-item:mouseenter",
		action: ["legend-item-highlight:highlight", "element-highlight:highlight"]
	}],
	end: [{
		trigger: "legend-item:mouseleave",
		action: ["legend-item-highlight:reset", "element-highlight:reset"]
	}]
});
registerInteraction("axis-label-highlight", {
	start: [{
		trigger: "axis-label:mouseenter",
		action: ["axis-label-highlight:highlight", "element-highlight:highlight"]
	}],
	end: [{
		trigger: "axis-label:mouseleave",
		action: ["axis-label-highlight:reset", "element-highlight:reset"]
	}]
});
registerInteraction("element-list-highlight", {
	start: [{
		trigger: "element:mouseenter",
		action: ["list-highlight:highlight", "element-highlight:highlight"]
	}],
	end: [{
		trigger: "element:mouseleave",
		action: ["list-highlight:reset", "element-highlight:reset"]
	}]
});
registerInteraction("element-range-highlight", {
	showEnable: [
		{
			trigger: "plot:mouseenter",
			action: "cursor:crosshair"
		},
		{
			trigger: "mask:mouseenter",
			action: "cursor:move"
		},
		{
			trigger: "plot:mouseleave",
			action: "cursor:default"
		},
		{
			trigger: "mask:mouseleave",
			action: "cursor:crosshair"
		}
	],
	start: [{
		trigger: "plot:mousedown",
		isEnable: function(context) {
			return !context.isInShape("mask");
		},
		action: ["rect-mask:start", "rect-mask:show"]
	}, {
		trigger: "mask:dragstart",
		action: ["rect-mask:moveStart"]
	}],
	processing: [
		{
			trigger: "plot:mousemove",
			action: ["rect-mask:resize"]
		},
		{
			trigger: "mask:drag",
			action: ["rect-mask:move"]
		},
		{
			trigger: "mask:change",
			action: ["element-range-highlight:highlight"]
		}
	],
	end: [
		{
			trigger: "plot:mouseup",
			action: ["rect-mask:end"]
		},
		{
			trigger: "mask:dragend",
			action: ["rect-mask:moveEnd"]
		},
		{
			trigger: "document:mouseup",
			isEnable: function(context) {
				return !context.isInPlot();
			},
			action: [
				"element-range-highlight:clear",
				"rect-mask:end",
				"rect-mask:hide"
			]
		}
	],
	rollback: [{
		trigger: "dblclick",
		action: ["element-range-highlight:clear", "rect-mask:hide"]
	}]
});
registerInteraction("brush", {
	showEnable: [{
		trigger: "plot:mouseenter",
		action: "cursor:crosshair"
	}, {
		trigger: "plot:mouseleave",
		action: "cursor:default"
	}],
	start: [{
		trigger: "mousedown",
		isEnable: isPointInView$1,
		action: [
			"brush:start",
			"rect-mask:start",
			"rect-mask:show"
		]
	}],
	processing: [{
		trigger: "mousemove",
		isEnable: isPointInView$1,
		action: ["rect-mask:resize"]
	}],
	end: [{
		trigger: "mouseup",
		isEnable: isPointInView$1,
		action: [
			"brush:filter",
			"brush:end",
			"rect-mask:end",
			"rect-mask:hide",
			"reset-button:show"
		]
	}],
	rollback: [{
		trigger: "reset-button:click",
		action: [
			"brush:reset",
			"reset-button:hide",
			"cursor:crosshair"
		]
	}]
});
registerInteraction("brush-visible", {
	showEnable: [{
		trigger: "plot:mouseenter",
		action: "cursor:crosshair"
	}, {
		trigger: "plot:mouseleave",
		action: "cursor:default"
	}],
	start: [{
		trigger: "plot:mousedown",
		action: ["rect-mask:start", "rect-mask:show"]
	}],
	processing: [{
		trigger: "plot:mousemove",
		action: ["rect-mask:resize"]
	}, {
		trigger: "mask:change",
		action: ["element-range-highlight:highlight"]
	}],
	end: [{
		trigger: "plot:mouseup",
		action: [
			"rect-mask:end",
			"rect-mask:hide",
			"element-filter:filter",
			"element-range-highlight:clear"
		]
	}],
	rollback: [{
		trigger: "dblclick",
		action: ["element-filter:clear"]
	}]
});
registerInteraction("brush-x", {
	showEnable: [{
		trigger: "plot:mouseenter",
		action: "cursor:crosshair"
	}, {
		trigger: "plot:mouseleave",
		action: "cursor:default"
	}],
	start: [{
		trigger: "mousedown",
		isEnable: isPointInView$1,
		action: [
			"brush-x:start",
			"x-rect-mask:start",
			"x-rect-mask:show"
		]
	}],
	processing: [{
		trigger: "mousemove",
		isEnable: isPointInView$1,
		action: ["x-rect-mask:resize"]
	}],
	end: [{
		trigger: "mouseup",
		isEnable: isPointInView$1,
		action: [
			"brush-x:filter",
			"brush-x:end",
			"x-rect-mask:end",
			"x-rect-mask:hide"
		]
	}],
	rollback: [{
		trigger: "dblclick",
		action: ["brush-x:reset"]
	}]
});
registerInteraction("element-path-highlight", {
	showEnable: [{
		trigger: "plot:mouseenter",
		action: "cursor:crosshair"
	}, {
		trigger: "plot:mouseleave",
		action: "cursor:default"
	}],
	start: [{
		trigger: "mousedown",
		isEnable: isPointInView$1,
		action: "path-mask:start"
	}, {
		trigger: "mousedown",
		isEnable: isPointInView$1,
		action: "path-mask:show"
	}],
	processing: [{
		trigger: "mousemove",
		action: "path-mask:addPoint"
	}],
	end: [{
		trigger: "mouseup",
		action: "path-mask:end"
	}],
	rollback: [{
		trigger: "dblclick",
		action: "path-mask:hide"
	}]
});
registerInteraction("brush-x-multi", {
	showEnable: [
		{
			trigger: "plot:mouseenter",
			action: "cursor:crosshair"
		},
		{
			trigger: "mask:mouseenter",
			action: "cursor:move"
		},
		{
			trigger: "plot:mouseleave",
			action: "cursor:default"
		},
		{
			trigger: "mask:mouseleave",
			action: "cursor:crosshair"
		}
	],
	start: [{
		trigger: "mousedown",
		isEnable: isPointInView$1,
		action: ["x-rect-multi-mask:start", "x-rect-multi-mask:show"]
	}, {
		trigger: "mask:dragstart",
		action: ["x-rect-multi-mask:moveStart"]
	}],
	processing: [
		{
			trigger: "mousemove",
			isEnable: function(context) {
				return !isMultipleMask(context);
			},
			action: ["x-rect-multi-mask:resize"]
		},
		{
			trigger: "multi-mask:change",
			action: "element-range-highlight:highlight"
		},
		{
			trigger: "mask:drag",
			action: ["x-rect-multi-mask:move"]
		}
	],
	end: [{
		trigger: "mouseup",
		action: ["x-rect-multi-mask:end"]
	}, {
		trigger: "mask:dragend",
		action: ["x-rect-multi-mask:moveEnd"]
	}],
	rollback: [
		{
			trigger: "dblclick",
			action: ["x-rect-multi-mask:clear", "cursor:crosshair"]
		},
		{
			trigger: "multi-mask:clearAll",
			action: ["element-range-highlight:clear"]
		},
		{
			trigger: "multi-mask:clearSingle",
			action: ["element-range-highlight:highlight"]
		}
	]
});
registerInteraction("element-single-selected", { start: [{
	trigger: "element:click",
	action: "element-single-selected:toggle"
}] });
registerInteraction("legend-filter", {
	showEnable: [{
		trigger: "legend-item:mouseenter",
		action: ["cursor:pointer", "list-radio:show"]
	}, {
		trigger: "legend-item:mouseleave",
		action: ["cursor:default", "list-radio:hide"]
	}],
	start: [
		{
			trigger: "legend-item:click",
			isEnable: function(context) {
				return !context.isInShape("legend-item-radio");
			},
			action: [
				"legend-item-highlight:reset",
				"element-highlight:reset",
				"list-unchecked:toggle",
				"data-filter:filter",
				"list-radio:show"
			]
		},
		{
			trigger: "legend-item-radio:mouseenter",
			action: ["list-radio:showTip"]
		},
		{
			trigger: "legend-item-radio:mouseleave",
			action: ["list-radio:hideTip"]
		},
		{
			trigger: "legend-item-radio:click",
			action: [
				"list-focus:toggle",
				"data-filter:filter",
				"list-radio:show"
			]
		}
	]
});
registerInteraction("continuous-filter", { start: [{
	trigger: "legend:valuechanged",
	action: "data-filter:filter"
}] });
registerInteraction("continuous-visible-filter", { start: [{
	trigger: "legend:valuechanged",
	action: "element-filter:filter"
}] });
registerInteraction("legend-visible-filter", {
	showEnable: [{
		trigger: "legend-item:mouseenter",
		action: "cursor:pointer"
	}, {
		trigger: "legend-item:mouseleave",
		action: "cursor:default"
	}],
	start: [{
		trigger: "legend-item:click",
		action: [
			"legend-item-highlight:reset",
			"element-highlight:reset",
			"list-unchecked:toggle",
			"element-filter:filter"
		]
	}]
});
registerInteraction("active-region", {
	start: [{
		trigger: "plot:mousemove",
		action: "active-region:show"
	}],
	end: [{
		trigger: "plot:mouseleave",
		action: "active-region:hide"
	}]
});
registerInteraction("axis-description", {
	start: [{
		trigger: "axis-description:mousemove",
		action: "axis-description:show"
	}],
	end: [{
		trigger: "axis-description:mouseleave",
		action: "axis-description:hide"
	}]
});
function isWheelDown(event) {
	event.gEvent.preventDefault();
	return event.gEvent.originalEvent.deltaY > 0;
}
registerInteraction("view-zoom", { start: [{
	trigger: "plot:mousewheel",
	isEnable: function(context) {
		return isWheelDown(context.event);
	},
	action: "scale-zoom:zoomOut",
	throttle: {
		wait: 100,
		leading: true,
		trailing: false
	}
}, {
	trigger: "plot:mousewheel",
	isEnable: function(context) {
		return !isWheelDown(context.event);
	},
	action: "scale-zoom:zoomIn",
	throttle: {
		wait: 100,
		leading: true,
		trailing: false
	}
}] });
registerInteraction("sibling-tooltip", {
	start: [{
		trigger: "plot:mousemove",
		action: "sibling-tooltip:show"
	}],
	end: [{
		trigger: "plot:mouseleave",
		action: "sibling-tooltip:hide"
	}]
});
registerInteraction("plot-mousewheel-scroll", { start: [{
	trigger: "plot:mousewheel",
	action: "mousewheel-scroll:scroll"
}] });

//#endregion
//#region node_modules/@antv/g2plot/esm/constant.js
/**
* 需要从轴配置中提取出来作为 meta 的属性 key 列表
*/
var AXIS_META_CONFIG_KEYS = [
	"type",
	"alias",
	"tickCount",
	"tickInterval",
	"min",
	"max",
	"nice",
	"minLimit",
	"maxLimit",
	"range",
	"tickMethod",
	"base",
	"exponent",
	"mask",
	"sync"
];

//#endregion
//#region node_modules/@antv/g2plot/esm/utils/invariant.js
var LEVEL;
(function(LEVEL$1) {
	LEVEL$1["ERROR"] = "error";
	LEVEL$1["WARN"] = "warn";
	LEVEL$1["INFO"] = "log";
})(LEVEL || (LEVEL = {}));
var BRAND = "AntV/G2Plot";
/**
* 获取错误消息
* @param format
* @param args
*/
function getMessage(format$1) {
	var args = [];
	for (var _i = 1; _i < arguments.length; _i++) args[_i - 1] = arguments[_i];
	var argIndex = 0;
	return "".concat(BRAND, ": ").concat(format$1.replace(/%s/g, function() {
		return "".concat(args[argIndex++]);
	}));
}
/**
* 打印语句
* @param level
* @param condition
* @param format
* @param args
*/
function log(level, condition, format$1) {
	var args = [];
	for (var _i = 3; _i < arguments.length; _i++) args[_i - 3] = arguments[_i];
	if (!condition) console[level](getMessage.apply(void 0, __spreadArray([format$1], args, false)));
}

//#endregion
//#region node_modules/@antv/g2plot/esm/utils/pick.js
/**
* 类似 lodash.pick 的方法
* @param obj
* @param keys
*/
function pick(obj, keys$1) {
	var r = {};
	if (obj !== null && typeof obj === "object") keys$1.forEach(function(key) {
		var v = obj[key];
		if (v !== void 0) r[key] = v;
	});
	return r;
}

//#endregion
//#region node_modules/@antv/g2plot/esm/utils/data.js
/**
* 查看数据是否是全负数、或者全正数
* @param data
* @param field
*/
function adjustYMetaByZero(data$2, field$5) {
	if (!data$2) return {};
	var numberData = data$2.filter(function(datum) {
		var v = get_default(datum, [field$5]);
		return is_number_default(v) && !isNaN(v);
	});
	var gtZero = numberData.every(function(datum) {
		return get_default(datum, [field$5]) >= 0;
	});
	var ltZero = numberData.every(function(datum) {
		return get_default(datum, [field$5]) <= 0;
	});
	if (gtZero) return { min: 0 };
	if (ltZero) return { max: 0 };
	return {};
}
/**
* 转换数据格式为带有节点与边的数据格式
* @param data
* @param sourceField
* @param targetField
* @param weightField
* @param rawFields 存放一些原数据
*/
function transformDataToNodeLinkData(data$2, sourceField, targetField, weightField, rawFields) {
	if (rawFields === void 0) rawFields = [];
	if (!Array.isArray(data$2)) return {
		nodes: [],
		links: []
	};
	var links = [];
	var nodesMap = {};
	var nodesIndex = -1;
	data$2.forEach(function(datum) {
		var source = datum[sourceField];
		var target = datum[targetField];
		var weight = datum[weightField];
		var rawData = pick(datum, rawFields);
		if (!nodesMap[source]) nodesMap[source] = __assign({
			id: ++nodesIndex,
			name: source
		}, rawData);
		if (!nodesMap[target]) nodesMap[target] = __assign({
			id: ++nodesIndex,
			name: target
		}, rawData);
		links.push(__assign({
			source: nodesMap[source].id,
			target: nodesMap[target].id,
			value: weight
		}, rawData));
	});
	return {
		nodes: Object.values(nodesMap).sort(function(a, b) {
			return a.id - b.id;
		}),
		links
	};
}
/**
* 处理不合法的数据(过滤 非数值型 和 NaN，保留 null)
* @param data
* @param angleField
*/
function processIllegalData(data$2, field$5) {
	var processData$1 = filter_default(data$2, function(d) {
		var v = d[field$5];
		return v === null || typeof v === "number" && !isNaN(v);
	});
	log(LEVEL.WARN, processData$1.length === data$2.length, "illegal data existed in chart data.");
	return processData$1;
}

//#endregion
//#region node_modules/@antv/g2plot/esm/utils/deep-assign.js
var MAX_MIX_LEVEL = 5;
var toString = {}.toString;
var isType = function(value$1, type) {
	return toString.call(value$1) === "[object " + type + "]";
};
var isArray = function(value$1) {
	return isType(value$1, "Array");
};
var isObjectLike = function(value$1) {
	/**
	* isObjectLike({}) => true
	* isObjectLike([1, 2, 3]) => true
	* isObjectLike(Function) => false
	*/
	return typeof value$1 === "object" && value$1 !== null;
};
var isPlainObject = function(value$1) {
	/**
	* isObjectLike(new Foo) => false
	* isObjectLike([1, 2, 3]) => false
	* isObjectLike({ x: 0, y: 0 }) => true
	*/
	if (!isObjectLike(value$1) || !isType(value$1, "Object")) return false;
	var proto = value$1;
	while (Object.getPrototypeOf(proto) !== null) proto = Object.getPrototypeOf(proto);
	return Object.getPrototypeOf(value$1) === proto;
};
/***
* @param {any} dist
* @param {any} src
* @param {number} level 当前层级
* @param {number} maxLevel 最大层级
*/
var deep = function(dist, src, level, maxLevel) {
	level = level || 0;
	maxLevel = maxLevel || MAX_MIX_LEVEL;
	for (var key in src) if (Object.prototype.hasOwnProperty.call(src, key)) {
		var value$1 = src[key];
		if (!value$1) dist[key] = value$1;
		else if (isPlainObject(value$1)) {
			if (!isPlainObject(dist[key])) dist[key] = {};
			if (level < maxLevel) deep(dist[key], value$1, level + 1, maxLevel);
			else dist[key] = src[key];
		} else if (isArray(value$1)) {
			dist[key] = [];
			dist[key] = dist[key].concat(value$1);
		} else dist[key] = value$1;
	}
};
/**
* deepAssign 功能类似 deepMix
* 不同点在于 deepAssign 会将 null undefined 等类型直接覆盖给 source
* 详细参考： __tests__/unit/utils/deep-assign-spec.ts
*/
var deepAssign = function(rst) {
	var args = [];
	for (var _i = 1; _i < arguments.length; _i++) args[_i - 1] = arguments[_i];
	for (var i = 0; i < args.length; i += 1) deep(rst, args[i]);
	return rst;
};

//#endregion
//#region node_modules/@antv/g2plot/esm/utils/dom.js
/**
* get the element's bounding size
* @param ele dom element
* @returns the element width and height
*/
function getContainerSize(ele) {
	if (!ele) return {
		width: 0,
		height: 0
	};
	var style = getComputedStyle(ele);
	return {
		width: (ele.clientWidth || parseInt(style.width, 10)) - parseInt(style.paddingLeft, 10) - parseInt(style.paddingRight, 10),
		height: (ele.clientHeight || parseInt(style.height, 10)) - parseInt(style.paddingTop, 10) - parseInt(style.paddingBottom, 10)
	};
}

//#endregion
//#region node_modules/@antv/g2plot/esm/utils/flow.js
/**
* 类似 lodash.flow 的方法
* @param flows
*/
function flow() {
	var flows = [];
	for (var _i = 0; _i < arguments.length; _i++) flows[_i] = arguments[_i];
	return function(param) {
		return flows.reduce(function(result, f) {
			return f(result);
		}, param);
	};
}

//#endregion
//#region node_modules/@antv/g2plot/esm/utils/geometry.js
/**
* 在 View 中查找第一个指定 type 类型的 geometry
* @param view
* @param type
*/
function findGeometry(view, type) {
	return view.geometries.find(function(g) {
		return g.type === type;
	});
}
/**
* 获取 View 的 所有 elements
*/
function getAllElements(view) {
	return reduce_default(view.geometries, function(r, geometry$34) {
		return r.concat(geometry$34.elements);
	}, []);
}
/**
* 递归获取 View 的 所有 elements, 包括 View 的子 View
*/
function getAllElementsRecursively(view) {
	if (get_default(view, ["views", "length"], 0) <= 0) return getAllElements(view);
	return reduce_default(view.views, function(ele, subView) {
		return ele.concat(getAllElementsRecursively(subView));
	}, getAllElements(view));
}
/**
* 递归获取 View 的 所有 geometries, 包括 View 的子 View
*/
function getAllGeometriesRecursively(view) {
	if (get_default(view, ["views", "length"], 0) <= 0) return view.geometries;
	return reduce_default(view.views, function(ele, subView) {
		return ele.concat(subView.geometries);
	}, view.geometries);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/utils/kebab-case.js
/**
* @desc simple kebabCase like lodash
*
* kebabCase('fooBar'); => 'foo-bar'
*/
function kebabCase(word$1) {
	if (!word$1) return word$1;
	return word$1.match(/(([A-Z]{0,1}[a-z]*[^A-Z])|([A-Z]{1}))/g).map(function(s) {
		return s.toLowerCase();
	}).join("-");
}

//#endregion
//#region node_modules/@antv/g2plot/esm/utils/label.js
/**
* 兼容 v1 label formatter
* @param labelOptions
*/
function transformLabel(labelOptions) {
	if (!is_type_default(labelOptions, "Object")) return labelOptions;
	var label$16 = __assign({}, labelOptions);
	if (label$16.formatter && !label$16.content) label$16.content = label$16.formatter;
	return label$16;
}

//#endregion
//#region node_modules/@antv/g2plot/esm/utils/context.js
var ctx;
/**
* 获取 canvas context
*/
function getCanvasContext() {
	if (!ctx) ctx = document.createElement("canvas").getContext("2d");
	return ctx;
}

//#endregion
//#region node_modules/@antv/g2plot/esm/utils/measure-text.js
/**
* 计算文本在画布中的宽度
* @param text 文本
* @param font 字体
*/
var measureTextWidth = memoize_default(function(text, font) {
	if (font === void 0) font = {};
	var fontSize = font.fontSize, _a$5 = font.fontFamily, fontFamily = _a$5 === void 0 ? "sans-serif" : _a$5, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
	var ctx$3 = getCanvasContext();
	ctx$3.font = [
		fontStyle,
		fontWeight,
		fontVariant,
		"".concat(fontSize, "px"),
		fontFamily
	].join(" ");
	return ctx$3.measureText(is_string_default(text) ? text : "").width;
}, function(text, font) {
	if (font === void 0) font = {};
	return __spreadArray([text], values_default(font), true).join("");
});

//#endregion
//#region node_modules/@antv/g2plot/esm/utils/number.js
/**
* 是否真实的是数字
* @param v
*/
function isRealNumber(v) {
	return typeof v === "number" && !isNaN(v);
}
/**
* @ignore
* Determines whether between is
* @param value
* @param start
* @param end
* @returns true if between
*/
function isBetween(value$1, start, end) {
	return value$1 >= Math.min(start, end) && value$1 <= Math.max(start, end);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/utils/padding.js
/**
* 把 padding 转换成统一的数组写法
* @param padding
*/
function normalPadding(padding$2) {
	if (is_number_default(padding$2)) return [
		padding$2,
		padding$2,
		padding$2,
		padding$2
	];
	if (is_array_default(padding$2)) {
		var length_1 = padding$2.length;
		if (length_1 === 1) return [
			padding$2[0],
			padding$2[0],
			padding$2[0],
			padding$2[0]
		];
		if (length_1 === 2) return [
			padding$2[0],
			padding$2[1],
			padding$2[0],
			padding$2[1]
		];
		if (length_1 === 3) return [
			padding$2[0],
			padding$2[1],
			padding$2[2],
			padding$2[1]
		];
		if (length_1 === 4) return padding$2;
	}
	return [
		0,
		0,
		0,
		0
	];
}
/**
* 获取调整的 appendPadding
*/
function getAdjustAppendPadding(padding$2, position, append) {
	if (position === void 0) position = "bottom";
	if (append === void 0) append = 25;
	var currentAppendPadding = normalPadding(padding$2);
	var PADDING$1 = [
		position.startsWith("top") ? append : 0,
		position.startsWith("right") ? append : 0,
		position.startsWith("bottom") ? append : 0,
		position.startsWith("left") ? append : 0
	];
	return [
		currentAppendPadding[0] + PADDING$1[0],
		currentAppendPadding[1] + PADDING$1[1],
		currentAppendPadding[2] + PADDING$1[2],
		currentAppendPadding[3] + PADDING$1[3]
	];
}
/**
* 根据图表的 padding 和 appendPadding 计算出图表的最终 padding
* @param array
*/
function resolveAllPadding(paddings) {
	var normalPaddings = paddings.map(function(item) {
		return normalPadding(item);
	});
	var finalPadding = [
		0,
		0,
		0,
		0
	];
	if (normalPaddings.length > 0) finalPadding = finalPadding.map(function(item, index) {
		normalPaddings.forEach(function(d, i) {
			item += normalPaddings[i][index];
		});
		return item;
	});
	return finalPadding;
}

//#endregion
//#region node_modules/@antv/g2plot/esm/utils/path.js
function points2Path(points, isInCircle) {
	var path = [];
	if (points.length) {
		path.push([
			"M",
			points[0].x,
			points[0].y
		]);
		for (var i = 1, length_1 = points.length; i < length_1; i += 1) {
			var item = points[i];
			path.push([
				"L",
				item.x,
				item.y
			]);
		}
		if (isInCircle) path.push(["Z"]);
	}
	return path;
}
/**
* @ignore
* 计算光滑的贝塞尔曲线
*/
var smoothBezier = function(points, smooth, isLoop, constraint) {
	var cps = [];
	var prevPoint;
	var nextPoint;
	var hasConstraint = !!constraint;
	var min$2;
	var max$2;
	if (hasConstraint) {
		min$2 = [Infinity, Infinity];
		max$2 = [-Infinity, -Infinity];
		for (var i = 0, l = points.length; i < l; i++) {
			var point$1 = points[i];
			min$2 = min$1([0, 0], min$2, point$1);
			max$2 = max$1([0, 0], max$2, point$1);
		}
		min$2 = min$1([0, 0], min$2, constraint[0]);
		max$2 = max$1([0, 0], max$2, constraint[1]);
	}
	for (var i = 0, len = points.length; i < len; i++) {
		var point$1 = points[i];
		if (isLoop) {
			prevPoint = points[i ? i - 1 : len - 1];
			nextPoint = points[(i + 1) % len];
		} else if (i === 0 || i === len - 1) {
			cps.push(point$1);
			continue;
		} else {
			prevPoint = points[i - 1];
			nextPoint = points[i + 1];
		}
		var v = [0, 0];
		v = sub(v, nextPoint, prevPoint);
		v = scale$3(v, v, smooth);
		var d0 = distance$6(point$1, prevPoint);
		var d1 = distance$6(point$1, nextPoint);
		var sum = d0 + d1;
		if (sum !== 0) {
			d0 /= sum;
			d1 /= sum;
		}
		var v1 = scale$3([0, 0], v, -d0);
		var v2 = scale$3([0, 0], v, d1);
		var cp0 = add([0, 0], point$1, v1);
		var cp1 = add([0, 0], point$1, v2);
		if (hasConstraint) {
			cp0 = max$1([0, 0], cp0, min$2);
			cp0 = min$1([0, 0], cp0, max$2);
			cp1 = max$1([0, 0], cp1, min$2);
			cp1 = min$1([0, 0], cp1, max$2);
		}
		cps.push(cp0);
		cps.push(cp1);
	}
	if (isLoop) cps.push(cps.shift());
	return cps;
};
/**
* @ignore
* 贝塞尔曲线
*/
function catmullRom2bezier(crp, z, constraint) {
	var isLoop = !!z;
	var pointList = [];
	for (var i = 0, l = crp.length; i < l; i += 2) pointList.push([crp[i], crp[i + 1]]);
	var controlPointList = smoothBezier(pointList, .4, isLoop, constraint);
	var len = pointList.length;
	var d1 = [];
	var cp1;
	var cp2;
	var p;
	for (var i = 0; i < len - 1; i++) {
		cp1 = controlPointList[i * 2];
		cp2 = controlPointList[i * 2 + 1];
		p = pointList[i + 1];
		d1.push([
			"C",
			cp1[0],
			cp1[1],
			cp2[0],
			cp2[1],
			p[0],
			p[1]
		]);
	}
	if (isLoop) {
		cp1 = controlPointList[len];
		cp2 = controlPointList[len + 1];
		p = pointList[0];
		d1.push([
			"C",
			cp1[0],
			cp1[1],
			cp2[0],
			cp2[1],
			p[0],
			p[1]
		]);
	}
	return d1;
}
/**
* @ignore
* 根据关键点获取限定了范围的平滑线
*/
function getSplinePath(points, isInCircle, constaint) {
	var data$2 = [];
	var first = points[0];
	var prePoint = null;
	if (points.length <= 2) return points2Path(points, isInCircle);
	for (var i = 0, len = points.length; i < len; i++) {
		var point$1 = points[i];
		if (!prePoint || !(prePoint.x === point$1.x && prePoint.y === point$1.y)) {
			data$2.push(point$1.x);
			data$2.push(point$1.y);
			prePoint = point$1;
		}
	}
	var splinePath$1 = catmullRom2bezier(data$2, isInCircle, constaint || [[0, 0], [1, 1]]);
	splinePath$1.unshift([
		"M",
		first.x,
		first.y
	]);
	return splinePath$1;
}

//#endregion
//#region node_modules/@antv/g2plot/esm/utils/statistic.js
/**
* @desc 生成 html-statistic 的 style 字符串 (兼容 canvas 的 shapeStyle 到 css样式上)
*
* @param width
* @param style
*/
function adapteStyle(style) {
	var styleObject = {
		overflow: "hidden",
		"white-space": "nowrap",
		"text-overflow": "ellipsis",
		display: "flex",
		justifyContent: "center",
		alignItems: "center"
	};
	var shapeStyleKeys = [
		"stroke",
		"lineWidth",
		"shadowColor",
		"strokeOpacity",
		"shadowBlur",
		"shadowOffsetX",
		"shadowOffsetY",
		"fill"
	];
	if (get_default(style, "fill")) styleObject["color"] = style["fill"];
	var _a$5 = pick(style, shapeStyleKeys), shadowColor = _a$5.shadowColor, _b = _a$5.shadowBlur, shadowBlur = _b === void 0 ? 0 : _b, _c = _a$5.shadowOffsetX, shadowOffsetX = _c === void 0 ? 0 : _c, _d = _a$5.shadowOffsetY, shadowOffsetY = _d === void 0 ? 0 : _d;
	styleObject["text-shadow"] = "".concat([
		shadowColor,
		"".concat(shadowOffsetX, "px"),
		"".concat(shadowOffsetY, "px"),
		"".concat(shadowBlur, "px")
	].join(" "));
	var _e = pick(style, shapeStyleKeys), stroke = _e.stroke, _f = _e.lineWidth, lineWidth = _f === void 0 ? 0 : _f;
	styleObject["-webkit-text-stroke"] = "".concat(["".concat(lineWidth, "px"), stroke].join(" "));
	each_default(style, function(v, k) {
		if (["fontSize"].includes(k) && is_number_default(v)) styleObject[kebabCase(k)] = "".concat(v, "px");
		else if (k && !shapeStyleKeys.includes(k)) styleObject[kebabCase(k)] = "".concat(v);
	});
	return styleObject;
}
/**
* @desc 设置 html-statistic 容器的默认样式
*
* - 默认事件穿透
*/
function setStatisticContainerStyle(container, style) {
	container.style["pointer-events"] = "none";
	each_default(style, function(v, k) {
		if (k && v) container.style[k] = v;
	});
}
/**
* 渲染环图 html-annotation（默认 position 居中 [50%, 50%]）
* @param chart
* @param options
* @param meta 字段元信息
* @param {optional} datum 当前的元数据
*/
var renderStatistic = function(chart, options, datum) {
	var statistic$3 = options.statistic, plotType = options.plotType;
	var titleOpt = statistic$3.title, contentOpt = statistic$3.content;
	[titleOpt, contentOpt].forEach(function(option, idx) {
		if (!option) return;
		var transform$7 = "";
		if (idx === 0) transform$7 = contentOpt ? "translate(-50%, -100%)" : "translate(-50%, -50%)";
		else transform$7 = titleOpt ? "translate(-50%, 0)" : "translate(-50%, -50%)";
		var style = is_function_default(option.style) ? option.style(datum) : option.style;
		chart.annotation().html(__assign(
			{
				position: ["50%", "50%"],
				html: function(container, view) {
					var coordinate$10 = view.getCoordinate();
					var containerW = 0;
					if (plotType === "pie" || plotType === "ring-progress") containerW = coordinate$10.getRadius() * coordinate$10.innerRadius * 2;
					else if (plotType === "liquid") {
						var liquidShape = get_default(view.geometries, [
							0,
							"elements",
							0,
							"shape"
						]);
						if (liquidShape) containerW = liquidShape.find(function(t) {
							return t.get("name") === "wrap";
						}).getCanvasBBox().width;
					} else if (!containerW) containerW = coordinate$10.getWidth();
					setStatisticContainerStyle(container, __assign({
						width: "".concat(containerW, "px"),
						transform: transform$7
					}, adapteStyle(style)));
					var filteredData = view.getData();
					if (option.customHtml) return option.customHtml(container, view, datum, filteredData);
					var text = option.content;
					if (option.formatter) text = option.formatter(datum, filteredData);
					return text ? is_string_default(text) ? text : "".concat(text) : "<div></div>";
				},
				key: "".concat(idx === 0 ? "top" : "bottom", "-statistic")
			},
			pick(option, [
				"offsetX",
				"offsetY",
				"rotate",
				"style",
				"formatter"
			])
			/** 透传配置 */
		));
	});
};
/**
* 渲染 html-annotation for gauge (等不规则 plot), 默认 position 居中居底 [50%, 100%]）
* @param chart
* @param options
* @param meta 字段元信息
* @param {optional} datum 当前的元数据
*/
var renderGaugeStatistic = function(chart, options, datum) {
	var statistic$3 = options.statistic;
	var titleOpt = statistic$3.title, contentOpt = statistic$3.content;
	[titleOpt, contentOpt].forEach(function(option) {
		if (!option) return;
		var style = is_function_default(option.style) ? option.style(datum) : option.style;
		chart.annotation().html(__assign(
			{
				position: ["50%", "100%"],
				html: function(container, view) {
					var coordinate$10 = view.getCoordinate();
					var polarCoord = view.views[0].getCoordinate();
					var polarCenter = polarCoord.getCenter();
					var polarRadius = polarCoord.getRadius();
					var polarMaxY = Math.max(Math.sin(polarCoord.startAngle), Math.sin(polarCoord.endAngle)) * polarRadius;
					var offsetY = polarCenter.y + polarMaxY - coordinate$10.y.start - parseFloat(get_default(style, "fontSize", 0));
					var containerWidth = coordinate$10.getRadius() * coordinate$10.innerRadius * 2;
					setStatisticContainerStyle(container, __assign({
						width: "".concat(containerWidth, "px"),
						transform: "translate(-50%, ".concat(offsetY, "px)")
					}, adapteStyle(style)));
					var filteredData = view.getData();
					if (option.customHtml) return option.customHtml(container, view, datum, filteredData);
					var text = option.content;
					if (option.formatter) text = option.formatter(datum, filteredData);
					return text ? is_string_default(text) ? text : "".concat(text) : "<div></div>";
				}
			},
			pick(option, [
				"offsetX",
				"offsetY",
				"rotate",
				"style",
				"formatter"
			])
			/** 透传配置 */
		));
	});
};

//#endregion
//#region node_modules/@antv/g2plot/esm/utils/template.js
/**
* 简单的模板引擎，使用方式如下（空格自动忽略）：
* template('hello, {name}', { name: 'AntV' }); // hello, AntV
* @param string
* @param options
*/
function template(source, data$2) {
	if (!data$2) return source;
	return reduce_default(data$2, function(r, v, k) {
		return r.replace(new RegExp("{\\s*".concat(k, "\\s*}"), "g"), v);
	}, source);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/utils/view.js
/**
* 在 Chart 中查找特定 id 的子 View
* @param chart
* @param id
*/
function findViewById(chart, id$1) {
	return chart.views.find(function(view) {
		return view.id === id$1;
	});
}
/**
* 获取同 view 同一级的所有 views
* @param view 当前 view
* @returns 同一级的 views
* @ignore
*/
function getViews(view) {
	var parent = view.parent;
	return parent ? parent.views : [];
}
/**
* 获取同 view 同一级的 views，不包括自身
* @param view 当前 view
* @returns 同一级的 views
* @ignore
*/
function getSiblingViews(view) {
	return getViews(view).filter(function(sub$1) {
		return sub$1 !== view;
	});
}
/**
* 所有的 Geometries 都使用同一动画（各个图形如有区别，自行覆盖）并添加处理动画回调
* @param view View
* @param animation 动画配置
*/
function addViewAnimation(view, animation$6, geometries) {
	if (geometries === void 0) geometries = view.geometries;
	if (typeof animation$6 === "boolean") view.animate(animation$6);
	else view.animate(true);
	each_default(geometries, function(g) {
		var animationCfg;
		if (is_function_default(animation$6)) animationCfg = animation$6(g.type || g.shapeType, g) || true;
		else animationCfg = animation$6;
		g.animate(animationCfg);
	});
}

//#endregion
//#region node_modules/@antv/g2plot/esm/utils/pattern/util.js
/**
* 获取设备像素比
*/
function getPixelRatio() {
	return typeof window === "object" ? window === null || window === void 0 ? void 0 : window.devicePixelRatio : 2;
}
/**
* 初始化 cavnas，设置宽高等
*/
function initCanvas(width, height) {
	if (height === void 0) height = width;
	var canvas = document.createElement("canvas");
	var pixelRatio = getPixelRatio();
	canvas.width = width * pixelRatio;
	canvas.height = height * pixelRatio;
	canvas.style.width = "".concat(width, "px");
	canvas.style.height = "".concat(height, "px");
	canvas.getContext("2d").scale(pixelRatio, pixelRatio);
	return canvas;
}
/**
* 绘制背景
*
* @param context
* @param cfg
* @param width
* @param height
*/
function drawBackground(context, cfg, width, height) {
	if (height === void 0) height = width;
	var backgroundColor = cfg.backgroundColor;
	context.globalAlpha = cfg.opacity;
	context.fillStyle = backgroundColor;
	context.beginPath();
	context.fillRect(0, 0, width, height);
	context.closePath();
}
/**
* 计算贴图单元大小
*
* @param size 元素大小
* @param padding 圆点间隔
* @param isStagger 是否交错
* @reutrn 返回贴图单元大小
*/
function getUnitPatternSize(size$1, padding$2, isStagger) {
	var unitSize = size$1 + padding$2;
	return isStagger ? unitSize * 2 : unitSize;
}
/**
* 计算有交错情况的元素坐标
*
* @param unitSize 贴图单元大小
* @param isStagger 是否交错
* @reutrn 元素中心坐标 x,y 数组集合
*/
function getSymbolsPosition(unitSize, isStagger) {
	return isStagger ? [[unitSize * (1 / 4), unitSize * (1 / 4)], [unitSize * (3 / 4), unitSize * (3 / 4)]] : [[unitSize * (1 / 2), unitSize * (1 / 2)]];
}
/**
* 给整个 pattern贴图 做变换, 目前支持旋转
*
* @param pattern 整个贴图
* @param dpr  设备像素比
* @param rotation 旋转角度
*/
function transformMatrix(dpr, rotation) {
	var radian = rotation * Math.PI / 180;
	return {
		a: Math.cos(radian) * (1 / dpr),
		b: Math.sin(radian) * (1 / dpr),
		c: -Math.sin(radian) * (1 / dpr),
		d: Math.cos(radian) * (1 / dpr),
		e: 0,
		f: 0
	};
}

//#endregion
//#region node_modules/@antv/g2plot/esm/utils/pattern/dot.js
/**
* dotPattern的默认配置
*/
var defaultDotPatternCfg = {
	size: 6,
	padding: 2,
	backgroundColor: "transparent",
	opacity: 1,
	rotation: 0,
	fill: "#fff",
	fillOpacity: .5,
	stroke: "transparent",
	lineWidth: 0,
	isStagger: true
};
/**
* 绘制圆点
*
* @param context
* @param cfg
* @param x 圆点中心坐标x
* @param y 圆点中心坐标y
*/
function drawDot(context, cfg, x, y) {
	var size$1 = cfg.size, fill = cfg.fill, lineWidth = cfg.lineWidth, stroke = cfg.stroke, fillOpacity = cfg.fillOpacity;
	context.beginPath();
	context.globalAlpha = fillOpacity;
	context.fillStyle = fill;
	context.strokeStyle = stroke;
	context.lineWidth = lineWidth;
	context.arc(x, y, size$1 / 2, 0, 2 * Math.PI, false);
	context.fill();
	if (lineWidth) context.stroke();
	context.closePath();
}
/**
* 创建 dot pattern，返回 HTMLCanvasElement
*
* @param cfg
* @returns HTMLCanvasElement
*/
function createDotPattern(cfg) {
	var dotCfg = deepAssign({}, defaultDotPatternCfg, cfg);
	var size$1 = dotCfg.size, padding$2 = dotCfg.padding, isStagger = dotCfg.isStagger, rotation = dotCfg.rotation;
	var unitSize = getUnitPatternSize(size$1, padding$2, isStagger);
	var dots = getSymbolsPosition(unitSize, isStagger);
	var canvas = initCanvas(unitSize, unitSize);
	var ctx$3 = canvas.getContext("2d");
	drawBackground(ctx$3, dotCfg, unitSize);
	for (var _i = 0, dots_1 = dots; _i < dots_1.length; _i++) {
		var _a$5 = dots_1[_i], x = _a$5[0], y = _a$5[1];
		drawDot(ctx$3, dotCfg, x, y);
	}
	var pattern$1 = ctx$3.createPattern(canvas, "repeat");
	if (pattern$1) {
		var dpr = getPixelRatio();
		var matrix = transformMatrix(dpr, rotation);
		pattern$1.setTransform(matrix);
	}
	return pattern$1;
}

//#endregion
//#region node_modules/@antv/g2plot/esm/utils/pattern/line.js
/**
* linePattern 的 默认配置
*/
var defaultLinePatternCfg = {
	rotation: 45,
	spacing: 5,
	opacity: 1,
	backgroundColor: "transparent",
	strokeOpacity: .5,
	stroke: "#fff",
	lineWidth: 2
};
/**
* 绘制line
*
* @param context canvasContext
* @param cfg linePattern 的配置
* @param d 绘制 path 所需的 d
*/
function drawLine(context, cfg, d) {
	var stroke = cfg.stroke, lineWidth = cfg.lineWidth, strokeOpacity = cfg.strokeOpacity;
	var path = new Path2D(d);
	context.globalAlpha = strokeOpacity;
	context.lineCap = "square";
	context.strokeStyle = lineWidth ? stroke : "transparent";
	context.lineWidth = lineWidth;
	context.stroke(path);
}
/**
* 创建 linePattern
*/
function createLinePattern(cfg) {
	var lineCfg = deepAssign({}, defaultLinePatternCfg, cfg);
	var spacing = lineCfg.spacing, rotation = lineCfg.rotation, lineWidth = lineCfg.lineWidth;
	var width = spacing + lineWidth || 1;
	var height = spacing + lineWidth || 1;
	var d = "\n            M 0 0 L ".concat(width, " 0\n            M 0 ").concat(height, " L ").concat(width, " ").concat(height, "\n            ");
	var canvas = initCanvas(width, height);
	var ctx$3 = canvas.getContext("2d");
	drawBackground(ctx$3, lineCfg, width, height);
	drawLine(ctx$3, lineCfg, d);
	var pattern$1 = ctx$3.createPattern(canvas, "repeat");
	if (pattern$1) {
		var dpr = getPixelRatio();
		var matrix = transformMatrix(dpr, rotation);
		pattern$1.setTransform(matrix);
	}
	return pattern$1;
}

//#endregion
//#region node_modules/@antv/g2plot/esm/utils/pattern/square.js
/**
* squarePattern 的 默认配置
*/
var defaultSquarePatternCfg = {
	size: 6,
	padding: 1,
	isStagger: true,
	backgroundColor: "transparent",
	opacity: 1,
	rotation: 0,
	fill: "#fff",
	fillOpacity: .5,
	stroke: "transparent",
	lineWidth: 0
};
/**
* 绘制square
*
* @param context canvasContext
* @param cfg squarePattern 的配置
* @param x和y square的中心位置
*/
function drawSquare(context, cfg, x, y) {
	var stroke = cfg.stroke, size$1 = cfg.size, fill = cfg.fill, lineWidth = cfg.lineWidth;
	context.globalAlpha = cfg.fillOpacity;
	context.strokeStyle = stroke;
	context.lineWidth = lineWidth;
	context.fillStyle = fill;
	context.strokeRect(x - size$1 / 2, y - size$1 / 2, size$1, size$1);
	context.fillRect(x - size$1 / 2, y - size$1 / 2, size$1, size$1);
}
/**
* 创建 squarePattern
*/
function createSquarePattern(cfg) {
	var squareCfg = deepAssign({}, defaultSquarePatternCfg, cfg);
	var size$1 = squareCfg.size, padding$2 = squareCfg.padding, isStagger = squareCfg.isStagger, rotation = squareCfg.rotation;
	var unitSize = getUnitPatternSize(size$1, padding$2, isStagger);
	var squares = getSymbolsPosition(unitSize, isStagger);
	var canvas = initCanvas(unitSize, unitSize);
	var ctx$3 = canvas.getContext("2d");
	drawBackground(ctx$3, squareCfg, unitSize);
	for (var _i = 0, squares_1 = squares; _i < squares_1.length; _i++) {
		var _a$5 = squares_1[_i], x = _a$5[0], y = _a$5[1];
		drawSquare(ctx$3, squareCfg, x, y);
	}
	var pattern$1 = ctx$3.createPattern(canvas, "repeat");
	if (pattern$1) {
		var dpr = getPixelRatio();
		var matrix = transformMatrix(dpr, rotation);
		pattern$1.setTransform(matrix);
	}
	return pattern$1;
}

//#endregion
//#region node_modules/@antv/g2plot/esm/utils/pattern/index.js
/**
* 获取内置的 CanvasPattern 方法
* @param options
* @returns
*/
function getCanvasPattern(options) {
	var type = options.type, cfg = options.cfg;
	var pattern$1;
	switch (type) {
		case "dot":
			pattern$1 = createDotPattern(cfg);
			break;
		case "line":
			pattern$1 = createLinePattern(cfg);
			break;
		case "square":
			pattern$1 = createSquarePattern(cfg);
			break;
		default: break;
	}
	return pattern$1;
}

//#endregion
//#region node_modules/@antv/g2plot/esm/adaptor/pattern.js
/**
* Pattern 通道，处理图案填充
* 🚀 目前支持图表类型：饼图、柱状图、条形图、玉珏图等（不支持在多 view 图表中，后续按需扩展）
*
* @param key key of style property
* @returns
*/
function pattern(key) {
	var _this = this;
	return function(params) {
		var _a$5;
		var options = params.options, chart = params.chart;
		var patternOption = options.pattern;
		if (!patternOption) return params;
		/** ~~~~~~~ 进行贴图图案处理 ~~~~~~~ */
		var style = function(datum) {
			var _a$6, _b, _c;
			var args = [];
			for (var _i = 1; _i < arguments.length; _i++) args[_i - 1] = arguments[_i];
			var defaultColor = chart.getTheme().defaultColor;
			var color$2 = defaultColor;
			var colorAttribute = (_b = (_a$6 = chart.geometries) === null || _a$6 === void 0 ? void 0 : _a$6[0]) === null || _b === void 0 ? void 0 : _b.getAttribute("color");
			if (colorAttribute) {
				var colorField = colorAttribute.getFields()[0];
				var seriesValue = get_default(datum, colorField);
				color$2 = Util.getMappingValue(colorAttribute, seriesValue, ((_c = colorAttribute.values) === null || _c === void 0 ? void 0 : _c[0]) || defaultColor);
			}
			var pattern$1 = patternOption;
			if (typeof patternOption === "function") pattern$1 = patternOption.call(_this, datum, color$2);
			if (pattern$1 instanceof CanvasPattern === false) pattern$1 = getCanvasPattern(deepAssign({}, { cfg: { backgroundColor: color$2 } }, pattern$1));
			var styleOption = options[key];
			return __assign(__assign({}, typeof styleOption === "function" ? styleOption.call.apply(styleOption, __spreadArray([_this, datum], args, false)) : styleOption || {}), { fill: pattern$1 || color$2 });
		};
		return deepAssign({}, params, { options: (_a$5 = {}, _a$5[key] = style, _a$5) });
	};
}

//#endregion
//#region node_modules/@antv/g2plot/esm/adaptor/common.js
/**
* 通用 legend 配置, 适用于带 colorField 或 seriesField 的图表
* @param params
*/
function legend(params) {
	var chart = params.chart, options = params.options;
	var legend$17 = options.legend, colorField = options.colorField, seriesField = options.seriesField;
	if (legend$17 === false) chart.legend(false);
	else if (colorField || seriesField) chart.legend(colorField || seriesField, legend$17);
	return params;
}
/**
* 通用 tooltip 配置
* @param params
*/
function tooltip(params) {
	var chart = params.chart;
	var tooltip$10 = params.options.tooltip;
	if (tooltip$10 !== void 0) chart.tooltip(tooltip$10);
	return params;
}
/**
* Interaction 配置
* @param params
*/
function interaction(params) {
	var chart = params.chart;
	var interactions = params.options.interactions;
	each_default(interactions, function(i) {
		if (i.enable === false) chart.removeInteraction(i.type);
		else chart.interaction(i.type, i.cfg || {});
	});
	return params;
}
/**
* 动画
* @param params
*/
function animation(params) {
	var chart = params.chart;
	var animation$6 = params.options.animation;
	addViewAnimation(chart, animation$6);
	return params;
}
/**
* 设置全局主题配置
* @param params
*/
function theme(params) {
	var chart = params.chart;
	var theme$3 = params.options.theme;
	if (theme$3) chart.theme(theme$3);
	return params;
}
/**
* 状态 state 配置
* @param params
*/
function state(params) {
	var chart = params.chart;
	var state$1 = params.options.state;
	if (state$1) each_default(chart.geometries, function(geometry$34) {
		geometry$34.state(state$1);
	});
	return params;
}
/**
* 处理缩略轴的 adaptor
* @param params
*/
function slider$2(params) {
	var chart = params.chart;
	var slider$3 = params.options.slider;
	chart.option("slider", slider$3);
	return params;
}
/**
* 处理缩略轴的 adaptor
* @param params
*/
function scrollbar(params) {
	var chart = params.chart;
	var scrollbar$1 = params.options.scrollbar;
	chart.option("scrollbar", scrollbar$1);
	return params;
}
/**
* scale 的 adaptor
* @param axes
*/
function scale(axes, meta$22) {
	return function(params) {
		var chart = params.chart, options = params.options;
		var scales = {};
		each_default(axes, function(axis$21, field$5) {
			scales[field$5] = pick(axis$21, AXIS_META_CONFIG_KEYS);
		});
		scales = deepAssign({}, meta$22, options.meta, scales);
		chart.scale(scales);
		return params;
	};
}
/**
* annotation 配置
* @param params
*/
function annotation(annotationOptions) {
	return function(params) {
		var chart = params.chart, options = params.options;
		var annotationController = chart.getController("annotation");
		/** 自定义 annotation */
		each_default(__spreadArray(__spreadArray([], options.annotations || [], true), annotationOptions || [], true), function(annotationOption) {
			annotationController.annotation(annotationOption);
		});
		return params;
	};
}
/**
* 自动设置 limitInPlot
* @param params
*/
function limitInPlot(params) {
	var chart = params.chart, options = params.options;
	var yAxis = options.yAxis, limitInPlot$4 = options.limitInPlot;
	var value$1 = limitInPlot$4;
	if (is_object_default(yAxis) && is_nil_default(limitInPlot$4)) if (Object.values(pick(yAxis, [
		"min",
		"max",
		"minLimit",
		"maxLimit"
	])).some(function(value$2) {
		return !is_nil_default(value$2);
	})) value$1 = true;
	else value$1 = false;
	chart.limitInPlot = value$1;
	return params;
}
/**
* 坐标系转换
*/
function transformations(coordinateType) {
	if (coordinateType === void 0) coordinateType = "rect";
	return function(params) {
		var chart = params.chart;
		var coordinate$10 = params.options.coordinate;
		var actions = Array.from(coordinate$10 || []).map(function(cfg) {
			if (cfg.type === "reflectX") return ["reflect", "x"];
			if (cfg.type === "reflectY") return ["reflect", "y"];
			if (cfg.type === "transpose") return ["transpose"];
			return null;
		}).filter(function(d) {
			return !!d;
		});
		if (actions.length !== 0) chart.coordinate({
			type: coordinateType,
			actions
		});
		return params;
	};
}

//#endregion
//#region node_modules/@antv/g2plot/esm/core/global.js
/**
* @file 全局的一些变量定义：含国际化、主题...
*/
var GLOBAL = { locale: "en-US" };
/**
* 全局变量设置
* @param key
* @param value
*/
function setGlobal(datum) {
	each_default(datum, function(v, k) {
		return GLOBAL[k] = v;
	});
}

//#endregion
//#region node_modules/@antv/g2plot/esm/core/locale.js
var LocaleMap = {};
/**
* register a locale
* @param locale
* @param localeObj
*/
function registerLocale(locale, localeObj) {
	LocaleMap[locale] = localeObj;
}
/**
* get locale of specific language
* @param lang
* @returns
*/
function getLocale(locale) {
	return { get: function(key, obj) {
		return template(get_default(LocaleMap[locale], key) || get_default(LocaleMap[GLOBAL.locale], key) || get_default(LocaleMap["en-US"], key) || key, obj);
	} };
}

//#endregion
//#region node_modules/@antv/g2plot/esm/locales/en_US.js
var EN_US_LOCALE = {
	locale: "en-US",
	general: {
		increase: "Increase",
		decrease: "Decrease",
		root: "Root"
	},
	statistic: { total: "Total" },
	conversionTag: { label: "Rate" },
	legend: {},
	tooltip: {},
	slider: {},
	scrollbar: {},
	waterfall: { total: "Total" }
};

//#endregion
//#region node_modules/@antv/g2plot/esm/locales/zh_CN.js
var ZH_CN_LOCALE = {
	locale: "zh-CN",
	general: {
		increase: "增加",
		decrease: "减少",
		root: "初始"
	},
	statistic: { total: "总计" },
	conversionTag: { label: "转化率" },
	legend: {},
	tooltip: {},
	slider: {},
	scrollbar: {},
	waterfall: { total: "总计" }
};

//#endregion
//#region node_modules/@antv/g2plot/esm/utils/tooltip.js
/**
* 获得 tooltip 的映射信息
* @param tooltip
* @param defaultFields
*/
function getTooltipMapping(tooltip$10, defaultFields) {
	if (tooltip$10 === false) return { fields: false };
	var fields = get_default(tooltip$10, "fields");
	var formatter = get_default(tooltip$10, "formatter");
	if (formatter && !fields) fields = defaultFields;
	return {
		fields,
		formatter
	};
}

//#endregion
//#region node_modules/@antv/g2plot/esm/adaptor/geometries/base.js
/**
* 获得映射的字段列表
* @param options
* @param field
*/
function getMappingField(o, field$5) {
	var type = o.type, xField = o.xField, yField = o.yField, colorField = o.colorField, shapeField = o.shapeField, sizeField = o.sizeField, styleField = o.styleField;
	var rawFields = o.rawFields;
	var fields = [];
	rawFields = (is_function_default(rawFields) ? rawFields(type, field$5) : rawFields) || [];
	if (field$5 === "color") fields = __spreadArray([colorField || xField], rawFields, true);
	else if (field$5 === "shape") fields = __spreadArray([shapeField || xField], rawFields, true);
	else if (field$5 === "size") fields = __spreadArray([sizeField || xField], rawFields, true);
	else {
		fields = __spreadArray([
			xField,
			yField,
			colorField,
			shapeField,
			sizeField,
			styleField
		], rawFields, true);
		var idx = [
			"x",
			"y",
			"color",
			"shape",
			"size",
			"style"
		].indexOf(field$5);
		var f = fields[idx];
		fields.splice(idx, 1);
		fields.unshift(f);
	}
	var mappingFields = uniq(fields.filter(function(f$1) {
		return !!f$1;
	}));
	/**
	* 修复 line geometry 无拆分时 color 回调错误
	* eg:
	*   geometry.color(xField, ()=> '#f24')
	*/
	var tileMappingField = type === "line" && [xField, yField].includes(mappingFields.join("*")) ? "" : mappingFields.join("*");
	return {
		mappingFields,
		tileMappingField
	};
}
/**
* 获得映射函数
* @param mappingFields
* @param func
*/
function getMappingFunction(mappingFields, func) {
	if (!func) return void 0;
	return function() {
		var args = [];
		for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
		var params = {};
		mappingFields.forEach(function(f, idx) {
			params[f] = args[idx];
		});
		delete params["undefined"];
		return func(params);
	};
}
/**
* 通用 geometry 的配置处理的 adaptor
* @param params
*/
function geometry$10(params) {
	var chart = params.chart, options = params.options;
	var type = options.type, args = options.args, mapping = options.mapping, xField = options.xField, yField = options.yField, colorField = options.colorField, shapeField = options.shapeField, sizeField = options.sizeField, tooltipFields = options.tooltipFields, label$16 = options.label, state$1 = options.state, customInfo = options.customInfo, customMappingField = options.customMappingField;
	if (!mapping) return params;
	var color$2 = mapping.color, shape = mapping.shape, size$1 = mapping.size, style = mapping.style, tooltip$10 = mapping.tooltip;
	var geometry$34 = chart[type](args).position("".concat(xField, "*").concat(yField));
	/**
	* color 的几种情况
	* g.color('red');
	* g.color('color', ['red', 'blue']);
	* g.color('x', (x, y) => 'red');
	* g.color('color', (color, x, y) => 'red');
	*/
	if (is_string_default(color$2)) colorField ? geometry$34.color(colorField, color$2) : geometry$34.color(color$2);
	else if (is_function_default(color$2)) {
		var _a$5 = getMappingField(options, "color"), mappingFields = _a$5.mappingFields, tileMappingField = _a$5.tileMappingField;
		geometry$34.color(customMappingField || tileMappingField, getMappingFunction(mappingFields, color$2));
	} else colorField && geometry$34.color(colorField, color$2);
	/**
	* shape 的几种情况
	* g.shape('rect');
	* g.shape('shape', ['rect', 'circle']);
	* g.shape('x*y', (x, y) => 'rect');
	* g.shape('shape*x*y', (shape, x, y) => 'rect');
	*/
	if (is_string_default(shape)) shapeField ? geometry$34.shape(shapeField, [shape]) : geometry$34.shape(shape);
	else if (is_function_default(shape)) {
		var _b = getMappingField(options, "shape"), mappingFields = _b.mappingFields, tileMappingField = _b.tileMappingField;
		geometry$34.shape(tileMappingField, getMappingFunction(mappingFields, shape));
	} else shapeField && geometry$34.shape(shapeField, shape);
	/**
	* size 的几种情况
	* g.size(10);
	* g.size('size', [10, 20]);
	* g.size('x*y', (x, y) => 10);
	* g.color('size*x*y', (size, x, y) => 1-);
	*/
	if (is_number_default(size$1)) sizeField ? geometry$34.size(sizeField, size$1) : geometry$34.size(size$1);
	else if (is_function_default(size$1)) {
		var _c = getMappingField(options, "size"), mappingFields = _c.mappingFields, tileMappingField = _c.tileMappingField;
		geometry$34.size(tileMappingField, getMappingFunction(mappingFields, size$1));
	} else sizeField && geometry$34.size(sizeField, size$1);
	/**
	* style 的几种情况
	* g.style({ fill: 'red' });
	* g.style('x*y*color', (x, y, color) => ({ fill: 'red' }));
	*/
	if (is_function_default(style)) {
		var _d = getMappingField(options, "style"), mappingFields = _d.mappingFields, tileMappingField = _d.tileMappingField;
		geometry$34.style(tileMappingField, getMappingFunction(mappingFields, style));
	} else if (is_object_default(style)) geometry$34.style(style);
	/**
	* tooltip 的 API
	* g.tooltip('x*y*color', (x, y, color) => ({ name, value }));
	* g.tooltip(false);
	*/
	if (tooltipFields === false) geometry$34.tooltip(false);
	else if (!is_empty_default(tooltipFields)) geometry$34.tooltip(tooltipFields.join("*"), getMappingFunction(tooltipFields, tooltip$10));
	/**
	* label 的映射
	*/
	if (label$16 === false) geometry$34.label(false);
	else if (label$16) {
		var callback = label$16.callback, fields = label$16.fields, cfg = __rest(label$16, ["callback", "fields"]);
		geometry$34.label({
			fields: fields || [yField],
			callback,
			cfg: transformLabel(cfg)
		});
	}
	/**
	* state 状态样式
	*/
	if (state$1) geometry$34.state(state$1);
	/**
	* 自定义信息
	*/
	if (customInfo) geometry$34.customInfo(customInfo);
	[xField, yField].filter(function(f) {
		return f !== colorField;
	}).forEach(function(f) {
		chart.legend(f, false);
	});
	return __assign(__assign({}, params), { ext: { geometry: geometry$34 } });
}

//#endregion
//#region node_modules/@antv/g2plot/esm/adaptor/geometries/area.js
/**
* area geometry 的配置处理
* @param params
*/
function area(params) {
	var options = params.options;
	var area$1 = options.area, xField = options.xField, yField = options.yField, seriesField = options.seriesField, smooth = options.smooth, tooltip$10 = options.tooltip, useDeferredLabel = options.useDeferredLabel;
	var _a$5 = getTooltipMapping(tooltip$10, [
		xField,
		yField,
		seriesField
	]), fields = _a$5.fields, formatter = _a$5.formatter;
	return area$1 ? geometry$10(deepAssign({}, params, { options: {
		type: "area",
		colorField: seriesField,
		tooltipFields: fields,
		mapping: deep_mix_default({
			shape: smooth ? "smooth" : "area",
			tooltip: formatter
		}, area$1),
		args: { useDeferredLabel }
	} })) : params;
}

//#endregion
//#region node_modules/@antv/g2plot/esm/adaptor/geometries/edge.js
/**
* edge 的配置处理
* @param params
*/
function edge(params) {
	var options = params.options;
	var edge$1 = options.edge, xField = options.xField, yField = options.yField, seriesField = options.seriesField, tooltip$10 = options.tooltip, useDeferredLabel = options.useDeferredLabel;
	var _a$5 = getTooltipMapping(tooltip$10, [
		xField,
		yField,
		seriesField
	]), fields = _a$5.fields, formatter = _a$5.formatter;
	return edge$1 ? geometry$10(deepAssign({}, params, { options: {
		type: "edge",
		colorField: seriesField,
		tooltipFields: fields,
		mapping: __assign({ tooltip: formatter }, edge$1),
		args: { useDeferredLabel }
	} })) : params;
}

//#endregion
//#region node_modules/@antv/g2plot/esm/adaptor/geometries/interval.js
/**
* 柱形图其他的 adaptor
* @param params
*/
function otherAdaptor(params) {
	var chart = params.chart, options = params.options, ext = params.ext;
	var seriesField = options.seriesField, isGroup = options.isGroup, isStack = options.isStack, marginRatio = options.marginRatio, widthRatio = options.widthRatio, groupField = options.groupField, theme$3 = options.theme;
	/**
	* adjust
	*/
	var adjust$2 = [];
	if (seriesField) {
		if (isGroup) adjust$2.push({
			type: "dodge",
			dodgeBy: groupField || seriesField,
			marginRatio
		});
		if (isStack) adjust$2.push({
			type: "stack",
			marginRatio
		});
	}
	if (adjust$2.length && (ext === null || ext === void 0 ? void 0 : ext.geometry)) (ext === null || ext === void 0 ? void 0 : ext.geometry).adjust(adjust$2);
	if (!is_nil_default(widthRatio)) chart.theme(deepAssign({}, is_object_default(theme$3) ? theme$3 : getTheme(theme$3), { columnWidthRatio: widthRatio }));
	return params;
}
function interval(params) {
	var options = params.options;
	var xField = options.xField, yField = options.yField, interval$2 = options.interval, seriesField = options.seriesField, tooltip$10 = options.tooltip, minColumnWidth = options.minColumnWidth, maxColumnWidth = options.maxColumnWidth, columnBackground = options.columnBackground, dodgePadding = options.dodgePadding, intervalPadding = options.intervalPadding, useDeferredLabel = options.useDeferredLabel;
	var _a$5 = getTooltipMapping(tooltip$10, [
		xField,
		yField,
		seriesField
	]), fields = _a$5.fields, formatter = _a$5.formatter;
	var ext = (interval$2 ? geometry$10(deepAssign({}, params, { options: {
		type: "interval",
		colorField: seriesField,
		tooltipFields: fields,
		mapping: __assign({ tooltip: formatter }, interval$2),
		args: {
			dodgePadding,
			intervalPadding,
			minColumnWidth,
			maxColumnWidth,
			background: columnBackground,
			useDeferredLabel
		}
	} })) : params).ext;
	return otherAdaptor(__assign(__assign({}, params), { ext }));
}

//#endregion
//#region node_modules/@antv/g2plot/esm/adaptor/geometries/line.js
/**
* line 辅助点的配置处理
* @param params
*/
function line(params) {
	var options = params.options;
	var line$1 = options.line, stepType = options.stepType, xField = options.xField, yField = options.yField, seriesField = options.seriesField, smooth = options.smooth, connectNulls = options.connectNulls, tooltip$10 = options.tooltip, useDeferredLabel = options.useDeferredLabel;
	var _a$5 = getTooltipMapping(tooltip$10, [
		xField,
		yField,
		seriesField
	]), fields = _a$5.fields, formatter = _a$5.formatter;
	return line$1 ? geometry$10(deepAssign({}, params, { options: {
		type: "line",
		colorField: seriesField,
		tooltipFields: fields,
		mapping: deep_mix_default({
			shape: stepType || (smooth ? "smooth" : "line"),
			tooltip: formatter
		}, line$1),
		args: {
			connectNulls,
			useDeferredLabel
		}
	} })) : params;
}

//#endregion
//#region node_modules/@antv/g2plot/esm/adaptor/geometries/point.js
/**
* point 辅助点的配置处理
* @param params
*/
function point(params) {
	var options = params.options;
	var point$1 = options.point, xField = options.xField, yField = options.yField, seriesField = options.seriesField, sizeField = options.sizeField, shapeField = options.shapeField, tooltip$10 = options.tooltip, useDeferredLabel = options.useDeferredLabel;
	var _a$5 = getTooltipMapping(tooltip$10, [
		xField,
		yField,
		seriesField,
		sizeField,
		shapeField
	]), fields = _a$5.fields, formatter = _a$5.formatter;
	return point$1 ? geometry$10(deepAssign({}, params, { options: {
		type: "point",
		colorField: seriesField,
		shapeField,
		tooltipFields: fields,
		mapping: __assign({ tooltip: formatter }, point$1),
		args: { useDeferredLabel }
	} })) : params;
}

//#endregion
//#region node_modules/@antv/g2plot/esm/adaptor/geometries/polygon.js
/**
* polygon 的配置处理
* @param params
*/
function polygon(params) {
	var options = params.options;
	var polygon$1 = options.polygon, xField = options.xField, yField = options.yField, seriesField = options.seriesField, tooltip$10 = options.tooltip, useDeferredLabel = options.useDeferredLabel;
	var _a$5 = getTooltipMapping(tooltip$10, [
		xField,
		yField,
		seriesField
	]), fields = _a$5.fields, formatter = _a$5.formatter;
	return polygon$1 ? geometry$10(deepAssign({}, params, { options: {
		type: "polygon",
		colorField: seriesField,
		tooltipFields: fields,
		mapping: __assign({ tooltip: formatter }, polygon$1),
		args: { useDeferredLabel }
	} })) : params;
}

//#endregion
//#region node_modules/@antv/g2plot/esm/adaptor/geometries/schema.js
/**
* schema 的配置处理
* @param params
*/
function schema(params) {
	var options = params.options;
	var schema$1 = options.schema, xField = options.xField, yField = options.yField, seriesField = options.seriesField, tooltip$10 = options.tooltip, useDeferredLabel = options.useDeferredLabel;
	var _a$5 = getTooltipMapping(tooltip$10, [
		xField,
		yField,
		seriesField
	]), fields = _a$5.fields, formatter = _a$5.formatter;
	return schema$1 ? geometry$10(deepAssign({}, params, { options: {
		type: "schema",
		colorField: seriesField,
		tooltipFields: fields,
		mapping: __assign({ tooltip: formatter }, schema$1),
		args: { useDeferredLabel }
	} })) : params;
}

//#endregion
//#region node_modules/@antv/g2plot/esm/adaptor/geometries/violin.js
/**
* violin 辅助点的配置处理
* @param params
*/
function violin(params) {
	var options = params.options;
	var violin$1 = options.violin, xField = options.xField, yField = options.yField, seriesField = options.seriesField, sizeField = options.sizeField, tooltip$10 = options.tooltip;
	var _a$5 = getTooltipMapping(tooltip$10, [
		xField,
		yField,
		seriesField,
		sizeField
	]), fields = _a$5.fields, formatter = _a$5.formatter;
	return violin$1 ? geometry$10(deepAssign({}, params, { options: {
		type: "violin",
		colorField: seriesField,
		tooltipFields: fields,
		mapping: __assign({ tooltip: formatter }, violin$1)
	} })) : params;
}

//#endregion
//#region node_modules/size-sensor/lib/id.js
var require_id = /* @__PURE__ */ __commonJS({ "node_modules/size-sensor/lib/id.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	/**
	* Created by hustcc on 18/6/9.
	* Contract: i@hust.cc
	*/
	var id = 1;
	/**
	* generate unique id in application
	* @return {string}
	*/
	var _default$1 = function _default$2() {
		return "".concat(id++);
	};
	exports["default"] = _default$1;
}) });

//#endregion
//#region node_modules/size-sensor/lib/debounce.js
var require_debounce = /* @__PURE__ */ __commonJS({ "node_modules/size-sensor/lib/debounce.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	/**
	* Created by hustcc on 18/6/9.
	* Contract: i@hust.cc
	*/
	var _default = function _default$2(fn) {
		var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 60;
		var timer$1 = null;
		return function() {
			var _this = this;
			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
			clearTimeout(timer$1);
			timer$1 = setTimeout(function() {
				fn.apply(_this, args);
			}, delay);
		};
	};
	exports["default"] = _default;
}) });

//#endregion
//#region node_modules/size-sensor/lib/constant.js
var require_constant = /* @__PURE__ */ __commonJS({ "node_modules/size-sensor/lib/constant.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	/**
	* Created by hustcc on 18/6/9.
	* Contract: i@hust.cc
	*/
	var SizeSensorId = "size-sensor-id";
	exports.SizeSensorId = SizeSensorId;
	var SensorClassName = "size-sensor-object";
	exports.SensorClassName = SensorClassName;
	var SensorTabIndex = "-1";
	exports.SensorTabIndex = SensorTabIndex;
}) });

//#endregion
//#region node_modules/size-sensor/lib/sensors/object.js
var require_object = /* @__PURE__ */ __commonJS({ "node_modules/size-sensor/lib/sensors/object.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var _debounce$1 = _interopRequireDefault$2(require_debounce());
	var _constant$2 = require_constant();
	function _interopRequireDefault$2(obj) {
		return obj && obj.__esModule ? obj : { "default": obj };
	}
	/**
	* Created by hustcc on 18/6/9.
	* Contract: i@hust.cc
	*/
	var createSensor$2 = function createSensor$3(element, whenDestroy) {
		var sensor = void 0;
		var listeners = [];
		/**
		* create object DOM of sensor
		* @returns {HTMLObjectElement}
		*/
		var newSensor = function newSensor$1() {
			if (getComputedStyle(element).position === "static") element.style.position = "relative";
			var obj = document.createElement("object");
			obj.onload = function() {
				obj.contentDocument.defaultView.addEventListener("resize", resizeListener);
				resizeListener();
			};
			obj.style.display = "block";
			obj.style.position = "absolute";
			obj.style.top = "0";
			obj.style.left = "0";
			obj.style.height = "100%";
			obj.style.width = "100%";
			obj.style.overflow = "hidden";
			obj.style.pointerEvents = "none";
			obj.style.zIndex = "-1";
			obj.style.opacity = "0";
			obj.setAttribute("class", _constant$2.SensorClassName);
			obj.setAttribute("tabindex", _constant$2.SensorTabIndex);
			obj.type = "text/html";
			element.appendChild(obj);
			obj.data = "about:blank";
			return obj;
		};
		/**
		* trigger listeners
		*/
		var resizeListener = (0, _debounce$1["default"])(function() {
			listeners.forEach(function(listener) {
				listener(element);
			});
		});
		/**
		* listen with one callback function
		* @param cb
		*/
		var bind$2 = function bind$3(cb) {
			if (!sensor) sensor = newSensor();
			if (listeners.indexOf(cb) === -1) listeners.push(cb);
		};
		/**
		* destroy all
		*/
		var destroy = function destroy$1() {
			if (sensor && sensor.parentNode) {
				if (sensor.contentDocument) sensor.contentDocument.defaultView.removeEventListener("resize", resizeListener);
				sensor.parentNode.removeChild(sensor);
				element.removeAttribute(_constant$2.SizeSensorId);
				sensor = void 0;
				listeners = [];
				whenDestroy && whenDestroy();
			}
		};
		return {
			element,
			bind: bind$2,
			destroy,
			unbind: function unbind(cb) {
				var idx = listeners.indexOf(cb);
				if (idx !== -1) listeners.splice(idx, 1);
				if (listeners.length === 0 && sensor) destroy();
			}
		};
	};
	exports.createSensor = createSensor$2;
}) });

//#endregion
//#region node_modules/size-sensor/lib/sensors/resizeObserver.js
var require_resizeObserver = /* @__PURE__ */ __commonJS({ "node_modules/size-sensor/lib/sensors/resizeObserver.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var _constant$1 = require_constant();
	var _debounce = _interopRequireDefault$1(require_debounce());
	function _interopRequireDefault$1(obj) {
		return obj && obj.__esModule ? obj : { "default": obj };
	}
	/**
	* Created by hustcc on 18/7/5.
	* Contract: i@hust.cc
	*/
	var createSensor$1 = function createSensor$3(element, whenDestroy) {
		var sensor = void 0;
		var listeners = [];
		/**
		* trigger listeners
		*/
		var resizeListener = (0, _debounce["default"])(function() {
			listeners.forEach(function(listener) {
				listener(element);
			});
		});
		/**
		* create ResizeObserver sensor
		* @returns
		*/
		var newSensor = function newSensor$1() {
			var s = new ResizeObserver(resizeListener);
			s.observe(element);
			resizeListener();
			return s;
		};
		/**
		* listen with callback
		* @param cb
		*/
		var bind$2 = function bind$3(cb) {
			if (!sensor) sensor = newSensor();
			if (listeners.indexOf(cb) === -1) listeners.push(cb);
		};
		/**
		* destroy
		*/
		var destroy = function destroy$1() {
			sensor.disconnect();
			listeners = [];
			sensor = void 0;
			element.removeAttribute(_constant$1.SizeSensorId);
			whenDestroy && whenDestroy();
		};
		return {
			element,
			bind: bind$2,
			destroy,
			unbind: function unbind(cb) {
				var idx = listeners.indexOf(cb);
				if (idx !== -1) listeners.splice(idx, 1);
				if (listeners.length === 0 && sensor) destroy();
			}
		};
	};
	exports.createSensor = createSensor$1;
}) });

//#endregion
//#region node_modules/size-sensor/lib/sensors/index.js
var require_sensors = /* @__PURE__ */ __commonJS({ "node_modules/size-sensor/lib/sensors/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var _object = require_object();
	var _resizeObserver = require_resizeObserver();
	/**
	* Created by hustcc on 18/7/5.
	* Contract: i@hust.cc
	*/
	/**
	* sensor strategies
	*/
	var createSensor = typeof ResizeObserver !== "undefined" ? _resizeObserver.createSensor : _object.createSensor;
	exports.createSensor = createSensor;
}) });

//#endregion
//#region node_modules/size-sensor/lib/sensorPool.js
var require_sensorPool = /* @__PURE__ */ __commonJS({ "node_modules/size-sensor/lib/sensorPool.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var _id = _interopRequireDefault(require_id());
	var _sensors = require_sensors();
	var _constant = require_constant();
	function _interopRequireDefault(obj) {
		return obj && obj.__esModule ? obj : { "default": obj };
	}
	/**
	* Created by hustcc on 18/6/9.
	* Contract: i@hust.cc
	*/
	/**
	* all the sensor objects.
	* sensor pool
	*/
	var Sensors = {};
	/**
	* When destroy the sensor, remove it from the pool
	*/
	exports.Sensors = Sensors;
	function clean(sensorId) {
		if (sensorId && Sensors[sensorId]) delete Sensors[sensorId];
	}
	/**
	* get one sensor
	* @param element
	* @returns {*}
	*/
	var getSensor = function getSensor$1(element) {
		var sensorId = element.getAttribute(_constant.SizeSensorId);
		if (sensorId && Sensors[sensorId]) return Sensors[sensorId];
		var newId = (0, _id["default"])();
		element.setAttribute(_constant.SizeSensorId, newId);
		var sensor = (0, _sensors.createSensor)(element, function() {
			return clean(newId);
		});
		Sensors[newId] = sensor;
		return sensor;
	};
	/**
	* 移除 sensor
	* @param sensor
	*/
	exports.getSensor = getSensor;
	var removeSensor = function removeSensor$1(sensor) {
		var sensorId = sensor.element.getAttribute(_constant.SizeSensorId);
		sensor.destroy();
		clean(sensorId);
	};
	exports.removeSensor = removeSensor;
}) });

//#endregion
//#region node_modules/size-sensor/lib/index.js
var require_lib = /* @__PURE__ */ __commonJS({ "node_modules/size-sensor/lib/index.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var _sensorPool = require_sensorPool();
	/**
	* Created by hustcc on 18/6/9.[高考时间]
	* Contract: i@hust.cc
	*/
	/**
	* bind an element with resize callback function
	* @param {*} element
	* @param {*} cb
	*/
	var bind$1 = function bind$2(element, cb) {
		var sensor = (0, _sensorPool.getSensor)(element);
		sensor.bind(cb);
		return function() {
			sensor.unbind(cb);
		};
	};
	/**
	* clear all the listener and sensor of an element
	* @param element
	*/
	exports.bind = bind$1;
}) });

//#endregion
//#region node_modules/@antv/g2plot/esm/core/plot.js
var import_lib = /* @__PURE__ */ __toESM(require_lib());
var SOURCE_ATTRIBUTE_NAME = "data-chart-source-type";
/** plot 图表容器的配置 */
var PLOT_CONTAINER_OPTIONS = [
	"padding",
	"appendPadding",
	"renderer",
	"pixelRatio",
	"syncViewPadding",
	"supportCSSTransform",
	"limitInPlot"
];
/**
* 所有 plot 的基类
*/
var Plot = function(_super) {
	__extends(Plot$1, _super);
	function Plot$1(container, options) {
		var _this = _super.call(this) || this;
		_this.container = typeof container === "string" ? document.getElementById(container) : container;
		_this.options = deepAssign({}, _this.getDefaultOptions(), options);
		_this.createG2();
		_this.bindEvents();
		return _this;
	}
	/**
	* 获取默认的 options 配置项
	* 每个组件都可以复写
	*/
	Plot$1.getDefaultOptions = function() {
		return {
			renderer: "canvas",
			xAxis: {
				nice: true,
				label: {
					autoRotate: false,
					autoHide: {
						type: "equidistance",
						cfg: { minGap: 6 }
					}
				}
			},
			yAxis: {
				nice: true,
				label: {
					autoHide: true,
					autoRotate: false
				}
			},
			animation: true
		};
	};
	/**
	* 创建 G2 实例
	*/
	Plot$1.prototype.createG2 = function() {
		var _a$5 = this.options, width = _a$5.width, height = _a$5.height, defaultInteractions = _a$5.defaultInteractions;
		this.chart = new chart_default(__assign(__assign(__assign(__assign({
			container: this.container,
			autoFit: false
		}, this.getChartSize(width, height)), { localRefresh: false }), pick(this.options, PLOT_CONTAINER_OPTIONS)), { defaultInteractions }));
		this.container.setAttribute(SOURCE_ATTRIBUTE_NAME, "G2Plot");
	};
	/**
	* 计算默认的 chart 大小。逻辑简化：如果存在 width 或 height，则直接使用，否则使用容器大小
	* @param width
	* @param height
	*/
	Plot$1.prototype.getChartSize = function(width, height) {
		var chartSize = getContainerSize(this.container);
		return {
			width: width || chartSize.width || 400,
			height: height || chartSize.height || 400
		};
	};
	/**
	* 绑定代理所有 G2 的事件
	*/
	Plot$1.prototype.bindEvents = function() {
		var _this = this;
		if (this.chart) this.chart.on("*", function(e) {
			if (e === null || e === void 0 ? void 0 : e.type) _this.emit(e.type, e);
		});
	};
	/**
	* 获取默认的 options 配置项
	* 每个组件都可以复写
	*/
	Plot$1.prototype.getDefaultOptions = function() {
		return Plot$1.getDefaultOptions();
	};
	/**
	* 绘制
	*/
	Plot$1.prototype.render = function() {
		this.chart.clear();
		this.chart.options = {
			data: [],
			animate: true
		};
		this.chart.views = [];
		this.execAdaptor();
		this.chart.render();
		this.bindSizeSensor();
	};
	/**
	* 更新: 更新配置且重新渲染
	* @param options
	*/
	Plot$1.prototype.update = function(options) {
		this.updateOption(options);
		this.render();
	};
	/**
	* 更新配置
	* @param options
	*/
	Plot$1.prototype.updateOption = function(options) {
		this.options = deepAssign({}, this.options, options);
	};
	/**
	* 设置状态
	* @param type 状态类型，支持 'active' | 'inactive' | 'selected' 三种
	* @param conditions 条件，支持数组
	* @param status 是否激活，默认 true
	*/
	Plot$1.prototype.setState = function(type, condition, status) {
		if (status === void 0) status = true;
		var elements = getAllElementsRecursively(this.chart);
		each_default(elements, function(ele) {
			if (condition(ele.getData())) ele.setState(type, status);
		});
	};
	/**
	* 获取状态
	*/
	Plot$1.prototype.getStates = function() {
		var elements = getAllElementsRecursively(this.chart);
		var stateObjects = [];
		each_default(elements, function(element) {
			var data$2 = element.getData();
			var states = element.getStates();
			each_default(states, function(state$1) {
				stateObjects.push({
					data: data$2,
					state: state$1,
					geometry: element.geometry,
					element
				});
			});
		});
		return stateObjects;
	};
	/**
	* 更新数据
	* @override
	* @param options
	*/
	Plot$1.prototype.changeData = function(data$2) {
		this.update({ data: data$2 });
	};
	/**
	* 修改画布大小
	* @param width
	* @param height
	*/
	Plot$1.prototype.changeSize = function(width, height) {
		this.chart.changeSize(width, height);
	};
	/**
	* 增加图表标注。通过 id 标识，如果匹配到，就做更新
	*/
	Plot$1.prototype.addAnnotations = function(annotations, view) {
		view = view ? view : this.chart;
		var incoming = __spreadArray([], annotations, true);
		var controller = view.getController("annotation");
		var current = controller.getComponents().map(function(co) {
			return co.extra;
		});
		controller.clear(true);
		var _loop_1 = function(i$1) {
			var annotation$3 = current[i$1];
			var findIndex$1 = incoming.findIndex(function(item) {
				return item.id && item.id === annotation$3.id;
			});
			if (findIndex$1 !== -1) {
				annotation$3 = deepAssign({}, annotation$3, incoming[findIndex$1]);
				incoming.splice(findIndex$1, 1);
			}
			controller.annotation(annotation$3);
		};
		for (var i = 0; i < current.length; i++) _loop_1(i);
		incoming.forEach(function(annotation$3) {
			return controller.annotation(annotation$3);
		});
		view.render(true);
	};
	/**
	* 删除图表标注。通过 id 标识，如果匹配到，就做删除
	*/
	Plot$1.prototype.removeAnnotations = function(annotations) {
		var controller = this.chart.getController("annotation");
		var current = controller.getComponents().map(function(co) {
			return co.extra;
		});
		controller.clear(true);
		var _loop_2 = function(i$1) {
			var annotation$3 = current[i$1];
			if (!annotations.find(function(item) {
				return item.id && item.id === annotation$3.id;
			})) controller.annotation(annotation$3);
		};
		for (var i = 0; i < current.length; i++) _loop_2(i);
		this.chart.render(true);
	};
	/**
	* 销毁
	*/
	Plot$1.prototype.destroy = function() {
		this.unbindSizeSensor();
		this.chart.destroy();
		this.off();
		this.container.removeAttribute(SOURCE_ATTRIBUTE_NAME);
	};
	/**
	* 执行 adaptor 操作
	*/
	Plot$1.prototype.execAdaptor = function() {
		var adaptor$35 = this.getSchemaAdaptor();
		var _a$5 = this.options, padding$2 = _a$5.padding, appendPadding = _a$5.appendPadding;
		this.chart.padding = padding$2;
		this.chart.appendPadding = appendPadding;
		adaptor$35({
			chart: this.chart,
			options: this.options
		});
	};
	/**
	* 当图表容器大小变化的时候，执行的函数
	*/
	Plot$1.prototype.triggerResize = function() {
		this.chart.forceFit();
	};
	/**
	* 绑定 dom 容器大小变化的事件
	*/
	Plot$1.prototype.bindSizeSensor = function() {
		var _this = this;
		if (this.unbind) return;
		var _a$5 = this.options.autoFit;
		if (_a$5 === void 0 ? true : _a$5) this.unbind = (0, import_lib.bind)(this.container, function() {
			var _a$6 = getContainerSize(_this.container), width = _a$6.width, height = _a$6.height;
			if (width !== _this.chart.width || height !== _this.chart.height) _this.triggerResize();
		});
	};
	/**
	* 取消绑定
	*/
	Plot$1.prototype.unbindSizeSensor = function() {
		if (this.unbind) {
			this.unbind();
			this.unbind = void 0;
		}
	};
	return Plot$1;
}(esm_default$1);

//#endregion
//#region node_modules/@antv/g2plot/esm/utils/transform/percent.js
/**
* 对数据进行百分比化
* @param data
* @param measure
* @param groupField
* @param as
*/
function percent(data$2, measure, groupField, as) {
	var sumMap = reduce_default(data$2, function(map$3, datum) {
		var groupValue = datum[groupField];
		var sum = map$3.has(groupValue) ? map$3.get(groupValue) : 0;
		var v = datum[measure];
		sum = isRealNumber(v) ? sum + v : sum;
		map$3.set(groupValue, sum);
		return map$3;
	}, /* @__PURE__ */ new Map());
	return map_default(data$2, function(datum) {
		var _a$5;
		var v = datum[measure];
		var groupValue = datum[groupField];
		var percentage = isRealNumber(v) && sumMap.get(groupValue) !== 0 ? v / sumMap.get(groupValue) : 0;
		return __assign(__assign({}, datum), (_a$5 = {}, _a$5[as] = percentage, _a$5));
	});
}
/**
* 对数据进行深层百分比化
* @param data
* @param measure  // 数值
* @param fields // 需要分组的 field值
* @param as // 存储percent 百分比的值
*/
function getDeepPercent(data$2, measure, fields, percent$1) {
	var sumMap = reduce_default(data$2, function(map$3, datum) {
		var groupValue = reduce_default(fields, function(value$1, field$5) {
			return "".concat(value$1).concat(datum[field$5]);
		}, "");
		var sum = map$3.has(groupValue) ? map$3.get(groupValue) : 0;
		var v = datum[measure];
		sum = isRealNumber(v) ? sum + v : sum;
		map$3.set(groupValue, sum);
		return map$3;
	}, /* @__PURE__ */ new Map());
	return map_default(data$2, function(datum) {
		var _a$5;
		var v = datum[measure];
		var groupValue = reduce_default(fields, function(value$1, field$5) {
			return "".concat(value$1).concat(datum[field$5]);
		}, "");
		var percentage = isRealNumber(v) && sumMap.get(groupValue) !== 0 ? v / sumMap.get(groupValue) : 0;
		return __assign(__assign({}, datum), (_a$5 = {}, _a$5[percent$1] = percentage, _a$5));
	});
}
/**
* 获取数据，如果是百分比，进行数据转换 (适用于面积图、柱状图、条形图)
* @param isPercent 是否百分比
*/
function getDataWhetherPercentage(data$2, yField, groupField, asField, isPercent) {
	return !isPercent ? data$2 : percent(data$2, yField, groupField, asField);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/line/adaptor.js
/**
* geometry 配置处理
* @param params
*/
function geometry$33(params) {
	var chart = params.chart, options = params.options;
	var data$2 = options.data, color$2 = options.color, lineStyle = options.lineStyle, lineShape = options.lineShape, pointMapping = options.point, areaMapping = options.area, seriesField = options.seriesField;
	var pointState = pointMapping === null || pointMapping === void 0 ? void 0 : pointMapping.state;
	var areaState = areaMapping === null || areaMapping === void 0 ? void 0 : areaMapping.state;
	chart.data(data$2);
	var primary = deepAssign({}, params, { options: {
		shapeField: seriesField,
		line: {
			color: color$2,
			style: lineStyle,
			shape: lineShape
		},
		point: pointMapping && __assign({
			color: color$2,
			shape: "circle"
		}, pointMapping),
		area: areaMapping && __assign({ color: color$2 }, areaMapping),
		label: void 0
	} });
	var second = deepAssign({}, primary, { options: {
		tooltip: false,
		state: pointState
	} });
	var areaParams = deepAssign({}, primary, { options: {
		tooltip: false,
		state: areaState
	} });
	line(primary);
	point(second);
	area(areaParams);
	return params;
}
/**
* meta 配置
* @param params
*/
function meta$17(params) {
	var _a$5, _b;
	var options = params.options;
	var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField, data$2 = options.data;
	return flow(scale((_a$5 = {}, _a$5[xField] = xAxis, _a$5[yField] = yAxis, _a$5), (_b = {}, _b[xField] = { type: "cat" }, _b[yField] = adjustYMetaByZero(data$2, yField), _b)))(params);
}
/**
* 坐标系配置. 支持 reflect 镜像处理
* @param params
*/
function coordinate$9(params) {
	var chart = params.chart;
	var reflect = params.options.reflect;
	if (reflect) {
		var p = reflect;
		if (!is_array_default(p)) p = [p];
		var actions = p.map(function(d) {
			return ["reflect", d];
		});
		chart.coordinate({
			type: "rect",
			actions
		});
	}
	return params;
}
/**
* axis 配置
* @param params
*/
function axis$20(params) {
	var chart = params.chart, options = params.options;
	var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
	if (xAxis === false) chart.axis(xField, false);
	else chart.axis(xField, xAxis);
	if (yAxis === false) chart.axis(yField, false);
	else chart.axis(yField, yAxis);
	return params;
}
/**
* legend 配置
* @param params
*/
function legend$16(params) {
	var chart = params.chart, options = params.options;
	var legend$17 = options.legend, seriesField = options.seriesField;
	if (legend$17 && seriesField) chart.legend(seriesField, legend$17);
	else if (legend$17 === false) chart.legend(false);
	return params;
}
/**
* 数据标签
* @param params
*/
function label$15(params) {
	var chart = params.chart, options = params.options;
	var label$16 = options.label, yField = options.yField;
	var lineGeometry = findGeometry(chart, "line");
	if (!label$16) lineGeometry.label(false);
	else {
		var fields = label$16.fields, callback = label$16.callback, cfg = __rest(label$16, ["fields", "callback"]);
		lineGeometry.label({
			fields: fields || [yField],
			callback,
			cfg: __assign({ layout: [
				{ type: "limit-in-plot" },
				{ type: "path-adjust-position" },
				{ type: "point-adjust-position" },
				{
					type: "limit-in-plot",
					cfg: { action: "hide" }
				}
			] }, transformLabel(cfg))
		});
	}
	return params;
}
/**
* 统一处理 adjust
* @param params
*/
function adjust$1(params) {
	var chart = params.chart;
	if (params.options.isStack) each_default(chart.geometries, function(g) {
		g.adjust("stack");
	});
	return params;
}
/**
* 折线图适配器
* @param chart
* @param options
*/
function adaptor$26(params) {
	return flow(geometry$33, meta$17, adjust$1, theme, coordinate$9, axis$20, legend$16, tooltip, label$15, slider$2, scrollbar, interaction, animation, annotation(), limitInPlot)(params);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/area/adaptor.js
/**
* geometry 处理
* @param params
*/
function geometry$32(params) {
	var chart = params.chart, options = params.options;
	var data$2 = options.data, areaStyle = options.areaStyle, areaShape = options.areaShape, color$2 = options.color, pointMapping = options.point, lineMapping = options.line, isPercent = options.isPercent, xField = options.xField, yField = options.yField, tooltip$10 = options.tooltip, seriesField = options.seriesField, startOnZero = options.startOnZero;
	var pointState = pointMapping === null || pointMapping === void 0 ? void 0 : pointMapping.state;
	var chartData = getDataWhetherPercentage(data$2, yField, xField, yField, isPercent);
	chart.data(chartData);
	var tooltipOptions = isPercent ? __assign({ formatter: function(datum) {
		return {
			name: datum[seriesField] || datum[xField],
			value: (Number(datum[yField]) * 100).toFixed(2) + "%"
		};
	} }, tooltip$10) : tooltip$10;
	var primary = deepAssign({}, params, { options: {
		area: {
			color: color$2,
			style: areaStyle,
			shape: areaShape
		},
		point: pointMapping && __assign({ color: color$2 }, pointMapping),
		tooltip: tooltipOptions,
		label: void 0,
		args: { startOnZero }
	} });
	var lineParams = {
		chart,
		options: deepAssign({ line: { size: 2 } }, omit_default(options, ["state"]), {
			line: lineMapping && __assign({ color: color$2 }, lineMapping),
			sizeField: seriesField,
			state: lineMapping === null || lineMapping === void 0 ? void 0 : lineMapping.state,
			tooltip: false,
			label: void 0,
			args: { startOnZero }
		})
	};
	var pointParams = deepAssign({}, primary, { options: {
		tooltip: false,
		state: pointState
	} });
	area(primary);
	line(lineParams);
	point(pointParams);
	return params;
}
/**
* 数据标签
* @param params
*/
function label$14(params) {
	var chart = params.chart, options = params.options;
	var label$16 = options.label, yField = options.yField;
	var areaGeometry = findGeometry(chart, "area");
	if (!label$16) areaGeometry.label(false);
	else {
		var fields = label$16.fields, callback = label$16.callback, cfg = __rest(label$16, ["fields", "callback"]);
		areaGeometry.label({
			fields: fields || [yField],
			callback,
			cfg: __assign({ layout: [
				{ type: "limit-in-plot" },
				{ type: "path-adjust-position" },
				{ type: "point-adjust-position" },
				{
					type: "limit-in-plot",
					cfg: { action: "hide" }
				}
			] }, transformLabel(cfg))
		});
	}
	return params;
}
/**
* 处理 adjust
* @param params
*/
function adjust(params) {
	var chart = params.chart, options = params.options;
	var isStack = options.isStack, isPercent = options.isPercent, seriesField = options.seriesField;
	if ((isPercent || isStack) && seriesField) each_default(chart.geometries, function(g) {
		g.adjust("stack");
	});
	return params;
}
/**
* 折线图适配器
* @param chart
* @param options
*/
function adaptor$21(params) {
	return flow(theme, pattern("areaStyle"), transformations("rect"), geometry$32, meta$17, adjust, axis$20, legend$16, tooltip, label$14, slider$2, annotation(), interaction, animation, limitInPlot)(params);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/area/constants.js
/**
* 面积图默认配置项
*/
var DEFAULT_OPTIONS$35 = deepAssign({}, Plot.getDefaultOptions(), {
	tooltip: {
		shared: true,
		showMarkers: true,
		showCrosshairs: true,
		crosshairs: { type: "x" }
	},
	isStack: true,
	line: {},
	legend: {
		position: "top-left",
		radio: {}
	}
});

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/area/index.js
var Area = function(_super) {
	__extends(Area$2, _super);
	function Area$2() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		/** 图表类型 */
		_this.type = "area";
		return _this;
	}
	/**
	* 获取 面积图 默认配置项
	* 供外部使用
	*/
	Area$2.getDefaultOptions = function() {
		return DEFAULT_OPTIONS$35;
	};
	/**
	* 获取 面积图 默认配置
	*/
	Area$2.prototype.getDefaultOptions = function() {
		return Area$2.getDefaultOptions();
	};
	/**
	* @override
	* @param data
	*/
	Area$2.prototype.changeData = function(data$2) {
		this.updateOption({ data: data$2 });
		var _a$5 = this.options, isPercent = _a$5.isPercent, xField = _a$5.xField, yField = _a$5.yField;
		var _b = this, chart = _b.chart, options = _b.options;
		meta$17({
			chart,
			options
		});
		this.chart.changeData(getDataWhetherPercentage(data$2, yField, xField, yField, isPercent));
	};
	/**
	* 获取 面积图 的适配器
	*/
	Area$2.prototype.getSchemaAdaptor = function() {
		return adaptor$21;
	};
	return Area$2;
}(Plot);

//#endregion
//#region node_modules/@antv/g2plot/esm/interactions/actions/reset-button.js
var PADDING_RIGHT = 10;
var PADDING_TOP$1 = 5;
/**
* Action 中的 Button 按钮配置
*
* 可能的使用场景：brush filter
*/
var BUTTON_ACTION_CONFIG = {
	padding: [8, 10],
	text: "reset",
	textStyle: { default: {
		x: 0,
		y: 0,
		fontSize: 12,
		fill: "#333333",
		cursor: "pointer"
	} },
	buttonStyle: {
		default: {
			fill: "#f7f7f7",
			stroke: "#cccccc",
			cursor: "pointer"
		},
		active: { fill: "#e6e6e6" }
	}
};
/**
* @override 复写 G2 Button Action, 后续直接使用 GUI
*/
var ButtonAction = function(_super) {
	__extends(ButtonAction$2, _super);
	function ButtonAction$2() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.buttonGroup = null;
		_this.buttonCfg = __assign({ name: "button" }, BUTTON_ACTION_CONFIG);
		return _this;
	}
	/**
	* 获取 mix 默认的配置和用户配置
	*/
	ButtonAction$2.prototype.getButtonCfg = function() {
		var view = this.context.view;
		var buttonCfg = get_default(view, [
			"interactions",
			"filter-action",
			"cfg",
			"buttonConfig"
		]);
		return deepAssign(this.buttonCfg, buttonCfg, this.cfg);
	};
	/**
	* 绘制 Button 和 文本
	*/
	ButtonAction$2.prototype.drawButton = function() {
		var config = this.getButtonCfg();
		var group$1 = this.context.view.foregroundGroup.addGroup({ name: config.name });
		var textShape = this.drawText(group$1);
		this.drawBackground(group$1, textShape.getBBox());
		this.buttonGroup = group$1;
	};
	/**
	* 绘制文本
	*/
	ButtonAction$2.prototype.drawText = function(group$1) {
		var _a$5;
		var config = this.getButtonCfg();
		return group$1.addShape({
			type: "text",
			name: "button-text",
			attrs: __assign({ text: config.text }, (_a$5 = config.textStyle) === null || _a$5 === void 0 ? void 0 : _a$5.default)
		});
	};
	ButtonAction$2.prototype.drawBackground = function(group$1, bbox) {
		var _a$5;
		var config = this.getButtonCfg();
		var padding$2 = normalPadding(config.padding);
		var buttonShape = group$1.addShape({
			type: "rect",
			name: "button-rect",
			attrs: __assign({
				x: bbox.x - padding$2[3],
				y: bbox.y - padding$2[0],
				width: bbox.width + padding$2[1] + padding$2[3],
				height: bbox.height + padding$2[0] + padding$2[2]
			}, (_a$5 = config.buttonStyle) === null || _a$5 === void 0 ? void 0 : _a$5.default)
		});
		buttonShape.toBack();
		group$1.on("mouseenter", function() {
			var _a$6;
			buttonShape.attr((_a$6 = config.buttonStyle) === null || _a$6 === void 0 ? void 0 : _a$6.active);
		});
		group$1.on("mouseleave", function() {
			var _a$6;
			buttonShape.attr((_a$6 = config.buttonStyle) === null || _a$6 === void 0 ? void 0 : _a$6.default);
		});
		return buttonShape;
	};
	ButtonAction$2.prototype.resetPosition = function() {
		var point$1 = this.context.view.getCoordinate().convert({
			x: 1,
			y: 1
		});
		var buttonGroup = this.buttonGroup;
		var bbox = buttonGroup.getBBox();
		var matrix = Util.transform(null, [[
			"t",
			point$1.x - bbox.width - PADDING_RIGHT,
			point$1.y + bbox.height + PADDING_TOP$1
		]]);
		buttonGroup.setMatrix(matrix);
	};
	/**
	* 显示
	*/
	ButtonAction$2.prototype.show = function() {
		if (!this.buttonGroup) this.drawButton();
		this.resetPosition();
		this.buttonGroup.show();
	};
	/**
	* 隐藏
	*/
	ButtonAction$2.prototype.hide = function() {
		if (this.buttonGroup) this.buttonGroup.hide();
	};
	/**
	* 销毁
	*/
	ButtonAction$2.prototype.destroy = function() {
		var buttonGroup = this.buttonGroup;
		if (buttonGroup) buttonGroup.remove();
		_super.prototype.destroy.call(this);
	};
	return ButtonAction$2;
}(base_default$1);

//#endregion
//#region node_modules/@antv/g2plot/esm/interactions/brush.js
registerAction("brush-reset-button", ButtonAction, { name: "brush-reset-button" });
registerInteraction("filter-action", {});
/**
* G2 已经内置了 brush、brush-x、brush-y 等交互，其它：
*
* 1. element-range-highlight 是否可用重命名为 brush-highlight？(mask 可以移动)
* 2. brush-visible 与 brush 的区别是？
*/
function isPointInView(context) {
	return context.isInPlot();
}
/**
* 获取 交互 start 阶段的相关配置
*/
function getInteractionCfg(interactionType, brushType, options) {
	var _a$5 = options || {}, mask = _a$5.mask, isStartEnable = _a$5.isStartEnable;
	var maskType = brushType || "rect";
	switch (interactionType) {
		case "brush": return {
			showEnable: [{
				trigger: "plot:mouseenter",
				action: "cursor:crosshair",
				isEnable: isStartEnable || (function() {
					return true;
				})
			}, {
				trigger: "plot:mouseleave",
				action: "cursor:default"
			}],
			start: [{
				trigger: "mousedown",
				isEnable: isStartEnable || isPointInView,
				action: [
					"brush:start",
					"".concat(maskType, "-mask:start"),
					"".concat(maskType, "-mask:show")
				],
				arg: [null, { maskStyle: mask === null || mask === void 0 ? void 0 : mask.style }]
			}],
			processing: [{
				trigger: "mousemove",
				isEnable: isPointInView,
				action: ["".concat(maskType, "-mask:resize")]
			}],
			end: [{
				trigger: "mouseup",
				isEnable: isPointInView,
				action: [
					"brush:filter",
					"brush:end",
					"".concat(maskType, "-mask:end"),
					"".concat(maskType, "-mask:hide"),
					"brush-reset-button:show"
				]
			}],
			rollback: [{
				trigger: "brush-reset-button:click",
				action: [
					"brush:reset",
					"brush-reset-button:hide",
					"cursor:crosshair"
				]
			}]
		};
		case "brush-highlight": return {
			showEnable: [
				{
					trigger: "plot:mouseenter",
					action: "cursor:crosshair",
					isEnable: isStartEnable || (function() {
						return true;
					})
				},
				{
					trigger: "plot:mousemove",
					action: "cursor:crosshair",
					isEnable: isStartEnable || (function() {
						return true;
					})
				},
				{
					trigger: "plot:mousemove",
					action: "cursor:default",
					isEnable: function(context) {
						return isStartEnable ? !isStartEnable(context) : false;
					}
				},
				{
					trigger: "mask:mouseenter",
					action: "cursor:move",
					isEnable: isStartEnable || (function() {
						return true;
					})
				},
				{
					trigger: "plot:mouseleave",
					action: "cursor:default"
				},
				{
					trigger: "mask:mouseleave",
					action: "cursor:crosshair"
				}
			],
			start: [{
				trigger: "plot:mousedown",
				isEnable: isStartEnable || (function(context) {
					return !context.isInShape("mask");
				}),
				action: ["".concat(maskType, "-mask:start"), "".concat(maskType, "-mask:show")],
				arg: [{ maskStyle: mask === null || mask === void 0 ? void 0 : mask.style }]
			}, {
				trigger: "mask:dragstart",
				action: ["".concat(maskType, "-mask:moveStart")]
			}],
			processing: [
				{
					trigger: "plot:mousemove",
					action: ["".concat(maskType, "-mask:resize")]
				},
				{
					trigger: "mask:drag",
					action: ["".concat(maskType, "-mask:move")]
				},
				{
					trigger: "mask:change",
					action: ["element-range-highlight:highlight"]
				}
			],
			end: [
				{
					trigger: "plot:mouseup",
					action: ["".concat(maskType, "-mask:end")]
				},
				{
					trigger: "mask:dragend",
					action: ["".concat(maskType, "-mask:moveEnd")]
				},
				{
					trigger: "document:mouseup",
					isEnable: function(context) {
						return !context.isInPlot();
					},
					action: [
						"element-range-highlight:clear",
						"".concat(maskType, "-mask:end"),
						"".concat(maskType, "-mask:hide")
					]
				}
			],
			rollback: [{
				trigger: "dblclick",
				action: ["element-range-highlight:clear", "".concat(maskType, "-mask:hide")]
			}]
		};
		case "brush-x": return {
			showEnable: [{
				trigger: "plot:mouseenter",
				action: "cursor:crosshair",
				isEnable: isStartEnable || (function() {
					return true;
				})
			}, {
				trigger: "plot:mouseleave",
				action: "cursor:default"
			}],
			start: [{
				trigger: "mousedown",
				isEnable: isStartEnable || isPointInView,
				action: [
					"brush-x:start",
					"".concat(maskType, "-mask:start"),
					"".concat(maskType, "-mask:show")
				],
				arg: [null, { maskStyle: mask === null || mask === void 0 ? void 0 : mask.style }]
			}],
			processing: [{
				trigger: "mousemove",
				isEnable: isPointInView,
				action: ["".concat(maskType, "-mask:resize")]
			}],
			end: [{
				trigger: "mouseup",
				isEnable: isPointInView,
				action: [
					"brush-x:filter",
					"brush-x:end",
					"".concat(maskType, "-mask:end"),
					"".concat(maskType, "-mask:hide")
				]
			}],
			rollback: [{
				trigger: "dblclick",
				action: ["brush-x:reset"]
			}]
		};
		case "brush-x-highlight": return {
			showEnable: [
				{
					trigger: "plot:mouseenter",
					action: "cursor:crosshair",
					isEnable: isStartEnable || (function() {
						return true;
					})
				},
				{
					trigger: "mask:mouseenter",
					action: "cursor:move",
					isEnable: isStartEnable || (function() {
						return true;
					})
				},
				{
					trigger: "plot:mouseleave",
					action: "cursor:default"
				},
				{
					trigger: "mask:mouseleave",
					action: "cursor:crosshair"
				}
			],
			start: [{
				trigger: "plot:mousedown",
				isEnable: isStartEnable || (function(context) {
					return !context.isInShape("mask");
				}),
				action: ["".concat(maskType, "-mask:start"), "".concat(maskType, "-mask:show")],
				arg: [{ maskStyle: mask === null || mask === void 0 ? void 0 : mask.style }]
			}, {
				trigger: "mask:dragstart",
				action: ["".concat(maskType, "-mask:moveStart")]
			}],
			processing: [
				{
					trigger: "plot:mousemove",
					action: ["".concat(maskType, "-mask:resize")]
				},
				{
					trigger: "mask:drag",
					action: ["".concat(maskType, "-mask:move")]
				},
				{
					trigger: "mask:change",
					action: ["element-range-highlight:highlight"]
				}
			],
			end: [
				{
					trigger: "plot:mouseup",
					action: ["".concat(maskType, "-mask:end")]
				},
				{
					trigger: "mask:dragend",
					action: ["".concat(maskType, "-mask:moveEnd")]
				},
				{
					trigger: "document:mouseup",
					isEnable: function(context) {
						return !context.isInPlot();
					},
					action: [
						"element-range-highlight:clear",
						"".concat(maskType, "-mask:end"),
						"".concat(maskType, "-mask:hide")
					]
				}
			],
			rollback: [{
				trigger: "dblclick",
				action: ["element-range-highlight:clear", "".concat(maskType, "-mask:hide")]
			}]
		};
		case "brush-y": return {
			showEnable: [{
				trigger: "plot:mouseenter",
				action: "cursor:crosshair",
				isEnable: isStartEnable || (function() {
					return true;
				})
			}, {
				trigger: "plot:mouseleave",
				action: "cursor:default"
			}],
			start: [{
				trigger: "mousedown",
				isEnable: isStartEnable || isPointInView,
				action: [
					"brush-y:start",
					"".concat(maskType, "-mask:start"),
					"".concat(maskType, "-mask:show")
				],
				arg: [null, { maskStyle: mask === null || mask === void 0 ? void 0 : mask.style }]
			}],
			processing: [{
				trigger: "mousemove",
				isEnable: isPointInView,
				action: ["".concat(maskType, "-mask:resize")]
			}],
			end: [{
				trigger: "mouseup",
				isEnable: isPointInView,
				action: [
					"brush-y:filter",
					"brush-y:end",
					"".concat(maskType, "-mask:end"),
					"".concat(maskType, "-mask:hide")
				]
			}],
			rollback: [{
				trigger: "dblclick",
				action: ["brush-y:reset"]
			}]
		};
		case "brush-y-highlight": return {
			showEnable: [
				{
					trigger: "plot:mouseenter",
					action: "cursor:crosshair",
					isEnable: isStartEnable || (function() {
						return true;
					})
				},
				{
					trigger: "mask:mouseenter",
					action: "cursor:move",
					isEnable: isStartEnable || (function() {
						return true;
					})
				},
				{
					trigger: "plot:mouseleave",
					action: "cursor:default"
				},
				{
					trigger: "mask:mouseleave",
					action: "cursor:crosshair"
				}
			],
			start: [{
				trigger: "plot:mousedown",
				isEnable: isStartEnable || (function(context) {
					return !context.isInShape("mask");
				}),
				action: ["".concat(maskType, "-mask:start"), "".concat(maskType, "-mask:show")],
				arg: [{ maskStyle: mask === null || mask === void 0 ? void 0 : mask.style }]
			}, {
				trigger: "mask:dragstart",
				action: ["".concat(maskType, "-mask:moveStart")]
			}],
			processing: [
				{
					trigger: "plot:mousemove",
					action: ["".concat(maskType, "-mask:resize")]
				},
				{
					trigger: "mask:drag",
					action: ["".concat(maskType, "-mask:move")]
				},
				{
					trigger: "mask:change",
					action: ["element-range-highlight:highlight"]
				}
			],
			end: [
				{
					trigger: "plot:mouseup",
					action: ["".concat(maskType, "-mask:end")]
				},
				{
					trigger: "mask:dragend",
					action: ["".concat(maskType, "-mask:moveEnd")]
				},
				{
					trigger: "document:mouseup",
					isEnable: function(context) {
						return !context.isInPlot();
					},
					action: [
						"element-range-highlight:clear",
						"".concat(maskType, "-mask:end"),
						"".concat(maskType, "-mask:hide")
					]
				}
			],
			rollback: [{
				trigger: "dblclick",
				action: ["element-range-highlight:clear", "".concat(maskType, "-mask:hide")]
			}]
		};
		default: return {};
	}
}
registerInteraction("brush", getInteractionCfg("brush"));
registerInteraction("brush-highlight", getInteractionCfg("brush-highlight"));
registerInteraction("brush-x", getInteractionCfg("brush-x", "x-rect"));
registerInteraction("brush-y", getInteractionCfg("brush-y", "y-rect"));
registerInteraction("brush-x-highlight", getInteractionCfg("brush-x-highlight", "x-rect"));
registerInteraction("brush-y-highlight", getInteractionCfg("brush-y-highlight", "y-rect"));

//#endregion
//#region node_modules/@antv/g2plot/esm/adaptor/brush.js
var BRUSH_TYPES = [
	"brush",
	"brush-x",
	"brush-y",
	"brush-highlight",
	"brush-x-highlight",
	"brush-y-highlight"
];
/**
* brush 交互
*/
function brushInteraction(params) {
	var options = params.options;
	var brush = options.brush;
	var interactions = filter_default(options.interactions || [], function(i) {
		return BRUSH_TYPES.indexOf(i.type) === -1;
	});
	if (brush === null || brush === void 0 ? void 0 : brush.enabled) {
		BRUSH_TYPES.forEach(function(type) {
			var enable = false;
			switch (brush.type) {
				case "x-rect":
					enable = type === (brush.action === "highlight" ? "brush-x-highlight" : "brush-x");
					break;
				case "y-rect":
					enable = type === (brush.action === "highlight" ? "brush-y-highlight" : "brush-y");
					break;
				default:
					enable = type === (brush.action === "highlight" ? "brush-highlight" : "brush");
					break;
			}
			var obj = {
				type,
				enable
			};
			if (brush) obj.cfg = getInteractionCfg(type, brush.type, brush);
			interactions.push(obj);
		});
		if ((brush === null || brush === void 0 ? void 0 : brush.action) !== "highlight") interactions.push({
			type: "filter-action",
			cfg: { buttonConfig: brush.button }
		});
	}
	return deepAssign({}, params, { options: { interactions } });
}

//#endregion
//#region node_modules/@antv/g2plot/esm/adaptor/connected-area.js
var INTERACTION_MAP = {
	hover: "__interval-connected-area-hover__",
	click: "__interval-connected-area-click__"
};
var getStartStages = function(trigger, style) {
	if (trigger === "hover") return [{
		trigger: "interval:mouseenter",
		action: ["element-highlight-by-color:highlight", "element-link-by-color:link"],
		arg: [null, { style }]
	}];
	return [{
		trigger: "interval:click",
		action: [
			"element-highlight-by-color:clear",
			"element-highlight-by-color:highlight",
			"element-link-by-color:clear",
			"element-link-by-color:unlink",
			"element-link-by-color:link"
		],
		arg: [
			null,
			null,
			null,
			null,
			{ style }
		]
	}];
};
/** hover 触发的连通区域交互 */
registerInteraction(INTERACTION_MAP.hover, {
	start: getStartStages(INTERACTION_MAP.hover),
	end: [{
		trigger: "interval:mouseleave",
		action: ["element-highlight-by-color:reset", "element-link-by-color:unlink"]
	}]
});
/** click 触发的联通区域交互 */
registerInteraction(INTERACTION_MAP.click, {
	start: getStartStages(INTERACTION_MAP.click),
	end: [{
		trigger: "document:mousedown",
		action: ["element-highlight-by-color:clear", "element-link-by-color:clear"]
	}]
});
/**
* 返回支持联通区域组件交互的 adaptor，适用于堆叠柱形图/堆叠条形图
* @param disable
*/
function connectedArea(disable) {
	if (disable === void 0) disable = false;
	return function(params) {
		var chart = params.chart;
		var connectedArea$1 = params.options.connectedArea;
		var clear = function() {
			chart.removeInteraction(INTERACTION_MAP.hover);
			chart.removeInteraction(INTERACTION_MAP.click);
		};
		if (!disable && connectedArea$1) {
			var trigger = connectedArea$1.trigger || "hover";
			clear();
			chart.interaction(INTERACTION_MAP[trigger], { start: getStartStages(trigger, connectedArea$1.style) });
		} else clear();
		return params;
	};
}

//#endregion
//#region node_modules/@antv/g2plot/esm/utils/conversion.js
/**
* 转化率的计算方式
* @param prev
* @param next
*/
function conversionTagFormatter(prev, next) {
	if (!is_number_default(prev) || !is_number_default(next)) return "-";
	if (prev === 0 && next === 0) return "-";
	if (prev === next) return "100%";
	if (prev === 0) return "∞";
	return "".concat((100 * next / prev).toFixed(2), "%");
}

//#endregion
//#region node_modules/@antv/g2plot/esm/adaptor/conversion-tag.js
function getConversionTagOptionsWithDefaults(options, horizontal) {
	return deepAssign({
		size: horizontal ? 32 : 80,
		spacing: horizontal ? 8 : 12,
		offset: horizontal ? 32 : 0,
		arrow: options.arrow !== false && {
			headSize: 12,
			style: { fill: "rgba(0, 0, 0, 0.05)" }
		},
		text: options.text !== false && {
			style: {
				fontSize: 12,
				fill: "rgba(0, 0, 0, 0.85)",
				textAlign: "center",
				textBaseline: "middle"
			},
			formatter: conversionTagFormatter
		}
	}, options);
}
function parsePoints(coordinate$10, element) {
	return map_default(element.getModel().points, function(point$1) {
		return coordinate$10.convertPoint(point$1);
	});
}
function renderArrowTag(config, elemPrev, elemNext) {
	var view = config.view, geometry$34 = config.geometry, group$1 = config.group, options = config.options, horizontal = config.horizontal;
	var offset = options.offset, size$1 = options.size, arrow = options.arrow;
	var coordinate$10 = view.getCoordinate();
	var pointPrev = parsePoints(coordinate$10, elemPrev)[3];
	var pointNext = parsePoints(coordinate$10, elemNext)[0];
	var totalHeight = pointNext.y - pointPrev.y;
	var totalWidth = pointNext.x - pointPrev.x;
	if (typeof arrow === "boolean") return;
	var headSize = arrow.headSize;
	var spacing = options.spacing;
	var points;
	if (horizontal) if ((totalWidth - headSize) / 2 < spacing) {
		spacing = Math.max(1, (totalWidth - headSize) / 2);
		points = [
			[pointPrev.x + spacing, pointPrev.y - offset],
			[pointPrev.x + spacing, pointPrev.y - offset - size$1],
			[pointNext.x - spacing, pointNext.y - offset - size$1 / 2]
		];
	} else points = [
		[pointPrev.x + spacing, pointPrev.y - offset],
		[pointPrev.x + spacing, pointPrev.y - offset - size$1],
		[pointNext.x - spacing - headSize, pointNext.y - offset - size$1],
		[pointNext.x - spacing, pointNext.y - offset - size$1 / 2],
		[pointNext.x - spacing - headSize, pointNext.y - offset]
	];
	else if ((totalHeight - headSize) / 2 < spacing) {
		spacing = Math.max(1, (totalHeight - headSize) / 2);
		points = [
			[pointPrev.x + offset, pointPrev.y + spacing],
			[pointPrev.x + offset + size$1, pointPrev.y + spacing],
			[pointNext.x + offset + size$1 / 2, pointNext.y - spacing]
		];
	} else points = [
		[pointPrev.x + offset, pointPrev.y + spacing],
		[pointPrev.x + offset + size$1, pointPrev.y + spacing],
		[pointNext.x + offset + size$1, pointNext.y - spacing - headSize],
		[pointNext.x + offset + size$1 / 2, pointNext.y - spacing],
		[pointNext.x + offset, pointNext.y - spacing - headSize]
	];
	group$1.addShape("polygon", {
		id: "".concat(view.id, "-conversion-tag-arrow-").concat(geometry$34.getElementId(elemPrev.getModel().mappingData)),
		name: "conversion-tag-arrow",
		origin: {
			element: elemPrev,
			nextElement: elemNext
		},
		attrs: __assign(__assign({}, arrow.style || {}), { points })
	});
}
function renderTextTag(config, elemPrev, elemNext) {
	var _a$5, _b, _c;
	var view = config.view, geometry$34 = config.geometry, group$1 = config.group, options = config.options, field$5 = config.field, horizontal = config.horizontal;
	var offset = options.offset, size$1 = options.size;
	if (typeof options.text === "boolean") return;
	var coordinate$10 = view.getCoordinate();
	var text = ((_a$5 = options.text) === null || _a$5 === void 0 ? void 0 : _a$5.formatter) && ((_b = options.text) === null || _b === void 0 ? void 0 : _b.formatter(elemPrev.getData()[field$5], elemNext.getData()[field$5]));
	var pointPrev = parsePoints(coordinate$10, elemPrev)[horizontal ? 3 : 0];
	var pointNext = parsePoints(coordinate$10, elemNext)[horizontal ? 0 : 3];
	var textShape = group$1.addShape("text", {
		id: "".concat(view.id, "-conversion-tag-text-").concat(geometry$34.getElementId(elemPrev.getModel().mappingData)),
		name: "conversion-tag-text",
		origin: {
			element: elemPrev,
			nextElement: elemNext
		},
		attrs: __assign(__assign({}, ((_c = options.text) === null || _c === void 0 ? void 0 : _c.style) || {}), {
			text,
			x: horizontal ? (pointPrev.x + pointNext.x) / 2 : pointPrev.x + offset + size$1 / 2,
			y: horizontal ? pointPrev.y - offset - size$1 / 2 : (pointPrev.y + pointNext.y) / 2
		})
	});
	if (horizontal) {
		var totalWidth = pointNext.x - pointPrev.x;
		var textWidth = textShape.getBBox().width;
		if (textWidth > totalWidth) {
			var cWidth = textWidth / text.length;
			var cEnd = Math.max(1, Math.ceil(totalWidth / cWidth) - 1);
			var textAdjusted = "".concat(text.slice(0, cEnd), "...");
			textShape.attr("text", textAdjusted);
		}
	}
}
function renderTag(options, elemPrev, elemNext) {
	renderArrowTag(options, elemPrev, elemNext);
	renderTextTag(options, elemPrev, elemNext);
}
/**
* 返回支持转化率组件的 adaptor，适用于柱形图/条形图
* @param field 用户转化率计算的字段
* @param horizontal 是否水平方向的转化率
* @param disabled 是否禁用
*/
function conversionTag$3(field$5, horizontal, disabled) {
	if (horizontal === void 0) horizontal = true;
	if (disabled === void 0) disabled = false;
	return function(params) {
		var options = params.options, chart = params.chart;
		var conversionTag$4 = options.conversionTag, theme$3 = options.theme;
		if (conversionTag$4 && !disabled) {
			chart.theme(deepAssign({}, is_object_default(theme$3) ? theme$3 : getTheme(theme$3), { columnWidthRatio: 1 / 3 }));
			chart.annotation().shape({ render: function(container, view) {
				var group$1 = container.addGroup({
					id: "".concat(chart.id, "-conversion-tag-group"),
					name: "conversion-tag-group"
				});
				var interval$2 = find_default(chart.geometries, function(geom) {
					return geom.type === "interval";
				});
				var config = {
					view,
					geometry: interval$2,
					group: group$1,
					field: field$5,
					horizontal,
					options: getConversionTagOptionsWithDefaults(conversionTag$4, horizontal)
				};
				var elements = interval$2.elements;
				each_default(elements, function(elem, idx) {
					if (idx > 0) renderTag(config, elements[idx - 1], elem);
				});
			} });
		}
		return params;
	};
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/column/adaptor.js
/**
* defaultOptions
* @param params
*/
function defaultOptions$6(params) {
	var options = params.options;
	var legend$17 = options.legend;
	var seriesField = options.seriesField, isStack = options.isStack;
	if (seriesField) {
		if (legend$17 !== false) legend$17 = __assign({ position: isStack ? "right-top" : "top-left" }, legend$17);
	} else legend$17 = false;
	params.options.legend = legend$17;
	return params;
}
/**
* 字段
* @param params
*/
function geometry$31(params) {
	var chart = params.chart, options = params.options;
	var data$2 = options.data, columnStyle = options.columnStyle, color$2 = options.color, columnWidthRatio = options.columnWidthRatio, isPercent = options.isPercent, isGroup = options.isGroup, isStack = options.isStack, xField = options.xField, yField = options.yField, seriesField = options.seriesField, groupField = options.groupField, tooltip$10 = options.tooltip, shape = options.shape;
	var percentData = isPercent && isGroup && isStack ? getDeepPercent(data$2, yField, [xField, groupField], yField) : getDataWhetherPercentage(data$2, yField, xField, yField, isPercent);
	var chartData = [];
	if (isStack && seriesField && !isGroup) percentData.forEach(function(item) {
		var stackedItem = chartData.find(function(v) {
			return v[xField] === item[xField] && v[seriesField] === item[seriesField];
		});
		if (stackedItem) stackedItem[yField] += item[yField] || 0;
		else chartData.push(__assign({}, item));
	});
	else chartData = percentData;
	chart.data(chartData);
	var tooltipOptions = isPercent ? __assign({ formatter: function(datum) {
		var _a$5;
		return {
			name: isGroup && isStack ? "".concat(datum[seriesField], " - ").concat(datum[groupField]) : (_a$5 = datum[seriesField]) !== null && _a$5 !== void 0 ? _a$5 : datum[xField],
			value: (Number(datum[yField]) * 100).toFixed(2) + "%"
		};
	} }, tooltip$10) : tooltip$10;
	var p = deepAssign({}, params, { options: {
		data: chartData,
		widthRatio: columnWidthRatio,
		tooltip: tooltipOptions,
		interval: {
			shape,
			style: columnStyle,
			color: color$2
		}
	} });
	interval(p);
	return p;
}
/**
* meta 配置
* @param params
*/
function meta$21(params) {
	var _a$5, _b;
	var options = params.options;
	var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField, data$2 = options.data;
	var percentYMeta = options.isPercent ? {
		max: 1,
		min: 0,
		minLimit: 0,
		maxLimit: 1
	} : {};
	return flow(scale((_a$5 = {}, _a$5[xField] = xAxis, _a$5[yField] = yAxis, _a$5), (_b = {}, _b[xField] = { type: "cat" }, _b[yField] = __assign(__assign({}, adjustYMetaByZero(data$2, yField)), percentYMeta), _b)))(params);
}
/**
* axis 配置
* @param params
*/
function axis$19(params) {
	var chart = params.chart, options = params.options;
	var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
	if (xAxis === false) chart.axis(xField, false);
	else chart.axis(xField, xAxis);
	if (yAxis === false) chart.axis(yField, false);
	else chart.axis(yField, yAxis);
	return params;
}
/**
* legend 配置
* @param params
*/
function legend$15(params) {
	var chart = params.chart, options = params.options;
	var legend$17 = options.legend, seriesField = options.seriesField;
	if (legend$17 && seriesField) chart.legend(seriesField, legend$17);
	else if (legend$17 === false) chart.legend(false);
	return params;
}
/**
* 数据标签
* @param params
*/
function label$13(params) {
	var chart = params.chart, options = params.options;
	var label$16 = options.label, yField = options.yField, isRange = options.isRange;
	var geometry$34 = findGeometry(chart, "interval");
	if (!label$16) geometry$34.label(false);
	else {
		var callback = label$16.callback, cfg = __rest(label$16, ["callback"]);
		geometry$34.label({
			fields: [yField],
			callback,
			cfg: __assign({ layout: (cfg === null || cfg === void 0 ? void 0 : cfg.position) ? void 0 : [
				{ type: "interval-adjust-position" },
				{ type: "interval-hide-overlap" },
				{ type: "adjust-color" },
				{
					type: "limit-in-plot",
					cfg: { action: "hide" }
				}
			] }, transformLabel(isRange ? __assign({ content: function(item) {
				var _a$5;
				return (_a$5 = item[yField]) === null || _a$5 === void 0 ? void 0 : _a$5.join("-");
			} }, cfg) : cfg))
		});
	}
	return params;
}
/**
* 柱形图 tooltip 配置 (对堆叠、分组做特殊处理)
* @param params
*/
function columnTooltip(params) {
	var chart = params.chart, options = params.options;
	var tooltip$10 = options.tooltip, isGroup = options.isGroup, isStack = options.isStack, groupField = options.groupField, data$2 = options.data, xField = options.xField, yField = options.yField, seriesField = options.seriesField;
	if (tooltip$10 === false) chart.tooltip(false);
	else {
		var tooltipOptions = tooltip$10;
		if (isGroup && isStack) {
			var customItems_1 = tooltipOptions.customItems;
			var tooltipFormatter_1 = (tooltipOptions === null || tooltipOptions === void 0 ? void 0 : tooltipOptions.formatter) || (function(datum) {
				return {
					name: "".concat(datum[seriesField], " - ").concat(datum[groupField]),
					value: datum[yField]
				};
			});
			tooltipOptions = __assign(__assign({}, tooltipOptions), { customItems: function(originalItems) {
				var items = [];
				each_default(originalItems, function(item) {
					filter_default(data$2, function(d) {
						return is_match_default(d, pick(item.data, [xField, seriesField]));
					}).forEach(function(datum) {
						items.push(__assign(__assign(__assign({}, item), {
							value: datum[yField],
							data: datum,
							mappingData: { _origin: datum }
						}), tooltipFormatter_1(datum)));
					});
				});
				return customItems_1 ? customItems_1(items) : items;
			} });
		}
		chart.tooltip(tooltipOptions);
	}
	return params;
}
/**
* 柱形图适配器
* @param params
*/
function adaptor$14(params, isBar) {
	if (isBar === void 0) isBar = false;
	var options = params.options;
	var seriesField = options.seriesField;
	return flow(defaultOptions$6, theme, pattern("columnStyle"), state, transformations("rect"), geometry$31, meta$21, axis$19, legend$15, columnTooltip, slider$2, scrollbar, label$13, brushInteraction, interaction, animation, annotation(), conversionTag$3(options.yField, !isBar, !!seriesField), connectedArea(!options.isStack), limitInPlot)(params);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/bar/adaptor.js
/**
* 处理默认配置项
* 1. switch xField、 yField
* 2. switch xAxis、 yAxis and adjust axis.position configuration
*/
function defaultOptions$5(params) {
	var options = params.options;
	var xField = options.xField, yField = options.yField, xAxis = options.xAxis, yAxis = options.yAxis;
	var position = {
		left: "bottom",
		right: "top",
		top: "left",
		bottom: "right"
	};
	var verticalAxis = yAxis !== false ? __assign({ position: position[(yAxis === null || yAxis === void 0 ? void 0 : yAxis.position) || "left"] }, yAxis) : false;
	var horizontalAxis = xAxis !== false ? __assign({ position: position[(xAxis === null || xAxis === void 0 ? void 0 : xAxis.position) || "bottom"] }, xAxis) : false;
	return __assign(__assign({}, params), { options: __assign(__assign({}, options), {
		xField: yField,
		yField: xField,
		xAxis: verticalAxis,
		yAxis: horizontalAxis
	}) });
}
/**
* label 适配器
* @param params
*/
function label$12(params) {
	var label$16 = params.options.label;
	if (label$16 && !label$16.position) {
		label$16.position = "left";
		if (!label$16.layout) label$16.layout = [
			{ type: "interval-adjust-position" },
			{ type: "interval-hide-overlap" },
			{ type: "adjust-color" },
			{
				type: "limit-in-plot",
				cfg: { action: "hide" }
			}
		];
	}
	return deepAssign({}, params, { options: { label: label$16 } });
}
/**
* legend 适配器
* @param params
*/
function legend$14(params) {
	var options = params.options;
	var seriesField = options.seriesField, isStack = options.isStack;
	var legend$17 = options.legend;
	if (seriesField) {
		if (legend$17 !== false) legend$17 = __assign({ position: isStack ? "top-left" : "right-top" }, legend$17 || {});
	} else legend$17 = false;
	return deepAssign({}, params, { options: { legend: legend$17 } });
}
/**
* coordinate 适配器
* @param params
*/
function coordinate$8(params) {
	var options = params.options;
	var coordinateOptions = [{ type: "transpose" }, { type: "reflectY" }].concat(options.coordinate || []);
	return deepAssign({}, params, { options: { coordinate: coordinateOptions } });
}
/**
* 柱形图适配器
* @param params
*/
function geometry$30(params) {
	var chart = params.chart, options = params.options;
	var barStyle = options.barStyle, barWidthRatio = options.barWidthRatio, minBarWidth = options.minBarWidth, maxBarWidth = options.maxBarWidth, barBackground = options.barBackground;
	return adaptor$14({
		chart,
		options: __assign(__assign({}, options), {
			columnStyle: barStyle,
			columnWidthRatio: barWidthRatio,
			minColumnWidth: minBarWidth,
			maxColumnWidth: maxBarWidth,
			columnBackground: barBackground
		})
	}, true);
}
/**
* @param chart
* @param options
*/
function adaptor$22(params) {
	return flow(defaultOptions$5, label$12, legend$14, tooltip, coordinate$8, geometry$30)(params);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/bar/constants.js
/**
* 条形图默认配置项
*/
var DEFAULT_OPTIONS$34 = deepAssign({}, Plot.getDefaultOptions(), {
	barWidthRatio: .6,
	marginRatio: 1 / 32,
	tooltip: {
		shared: true,
		showMarkers: false,
		offset: 20
	},
	legend: { radio: {} },
	interactions: [{ type: "active-region" }]
});

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/bar/index.js
/**
* 条形图
*/
var Bar = function(_super) {
	__extends(Bar$1, _super);
	function Bar$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		/** 图表类型 */
		_this.type = "bar";
		return _this;
	}
	/**
	* 获取 条形图 默认配置项
	* 供外部使用
	*/
	Bar$1.getDefaultOptions = function() {
		return DEFAULT_OPTIONS$34;
	};
	/**
	* @override
	*/
	Bar$1.prototype.changeData = function(data$2) {
		var _a$5, _b;
		this.updateOption({ data: data$2 });
		var _c = this, chart = _c.chart, options = _c.options;
		var isPercent = options.isPercent;
		var xField = options.xField, yField = options.yField, xAxis = options.xAxis, yAxis = options.yAxis;
		_a$5 = [yField, xField], xField = _a$5[0], yField = _a$5[1];
		_b = [yAxis, xAxis], xAxis = _b[0], yAxis = _b[1];
		var switchedFieldOptions = __assign(__assign({}, options), {
			xField,
			yField,
			yAxis,
			xAxis
		});
		meta$21({
			chart,
			options: switchedFieldOptions
		});
		chart.changeData(getDataWhetherPercentage(data$2, xField, yField, xField, isPercent));
	};
	/**
	* 获取 条形图 默认配置
	*/
	Bar$1.prototype.getDefaultOptions = function() {
		return Bar$1.getDefaultOptions();
	};
	/**
	* 获取 条形图 的适配器
	*/
	Bar$1.prototype.getSchemaAdaptor = function() {
		return adaptor$22;
	};
	return Bar$1;
}(Plot);

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/column/constants.js
/**
* 柱形图默认配置项
*/
var DEFAULT_OPTIONS$33 = deepAssign({}, Plot.getDefaultOptions(), {
	columnWidthRatio: .6,
	marginRatio: 1 / 32,
	tooltip: {
		shared: true,
		showMarkers: false,
		offset: 20
	},
	legend: { radio: {} },
	interactions: [{ type: "active-region" }]
});

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/column/index.js
/**
* 柱形图
*/
var Column = function(_super) {
	__extends(Column$1, _super);
	function Column$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		/** 图表类型 */
		_this.type = "column";
		return _this;
	}
	/**
	* 获取 柱形图 默认配置项
	* 供外部使用
	*/
	Column$1.getDefaultOptions = function() {
		return DEFAULT_OPTIONS$33;
	};
	/**
	* @override
	*/
	Column$1.prototype.changeData = function(data$2) {
		this.updateOption({ data: data$2 });
		var _a$5 = this.options, yField = _a$5.yField, xField = _a$5.xField, isPercent = _a$5.isPercent;
		var _b = this, chart = _b.chart, options = _b.options;
		meta$21({
			chart,
			options
		});
		this.chart.changeData(getDataWhetherPercentage(data$2, yField, xField, yField, isPercent));
	};
	/**
	* 获取 柱形图 默认配置
	*/
	Column$1.prototype.getDefaultOptions = function() {
		return Column$1.getDefaultOptions();
	};
	/**
	* 获取 柱形图 的适配器
	*/
	Column$1.prototype.getSchemaAdaptor = function() {
		return adaptor$14;
	};
	return Column$1;
}(Plot);

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/funnel/constant.js
var _a$2;
var FUNNEL_PERCENT = "$$percentage$$";
var FUNNEL_MAPPING_VALUE = "$$mappingValue$$";
var FUNNEL_CONVERSATION = "$$conversion$$";
var FUNNEL_TOTAL_PERCENT = "$$totalPercentage$$";
var PLOYGON_X = "$$x$$";
var PLOYGON_Y = "$$y$$";
/**
* 漏斗图 默认配置项
*/
var DEFAULT_OPTIONS$32 = {
	appendPadding: [0, 80],
	minSize: 0,
	maxSize: 1,
	meta: (_a$2 = {}, _a$2[FUNNEL_MAPPING_VALUE] = {
		min: 0,
		max: 1,
		nice: false
	}, _a$2),
	label: { style: {
		fill: "#fff",
		fontSize: 12
	} },
	tooltip: {
		showTitle: false,
		showMarkers: false,
		shared: false
	},
	conversionTag: {
		offsetX: 10,
		offsetY: 0,
		style: {
			fontSize: 12,
			fill: "rgba(0,0,0,0.45)"
		}
	}
};

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/funnel/geometries/common.js
var CONVERSION_TAG_NAME = "CONVERSION_TAG_NAME";
/**
* 漏斗图 transform
* @param geometry
*/
function transformData$8(data$2, originData, options) {
	var formatData = [];
	var yField = options.yField, maxSize = options.maxSize, minSize = options.minSize;
	var maxYFieldValue = get_default(max_by_default(originData, yField), [yField]);
	var max$2 = is_number_default(maxSize) ? maxSize : 1;
	var min$2 = is_number_default(minSize) ? minSize : 0;
	formatData = map_default(data$2, function(row, index) {
		var percent$1 = (row[yField] || 0) / maxYFieldValue;
		row[FUNNEL_PERCENT] = percent$1;
		row[FUNNEL_MAPPING_VALUE] = (max$2 - min$2) * percent$1 + min$2;
		row[FUNNEL_CONVERSATION] = [get_default(data$2, [index - 1, yField]), row[yField]];
		return row;
	});
	return formatData;
}
/**
* 漏斗图通用转化率组件
* @param getLineCoordinate 用于获取特定的 line 的位置及配置
*/
function conversionTagComponent(getLineCoordinate) {
	return function(params) {
		var chart = params.chart, options = params.options;
		var conversionTag$4 = options.conversionTag;
		var data$2 = options.filteredData || chart.getOptions().data;
		if (conversionTag$4) {
			var formatter_1 = conversionTag$4.formatter;
			data$2.forEach(function(obj, index) {
				if (index <= 0 || Number.isNaN(obj[FUNNEL_MAPPING_VALUE])) return;
				var lineOption = getLineCoordinate(obj, index, data$2, {
					top: true,
					name: CONVERSION_TAG_NAME,
					text: {
						content: is_function_default(formatter_1) ? formatter_1(obj, data$2) : formatter_1,
						offsetX: conversionTag$4.offsetX,
						offsetY: conversionTag$4.offsetY,
						position: "end",
						autoRotate: false,
						style: __assign({
							textAlign: "start",
							textBaseline: "middle"
						}, conversionTag$4.style)
					}
				});
				chart.annotation().line(lineOption);
			});
		}
		return params;
	};
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/funnel/geometries/basic.js
/**
* 处理字段数据
* @param params
*/
function field$4(params) {
	var chart = params.chart, options = params.options;
	var _a$5 = options.data, data$2 = _a$5 === void 0 ? [] : _a$5, yField = options.yField, maxSize = options.maxSize, minSize = options.minSize;
	var formatData = transformData$8(data$2, data$2, {
		yField,
		maxSize,
		minSize
	});
	chart.data(formatData);
	return params;
}
/**
* geometry处理
* @param params
*/
function geometry$29(params) {
	var chart = params.chart, options = params.options;
	var xField = options.xField, yField = options.yField, color$2 = options.color, tooltip$10 = options.tooltip, label$16 = options.label, _a$5 = options.shape, shape = _a$5 === void 0 ? "funnel" : _a$5, funnelStyle = options.funnelStyle, state$1 = options.state;
	var _b = getTooltipMapping(tooltip$10, [xField, yField]), fields = _b.fields, formatter = _b.formatter;
	geometry$10({
		chart,
		options: {
			type: "interval",
			xField,
			yField: FUNNEL_MAPPING_VALUE,
			colorField: xField,
			tooltipFields: is_array_default(fields) && fields.concat([FUNNEL_PERCENT, FUNNEL_CONVERSATION]),
			mapping: {
				shape,
				tooltip: formatter,
				color: color$2,
				style: funnelStyle
			},
			label: label$16,
			state: state$1
		}
	});
	findGeometry(params.chart, "interval").adjust("symmetric");
	return params;
}
/**
* 转置处理
* @param params
*/
function transpose$1(params) {
	var chart = params.chart;
	var isTransposed = params.options.isTransposed;
	chart.coordinate({
		type: "rect",
		actions: !isTransposed ? [["transpose"], [
			"scale",
			1,
			-1
		]] : []
	});
	return params;
}
/**
* 转化率组件
* @param params
*/
function conversionTag(params) {
	var options = params.options, chart = params.chart;
	var maxSize = options.maxSize;
	var dataArray = get_default(chart, [
		"geometries",
		"0",
		"dataArray"
	], []);
	var size$1 = get_default(chart, [
		"options",
		"data",
		"length"
	]);
	var x = map_default(dataArray, function(item) {
		return get_default(item, [
			"0",
			"nextPoints",
			"0",
			"x"
		]) * size$1 - .5;
	});
	var getLineCoordinate = function(datum, datumIndex, data$2, initLineOption) {
		var percent$1 = maxSize - (maxSize - datum[FUNNEL_MAPPING_VALUE]) / 2;
		return __assign(__assign({}, initLineOption), {
			start: [x[datumIndex - 1] || datumIndex - .5, percent$1],
			end: [x[datumIndex - 1] || datumIndex - .5, percent$1 + .05]
		});
	};
	conversionTagComponent(getLineCoordinate)(params);
	return params;
}
/**
* 基础漏斗
* @param chart
* @param options
*/
function basicFunnel(params) {
	return flow(field$4, geometry$29, transpose$1, conversionTag)(params);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/funnel/geometries/compare.js
/**
* 处理字段数据
* @param params
*/
function field$3(params) {
	var _a$5;
	var chart = params.chart, options = params.options;
	var _b = options.data, data$2 = _b === void 0 ? [] : _b, yField = options.yField;
	chart.data(data$2);
	chart.scale((_a$5 = {}, _a$5[yField] = { sync: true }, _a$5));
	return params;
}
/**
* geometry处理
* @param params
*/
function geometry$28(params) {
	var chart = params.chart, options = params.options;
	var data$2 = options.data, xField = options.xField, yField = options.yField, color$2 = options.color, compareField = options.compareField, isTransposed = options.isTransposed, tooltip$10 = options.tooltip, maxSize = options.maxSize, minSize = options.minSize, label$16 = options.label, funnelStyle = options.funnelStyle, state$1 = options.state, showFacetTitle = options.showFacetTitle;
	chart.facet("mirror", {
		fields: [compareField],
		transpose: !isTransposed,
		padding: isTransposed ? 0 : [
			32,
			0,
			0,
			0
		],
		showTitle: showFacetTitle,
		eachView: function(view, facet) {
			var index = isTransposed ? facet.rowIndex : facet.columnIndex;
			if (!isTransposed) view.coordinate({
				type: "rect",
				actions: [["transpose"], [
					"scale",
					index === 0 ? -1 : 1,
					-1
				]]
			});
			var formatterData = transformData$8(facet.data, data$2, {
				yField,
				maxSize,
				minSize
			});
			view.data(formatterData);
			var _a$5 = getTooltipMapping(tooltip$10, [
				xField,
				yField,
				compareField
			]), fields = _a$5.fields, formatter = _a$5.formatter;
			var defaultFacetLabel = isTransposed ? {
				offset: index === 0 ? 10 : -23,
				position: index === 0 ? "bottom" : "top"
			} : {
				offset: 10,
				position: "left",
				style: { textAlign: index === 0 ? "end" : "start" }
			};
			geometry$10({
				chart: view,
				options: {
					type: "interval",
					xField,
					yField: FUNNEL_MAPPING_VALUE,
					colorField: xField,
					tooltipFields: is_array_default(fields) && fields.concat([FUNNEL_PERCENT, FUNNEL_CONVERSATION]),
					mapping: {
						shape: "funnel",
						tooltip: formatter,
						color: color$2,
						style: funnelStyle
					},
					label: label$16 === false ? false : deepAssign({}, defaultFacetLabel, label$16),
					state: state$1
				}
			});
		}
	});
	return params;
}
function compareConversionTag(params) {
	var chart = params.chart, index = params.index, options = params.options;
	var conversionTag$4 = options.conversionTag, isTransposed = options.isTransposed;
	(is_number_default(index) ? [chart] : chart.views).forEach(function(view, viewIndex) {
		var dataArray = get_default(view, [
			"geometries",
			"0",
			"dataArray"
		], []);
		var size$1 = get_default(view, [
			"options",
			"data",
			"length"
		]);
		var x = map_default(dataArray, function(item) {
			return get_default(item, [
				"0",
				"nextPoints",
				"0",
				"x"
			]) * size$1 - .5;
		});
		var getLineCoordinate = function(datum, datumIndex, data$2, initLineOption) {
			var ratio = (index || viewIndex) === 0 ? -1 : 1;
			return deepAssign({}, initLineOption, {
				start: [x[datumIndex - 1] || datumIndex - .5, datum[FUNNEL_MAPPING_VALUE]],
				end: [x[datumIndex - 1] || datumIndex - .5, datum[FUNNEL_MAPPING_VALUE] + .05],
				text: isTransposed ? { style: { textAlign: "start" } } : {
					offsetX: conversionTag$4 !== false ? ratio * conversionTag$4.offsetX : 0,
					style: { textAlign: (index || viewIndex) === 0 ? "end" : "start" }
				}
			});
		};
		conversionTagComponent(getLineCoordinate)(deepAssign({}, {
			chart: view,
			options
		}));
	});
}
/**
* 转化率组件
* @param params
*/
function conversionTag$2(params) {
	params.chart.once("beforepaint", function() {
		return compareConversionTag(params);
	});
	return params;
}
/**
* 对比漏斗
* @param chart
* @param options
*/
function compareFunnel(params) {
	return flow(field$3, geometry$28, conversionTag$2)(params);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/funnel/geometries/dynamic-height.js
/**
* 动态高度漏斗图
* @param params
* 需求: 每个漏斗项的高度根据 yfield 等比生成。漏斗上下宽度比为2，即斜率为 2。
* 实现方式: 使用 g2 多边形，data -> 点坐标 -> 绘制
* 以漏斗底部中心点为坐标轴原点，漏斗在 -0.5 <= x <= 0.5, 0 <= y <= 1 的正方形中绘制
* 先计算第一象限的点, 第二象限的点即为镜像 x 轴取反。
* 第一象限共需计算 data.length + 1 个点，在 y = 4x - 1 上。首尾分别是[0.5, 1], [0.25, 0]。根据 data 计算出 y 值，从而得到 y 值
*/
/**
* 处理数据
* @param params
*/
function field$2(params) {
	var chart = params.chart, options = params.options;
	var _a$5 = options.data, data$2 = _a$5 === void 0 ? [] : _a$5, yField = options.yField;
	var sum = reduce_default(data$2, function(total, item) {
		return total + (item[yField] || 0);
	}, 0);
	var max$2 = max_by_default(data$2, yField)[yField];
	var formatData = map_default(data$2, function(row, index) {
		var x = [];
		var y = [];
		row[FUNNEL_TOTAL_PERCENT] = (row[yField] || 0) / sum;
		if (index) {
			var preItemX = data$2[index - 1][PLOYGON_X];
			var preItemY = data$2[index - 1][PLOYGON_Y];
			x[0] = preItemX[3];
			y[0] = preItemY[3];
			x[1] = preItemX[2];
			y[1] = preItemY[2];
		} else {
			x[0] = -.5;
			y[0] = 1;
			x[1] = .5;
			y[1] = 1;
		}
		y[2] = y[1] - row[FUNNEL_TOTAL_PERCENT];
		x[2] = (y[2] + 1) / 4;
		y[3] = y[2];
		x[3] = -x[2];
		row[PLOYGON_X] = x;
		row[PLOYGON_Y] = y;
		row[FUNNEL_PERCENT] = (row[yField] || 0) / max$2;
		row[FUNNEL_CONVERSATION] = [get_default(data$2, [index - 1, yField]), row[yField]];
		return row;
	});
	chart.data(formatData);
	return params;
}
/**
* geometry处理
* @param params
*/
function geometry$27(params) {
	var chart = params.chart, options = params.options;
	var xField = options.xField, yField = options.yField, color$2 = options.color, tooltip$10 = options.tooltip, label$16 = options.label, funnelStyle = options.funnelStyle, state$1 = options.state;
	var _a$5 = getTooltipMapping(tooltip$10, [xField, yField]), fields = _a$5.fields, formatter = _a$5.formatter;
	geometry$10({
		chart,
		options: {
			type: "polygon",
			xField: PLOYGON_X,
			yField: PLOYGON_Y,
			colorField: xField,
			tooltipFields: is_array_default(fields) && fields.concat([FUNNEL_PERCENT, FUNNEL_CONVERSATION]),
			label: label$16,
			state: state$1,
			mapping: {
				tooltip: formatter,
				color: color$2,
				style: funnelStyle
			}
		}
	});
	return params;
}
/**
* 转置处理
* @param params
*/
function transpose(params) {
	var chart = params.chart;
	var isTransposed = params.options.isTransposed;
	chart.coordinate({
		type: "rect",
		actions: isTransposed ? [["transpose"], ["reflect", "x"]] : []
	});
	return params;
}
/**
* 转化率组件
* @param params
*/
function conversionTag$1(params) {
	var getLineCoordinate = function(datum, datumIndex, data$2, initLineOption) {
		return __assign(__assign({}, initLineOption), {
			start: [datum[PLOYGON_X][1], datum[PLOYGON_Y][1]],
			end: [datum[PLOYGON_X][1] + .05, datum[PLOYGON_Y][1]]
		});
	};
	conversionTagComponent(getLineCoordinate)(params);
	return params;
}
/**
* 动态高度漏斗
* @param chart
* @param options
*/
function dynamicHeightFunnel(params) {
	return flow(field$2, geometry$27, transpose, conversionTag$1)(params);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/funnel/geometries/facet.js
/**
* 处理字段数据
* @param params
*/
function field$1(params) {
	var _a$5;
	var chart = params.chart, options = params.options;
	var _b = options.data, data$2 = _b === void 0 ? [] : _b, yField = options.yField;
	chart.data(data$2);
	chart.scale((_a$5 = {}, _a$5[yField] = { sync: true }, _a$5));
	return params;
}
/**
* geometry处理
* @param params
*/
function geometry$26(params) {
	var chart = params.chart, options = params.options;
	var seriesField = options.seriesField, isTransposed = options.isTransposed, showFacetTitle = options.showFacetTitle;
	chart.facet("rect", {
		fields: [seriesField],
		padding: [
			isTransposed ? 0 : 32,
			10,
			0,
			10
		],
		showTitle: showFacetTitle,
		eachView: function(view, facet) {
			basicFunnel(deepAssign({}, params, {
				chart: view,
				options: { data: facet.data }
			}));
		}
	});
	return params;
}
/**
* 分面漏斗
* @param chart
* @param options
*/
function facetFunnel(params) {
	return flow(field$1, geometry$26)(params);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/funnel/interactions/funnel-conversion-tag.js
/**
* Funnel 转化率跟随 legend 变化事件
*/
var ConversionTagAction = function(_super) {
	__extends(ConversionTagAction$1, _super);
	function ConversionTagAction$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.rendering = false;
		return _this;
	}
	ConversionTagAction$1.prototype.change = function(options) {
		var _this = this;
		if (!this.rendering) {
			var seriesField = options.seriesField, compareField = options.compareField;
			var conversionTag_1 = compareField ? compareConversionTag : conversionTag;
			var view = this.context.view;
			var views = seriesField || compareField ? view.views : [view];
			map_default(views, function(v, index) {
				var annotationController = v.getController("annotation");
				var annotations = filter_default(get_default(annotationController, ["option"], []), function(_a$5) {
					return _a$5.name !== CONVERSION_TAG_NAME;
				});
				annotationController.clear(true);
				each_default(annotations, function(annotation$3) {
					if (typeof annotation$3 === "object") v.annotation()[annotation$3.type](annotation$3);
				});
				var data$2 = get_default(v, ["filteredData"], v.getOptions().data);
				conversionTag_1({
					chart: v,
					index,
					options: __assign(__assign({}, options), { filteredData: transformData$8(data$2, data$2, options) })
				});
				v.filterData(data$2);
				_this.rendering = true;
				v.render(true);
			});
		}
		this.rendering = false;
	};
	return ConversionTagAction$1;
}(base_default$1);

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/funnel/interactions/index.js
var FUNNEL_CONVERSION_TAG = "funnel-conversion-tag";
var FUNNEL_LEGEND_FILTER = "funnel-afterrender";
var interactionStart = {
	trigger: "afterrender",
	action: "".concat(FUNNEL_CONVERSION_TAG, ":change")
};
registerAction(FUNNEL_CONVERSION_TAG, ConversionTagAction);
registerInteraction(FUNNEL_LEGEND_FILTER, { start: [interactionStart] });

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/funnel/adaptor.js
/**
*
* 各式漏斗图geometry实现细节有较大不同,
* 1. 普通漏斗图：interval.shape('funnel')
* 2. 对比漏斗图：分面
* 3. 动态高度漏斗图：polypon
* 4. 分面漏斗图：普通 + list 分面
* /

/**
* options 处理
* @param params
*/
function defaultOptions$4(params) {
	var options = params.options;
	var compareField = options.compareField, xField = options.xField, yField = options.yField, locale = options.locale, funnelStyle = options.funnelStyle, data$2 = options.data;
	var i18n = getLocale(locale);
	var defaultOption = {
		label: compareField ? {
			fields: [
				xField,
				yField,
				compareField,
				FUNNEL_PERCENT,
				FUNNEL_CONVERSATION
			],
			formatter: function(datum) {
				return "".concat(datum[yField]);
			}
		} : {
			fields: [
				xField,
				yField,
				FUNNEL_PERCENT,
				FUNNEL_CONVERSATION
			],
			offset: 0,
			position: "middle",
			formatter: function(datum) {
				return "".concat(datum[xField], " ").concat(datum[yField]);
			}
		},
		tooltip: {
			title: xField,
			formatter: function(datum) {
				return {
					name: datum[xField],
					value: datum[yField]
				};
			}
		},
		conversionTag: { formatter: function(datum) {
			return "".concat(i18n.get(["conversionTag", "label"]), ": ").concat(conversionTagFormatter.apply(void 0, datum[FUNNEL_CONVERSATION]));
		} }
	};
	var style;
	if (compareField || funnelStyle) style = function(datum) {
		return deepAssign({}, compareField && {
			lineWidth: 1,
			stroke: "#fff"
		}, is_function_default(funnelStyle) ? funnelStyle(datum) : funnelStyle);
	};
	return deepAssign({ options: defaultOption }, params, { options: {
		funnelStyle: style,
		data: clone_default(data$2)
	} });
}
/**
* geometry处理
* @param params
*/
function geometry$25(params) {
	var options = params.options;
	var compareField = options.compareField, dynamicHeight = options.dynamicHeight;
	if (options.seriesField) return facetFunnel(params);
	if (compareField) return compareFunnel(params);
	if (dynamicHeight) return dynamicHeightFunnel(params);
	return basicFunnel(params);
}
/**
* meta 配置
* @param params
*/
function meta$20(params) {
	var _a$5;
	var options = params.options;
	var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
	return flow(scale((_a$5 = {}, _a$5[xField] = xAxis, _a$5[yField] = yAxis, _a$5)))(params);
}
/**
* 坐标轴
* @param params
*/
function axis$18(params) {
	params.chart.axis(false);
	return params;
}
/**
* legend 配置
* @param params
*/
function legend$13(params) {
	var chart = params.chart;
	var legend$17 = params.options.legend;
	if (legend$17 === false) chart.legend(false);
	else chart.legend(legend$17);
	return params;
}
/**
* Interaction 配置
* @param params
*/
function interaction$8(params) {
	var chart = params.chart, options = params.options;
	var interactions = options.interactions, dynamicHeight = options.dynamicHeight;
	each_default(interactions, function(i) {
		if (i.enable === false) chart.removeInteraction(i.type);
		else chart.interaction(i.type, i.cfg || {});
	});
	if (!dynamicHeight) chart.interaction(FUNNEL_LEGEND_FILTER, { start: [__assign(__assign({}, interactionStart), { arg: options })] });
	else chart.removeInteraction(FUNNEL_LEGEND_FILTER);
	return params;
}
/**
* 漏斗图适配器
* @param chart
* @param options
*/
function adaptor$23(params) {
	return flow(defaultOptions$4, geometry$25, meta$20, axis$18, tooltip, interaction$8, legend$13, animation, theme, annotation())(params);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/funnel/index.js
var Funnel = function(_super) {
	__extends(Funnel$1, _super);
	function Funnel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		/** 图表类型 */
		_this.type = "funnel";
		return _this;
	}
	Funnel$1.getDefaultOptions = function() {
		return DEFAULT_OPTIONS$32;
	};
	/**
	* 获取 漏斗图 默认配置项
	*/
	Funnel$1.prototype.getDefaultOptions = function() {
		return Funnel$1.getDefaultOptions();
	};
	/**
	* 获取 漏斗图 的适配器
	*/
	Funnel$1.prototype.getSchemaAdaptor = function() {
		return adaptor$23;
	};
	/**
	* 设置状态
	* @param type 状态类型，支持 'active' | 'inactive' | 'selected' 三种
	* @param conditions 条件，支持数组
	* @param status 是否激活，默认 true
	*/
	Funnel$1.prototype.setState = function(type, condition, status) {
		if (status === void 0) status = true;
		var elements = getAllElementsRecursively(this.chart);
		each_default(elements, function(ele) {
			if (condition(ele.getData())) ele.setState(type, status);
		});
	};
	/**
	* 获取状态
	*/
	Funnel$1.prototype.getStates = function() {
		var elements = getAllElementsRecursively(this.chart);
		var stateObjects = [];
		each_default(elements, function(element) {
			var data$2 = element.getData();
			var states = element.getStates();
			each_default(states, function(state$1) {
				stateObjects.push({
					data: data$2,
					state: state$1,
					geometry: element.geometry,
					element
				});
			});
		});
		return stateObjects;
	};
	/** 漏斗 转化率 字段 */
	Funnel$1.CONVERSATION_FIELD = FUNNEL_CONVERSATION;
	/** 漏斗 百分比 字段 */
	Funnel$1.PERCENT_FIELD = FUNNEL_PERCENT;
	/** 漏斗 总转换率百分比 字段 */
	Funnel$1.TOTAL_PERCENT_FIELD = FUNNEL_TOTAL_PERCENT;
	return Funnel$1;
}(Plot);

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/gauge/constants.js
var _a$1;
var RANGE_VALUE = "range";
var RANGE_TYPE = "type";
var PERCENT = "percent";
var DEFAULT_COLOR$1 = "#f0f0f0";
/** 仪表盘由 指针和表盘 组成 */
var INDICATEOR_VIEW_ID = "indicator-view";
var RANGE_VIEW_ID = "range-view";
/**
* 仪表盘默认配置项
*/
var DEFAULT_OPTIONS$31 = {
	percent: 0,
	range: { ticks: [] },
	innerRadius: .9,
	radius: .95,
	startAngle: -7 / 6 * Math.PI,
	endAngle: 1 / 6 * Math.PI,
	syncViewPadding: true,
	axis: {
		line: null,
		label: {
			offset: -24,
			style: {
				textAlign: "center",
				textBaseline: "middle"
			}
		},
		subTickLine: { length: -8 },
		tickLine: { length: -12 },
		grid: null
	},
	indicator: {
		pointer: { style: {
			lineWidth: 5,
			lineCap: "round"
		} },
		pin: { style: {
			r: 9.75,
			lineWidth: 4.5,
			fill: "#fff"
		} }
	},
	statistic: { title: false },
	meta: (_a$1 = {}, _a$1[RANGE_VALUE] = { sync: "v" }, _a$1[PERCENT] = {
		sync: "v",
		tickCount: 5,
		tickInterval: .2
	}, _a$1),
	animation: false
};

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/gauge/utils.js
/**
* 将 range 生成为 data 数据
* @param range
* @param key
* @returns {GaugeRangeData}
*/
function processRangeData(range, percent$1) {
	return range.map(function(r, idx) {
		var _a$5;
		return _a$5 = {}, _a$5[RANGE_VALUE] = r - (range[idx - 1] || 0), _a$5[RANGE_TYPE] = "".concat(idx), _a$5[PERCENT] = percent$1, _a$5;
	});
}
/**
* 获取 仪表盘 指针数据
* @param percent
*/
function getIndicatorData(percent$1) {
	var _a$5;
	return [(_a$5 = {}, _a$5[PERCENT] = clamp_default(percent$1, 0, 1), _a$5)];
}
/**
* 获取仪表盘 表盘弧形数据
* @param percent
* @param range
*/
function getRangeData(percent$1, range) {
	var ticks = get_default(range, ["ticks"], []);
	var clampTicks = size(ticks) ? uniq(ticks) : [
		0,
		clamp_default(percent$1, 0, 1),
		1
	];
	if (!clampTicks[0]) clampTicks.shift();
	return processRangeData(clampTicks, percent$1);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/gauge/adaptor.js
/**
* geometry 处理
* @param params
*/
function geometry$24(params) {
	var chart = params.chart, options = params.options;
	var percent$1 = options.percent, range = options.range, radius = options.radius, innerRadius = options.innerRadius, startAngle = options.startAngle, endAngle = options.endAngle, axis$21 = options.axis, indicator = options.indicator, gaugeStyle = options.gaugeStyle, type = options.type, meter = options.meter;
	var color$2 = range.color, rangeWidth = range.width;
	if (indicator) {
		var indicatorData = getIndicatorData(percent$1);
		var v1 = chart.createView({ id: INDICATEOR_VIEW_ID });
		v1.data(indicatorData);
		v1.point().position("".concat(PERCENT, "*1")).shape(indicator.shape || "gauge-indicator").customInfo({
			defaultColor: chart.getTheme().defaultColor,
			indicator
		});
		v1.coordinate("polar", {
			startAngle,
			endAngle,
			radius: innerRadius * radius
		});
		v1.axis(PERCENT, axis$21);
		v1.scale(PERCENT, pick(axis$21, AXIS_META_CONFIG_KEYS));
	}
	var rangeData = getRangeData(percent$1, options.range);
	var v2 = chart.createView({ id: RANGE_VIEW_ID });
	v2.data(rangeData);
	var rangeColor = is_string_default(color$2) ? [color$2, DEFAULT_COLOR$1] : color$2;
	interval({
		chart: v2,
		options: {
			xField: "1",
			yField: RANGE_VALUE,
			seriesField: RANGE_TYPE,
			rawFields: [PERCENT],
			isStack: true,
			interval: {
				color: rangeColor,
				style: gaugeStyle,
				shape: type === "meter" ? "meter-gauge" : null
			},
			args: {
				zIndexReversed: true,
				sortZIndex: true
			},
			minColumnWidth: rangeWidth,
			maxColumnWidth: rangeWidth
		}
	}).ext.geometry.customInfo({ meter });
	v2.coordinate("polar", {
		innerRadius,
		radius,
		startAngle,
		endAngle
	}).transpose();
	return params;
}
/**
* meta 配置
* @param params
*/
function meta$19(params) {
	var _a$5;
	return flow(scale((_a$5 = { range: {
		min: 0,
		max: 1,
		maxLimit: 1,
		minLimit: 0
	} }, _a$5[PERCENT] = {}, _a$5)))(params);
}
/**
* 统计指标文档
* @param params
*/
function statistic$2(params, updated) {
	var chart = params.chart, options = params.options;
	var statistic$3 = options.statistic, percent$1 = options.percent;
	chart.getController("annotation").clear(true);
	if (statistic$3) {
		var contentOption = statistic$3.content;
		var transformContent = void 0;
		if (contentOption) transformContent = deepAssign({}, {
			content: "".concat((percent$1 * 100).toFixed(2), "%"),
			style: {
				opacity: .75,
				fontSize: "30px",
				lineHeight: 1,
				textAlign: "center",
				color: "rgba(44,53,66,0.85)"
			}
		}, contentOption);
		renderGaugeStatistic(chart, { statistic: __assign(__assign({}, statistic$3), { content: transformContent }) }, { percent: percent$1 });
	}
	if (updated) chart.render(true);
	return params;
}
/**
* tooltip 配置
*/
function tooltip$9(params) {
	var chart = params.chart;
	var tooltip$10 = params.options.tooltip;
	if (tooltip$10) chart.tooltip(deepAssign({
		showTitle: false,
		showMarkers: false,
		containerTpl: "<div class=\"g2-tooltip\"><div class=\"g2-tooltip-list\"></div></div>",
		domStyles: { "g2-tooltip": {
			padding: "4px 8px",
			fontSize: "10px"
		} },
		customContent: function(x, data$2) {
			var percent$1 = get_default(data$2, [
				0,
				"data",
				PERCENT
			], 0);
			return "".concat((percent$1 * 100).toFixed(2), "%");
		}
	}, tooltip$10));
	else chart.tooltip(false);
	return params;
}
/**
* other 配置
* @param params
*/
function other(params) {
	params.chart.legend(false);
	return params;
}
/**
* 图适配器
* @param chart
* @param options
*/
function adaptor$24(params) {
	return flow(theme, animation, geometry$24, meta$19, tooltip$9, statistic$2, interaction, annotation(), other)(params);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/gauge/shapes/indicator.js
registerShape("point", "gauge-indicator", { draw: function(cfg, container) {
	var _a$5 = cfg.customInfo, indicator = _a$5.indicator, defaultColor = _a$5.defaultColor;
	var _b = indicator, pointer = _b.pointer, pin$1 = _b.pin;
	var group$1 = container.addGroup();
	var center$1 = this.parsePoint({
		x: 0,
		y: 0
	});
	if (pointer) group$1.addShape("line", {
		name: "pointer",
		attrs: __assign({
			x1: center$1.x,
			y1: center$1.y,
			x2: cfg.x,
			y2: cfg.y,
			stroke: defaultColor
		}, pointer.style)
	});
	if (pin$1) group$1.addShape("circle", {
		name: "pin",
		attrs: __assign({
			x: center$1.x,
			y: center$1.y,
			stroke: defaultColor
		}, pin$1.style)
	});
	return group$1;
} });

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/gauge/shapes/meter-gauge.js
/**
* 自定义 Shape 部分: 自定义米轨仪表盘
* 定义 STEP, STEP_RATIO. 可绘制区域: 1 / (STEP + 1) * i -> 1 / (STEP + 1) * i + (STEP_RATIO / (STEP + 1))
*/
registerShape("interval", "meter-gauge", { draw: function(cfg, container) {
	var _a$5 = cfg.customInfo.meter, meter = _a$5 === void 0 ? {} : _a$5;
	var _b = meter.steps, STEP = _b === void 0 ? 50 : _b, _c = meter.stepRatio, STEP_RATIO = _c === void 0 ? .5 : _c;
	STEP = STEP < 1 ? 1 : STEP;
	STEP_RATIO = clamp_default(STEP_RATIO, 0, 1);
	var _d = this.coordinate, COORD_START_ANGLE = _d.startAngle, COORD_END_ANGLE = _d.endAngle;
	var GAP$1 = 0;
	if (STEP_RATIO > 0 && STEP_RATIO < 1) GAP$1 = (COORD_END_ANGLE - COORD_START_ANGLE) / STEP / (STEP_RATIO / (1 - STEP_RATIO) + 1 - 1 / STEP);
	var INTERVAL = GAP$1 / (1 - STEP_RATIO) * STEP_RATIO;
	var group$1 = container.addGroup();
	var center$1 = this.coordinate.getCenter();
	var radius = this.coordinate.getRadius();
	var _e = Util.getAngle(cfg, this.coordinate), START_ANGLE = _e.startAngle, END_ANGLE = _e.endAngle;
	for (var startAngle = START_ANGLE; startAngle < END_ANGLE;) {
		var endAngle = void 0;
		var r = (startAngle - COORD_START_ANGLE) % (INTERVAL + GAP$1);
		if (r < INTERVAL) endAngle = startAngle + (INTERVAL - r);
		else {
			startAngle += INTERVAL + GAP$1 - r;
			endAngle = startAngle + INTERVAL;
		}
		var path = Util.getSectorPath(center$1.x, center$1.y, radius, startAngle, Math.min(endAngle, END_ANGLE), radius * this.coordinate.innerRadius);
		group$1.addShape("path", {
			name: "meter-gauge",
			attrs: {
				path,
				fill: cfg.color,
				stroke: cfg.color,
				lineWidth: .5
			}
		});
		startAngle = endAngle + GAP$1;
	}
	return group$1;
} });

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/gauge/index.js
/**
* 仪表盘
*/
var Gauge = function(_super) {
	__extends(Gauge$1, _super);
	function Gauge$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		/** 图表类型 */
		_this.type = "gauge";
		return _this;
	}
	/**
	* 获取 仪表盘 默认配置项
	* 供外部使用
	*/
	Gauge$1.getDefaultOptions = function() {
		return DEFAULT_OPTIONS$31;
	};
	/**
	* 更新数据
	* @param percent
	*/
	Gauge$1.prototype.changeData = function(percent$1) {
		this.chart.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, event_default.fromData(this.chart, VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
		this.updateOption({ percent: percent$1 });
		var indicatorView = this.chart.views.find(function(v) {
			return v.id === INDICATEOR_VIEW_ID;
		});
		if (indicatorView) indicatorView.data(getIndicatorData(percent$1));
		var rangeView = this.chart.views.find(function(v) {
			return v.id === RANGE_VIEW_ID;
		});
		if (rangeView) rangeView.data(getRangeData(percent$1, this.options.range));
		statistic$2({
			chart: this.chart,
			options: this.options
		}, true);
		this.chart.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, event_default.fromData(this.chart, VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
	};
	/**
	* 获取默认配置
	* 供 base 使用
	*/
	Gauge$1.prototype.getDefaultOptions = function() {
		return Gauge$1.getDefaultOptions();
	};
	/**
	* 获取适配器
	*/
	Gauge$1.prototype.getSchemaAdaptor = function() {
		return adaptor$24;
	};
	return Gauge$1;
}(Plot);

//#endregion
//#region node_modules/@antv/g2plot/esm/utils/transform/histogram.js
function getBinKey(value$1, binWidth, binNumber) {
	if (binNumber === 1) return [0, binWidth];
	var index = Math.floor(value$1 / binWidth);
	return [binWidth * index, binWidth * (index + 1)];
}
function sturges(values$1) {
	return Math.ceil(Math.log(values$1.length) / Math.LN2) + 1;
}
/**
* 对数据进行百分比化
* @param data
* @param binField
* @param binWidth
* @param binNumber
* @param stackField
*/
function binHistogram(data$2, binField, binWidth, binNumber, stackField) {
	var originData_copy = clone_default(data$2);
	sort_by_default(originData_copy, binField);
	var values$1 = values_of_key_default(originData_copy, binField);
	var range = get_range_default(values$1);
	var rangeWidth = range.max - range.min;
	var _binWidth = binWidth;
	if (!binWidth && binNumber) _binWidth = binNumber > 1 ? rangeWidth / (binNumber - 1) : range.max;
	if (!binWidth && !binNumber) {
		var _defaultBinNumber = sturges(values$1);
		_binWidth = rangeWidth / _defaultBinNumber;
	}
	var bins = {};
	var groups = group_by_default(originData_copy, stackField);
	if (is_empty_default(groups)) each_default(originData_copy, function(data$3) {
		var value$1 = data$3[binField];
		var bin = getBinKey(value$1, _binWidth, binNumber);
		var binKey = "".concat(bin[0], "-").concat(bin[1]);
		if (!has_key_default(bins, binKey)) bins[binKey] = {
			range: bin,
			count: 0
		};
		bins[binKey].count += 1;
	});
	else Object.keys(groups).forEach(function(groupKey) {
		each_default(groups[groupKey], function(data$3) {
			var value$1 = data$3[binField];
			var bin = getBinKey(value$1, _binWidth, binNumber);
			var binKey = "".concat(bin[0], "-").concat(bin[1]);
			var groupKeyBinKey = "".concat(binKey, "-").concat(groupKey);
			if (!has_key_default(bins, groupKeyBinKey)) {
				bins[groupKeyBinKey] = {
					range: bin,
					count: 0
				};
				bins[groupKeyBinKey][stackField] = groupKey;
			}
			bins[groupKeyBinKey].count += 1;
		});
	});
	var plotData = [];
	each_default(bins, function(bin) {
		plotData.push(bin);
	});
	return plotData;
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/histogram/constant.js
/** 直方图 xField */
var HISTOGRAM_X_FIELD = "range";
/** 直方图 yField */
var HISTOGRAM_Y_FIELD = "count";
/**
* 默认配置项
*/
var DEFAULT_OPTIONS$30 = deepAssign({}, Plot.getDefaultOptions(), {
	columnStyle: { stroke: "#FFFFFF" },
	tooltip: {
		shared: true,
		showMarkers: false
	},
	interactions: [{ type: "active-region" }]
});

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/histogram/adaptor.js
/**
* geometry 处理
* @param params
*/
function geometry$23(params) {
	var chart = params.chart, options = params.options;
	var data$2 = options.data, binField = options.binField, binNumber = options.binNumber, binWidth = options.binWidth, color$2 = options.color, stackField = options.stackField, legend$17 = options.legend, columnStyle = options.columnStyle;
	var plotData = binHistogram(data$2, binField, binWidth, binNumber, stackField);
	chart.data(plotData);
	var p = deepAssign({}, params, { options: {
		xField: HISTOGRAM_X_FIELD,
		yField: HISTOGRAM_Y_FIELD,
		seriesField: stackField,
		isStack: true,
		interval: {
			color: color$2,
			style: columnStyle
		}
	} });
	interval(p);
	if (legend$17 && stackField) chart.legend(stackField, legend$17);
	else chart.legend(false);
	return params;
}
/**
* meta 配置
* @param params
*/
function meta$18(params) {
	var _a$5;
	var options = params.options;
	var xAxis = options.xAxis, yAxis = options.yAxis;
	return flow(scale((_a$5 = {}, _a$5[HISTOGRAM_X_FIELD] = xAxis, _a$5[HISTOGRAM_Y_FIELD] = yAxis, _a$5)))(params);
}
/**
* axis 配置
* @param params
*/
function axis$17(params) {
	var chart = params.chart, options = params.options;
	var xAxis = options.xAxis, yAxis = options.yAxis;
	if (xAxis === false) chart.axis(HISTOGRAM_X_FIELD, false);
	else chart.axis(HISTOGRAM_X_FIELD, xAxis);
	if (yAxis === false) chart.axis(HISTOGRAM_Y_FIELD, false);
	else chart.axis(HISTOGRAM_Y_FIELD, yAxis);
	return params;
}
/**
* label 配置
* @param params
*/
function label$11(params) {
	var chart = params.chart;
	var label$16 = params.options.label;
	var geometry$34 = findGeometry(chart, "interval");
	if (!label$16) geometry$34.label(false);
	else {
		var callback = label$16.callback, cfg = __rest(label$16, ["callback"]);
		geometry$34.label({
			fields: [HISTOGRAM_Y_FIELD],
			callback,
			cfg: transformLabel(cfg)
		});
	}
	return params;
}
/**
* 直方图适配器
* @param chart
* @param options
*/
function adaptor$25(params) {
	return flow(theme, pattern("columnStyle"), geometry$23, meta$18, axis$17, state, label$11, tooltip, interaction, animation)(params);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/histogram/index.js
var Histogram = function(_super) {
	__extends(Histogram$1, _super);
	function Histogram$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		/** 图表类型 */
		_this.type = "histogram";
		return _this;
	}
	/**
	* 获取 默认配置项
	* 供外部使用
	*/
	Histogram$1.getDefaultOptions = function() {
		return DEFAULT_OPTIONS$30;
	};
	Histogram$1.prototype.changeData = function(data$2) {
		this.updateOption({ data: data$2 });
		var _a$5 = this.options, binField = _a$5.binField, binNumber = _a$5.binNumber, binWidth = _a$5.binWidth, stackField = _a$5.stackField;
		this.chart.changeData(binHistogram(data$2, binField, binWidth, binNumber, stackField));
	};
	/**
	* 获取直方图的适配器
	*/
	Histogram$1.prototype.getDefaultOptions = function() {
		return Histogram$1.getDefaultOptions();
	};
	/**
	* 获取直方图的适配器
	*/
	Histogram$1.prototype.getSchemaAdaptor = function() {
		return adaptor$25;
	};
	return Histogram$1;
}(Plot);

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/line/constants.js
/**
* 折线图默认配置项
*/
var DEFAULT_OPTIONS$29 = deepAssign({}, Plot.getDefaultOptions(), {
	tooltip: {
		shared: true,
		showMarkers: true,
		showCrosshairs: true,
		crosshairs: { type: "x" }
	},
	legend: {
		position: "top-left",
		radio: {}
	},
	isStack: false
});

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/line/interactions/marker-active.js
var MarkerActiveAction = function(_super) {
	__extends(MarkerActiveAction$1, _super);
	function MarkerActiveAction$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	MarkerActiveAction$1.prototype.active = function() {
		var view = this.getView();
		var evt = this.context.event;
		if (evt.data) {
			var items_1 = evt.data.items;
			var points = view.geometries.filter(function(geom) {
				return geom.type === "point";
			});
			each_default(points, function(point$1) {
				each_default(point$1.elements, function(element) {
					var active = find_index_default(items_1, function(item) {
						return item.data === element.data;
					}) !== -1;
					element.setState("active", active);
				});
			});
		}
	};
	MarkerActiveAction$1.prototype.reset = function() {
		var points = this.getView().geometries.filter(function(geom) {
			return geom.type === "point";
		});
		each_default(points, function(point$1) {
			each_default(point$1.elements, function(element) {
				element.setState("active", false);
			});
		});
	};
	MarkerActiveAction$1.prototype.getView = function() {
		return this.context.view;
	};
	return MarkerActiveAction$1;
}(base_default$1);

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/line/interactions/index.js
registerAction("marker-active", MarkerActiveAction);
registerInteraction("marker-active", {
	start: [{
		trigger: "tooltip:show",
		action: "marker-active:active"
	}],
	end: [{
		trigger: "tooltip:hide",
		action: "marker-active:reset"
	}]
});

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/line/index.js
var Line = function(_super) {
	__extends(Line$6, _super);
	function Line$6() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		/** 图表类型 */
		_this.type = "line";
		return _this;
	}
	/**
	* 获取 折线图 默认配置项
	* 供外部使用
	*/
	Line$6.getDefaultOptions = function() {
		return DEFAULT_OPTIONS$29;
	};
	/**
	* @override
	* @param data
	*/
	Line$6.prototype.changeData = function(data$2) {
		this.updateOption({ data: data$2 });
		var _a$5 = this, chart = _a$5.chart, options = _a$5.options;
		meta$17({
			chart,
			options
		});
		this.chart.changeData(data$2);
	};
	/**
	* 获取 折线图 默认配置
	*/
	Line$6.prototype.getDefaultOptions = function() {
		return Line$6.getDefaultOptions();
	};
	/**
	* 获取 折线图 的适配器
	*/
	Line$6.prototype.getSchemaAdaptor = function() {
		return adaptor$26;
	};
	return Line$6;
}(Plot);

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/pie/contants.js
/**
* 饼图默认配置项
*/
var DEFAULT_OPTIONS$28 = deepAssign({}, Plot.getDefaultOptions(), {
	legend: {
		position: "right",
		radio: {}
	},
	tooltip: {
		shared: false,
		showTitle: false,
		showMarkers: false
	},
	label: { layout: {
		type: "limit-in-plot",
		cfg: { action: "ellipsis" }
	} },
	pieStyle: {
		stroke: "white",
		lineWidth: 1
	},
	statistic: {
		title: { style: {
			fontWeight: 300,
			color: "#4B535E",
			textAlign: "center",
			fontSize: "20px",
			lineHeight: 1
		} },
		content: { style: {
			fontWeight: "bold",
			color: "rgba(44,53,66,0.85)",
			textAlign: "center",
			fontSize: "32px",
			lineHeight: 1
		} }
	},
	theme: { components: { annotation: { text: { animate: false } } } }
});

//#endregion
//#region node_modules/@antv/g2plot/esm/utils/matrix.js
var ORIGIN_MATRIX = [
	1,
	0,
	0,
	0,
	1,
	0,
	0,
	0,
	1
];
/**
* 矩阵变换
* @param actions
* @param matrix
*/
function transform$2(actions, matrix) {
	var ulMatrix = matrix ? __spreadArray([], matrix, true) : __spreadArray([], ORIGIN_MATRIX, true);
	return Util.transform(ulMatrix, actions);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/pie/interactions/actions/legend-active.js
/**
* 饼图 图例激活 action
*/
var PieLegendAction = function(_super) {
	__extends(PieLegendAction$1, _super);
	function PieLegendAction$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	/**
	* 获取激活的图形元素
	*/
	PieLegendAction$1.prototype.getActiveElements = function() {
		var delegateObject = Util.getDelegationObject(this.context);
		if (delegateObject) {
			var view = this.context.view;
			var component$1 = delegateObject.component, item_1 = delegateObject.item;
			var field_1 = component$1.get("field");
			if (field_1) return view.geometries[0].elements.filter(function(ele) {
				return ele.getModel().data[field_1] === item_1.value;
			});
		}
		return [];
	};
	/**
	* 获取激活的标签
	*/
	PieLegendAction$1.prototype.getActiveElementLabels = function() {
		var view = this.context.view;
		var elements = this.getActiveElements();
		return view.geometries[0].labelsContainer.getChildren().filter(function(label$16) {
			return elements.find(function(ele) {
				return is_equal_default(ele.getData(), label$16.get("data"));
			});
		});
	};
	PieLegendAction$1.prototype.transfrom = function(offset) {
		if (offset === void 0) offset = 7.5;
		var elements = this.getActiveElements();
		var elementLabels = this.getActiveElementLabels();
		elements.forEach(function(element, idx) {
			var labelShape = elementLabels[idx];
			var coordinate$10 = element.geometry.coordinate;
			if (coordinate$10.isPolar && coordinate$10.isTransposed) {
				var _a$5 = Util.getAngle(element.getModel(), coordinate$10), startAngle = _a$5.startAngle, endAngle = _a$5.endAngle;
				var middleAngle = (startAngle + endAngle) / 2;
				var r = offset;
				var x = r * Math.cos(middleAngle);
				var y = r * Math.sin(middleAngle);
				element.shape.setMatrix(transform$2([[
					"t",
					x,
					y
				]]));
				labelShape.setMatrix(transform$2([[
					"t",
					x,
					y
				]]));
			}
		});
	};
	PieLegendAction$1.prototype.active = function() {
		this.transfrom();
	};
	/**
	* 激活态还原
	*/
	PieLegendAction$1.prototype.reset = function() {
		this.transfrom(0);
	};
	return PieLegendAction$1;
}(base_default$1);

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/pie/interactions/util.js
/**
* 获取当前事件相关的图表元素
* @param context 交互的上下文
* @ignore
*/
function getCurrentElement(context) {
	var event = context.event;
	var element;
	var target = event.target;
	if (target) element = target.get("element");
	return element;
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/pie/interactions/actions/statistic-active.js
/**
* Pie 中心文本事件的 Action
*/
var StatisticAction = function(_super) {
	__extends(StatisticAction$1, _super);
	function StatisticAction$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	StatisticAction$1.prototype.getAnnotations = function(_view) {
		return (_view || this.context.view).getController("annotation").option;
	};
	StatisticAction$1.prototype.getInitialAnnotation = function() {
		return this.initialAnnotation;
	};
	StatisticAction$1.prototype.init = function() {
		var _this = this;
		var view = this.context.view;
		view.removeInteraction("tooltip");
		view.on("afterchangesize", function() {
			_this.initialAnnotation = _this.getAnnotations(view);
		});
	};
	StatisticAction$1.prototype.change = function(arg) {
		var _a$5 = this.context, view = _a$5.view, event = _a$5.event;
		if (!this.initialAnnotation) this.initialAnnotation = this.getAnnotations();
		var data$2 = get_default(event, ["data", "data"]);
		if (event.type.match("legend-item")) {
			var delegateObject = Util.getDelegationObject(this.context);
			var colorField_1 = view.getGroupedFields()[0];
			if (delegateObject && colorField_1) {
				var item_1 = delegateObject.item;
				data$2 = view.getData().find(function(d) {
					return d[colorField_1] === item_1.value;
				});
			}
		}
		if (data$2) {
			var annotations = get_default(arg, "annotations", []);
			var statistic$3 = get_default(arg, "statistic", {});
			view.getController("annotation").clear(true);
			each_default(annotations, function(annotation$3) {
				if (typeof annotation$3 === "object") view.annotation()[annotation$3.type](annotation$3);
			});
			renderStatistic(view, {
				statistic: statistic$3,
				plotType: "pie"
			}, data$2);
			view.render(true);
		}
		var ele = getCurrentElement(this.context);
		if (ele) ele.shape.toFront();
	};
	StatisticAction$1.prototype.reset = function() {
		var view = this.context.view;
		view.getController("annotation").clear(true);
		var initialStatistic = this.getInitialAnnotation();
		each_default(initialStatistic, function(a) {
			view.annotation()[a.type](a);
		});
		view.render(true);
	};
	return StatisticAction$1;
}(base_default$1);

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/pie/interactions/index.js
var PIE_STATISTIC = "pie-statistic";
registerAction(PIE_STATISTIC, StatisticAction);
registerInteraction("pie-statistic-active", {
	start: [{
		trigger: "element:mouseenter",
		action: "pie-statistic:change"
	}],
	end: [{
		trigger: "element:mouseleave",
		action: "pie-statistic:reset"
	}]
});
registerAction("pie-legend", PieLegendAction);
registerInteraction("pie-legend-active", {
	start: [{
		trigger: "legend-item:mouseenter",
		action: "pie-legend:active"
	}],
	end: [{
		trigger: "legend-item:mouseleave",
		action: "pie-legend:reset"
	}]
});

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/pie/utils.js
/**
* 获取总计值
* @param data
* @param field
*/
function getTotalValue(data$2, field$5) {
	var total = null;
	each_default(data$2, function(item) {
		if (typeof item[field$5] === "number") total += item[field$5];
	});
	return total;
}
/**
* pie label offset adaptor
*/
function adaptOffset(type, offset) {
	var defaultOffset;
	switch (type) {
		case "inner":
			defaultOffset = "-30%";
			if (is_string_default(offset) && offset.endsWith("%")) return parseFloat(offset) * .01 > 0 ? defaultOffset : offset;
			return offset < 0 ? offset : defaultOffset;
		case "outer":
			defaultOffset = 12;
			if (is_string_default(offset) && offset.endsWith("%")) return parseFloat(offset) * .01 < 0 ? defaultOffset : offset;
			return offset > 0 ? offset : defaultOffset;
		default: return offset;
	}
}
/**
* 判断数据是否全部为 0
* @param data
* @param angleField
*/
function isAllZero(data$2, angleField) {
	return every_default(processIllegalData(data$2, angleField), function(d) {
		return d[angleField] === 0;
	});
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/pie/adaptor.js
/**
* 字段
* @param params
*/
function geometry$22(params) {
	var chart = params.chart, options = params.options;
	var data$2 = options.data, angleField = options.angleField, colorField = options.colorField, color$2 = options.color, pieStyle = options.pieStyle, shape = options.shape;
	var processData$1 = processIllegalData(data$2, angleField);
	if (isAllZero(processData$1, angleField)) {
		var percentageField_1 = "$$percentage$$";
		processData$1 = processData$1.map(function(d) {
			var _a$5;
			return __assign(__assign({}, d), (_a$5 = {}, _a$5[percentageField_1] = 1 / processData$1.length, _a$5));
		});
		chart.data(processData$1);
		var p = deepAssign({}, params, { options: {
			xField: "1",
			yField: percentageField_1,
			seriesField: colorField,
			isStack: true,
			interval: {
				color: color$2,
				shape,
				style: pieStyle
			},
			args: {
				zIndexReversed: true,
				sortZIndex: true
			}
		} });
		interval(p);
	} else {
		chart.data(processData$1);
		var p = deepAssign({}, params, { options: {
			xField: "1",
			yField: angleField,
			seriesField: colorField,
			isStack: true,
			interval: {
				color: color$2,
				shape,
				style: pieStyle
			},
			args: {
				zIndexReversed: true,
				sortZIndex: true
			}
		} });
		interval(p);
	}
	return params;
}
/**
* meta 配置
* @param params
*/
function meta$16(params) {
	var _a$5;
	var chart = params.chart, options = params.options;
	var meta$22 = options.meta, colorField = options.colorField;
	var scales = deepAssign({}, meta$22);
	chart.scale(scales, (_a$5 = {}, _a$5[colorField] = { type: "cat" }, _a$5));
	return params;
}
/**
* coord 配置
* @param params
*/
function coordinate$7(params) {
	var chart = params.chart, options = params.options;
	var radius = options.radius, innerRadius = options.innerRadius, startAngle = options.startAngle, endAngle = options.endAngle;
	chart.coordinate({
		type: "theta",
		cfg: {
			radius,
			innerRadius,
			startAngle,
			endAngle
		}
	});
	return params;
}
/**
* label 配置
* @param params
*/
function label$10(params) {
	var chart = params.chart, options = params.options;
	var label$16 = options.label, colorField = options.colorField, angleField = options.angleField;
	var geometry$34 = chart.geometries[0];
	if (!label$16) geometry$34.label(false);
	else {
		var callback = label$16.callback, cfg = __rest(label$16, ["callback"]);
		var labelCfg = transformLabel(cfg);
		if (labelCfg.content) {
			var content_1 = labelCfg.content;
			labelCfg.content = function(data$2, dataum, index) {
				var name = data$2[colorField];
				var value$1 = data$2[angleField];
				var angleScale = chart.getScaleByField(angleField);
				var percent$1 = angleScale === null || angleScale === void 0 ? void 0 : angleScale.scale(value$1);
				return is_function_default(content_1) ? content_1(__assign(__assign({}, data$2), { percent: percent$1 }), dataum, index) : is_string_default(content_1) ? template(content_1, {
					value: value$1,
					name,
					percentage: is_number_default(percent$1) && !is_nil_default(value$1) ? "".concat((percent$1 * 100).toFixed(2), "%") : null
				}) : content_1;
			};
		}
		var labelLayoutType = labelCfg.type ? {
			inner: "",
			outer: "pie-outer",
			spider: "pie-spider"
		}[labelCfg.type] : "pie-outer";
		var labelLayoutCfg = labelCfg.layout ? !is_array_default(labelCfg.layout) ? [labelCfg.layout] : labelCfg.layout : [];
		labelCfg.layout = (labelLayoutType ? [{ type: labelLayoutType }] : []).concat(labelLayoutCfg);
		geometry$34.label({
			fields: colorField ? [angleField, colorField] : [angleField],
			callback,
			cfg: __assign(__assign({}, labelCfg), {
				offset: adaptOffset(labelCfg.type, labelCfg.offset),
				type: "pie"
			})
		});
	}
	return params;
}
/**
* statistic options 处理
* 1. 默认继承 default options 的样式
* 2. 默认使用 meta 的 formatter
*/
function transformStatisticOptions(options) {
	var innerRadius = options.innerRadius, statistic$3 = options.statistic, angleField = options.angleField, colorField = options.colorField, meta$22 = options.meta, locale = options.locale;
	var i18n = getLocale(locale);
	if (innerRadius && statistic$3) {
		var _a$5 = deepAssign({}, DEFAULT_OPTIONS$28.statistic, statistic$3), titleOpt_1 = _a$5.title, contentOpt_1 = _a$5.content;
		if (titleOpt_1 !== false) titleOpt_1 = deepAssign({}, { formatter: function(datum) {
			var text = datum ? datum[colorField] : !is_nil_default(titleOpt_1.content) ? titleOpt_1.content : i18n.get(["statistic", "total"]);
			return (get_default(meta$22, [colorField, "formatter"]) || (function(v) {
				return v;
			}))(text);
		} }, titleOpt_1);
		if (contentOpt_1 !== false) contentOpt_1 = deepAssign({}, { formatter: function(datum, data$2) {
			var dataValue = datum ? datum[angleField] : getTotalValue(data$2, angleField);
			var metaFormatter = get_default(meta$22, [angleField, "formatter"]) || (function(v) {
				return v;
			});
			if (datum) return metaFormatter(dataValue);
			return !is_nil_default(contentOpt_1.content) ? contentOpt_1.content : metaFormatter(dataValue);
		} }, contentOpt_1);
		return deepAssign({}, { statistic: {
			title: titleOpt_1,
			content: contentOpt_1
		} }, options);
	}
	return options;
}
/**
* statistic 中心文本配置
* @param params
*/
function pieAnnotation(params) {
	var chart = params.chart, options = params.options;
	var _a$5 = transformStatisticOptions(options), innerRadius = _a$5.innerRadius, statistic$3 = _a$5.statistic;
	chart.getController("annotation").clear(true);
	flow(annotation())(params);
	/** 中心文本 指标卡 */
	if (innerRadius && statistic$3) renderStatistic(chart, {
		statistic: statistic$3,
		plotType: "pie"
	});
	return params;
}
/**
* 饼图 tooltip 配置
* 1. 强制 tooltip.shared 为 false
* @param params
*/
function tooltip$8(params) {
	var chart = params.chart, options = params.options;
	var tooltip$10 = options.tooltip, colorField = options.colorField, angleField = options.angleField, data$2 = options.data;
	if (tooltip$10 === false) chart.tooltip(tooltip$10);
	else {
		chart.tooltip(deepAssign({}, tooltip$10, { shared: false }));
		if (isAllZero(data$2, angleField)) {
			var fields = get_default(tooltip$10, "fields");
			var formatter = get_default(tooltip$10, "formatter");
			if (is_empty_default(get_default(tooltip$10, "fields"))) {
				fields = [colorField, angleField];
				formatter = formatter || (function(datum) {
					return {
						name: datum[colorField],
						value: to_string_default(datum[angleField])
					};
				});
			}
			chart.geometries[0].tooltip(fields.join("*"), getMappingFunction(fields, formatter));
		}
	}
	return params;
}
/**
* Interaction 配置 (饼图特殊的 interaction, 中心文本变更的时候，需要将一些配置参数传进去）
* @param params
*/
function interaction$7(params) {
	var chart = params.chart, options = params.options;
	var _a$5 = transformStatisticOptions(options), interactions = _a$5.interactions, statistic$3 = _a$5.statistic, annotations = _a$5.annotations;
	each_default(interactions, function(i) {
		var _a$6, _b;
		if (i.enable === false) chart.removeInteraction(i.type);
		else if (i.type === "pie-statistic-active") {
			var startStages_1 = [];
			if (!((_a$6 = i.cfg) === null || _a$6 === void 0 ? void 0 : _a$6.start)) startStages_1 = [{
				trigger: "element:mouseenter",
				action: "".concat(PIE_STATISTIC, ":change"),
				arg: {
					statistic: statistic$3,
					annotations
				}
			}];
			each_default((_b = i.cfg) === null || _b === void 0 ? void 0 : _b.start, function(stage) {
				startStages_1.push(__assign(__assign({}, stage), { arg: {
					statistic: statistic$3,
					annotations
				} }));
			});
			chart.interaction(i.type, deepAssign({}, i.cfg, { start: startStages_1 }));
		} else chart.interaction(i.type, i.cfg || {});
	});
	return params;
}
/**
* 饼图适配器
* @param chart
* @param options
*/
function adaptor$27(params) {
	return flow(
		pattern("pieStyle"),
		geometry$22,
		meta$16,
		theme,
		coordinate$7,
		legend,
		tooltip$8,
		label$10,
		state,
		/** 指标卡中心文本 放在下层 */
		pieAnnotation,
		interaction$7,
		animation
	)(params);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/pie/index.js
var Pie = function(_super) {
	__extends(Pie$1, _super);
	function Pie$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		/** 图表类型 */
		_this.type = "pie";
		return _this;
	}
	/**
	* 获取 饼图 默认配置项
	* 供外部使用
	*/
	Pie$1.getDefaultOptions = function() {
		return DEFAULT_OPTIONS$28;
	};
	/**
	* 更新数据
	* @param data
	*/
	Pie$1.prototype.changeData = function(data$2) {
		this.chart.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, event_default.fromData(this.chart, VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
		var prevOptions = this.options;
		var angleField = this.options.angleField;
		var prevData = processIllegalData(prevOptions.data, angleField);
		var curData = processIllegalData(data$2, angleField);
		if (isAllZero(prevData, angleField) || isAllZero(curData, angleField)) this.update({ data: data$2 });
		else {
			this.updateOption({ data: data$2 });
			this.chart.data(curData);
			pieAnnotation({
				chart: this.chart,
				options: this.options
			});
			this.chart.render(true);
		}
		this.chart.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, event_default.fromData(this.chart, VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
	};
	/**
	* 获取 饼图 默认配置项, 供 base 获取
	*/
	Pie$1.prototype.getDefaultOptions = function() {
		return Pie$1.getDefaultOptions();
	};
	/**
	* 获取 饼图 的适配器
	*/
	Pie$1.prototype.getSchemaAdaptor = function() {
		return adaptor$27;
	};
	return Pie$1;
}(Plot);

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/progress/constants.js
var DEFAULT_COLOR = ["#FAAD14", "#E8EDF3"];
/**
* 默认配置项
*/
var DEFAULT_OPTIONS$27 = {
	percent: .2,
	color: DEFAULT_COLOR,
	animation: {}
};

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/progress/utils.js
/**
* 获取进度条数据
*/
function getProgressData(percent$1) {
	var clampPercent = clamp_default(isRealNumber(percent$1) ? percent$1 : 0, 0, 1);
	return [{
		current: "".concat(clampPercent),
		type: "current",
		percent: clampPercent
	}, {
		current: "".concat(clampPercent),
		type: "target",
		percent: 1
	}];
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/progress/adaptor.js
/**
* 字段
* @param params
*/
function geometry$21(params) {
	var chart = params.chart, options = params.options;
	var percent$1 = options.percent, progressStyle = options.progressStyle, color$2 = options.color, barWidthRatio = options.barWidthRatio;
	chart.data(getProgressData(percent$1));
	var p = deepAssign({}, params, { options: {
		xField: "current",
		yField: "percent",
		seriesField: "type",
		widthRatio: barWidthRatio,
		interval: {
			style: progressStyle,
			color: is_string_default(color$2) ? [color$2, DEFAULT_COLOR[1]] : color$2
		},
		args: {
			zIndexReversed: true,
			sortZIndex: true
		}
	} });
	interval(p);
	chart.tooltip(false);
	chart.axis(false);
	chart.legend(false);
	return params;
}
/**
* other 配置
* @param params
*/
function coordinate$6(params) {
	params.chart.coordinate("rect").transpose();
	return params;
}
/**
* 进度图适配器
* @param chart
* @param options
*/
function adaptor$28(params) {
	return flow(geometry$21, scale({}), coordinate$6, animation, theme, annotation())(params);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/progress/index.js
var Progress = function(_super) {
	__extends(Progress$1, _super);
	function Progress$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		/** 图表类型 */
		_this.type = "process";
		return _this;
	}
	/**
	* 获取 仪表盘 默认配置项
	* 供外部使用
	*/
	Progress$1.getDefaultOptions = function() {
		return DEFAULT_OPTIONS$27;
	};
	/**
	* 更新数据
	* @param percent
	*/
	Progress$1.prototype.changeData = function(percent$1) {
		this.updateOption({ percent: percent$1 });
		this.chart.changeData(getProgressData(percent$1));
	};
	Progress$1.prototype.getDefaultOptions = function() {
		return Progress$1.getDefaultOptions();
	};
	/**
	* 获取 进度图 的适配器
	*/
	Progress$1.prototype.getSchemaAdaptor = function() {
		return adaptor$28;
	};
	return Progress$1;
}(Plot);

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/ring-progress/adaptor.js
/**
* coordinate 配置
* @param params
*/
function coordinate$5(params) {
	var chart = params.chart, options = params.options;
	var innerRadius = options.innerRadius, radius = options.radius;
	chart.coordinate("theta", {
		innerRadius,
		radius
	});
	return params;
}
/**
* statistic 配置
* @param params
*/
function statistic$1(params, updated) {
	var chart = params.chart, options = params.options;
	var innerRadius = options.innerRadius, statistic$3 = options.statistic, percent$1 = options.percent, meta$22 = options.meta;
	chart.getController("annotation").clear(true);
	/** 中心文本 指标卡 */
	if (innerRadius && statistic$3) {
		var metaFormatter = get_default(meta$22, ["percent", "formatter"]) || (function(v) {
			return "".concat((v * 100).toFixed(2), "%");
		});
		var contentOpt = statistic$3.content;
		if (contentOpt) contentOpt = deepAssign({}, contentOpt, { content: !is_nil_default(contentOpt.content) ? contentOpt.content : metaFormatter(percent$1) });
		renderStatistic(chart, {
			statistic: __assign(__assign({}, statistic$3), { content: contentOpt }),
			plotType: "ring-progress"
		}, { percent: percent$1 });
	}
	if (updated) chart.render(true);
	return params;
}
/**
* 环形进度图适配器
* @param chart
* @param options
*/
function adaptor$29(params) {
	return flow(geometry$21, scale({}), coordinate$5, statistic$1, animation, theme, annotation())(params);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/ring-progress/constants.js
/**
* 仪表盘默认配置项
*/
var DEFAULT_OPTIONS$26 = {
	percent: .2,
	innerRadius: .8,
	radius: .98,
	color: ["#FAAD14", "#E8EDF3"],
	statistic: {
		title: false,
		content: { style: {
			fontSize: "14px",
			fontWeight: 300,
			fill: "#4D4D4D",
			textAlign: "center",
			textBaseline: "middle"
		} }
	},
	animation: {}
};

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/ring-progress/index.js
var RingProgress = function(_super) {
	__extends(RingProgress$1, _super);
	function RingProgress$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		/** 图表类型 */
		_this.type = "ring-process";
		return _this;
	}
	/**
	* 获取默认配置项
	* 供外部使用
	*/
	RingProgress$1.getDefaultOptions = function() {
		return DEFAULT_OPTIONS$26;
	};
	/**
	* 更新数据
	* @param percent
	*/
	RingProgress$1.prototype.changeData = function(percent$1) {
		this.chart.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, event_default.fromData(this.chart, VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
		this.updateOption({ percent: percent$1 });
		this.chart.data(getProgressData(percent$1));
		statistic$1({
			chart: this.chart,
			options: this.options
		}, true);
		this.chart.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, event_default.fromData(this.chart, VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
	};
	RingProgress$1.prototype.getDefaultOptions = function() {
		return RingProgress$1.getDefaultOptions();
	};
	/**
	* 获取 环形进度图 的适配器
	*/
	RingProgress$1.prototype.getSchemaAdaptor = function() {
		return adaptor$29;
	};
	return RingProgress$1;
}(Plot);

//#endregion
//#region node_modules/d3-regression/dist/d3-regression.js
var require_d3_regression = /* @__PURE__ */ __commonJS({ "node_modules/d3-regression/dist/d3-regression.js": ((exports, module) => {
	(function(global, factory) {
		typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global = global || self, factory(global.d3 = {}));
	})(exports, (function(exports$1) {
		function _slicedToArray(arr, i) {
			return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
		}
		function _arrayWithHoles(arr) {
			if (Array.isArray(arr)) return arr;
		}
		function _iterableToArrayLimit(arr, i) {
			var _arr = [];
			var _n = true;
			var _d = false;
			var _e = void 0;
			try {
				for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
					_arr.push(_s.value);
					if (i && _arr.length === i) break;
				}
			} catch (err) {
				_d = true;
				_e = err;
			} finally {
				try {
					if (!_n && _i["return"] != null) _i["return"]();
				} finally {
					if (_d) throw _e;
				}
			}
			return _arr;
		}
		function _nonIterableRest() {
			throw new TypeError("Invalid attempt to destructure non-iterable instance");
		}
		function points(data$2, x, y, sort) {
			data$2 = data$2.filter(function(d$1, i$1) {
				var u = x(d$1, i$1), v = y(d$1, i$1);
				return u != null && isFinite(u) && v != null && isFinite(v);
			});
			if (sort) data$2.sort(function(a, b) {
				return x(a) - x(b);
			});
			var n = data$2.length, X = new Float64Array(n), Y = new Float64Array(n);
			var ux = 0, uy = 0, xv, yv, d;
			for (var i = 0; i < n;) {
				d = data$2[i];
				X[i] = xv = +x(d, i, data$2);
				Y[i] = yv = +y(d, i, data$2);
				++i;
				ux += (xv - ux) / i;
				uy += (yv - uy) / i;
			}
			for (var _i = 0; _i < n; ++_i) {
				X[_i] -= ux;
				Y[_i] -= uy;
			}
			return [
				X,
				Y,
				ux,
				uy
			];
		}
		function visitPoints(data$2, x, y, cb) {
			var iterations = 0;
			for (var i = 0, n = data$2.length; i < n; i++) {
				var d = data$2[i], dx = +x(d, i, data$2), dy = +y(d, i, data$2);
				if (dx != null && isFinite(dx) && dy != null && isFinite(dy)) cb(dx, dy, iterations++);
			}
		}
		function determination(data$2, x, y, uY, predict) {
			var SSE = 0, SST = 0;
			visitPoints(data$2, x, y, function(dx, dy) {
				var sse = dy - predict(dx), sst = dy - uY;
				SSE += sse * sse;
				SST += sst * sst;
			});
			return 1 - SSE / SST;
		}
		function angle$1(line$1) {
			return Math.atan2(line$1[1][1] - line$1[0][1], line$1[1][0] - line$1[0][0]) * 180 / Math.PI;
		}
		function midpoint(line$1) {
			return [(line$1[0][0] + line$1[1][0]) / 2, (line$1[0][1] + line$1[1][1]) / 2];
		}
		function interpose(xmin, xmax, predict) {
			var l = Math.log(xmax - xmin) * Math.LOG10E + 1 | 0;
			var precision = 1 * Math.pow(10, -l / 2 - 1), maxIter = 1e4;
			var points$1 = [px(xmin), px(xmax)], iter = 0;
			while (find$2(points$1) && iter < maxIter);
			return points$1;
			function px(x) {
				return [x, predict(x)];
			}
			function find$2(points$2) {
				iter++;
				var n = points$2.length;
				var found = false;
				for (var i = 0; i < n - 1; i++) {
					var p0 = points$2[i], p1 = points$2[i + 1], m = midpoint([p0, p1]), mp = px(m[0]), a0 = angle$1([p0, m]), a1 = angle$1([p0, mp]);
					if (Math.abs(a0 - a1) > precision) {
						points$2.splice(i + 1, 0, mp);
						found = true;
					}
				}
				return found;
			}
		}
		function ols(uX, uY, uXY, uX2) {
			var delta = uX2 - uX * uX, slope = Math.abs(delta) < 1e-24 ? 0 : (uXY - uX * uY) / delta;
			return [uY - slope * uX, slope];
		}
		function exponential$1() {
			var x = function x$1(d) {
				return d[0];
			}, y = function y$1(d) {
				return d[1];
			}, domain;
			function exponential$2(data$2) {
				var n = 0, Y = 0, YL = 0, XY = 0, XYL = 0, X2Y = 0, xmin = domain ? +domain[0] : Infinity, xmax = domain ? +domain[1] : -Infinity;
				visitPoints(data$2, x, y, function(dx, dy) {
					var ly = Math.log(dy), xy = dx * dy;
					++n;
					Y += (dy - Y) / n;
					XY += (xy - XY) / n;
					X2Y += (dx * xy - X2Y) / n;
					YL += (dy * ly - YL) / n;
					XYL += (xy * ly - XYL) / n;
					if (!domain) {
						if (dx < xmin) xmin = dx;
						if (dx > xmax) xmax = dx;
					}
				});
				var _ols = ols(XY / Y, YL / Y, XYL / Y, X2Y / Y), _ols2 = _slicedToArray(_ols, 2), a = _ols2[0], b = _ols2[1];
				a = Math.exp(a);
				var fn = function fn$1(x$1) {
					return a * Math.exp(b * x$1);
				}, out = interpose(xmin, xmax, fn);
				out.a = a;
				out.b = b;
				out.predict = fn;
				out.rSquared = determination(data$2, x, y, Y, fn);
				return out;
			}
			exponential$2.domain = function(arr) {
				return arguments.length ? (domain = arr, exponential$2) : domain;
			};
			exponential$2.x = function(fn) {
				return arguments.length ? (x = fn, exponential$2) : x;
			};
			exponential$2.y = function(fn) {
				return arguments.length ? (y = fn, exponential$2) : y;
			};
			return exponential$2;
		}
		function linear$3() {
			var x = function x$1(d) {
				return d[0];
			}, y = function y$1(d) {
				return d[1];
			}, domain;
			function linear$4(data$2) {
				var n = 0, X = 0, Y = 0, XY = 0, X2 = 0, xmin = domain ? +domain[0] : Infinity, xmax = domain ? +domain[1] : -Infinity;
				visitPoints(data$2, x, y, function(dx, dy) {
					++n;
					X += (dx - X) / n;
					Y += (dy - Y) / n;
					XY += (dx * dy - XY) / n;
					X2 += (dx * dx - X2) / n;
					if (!domain) {
						if (dx < xmin) xmin = dx;
						if (dx > xmax) xmax = dx;
					}
				});
				var _ols = ols(X, Y, XY, X2), _ols2 = _slicedToArray(_ols, 2), intercept = _ols2[0], slope = _ols2[1], fn = function fn$1(x$1) {
					return slope * x$1 + intercept;
				}, out = [[xmin, fn(xmin)], [xmax, fn(xmax)]];
				out.a = slope;
				out.b = intercept;
				out.predict = fn;
				out.rSquared = determination(data$2, x, y, Y, fn);
				return out;
			}
			linear$4.domain = function(arr) {
				return arguments.length ? (domain = arr, linear$4) : domain;
			};
			linear$4.x = function(fn) {
				return arguments.length ? (x = fn, linear$4) : x;
			};
			linear$4.y = function(fn) {
				return arguments.length ? (y = fn, linear$4) : y;
			};
			return linear$4;
		}
		function median(arr) {
			arr.sort(function(a, b) {
				return a - b;
			});
			var i = arr.length / 2;
			return i % 1 === 0 ? (arr[i - 1] + arr[i]) / 2 : arr[Math.floor(i)];
		}
		var maxiters = 2, epsilon = 1e-12;
		function loess() {
			var x = function x$1(d) {
				return d[0];
			}, y = function y$1(d) {
				return d[1];
			}, bandwidth = .3;
			function loess$1(data$2) {
				var _points = points(data$2, x, y, true), _points2 = _slicedToArray(_points, 4), xv = _points2[0], yv = _points2[1], ux = _points2[2], uy = _points2[3], n = xv.length, bw = Math.max(2, ~~(bandwidth * n)), yhat = new Float64Array(n), residuals = new Float64Array(n), robustWeights = new Float64Array(n).fill(1);
				for (var iter = -1; ++iter <= maxiters;) {
					var interval$2 = [0, bw - 1];
					for (var i = 0; i < n; ++i) {
						var dx = xv[i], i0 = interval$2[0], i1 = interval$2[1], edge$1 = dx - xv[i0] > xv[i1] - dx ? i0 : i1;
						var W = 0, X = 0, Y = 0, XY = 0, X2 = 0, denom = 1 / Math.abs(xv[edge$1] - dx || 1);
						for (var k = i0; k <= i1; ++k) {
							var xk = xv[k], yk = yv[k], w = tricube(Math.abs(dx - xk) * denom) * robustWeights[k], xkw = xk * w;
							W += w;
							X += xkw;
							Y += yk * w;
							XY += yk * xkw;
							X2 += xk * xkw;
						}
						var _ols = ols(X / W, Y / W, XY / W, X2 / W), _ols2 = _slicedToArray(_ols, 2), a = _ols2[0], b = _ols2[1];
						yhat[i] = a + b * dx;
						residuals[i] = Math.abs(yv[i] - yhat[i]);
						updateInterval(xv, i + 1, interval$2);
					}
					if (iter === maxiters) break;
					var medianResidual = median(residuals);
					if (Math.abs(medianResidual) < epsilon) break;
					for (var _i = 0, arg, _w; _i < n; ++_i) {
						arg = residuals[_i] / (6 * medianResidual);
						robustWeights[_i] = arg >= 1 ? epsilon : (_w = 1 - arg * arg) * _w;
					}
				}
				return output(xv, yhat, ux, uy);
			}
			loess$1.bandwidth = function(bw) {
				return arguments.length ? (bandwidth = bw, loess$1) : bandwidth;
			};
			loess$1.x = function(fn) {
				return arguments.length ? (x = fn, loess$1) : x;
			};
			loess$1.y = function(fn) {
				return arguments.length ? (y = fn, loess$1) : y;
			};
			return loess$1;
		}
		function tricube(x) {
			return (x = 1 - x * x * x) * x * x;
		}
		function updateInterval(xv, i, interval$2) {
			var val = xv[i], left$1 = interval$2[0], right$1 = interval$2[1] + 1;
			if (right$1 >= xv.length) return;
			while (i > left$1 && xv[right$1] - val <= val - xv[left$1]) {
				interval$2[0] = ++left$1;
				interval$2[1] = right$1;
				++right$1;
			}
		}
		function output(xv, yhat, ux, uy) {
			var n = xv.length, out = [];
			var i = 0, cnt = 0, prev = [], v;
			for (; i < n; ++i) {
				v = xv[i] + ux;
				if (prev[0] === v) prev[1] += (yhat[i] - prev[1]) / ++cnt;
				else {
					cnt = 0;
					prev[1] += uy;
					prev = [v, yhat[i]];
					out.push(prev);
				}
			}
			prev[1] += uy;
			return out;
		}
		function logarithmic() {
			var x = function x$1(d) {
				return d[0];
			}, y = function y$1(d) {
				return d[1];
			}, base = Math.E, domain;
			function logarithmic$1(data$2) {
				var n = 0, X = 0, Y = 0, XY = 0, X2 = 0, xmin = domain ? +domain[0] : Infinity, xmax = domain ? +domain[1] : -Infinity, lb = Math.log(base);
				visitPoints(data$2, x, y, function(dx, dy) {
					var lx = Math.log(dx) / lb;
					++n;
					X += (lx - X) / n;
					Y += (dy - Y) / n;
					XY += (lx * dy - XY) / n;
					X2 += (lx * lx - X2) / n;
					if (!domain) {
						if (dx < xmin) xmin = dx;
						if (dx > xmax) xmax = dx;
					}
				});
				var _ols = ols(X, Y, XY, X2), _ols2 = _slicedToArray(_ols, 2), intercept = _ols2[0], slope = _ols2[1], fn = function fn$1(x$1) {
					return slope * Math.log(x$1) / lb + intercept;
				}, out = interpose(xmin, xmax, fn);
				out.a = slope;
				out.b = intercept;
				out.predict = fn;
				out.rSquared = determination(data$2, x, y, Y, fn);
				return out;
			}
			logarithmic$1.domain = function(arr) {
				return arguments.length ? (domain = arr, logarithmic$1) : domain;
			};
			logarithmic$1.x = function(fn) {
				return arguments.length ? (x = fn, logarithmic$1) : x;
			};
			logarithmic$1.y = function(fn) {
				return arguments.length ? (y = fn, logarithmic$1) : y;
			};
			logarithmic$1.base = function(n) {
				return arguments.length ? (base = n, logarithmic$1) : base;
			};
			return logarithmic$1;
		}
		function quad() {
			var x = function x$1(d) {
				return d[0];
			}, y = function y$1(d) {
				return d[1];
			}, domain;
			function quadratic(data$2) {
				var _points = points(data$2, x, y), _points2 = _slicedToArray(_points, 4), xv = _points2[0], yv = _points2[1], ux = _points2[2], uy = _points2[3], n = xv.length;
				var X2 = 0, X3 = 0, X4 = 0, XY = 0, X2Y = 0, i, dx, dy, x2;
				for (i = 0; i < n;) {
					dx = xv[i];
					dy = yv[i++];
					x2 = dx * dx;
					X2 += (x2 - X2) / i;
					X3 += (x2 * dx - X3) / i;
					X4 += (x2 * x2 - X4) / i;
					XY += (dx * dy - XY) / i;
					X2Y += (x2 * dy - X2Y) / i;
				}
				var Y = 0, n0 = 0, xmin = domain ? +domain[0] : Infinity, xmax = domain ? +domain[1] : -Infinity;
				visitPoints(data$2, x, y, function(dx$1, dy$1) {
					n0++;
					Y += (dy$1 - Y) / n0;
					if (!domain) {
						if (dx$1 < xmin) xmin = dx$1;
						if (dx$1 > xmax) xmax = dx$1;
					}
				});
				var X2X2 = X4 - X2 * X2, d = X2 * X2X2 - X3 * X3, a = (X2Y * X2 - XY * X3) / d, b = (XY * X2X2 - X2Y * X3) / d, c = -a * X2, fn = function fn$1(x$1) {
					x$1 = x$1 - ux;
					return a * x$1 * x$1 + b * x$1 + c + uy;
				};
				var out = interpose(xmin, xmax, fn);
				out.a = a;
				out.b = b - 2 * a * ux;
				out.c = c - b * ux + a * ux * ux + uy;
				out.predict = fn;
				out.rSquared = determination(data$2, x, y, Y, fn);
				return out;
			}
			quadratic.domain = function(arr) {
				return arguments.length ? (domain = arr, quadratic) : domain;
			};
			quadratic.x = function(fn) {
				return arguments.length ? (x = fn, quadratic) : x;
			};
			quadratic.y = function(fn) {
				return arguments.length ? (y = fn, quadratic) : y;
			};
			return quadratic;
		}
		function polynomial() {
			var x = function x$1(d) {
				return d[0];
			}, y = function y$1(d) {
				return d[1];
			}, order = 3, domain;
			function polynomial$1(data$2) {
				if (order === 1) {
					var o = linear$3().x(x).y(y).domain(domain)(data$2);
					o.coefficients = [o.b, o.a];
					delete o.a;
					delete o.b;
					return o;
				}
				if (order === 2) {
					var _o = quad().x(x).y(y).domain(domain)(data$2);
					_o.coefficients = [
						_o.c,
						_o.b,
						_o.a
					];
					delete _o.a;
					delete _o.b;
					delete _o.c;
					return _o;
				}
				var _points = points(data$2, x, y), _points2 = _slicedToArray(_points, 4), xv = _points2[0], yv = _points2[1], ux = _points2[2], uy = _points2[3], n = xv.length, lhs = [], rhs = [], k = order + 1;
				var Y = 0, n0 = 0, xmin = domain ? +domain[0] : Infinity, xmax = domain ? +domain[1] : -Infinity;
				visitPoints(data$2, x, y, function(dx, dy) {
					++n0;
					Y += (dy - Y) / n0;
					if (!domain) {
						if (dx < xmin) xmin = dx;
						if (dx > xmax) xmax = dx;
					}
				});
				var i, j, l, v, c;
				for (i = 0; i < k; ++i) {
					for (l = 0, v = 0; l < n; ++l) v += Math.pow(xv[l], i) * yv[l];
					lhs.push(v);
					c = new Float64Array(k);
					for (j = 0; j < k; ++j) {
						for (l = 0, v = 0; l < n; ++l) v += Math.pow(xv[l], i + j);
						c[j] = v;
					}
					rhs.push(c);
				}
				rhs.push(lhs);
				var coef = gaussianElimination(rhs), fn = function fn$1(x$1) {
					x$1 -= ux;
					var y$1 = uy + coef[0] + coef[1] * x$1 + coef[2] * x$1 * x$1;
					for (i = 3; i < k; ++i) y$1 += coef[i] * Math.pow(x$1, i);
					return y$1;
				}, out = interpose(xmin, xmax, fn);
				out.coefficients = uncenter(k, coef, -ux, uy);
				out.predict = fn;
				out.rSquared = determination(data$2, x, y, Y, fn);
				return out;
			}
			polynomial$1.domain = function(arr) {
				return arguments.length ? (domain = arr, polynomial$1) : domain;
			};
			polynomial$1.x = function(fn) {
				return arguments.length ? (x = fn, polynomial$1) : x;
			};
			polynomial$1.y = function(fn) {
				return arguments.length ? (y = fn, polynomial$1) : y;
			};
			polynomial$1.order = function(n) {
				return arguments.length ? (order = n, polynomial$1) : order;
			};
			return polynomial$1;
		}
		function uncenter(k, a, x, y) {
			var z = Array(k);
			var i, j, v, c;
			for (i = 0; i < k; ++i) z[i] = 0;
			for (i = k - 1; i >= 0; --i) {
				v = a[i];
				c = 1;
				z[i] += v;
				for (j = 1; j <= i; ++j) {
					c *= (i + 1 - j) / j;
					z[i - j] += v * Math.pow(x, j) * c;
				}
			}
			z[0] += y;
			return z;
		}
		function gaussianElimination(matrix) {
			var n = matrix.length - 1, coef = [];
			var i, j, k, r, t;
			for (i = 0; i < n; ++i) {
				r = i;
				for (j = i + 1; j < n; ++j) if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][r])) r = j;
				for (k = i; k < n + 1; ++k) {
					t = matrix[k][i];
					matrix[k][i] = matrix[k][r];
					matrix[k][r] = t;
				}
				for (j = i + 1; j < n; ++j) for (k = n; k >= i; k--) matrix[k][j] -= matrix[k][i] * matrix[i][j] / matrix[i][i];
			}
			for (j = n - 1; j >= 0; --j) {
				t = 0;
				for (k = j + 1; k < n; ++k) t += matrix[k][j] * coef[k];
				coef[j] = (matrix[n][j] - t) / matrix[j][j];
			}
			return coef;
		}
		function power() {
			var x = function x$1(d) {
				return d[0];
			}, y = function y$1(d) {
				return d[1];
			}, domain;
			function power$1(data$2) {
				var n = 0, X = 0, Y = 0, XY = 0, X2 = 0, YS = 0, xmin = domain ? +domain[0] : Infinity, xmax = domain ? +domain[1] : -Infinity;
				visitPoints(data$2, x, y, function(dx, dy) {
					var lx = Math.log(dx), ly = Math.log(dy);
					++n;
					X += (lx - X) / n;
					Y += (ly - Y) / n;
					XY += (lx * ly - XY) / n;
					X2 += (lx * lx - X2) / n;
					YS += (dy - YS) / n;
					if (!domain) {
						if (dx < xmin) xmin = dx;
						if (dx > xmax) xmax = dx;
					}
				});
				var _ols = ols(X, Y, XY, X2), _ols2 = _slicedToArray(_ols, 2), a = _ols2[0], b = _ols2[1];
				a = Math.exp(a);
				var fn = function fn$1(x$1) {
					return a * Math.pow(x$1, b);
				}, out = interpose(xmin, xmax, fn);
				out.a = a;
				out.b = b;
				out.predict = fn;
				out.rSquared = determination(data$2, x, y, YS, fn);
				return out;
			}
			power$1.domain = function(arr) {
				return arguments.length ? (domain = arr, power$1) : domain;
			};
			power$1.x = function(fn) {
				return arguments.length ? (x = fn, power$1) : x;
			};
			power$1.y = function(fn) {
				return arguments.length ? (y = fn, power$1) : y;
			};
			return power$1;
		}
		exports$1.regressionExp = exponential$1;
		exports$1.regressionLinear = linear$3;
		exports$1.regressionLoess = loess;
		exports$1.regressionLog = logarithmic;
		exports$1.regressionPoly = polynomial;
		exports$1.regressionPow = power;
		exports$1.regressionQuad = quad;
		Object.defineProperty(exports$1, "__esModule", { value: true });
	}));
}) });

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/scatter/util.js
var import_d3_regression = /* @__PURE__ */ __toESM(require_d3_regression());
var REGRESSION_MAP = {
	exp: import_d3_regression.regressionExp,
	linear: import_d3_regression.regressionLinear,
	loess: import_d3_regression.regressionLoess,
	log: import_d3_regression.regressionLog,
	poly: import_d3_regression.regressionPoly,
	pow: import_d3_regression.regressionPow,
	quad: import_d3_regression.regressionQuad
};
/**
* 获取四象限默认配置
* @param {number} xBaseline
* @param {number} yBaseline
*/
function getQuadrantDefaultConfig(xBaseline, yBaseline) {
	var textOffset = 10;
	return {
		regionStyle: [
			{
				position: {
					start: [xBaseline, "max"],
					end: ["max", yBaseline]
				},
				style: {
					fill: "#d8d0c0",
					opacity: .4
				}
			},
			{
				position: {
					start: ["min", "max"],
					end: [xBaseline, yBaseline]
				},
				style: {
					fill: "#a3dda1",
					opacity: .4
				}
			},
			{
				position: {
					start: ["min", yBaseline],
					end: [xBaseline, "min"]
				},
				style: {
					fill: "#d8d0c0",
					opacity: .4
				}
			},
			{
				position: {
					start: [xBaseline, yBaseline],
					end: ["max", "min"]
				},
				style: {
					fill: "#a3dda1",
					opacity: .4
				}
			}
		],
		lineStyle: {
			stroke: "#9ba29a",
			lineWidth: 1
		},
		labelStyle: [
			{
				position: ["max", yBaseline],
				offsetX: -textOffset,
				offsetY: -textOffset,
				style: {
					textAlign: "right",
					textBaseline: "bottom",
					fontSize: 14,
					fill: "#ccc"
				}
			},
			{
				position: ["min", yBaseline],
				offsetX: textOffset,
				offsetY: -textOffset,
				style: {
					textAlign: "left",
					textBaseline: "bottom",
					fontSize: 14,
					fill: "#ccc"
				}
			},
			{
				position: ["min", yBaseline],
				offsetX: textOffset,
				offsetY: textOffset,
				style: {
					textAlign: "left",
					textBaseline: "top",
					fontSize: 14,
					fill: "#ccc"
				}
			},
			{
				position: ["max", yBaseline],
				offsetX: -textOffset,
				offsetY: textOffset,
				style: {
					textAlign: "right",
					textBaseline: "top",
					fontSize: 14,
					fill: "#ccc"
				}
			}
		]
	};
}
var splinePath = function(data$2, config) {
	var view = config.view, _a$5 = config.options, xField = _a$5.xField, yField = _a$5.yField;
	var xScaleView = view.getScaleByField(xField);
	var yScaleView = view.getScaleByField(yField);
	var pathData = data$2.map(function(d) {
		return view.getCoordinate().convert({
			x: xScaleView.scale(d[0]),
			y: yScaleView.scale(d[1])
		});
	});
	return getSplinePath(pathData, false);
};
var getPath = function(config) {
	var options = config.options;
	var xField = options.xField, yField = options.yField, data$2 = options.data, regressionLine$1 = options.regressionLine;
	var _a$5 = regressionLine$1.type, type = _a$5 === void 0 ? "linear" : _a$5, algorithm = regressionLine$1.algorithm, customEquation = regressionLine$1.equation;
	var pathData;
	var equation = null;
	if (algorithm) {
		pathData = is_array_default(algorithm) ? algorithm : algorithm(data$2);
		equation = customEquation;
	} else {
		pathData = REGRESSION_MAP[type]().x(function(d) {
			return d[xField];
		}).y(function(d) {
			return d[yField];
		})(data$2);
		equation = getRegressionEquation(type, pathData);
	}
	return [splinePath(pathData, config), equation];
};
/**
* 调整散点图 meta: { min, max } ① data.length === 1 ② 所有数据 y 值相等 ③ 所有数据 x 值相等
* @param options
* @returns
*/
var getMeta = function(options) {
	var _a$5;
	var _b = options.meta, meta$22 = _b === void 0 ? {} : _b, xField = options.xField, yField = options.yField, data$2 = options.data;
	var xFieldValue = data$2[0][xField];
	var yFieldValue = data$2[0][yField];
	var xIsPositiveNumber = xFieldValue > 0;
	var yIsPositiveNumber = yFieldValue > 0;
	/**
	* 获得对应字段的 min max scale 配置
	*/
	function getMetaMinMax(field$5, axis$21) {
		var fieldMeta = get_default(meta$22, [field$5]);
		function getCustomValue(type) {
			return get_default(fieldMeta, type);
		}
		var range = {};
		if (axis$21 === "x") {
			if (is_number_default(xFieldValue)) {
				if (!is_number_default(getCustomValue("min"))) range["min"] = xIsPositiveNumber ? 0 : xFieldValue * 2;
				if (!is_number_default(getCustomValue("max"))) range["max"] = xIsPositiveNumber ? xFieldValue * 2 : 0;
			}
			return range;
		}
		if (is_number_default(yFieldValue)) {
			if (!is_number_default(getCustomValue("min"))) range["min"] = yIsPositiveNumber ? 0 : yFieldValue * 2;
			if (!is_number_default(getCustomValue("max"))) range["max"] = yIsPositiveNumber ? yFieldValue * 2 : 0;
		}
		return range;
	}
	return __assign(__assign({}, meta$22), (_a$5 = {}, _a$5[xField] = __assign(__assign({}, meta$22[xField]), getMetaMinMax(xField, "x")), _a$5[yField] = __assign(__assign({}, meta$22[yField]), getMetaMinMax(yField, "y")), _a$5));
};
/**
* 获取回归函数表达式
* @param {string} type - 回归函数类型
* @param {D3RegressionResult} res - 回归计算结果集
* @return {string}
*/
function getRegressionEquation(type, res) {
	var _a$5, _b, _c;
	var roundByPrecision = function(n, p) {
		if (p === void 0) p = 4;
		return Math.round(n * Math.pow(10, p)) / Math.pow(10, p);
	};
	var safeFormat = function(value$1) {
		return Number.isFinite(value$1) ? roundByPrecision(value$1) : "?";
	};
	switch (type) {
		case "linear": return "y = ".concat(safeFormat(res.a), "x + ").concat(safeFormat(res.b), ", R^2 = ").concat(safeFormat(res.rSquared));
		case "exp": return "y = ".concat(safeFormat(res.a), "e^(").concat(safeFormat(res.b), "x), R^2 = ").concat(safeFormat(res.rSquared));
		case "log": return "y = ".concat(safeFormat(res.a), "ln(x) + ").concat(safeFormat(res.b), ", R^2 = ").concat(safeFormat(res.rSquared));
		case "quad": return "y = ".concat(safeFormat(res.a), "x^2 + ").concat(safeFormat(res.b), "x + ").concat(safeFormat(res.c), ", R^2 = ").concat(safeFormat(res.rSquared));
		case "poly":
			var temp = "y = ".concat(safeFormat((_a$5 = res.coefficients) === null || _a$5 === void 0 ? void 0 : _a$5[0]), " + ").concat(safeFormat((_b = res.coefficients) === null || _b === void 0 ? void 0 : _b[1]), "x + ").concat(safeFormat((_c = res.coefficients) === null || _c === void 0 ? void 0 : _c[2]), "x^2");
			for (var i = 3; i < res.coefficients.length; ++i) temp += " + ".concat(safeFormat(res.coefficients[i]), "x^").concat(i);
			return "".concat(temp, ", R^2 = ").concat(safeFormat(res.rSquared));
		case "pow": return "y = ".concat(safeFormat(res.a), "x^").concat(safeFormat(res.b), ", R^2 = ").concat(safeFormat(res.rSquared));
	}
	return null;
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/scatter/adaptor.js
/**
* 散点图默认美观
* ① data.length === 1 ② 所有数据 y 值相等 ③ 所有数据 x 值相等
* @param params
* @returns params
*/
function transformOptions$1(options) {
	var _a$5 = options.data, data$2 = _a$5 === void 0 ? [] : _a$5, xField = options.xField, yField = options.yField;
	if (data$2.length) {
		var isOneX = true;
		var isOneY = true;
		var prev = data$2[0];
		var curr = void 0;
		for (var i = 1; i < data$2.length; i++) {
			curr = data$2[i];
			if (prev[xField] !== curr[xField]) isOneX = false;
			if (prev[yField] !== curr[yField]) isOneY = false;
			if (!isOneX && !isOneY) break;
			prev = curr;
		}
		var keys$1 = [];
		isOneX && keys$1.push(xField);
		isOneY && keys$1.push(yField);
		var meta_1 = pick(getMeta(options), keys$1);
		return deepAssign({}, options, { meta: meta_1 });
	}
	return options;
}
/**
* 字段
* @param params
*/
function geometry$20(params) {
	var chart = params.chart, options = params.options;
	var data$2 = options.data, type = options.type, color$2 = options.color, shape = options.shape, pointStyle = options.pointStyle, shapeField = options.shapeField, colorField = options.colorField, xField = options.xField, yField = options.yField, sizeField = options.sizeField;
	var size$1 = options.size;
	var tooltip$10 = options.tooltip;
	if (sizeField) {
		if (!size$1) size$1 = [2, 8];
		if (is_number_default(size$1)) size$1 = [size$1, size$1];
	}
	if (tooltip$10 && !tooltip$10.fields) tooltip$10 = __assign(__assign({}, tooltip$10), { fields: [
		xField,
		yField,
		colorField,
		sizeField,
		shapeField
	] });
	chart.data(data$2);
	point(deepAssign({}, params, { options: {
		seriesField: colorField,
		point: {
			color: color$2,
			shape,
			size: size$1,
			style: pointStyle
		},
		tooltip: tooltip$10
	} }));
	var geometry$34 = findGeometry(chart, "point");
	if (type) geometry$34.adjust(type);
	return params;
}
/**
* meta 配置
* @param params
*/
function meta$15(params) {
	var _a$5;
	var options = params.options;
	var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
	var newOptions = transformOptions$1(options);
	return flow(scale((_a$5 = {}, _a$5[xField] = xAxis, _a$5[yField] = yAxis, _a$5)))(deepAssign({}, params, { options: newOptions }));
}
/**
* axis 配置
* @param params
*/
function axis$16(params) {
	var chart = params.chart, options = params.options;
	var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
	chart.axis(xField, xAxis);
	chart.axis(yField, yAxis);
	return params;
}
/**
* legend 配置
* @param params
*/
function legend$12(params) {
	var chart = params.chart, options = params.options;
	var legend$17 = options.legend, colorField = options.colorField, shapeField = options.shapeField, sizeField = options.sizeField, shapeLegend = options.shapeLegend, sizeLegend = options.sizeLegend;
	/** legend 不为 false, 则展示图例, 优先展示 color 分类图例 */
	var showLegend = legend$17 !== false;
	if (colorField) chart.legend(colorField, showLegend ? legend$17 : false);
	if (shapeField) if (shapeLegend) chart.legend(shapeField, shapeLegend);
	else chart.legend(shapeField, shapeLegend === false ? false : legend$17);
	if (sizeField) chart.legend(sizeField, sizeLegend ? sizeLegend : false);
	/** 默认不展示 shape 图例，当 shapeLegend 为 undefined 也不展示图例 */
	/** 默认没有 sizeField，则隐藏连续图例 */
	if (!showLegend && !shapeLegend && !sizeLegend) chart.legend(false);
	return params;
}
/**
* 数据标签
* @param params
*/
function label$9(params) {
	var chart = params.chart, options = params.options;
	var label$16 = options.label, yField = options.yField;
	var scatterGeometry = findGeometry(chart, "point");
	if (!label$16) scatterGeometry.label(false);
	else {
		var callback = label$16.callback, cfg = __rest(label$16, ["callback"]);
		scatterGeometry.label({
			fields: [yField],
			callback,
			cfg: transformLabel(cfg)
		});
	}
	return params;
}
/**
* annotation 配置
* - 特殊 annotation: quadrant(四象限)
* @param params
*/
function scatterAnnotation(params) {
	var quadrant = params.options.quadrant;
	var annotationOptions = [];
	if (quadrant) {
		var _a$5 = quadrant.xBaseline, xBaseline = _a$5 === void 0 ? 0 : _a$5, _b = quadrant.yBaseline, yBaseline = _b === void 0 ? 0 : _b, labels_1 = quadrant.labels, regionStyle_1 = quadrant.regionStyle, lineStyle = quadrant.lineStyle;
		var defaultConfig_1 = getQuadrantDefaultConfig(xBaseline, yBaseline);
		new Array(4).join(",").split(",").forEach(function(_, index) {
			annotationOptions.push(__assign(__assign({
				type: "region",
				top: false
			}, defaultConfig_1.regionStyle[index].position), { style: deepAssign({}, defaultConfig_1.regionStyle[index].style, regionStyle_1 === null || regionStyle_1 === void 0 ? void 0 : regionStyle_1[index]) }), __assign({
				type: "text",
				top: true
			}, deepAssign({}, defaultConfig_1.labelStyle[index], labels_1 === null || labels_1 === void 0 ? void 0 : labels_1[index])));
		});
		annotationOptions.push({
			type: "line",
			top: false,
			start: ["min", yBaseline],
			end: ["max", yBaseline],
			style: deepAssign({}, defaultConfig_1.lineStyle, lineStyle)
		}, {
			type: "line",
			top: false,
			start: [xBaseline, "min"],
			end: [xBaseline, "max"],
			style: deepAssign({}, defaultConfig_1.lineStyle, lineStyle)
		});
	}
	return flow(annotation(annotationOptions))(params);
}
function regressionLine(params) {
	var options = params.options, chart = params.chart;
	var regressionLine$1 = options.regressionLine;
	if (regressionLine$1) {
		var style_1 = regressionLine$1.style, _a$5 = regressionLine$1.equationStyle, equationStyle_1 = _a$5 === void 0 ? {} : _a$5, _b = regressionLine$1.top, top_1 = _b === void 0 ? false : _b, _c = regressionLine$1.showEquation, showEquation_1 = _c === void 0 ? false : _c;
		var defaultStyle_1 = {
			stroke: "#9ba29a",
			lineWidth: 2,
			opacity: .5
		};
		var defaulEquationStyle_1 = {
			x: 20,
			y: 20,
			textAlign: "left",
			textBaseline: "middle",
			fontSize: 14,
			fillOpacity: .5
		};
		chart.annotation().shape({
			top: top_1,
			render: function(container, view) {
				var group$1 = container.addGroup({
					id: "".concat(chart.id, "-regression-line"),
					name: "regression-line-group"
				});
				var _a$6 = getPath({
					view,
					options
				}), path = _a$6[0], equation = _a$6[1];
				group$1.addShape("path", {
					name: "regression-line",
					attrs: __assign(__assign({ path }, defaultStyle_1), style_1)
				});
				if (showEquation_1) group$1.addShape("text", {
					name: "regression-equation",
					attrs: __assign(__assign(__assign({}, defaulEquationStyle_1), equationStyle_1), { text: equation })
				});
			}
		});
	}
	return params;
}
/**
* tooltip 配置
* @param params
*/
function tooltip$7(params) {
	var chart = params.chart;
	var tooltip$10 = params.options.tooltip;
	if (tooltip$10) chart.tooltip(tooltip$10);
	else if (tooltip$10 === false) chart.tooltip(false);
	return params;
}
/**
* 散点图适配器
* @param chart
* @param options
*/
function adaptor$30(params) {
	return flow(geometry$20, meta$15, axis$16, legend$12, tooltip$7, label$9, brushInteraction, slider$2, scrollbar, interaction, scatterAnnotation, animation, theme, regressionLine)(params);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/scatter/constant.js
/**
* 散点图 默认配置项
*/
var DEFAULT_OPTIONS$25 = deepAssign({}, Plot.getDefaultOptions(), {
	size: 4,
	tooltip: {
		showTitle: false,
		showMarkers: false,
		showCrosshairs: true,
		crosshairs: { type: "xy" }
	}
});

//#endregion
//#region node_modules/@antv/g2plot/esm/interactions/drag-move.js
registerInteraction("drag-move", {
	start: [{
		trigger: "plot:mousedown",
		action: "scale-translate:start"
	}],
	processing: [{
		trigger: "plot:mousemove",
		action: "scale-translate:translate",
		throttle: {
			wait: 100,
			leading: true,
			trailing: false
		}
	}],
	end: [{
		trigger: "plot:mouseup",
		action: "scale-translate:end"
	}]
});

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/scatter/index.js
var Scatter = function(_super) {
	__extends(Scatter$1, _super);
	function Scatter$1(container, options) {
		var _this = _super.call(this, container, options) || this;
		/** 图表类型 */
		_this.type = "scatter";
		_this.on(VIEW_LIFE_CIRCLE.BEFORE_RENDER, function(evt) {
			var _a$5, _b;
			var _c = _this, options$1 = _c.options, chart = _c.chart;
			if (((_a$5 = evt.data) === null || _a$5 === void 0 ? void 0 : _a$5.source) === EVENTS.FILTER) {
				var filteredData = _this.chart.filterData(_this.chart.getData());
				meta$15({
					chart,
					options: __assign(__assign({}, options$1), { data: filteredData })
				});
			}
			if (((_b = evt.data) === null || _b === void 0 ? void 0 : _b.source) === EVENTS.RESET) meta$15({
				chart,
				options: options$1
			});
		});
		return _this;
	}
	/**
	* 获取 散点图 默认配置项
	* 供外部使用
	*/
	Scatter$1.getDefaultOptions = function() {
		return DEFAULT_OPTIONS$25;
	};
	/**
	* @override
	* @param data
	*/
	Scatter$1.prototype.changeData = function(data$2) {
		this.updateOption(transformOptions$1(deepAssign({}, this.options, { data: data$2 })));
		var _a$5 = this, options = _a$5.options, chart = _a$5.chart;
		meta$15({
			chart,
			options
		});
		this.chart.changeData(data$2);
	};
	/**
	* 获取 散点图 的适配器
	*/
	Scatter$1.prototype.getSchemaAdaptor = function() {
		return adaptor$30;
	};
	Scatter$1.prototype.getDefaultOptions = function() {
		return Scatter$1.getDefaultOptions();
	};
	return Scatter$1;
}(Plot);

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/stock/constant.js
var Y_FIELD$4 = "$$stock-range$$";
var TREND_FIELD = "trend";
var TREND_UP = "up";
var TREND_DOWN = "down";
/** tooltip 配置 */
var DEFAULT_TOOLTIP_OPTIONS$2 = {
	showMarkers: false,
	showCrosshairs: true,
	shared: true,
	crosshairs: {
		type: "xy",
		follow: true,
		text: function(type, defaultContent, items) {
			var textContent;
			if (type === "x") {
				var item = items[0];
				textContent = item ? item.title : defaultContent;
			} else textContent = defaultContent;
			return {
				position: type === "y" ? "start" : "end",
				content: textContent,
				style: { fill: "#dfdfdf" }
			};
		},
		textBackground: {
			padding: [2, 4],
			style: { fill: "#666" }
		}
	}
};
/**
* 散点图 默认配置项
*/
var DEFAULT_OPTIONS$24 = deepAssign({}, Plot.getDefaultOptions(), {
	tooltip: DEFAULT_TOOLTIP_OPTIONS$2,
	interactions: [{ type: "tooltip" }],
	legend: { position: "top-left" },
	risingFill: "#ef5350",
	fallingFill: "#26a69a"
});

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/stock/utils.js
/**
* @desc 股票图数据处理
* @param data
* @param yField
*/
function getStockData(data$2, yField) {
	return map_default(data$2, function(item) {
		var obj = item && __assign({}, item);
		if (is_array_default(yField) && obj) {
			var open_1 = yField[0], close_1 = yField[1], high = yField[2], low = yField[3];
			obj[TREND_FIELD] = obj[open_1] <= obj[close_1] ? TREND_UP : TREND_DOWN;
			obj[Y_FIELD$4] = [
				obj[open_1],
				obj[close_1],
				obj[high],
				obj[low]
			];
		}
		return obj;
	});
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/stock/adaptor.js
/**
* 图表配置处理
* @param params
*/
function geometry$19(params) {
	var chart = params.chart, options = params.options;
	var yField = options.yField;
	var data$2 = options.data, risingFill = options.risingFill, fallingFill = options.fallingFill, tooltip$10 = options.tooltip, stockStyle = options.stockStyle;
	chart.data(getStockData(data$2, yField));
	var tooltipOptions = tooltip$10;
	if (tooltipOptions !== false) tooltipOptions = deepAssign({}, { fields: yField }, tooltipOptions);
	schema(deepAssign({}, params, { options: {
		schema: {
			shape: "candle",
			color: [risingFill, fallingFill],
			style: stockStyle
		},
		yField: Y_FIELD$4,
		seriesField: TREND_FIELD,
		rawFields: yField,
		tooltip: tooltipOptions
	} }));
	return params;
}
/**
* meta 配置
* @param params
*/
function meta$14(params) {
	var _a$5, _b;
	var chart = params.chart, options = params.options;
	var meta$22 = options.meta, xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField;
	var baseMeta = (_a$5 = {}, _a$5[xField] = {
		type: "timeCat",
		tickCount: 6
	}, _a$5[TREND_FIELD] = { values: [TREND_UP, TREND_DOWN] }, _a$5);
	var scales = deepAssign(baseMeta, meta$22, (_b = {}, _b[xField] = pick(xAxis, AXIS_META_CONFIG_KEYS), _b[Y_FIELD$4] = pick(yAxis, AXIS_META_CONFIG_KEYS), _b));
	chart.scale(scales);
	return params;
}
/**
* axis 配置
* @param params
*/
function axis$15(params) {
	var chart = params.chart, options = params.options;
	var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField;
	if (xAxis === false) chart.axis(xField, false);
	else chart.axis(xField, xAxis);
	if (yAxis === false) chart.axis(Y_FIELD$4, false);
	else chart.axis(Y_FIELD$4, yAxis);
	return params;
}
/**
* tooltip 配置
* @param params
*/
function tooltip$6(params) {
	var chart = params.chart;
	var tooltip$10 = params.options.tooltip;
	if (tooltip$10 !== false) chart.tooltip(tooltip$10);
	else chart.tooltip(false);
	return params;
}
/**
* legend 配置
* @param params
*/
function legend$11(params) {
	var chart = params.chart;
	var legend$17 = params.options.legend;
	if (legend$17) chart.legend(TREND_FIELD, legend$17);
	else if (legend$17 === false) chart.legend(false);
	return params;
}
/**
* K线图适配器
* @param chart
* @param options
*/
function adaptor$31(params) {
	flow(theme, geometry$19, meta$14, axis$15, tooltip$6, legend$11, interaction, animation, annotation(), slider$2)(params);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/stock/index.js
var Stock = function(_super) {
	__extends(Stock$1, _super);
	function Stock$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		/** 图表类型 */
		_this.type = "stock";
		return _this;
	}
	/**
	* 获取 散点图 默认配置项
	* 供外部使用
	*/
	Stock$1.getDefaultOptions = function() {
		return DEFAULT_OPTIONS$24;
	};
	/**
	* 默认配置
	*  g2/g2plot默 认 配 置 -->  图 表 默 认 配 置  --> 开 发 者 自 定 义 配 置  --> 最 终 绘 图 配 置
	*/
	Stock$1.prototype.getDefaultOptions = function() {
		return Stock$1.getDefaultOptions();
	};
	/**
	* 获取 蜡烛图 的适配器
	*/
	Stock$1.prototype.getSchemaAdaptor = function() {
		return adaptor$31;
	};
	/**
	* @override
	* @param data
	*/
	Stock$1.prototype.changeData = function(data$2) {
		this.updateOption({ data: data$2 });
		var yField = this.options.yField;
		this.chart.changeData(getStockData(data$2, yField));
	};
	return Stock$1;
}(Plot);

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/tiny-line/utils.js
function getTinyData(data$2) {
	return map_default(data$2 || [], function(y, x) {
		return {
			x: "".concat(x),
			y
		};
	});
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/tiny-line/constants.js
var X_FIELD$3 = "x";
var Y_FIELD$3 = "y";
var DEFAULT_TOOLTIP_OPTIONS$1 = {
	showTitle: false,
	shared: true,
	showMarkers: false,
	customContent: function(x, data$2) {
		return "".concat(get_default(data$2, [
			0,
			"data",
			"y"
		], 0));
	},
	containerTpl: "<div class=\"g2-tooltip\"><div class=\"g2-tooltip-list\"></div></div>",
	itemTpl: "<span>{value}</span>",
	domStyles: { "g2-tooltip": {
		padding: "2px 4px",
		fontSize: "10px"
	} },
	showCrosshairs: true,
	crosshairs: { type: "x" }
};
/**
* 默认配置项
*/
var DEFAULT_OPTIONS$21 = {
	appendPadding: 2,
	tooltip: __assign({}, DEFAULT_TOOLTIP_OPTIONS$1),
	animation: {}
};

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/tiny-area/adaptor.js
/**
* 字段
* @param params
*/
function geometry$18(params) {
	var chart = params.chart, options = params.options;
	var data$2 = options.data, color$2 = options.color, areaStyle = options.areaStyle, pointOptions = options.point, lineOptions = options.line;
	var pointState = pointOptions === null || pointOptions === void 0 ? void 0 : pointOptions.state;
	var seriesData = getTinyData(data$2);
	chart.data(seriesData);
	var primary = deepAssign({}, params, { options: {
		xField: X_FIELD$3,
		yField: Y_FIELD$3,
		area: {
			color: color$2,
			style: areaStyle
		},
		line: lineOptions,
		point: pointOptions
	} });
	var second = deepAssign({}, primary, { options: { tooltip: false } });
	var pointParams = deepAssign({}, primary, { options: {
		tooltip: false,
		state: pointState
	} });
	area(primary);
	line(second);
	point(pointParams);
	chart.axis(false);
	chart.legend(false);
	return params;
}
/**
* meta 配置
* @param params
*/
function meta$13(params) {
	var _a$5, _b;
	var options = params.options;
	var xAxis = options.xAxis, yAxis = options.yAxis, data$2 = options.data;
	var seriesData = getTinyData(data$2);
	return flow(scale((_a$5 = {}, _a$5[X_FIELD$3] = xAxis, _a$5[Y_FIELD$3] = yAxis, _a$5), (_b = {}, _b[X_FIELD$3] = { type: "cat" }, _b[Y_FIELD$3] = adjustYMetaByZero(seriesData, Y_FIELD$3), _b)))(params);
}
/**
* 迷你面积图适配器
* @param chart
* @param options
*/
function adaptor$32(params) {
	return flow(pattern("areaStyle"), geometry$18, meta$13, tooltip, theme, animation, annotation())(params);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/tiny-area/constants.js
/**
* 默认配置项
*/
var DEFAULT_OPTIONS$23 = {
	appendPadding: 2,
	tooltip: __assign({}, DEFAULT_TOOLTIP_OPTIONS$1),
	color: "l(90) 0:#E5EDFE 1:#ffffff",
	areaStyle: { fillOpacity: .6 },
	line: {
		size: 1,
		color: "#5B8FF9"
	},
	animation: {}
};

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/tiny-area/index.js
var TinyArea = function(_super) {
	__extends(TinyArea$1, _super);
	function TinyArea$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		/** 图表类型 */
		_this.type = "tiny-area";
		return _this;
	}
	/**
	* 获取默认配置项
	* 供外部使用
	*/
	TinyArea$1.getDefaultOptions = function() {
		return DEFAULT_OPTIONS$23;
	};
	/**
	* @override
	* @param data
	*/
	TinyArea$1.prototype.changeData = function(data$2) {
		this.updateOption({ data: data$2 });
		var _a$5 = this, chart = _a$5.chart, options = _a$5.options;
		meta$13({
			chart,
			options
		});
		chart.changeData(getTinyData(data$2));
	};
	TinyArea$1.prototype.getDefaultOptions = function() {
		return TinyArea$1.getDefaultOptions();
	};
	/**
	* 获取 迷你面积图 的适配器
	*/
	TinyArea$1.prototype.getSchemaAdaptor = function() {
		return adaptor$32;
	};
	return TinyArea$1;
}(Plot);

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/tiny-column/adaptor.js
/**
* 字段
* @param params
*/
function geometry$17(params) {
	var chart = params.chart, options = params.options;
	var data$2 = options.data, color$2 = options.color, columnStyle = options.columnStyle, columnWidthRatio = options.columnWidthRatio;
	var seriesData = getTinyData(data$2);
	chart.data(seriesData);
	var p = deepAssign({}, params, { options: {
		xField: X_FIELD$3,
		yField: Y_FIELD$3,
		widthRatio: columnWidthRatio,
		interval: {
			style: columnStyle,
			color: color$2
		}
	} });
	interval(p);
	chart.axis(false);
	chart.legend(false);
	chart.interaction("element-active");
	return params;
}
/**
* 迷你柱形图适配器
* @param chart
* @param options
*/
function adaptor$33(params) {
	return flow(theme, pattern("columnStyle"), geometry$17, meta$13, tooltip, animation, annotation())(params);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/tiny-column/constants.js
var DEFAULT_TOOLTIP_OPTIONS = {
	showTitle: false,
	shared: true,
	showMarkers: false,
	customContent: function(x, data$2) {
		return "".concat(get_default(data$2, [
			0,
			"data",
			"y"
		], 0));
	},
	containerTpl: "<div class=\"g2-tooltip\"><div class=\"g2-tooltip-list\"></div></div>",
	itemTpl: "<span>{value}</span>",
	domStyles: { "g2-tooltip": {
		padding: "2px 4px",
		fontSize: "10px"
	} }
};
/**
* 默认配置项
*/
var DEFAULT_OPTIONS$22 = {
	appendPadding: 2,
	tooltip: __assign({}, DEFAULT_TOOLTIP_OPTIONS),
	animation: {}
};

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/tiny-column/index.js
var TinyColumn = function(_super) {
	__extends(TinyColumn$1, _super);
	function TinyColumn$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		/** 图表类型 */
		_this.type = "tiny-column";
		return _this;
	}
	/**
	* 获取默认配置项
	* 供外部使用
	*/
	TinyColumn$1.getDefaultOptions = function() {
		return DEFAULT_OPTIONS$22;
	};
	/**
	* @override
	* @param data
	*/
	TinyColumn$1.prototype.changeData = function(data$2) {
		this.updateOption({ data: data$2 });
		var _a$5 = this, chart = _a$5.chart, options = _a$5.options;
		meta$13({
			chart,
			options
		});
		chart.changeData(getTinyData(data$2));
	};
	TinyColumn$1.prototype.getDefaultOptions = function() {
		return TinyColumn$1.getDefaultOptions();
	};
	/**
	* 获取 迷你柱形图 的适配器
	*/
	TinyColumn$1.prototype.getSchemaAdaptor = function() {
		return adaptor$33;
	};
	return TinyColumn$1;
}(Plot);

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/tiny-line/adaptor.js
/**
* 字段
* @param params
*/
function geometry$16(params) {
	var chart = params.chart, options = params.options;
	var data$2 = options.data, color$2 = options.color, lineStyle = options.lineStyle, pointMapping = options.point;
	var pointState = pointMapping === null || pointMapping === void 0 ? void 0 : pointMapping.state;
	var seriesData = getTinyData(data$2);
	chart.data(seriesData);
	var primary = deepAssign({}, params, { options: {
		xField: X_FIELD$3,
		yField: Y_FIELD$3,
		line: {
			color: color$2,
			style: lineStyle
		},
		point: pointMapping
	} });
	var pointParams = deepAssign({}, primary, { options: {
		tooltip: false,
		state: pointState
	} });
	line(primary);
	point(pointParams);
	chart.axis(false);
	chart.legend(false);
	return params;
}
/**
* 迷你折线图适配器
* @param chart
* @param options
*/
function adaptor$34(params) {
	return flow(geometry$16, meta$13, theme, tooltip, animation, annotation())(params);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/tiny-line/index.js
var TinyLine = function(_super) {
	__extends(TinyLine$1, _super);
	function TinyLine$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		/** 图表类型 */
		_this.type = "tiny-line";
		return _this;
	}
	/**
	* 获取默认配置项
	* 供外部使用
	*/
	TinyLine$1.getDefaultOptions = function() {
		return DEFAULT_OPTIONS$21;
	};
	/**
	* @override
	* @param data
	*/
	TinyLine$1.prototype.changeData = function(data$2) {
		this.updateOption({ data: data$2 });
		var _a$5 = this, chart = _a$5.chart, options = _a$5.options;
		meta$13({
			chart,
			options
		});
		chart.changeData(getTinyData(data$2));
	};
	TinyLine$1.prototype.getDefaultOptions = function() {
		return TinyLine$1.getDefaultOptions();
	};
	/**
	* 获取 迷你折线图 的适配器
	*/
	TinyLine$1.prototype.getSchemaAdaptor = function() {
		return adaptor$34;
	};
	return TinyLine$1;
}(Plot);

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/mix/utils.js
/**
* 可在 multi-view 中使用的 plots
*/
var PLOT_ADAPTORS = {
	line: adaptor$26,
	pie: adaptor$27,
	column: adaptor$14,
	bar: adaptor$22,
	area: adaptor$21,
	gauge: adaptor$24,
	"tiny-line": adaptor$34,
	"tiny-column": adaptor$33,
	"tiny-area": adaptor$32,
	"ring-progress": adaptor$29,
	progress: adaptor$28,
	scatter: adaptor$30,
	histogram: adaptor$25,
	funnel: adaptor$23,
	stock: adaptor$31
};
/**
* 获取指定 plot 的 class contructor
* @param {string} plot
*/
var PLOT_CONSTRUCTOR = {
	line: Line,
	pie: Pie,
	column: Column,
	bar: Bar,
	area: Area,
	gauge: Gauge,
	"tiny-line": TinyLine,
	"tiny-column": TinyColumn,
	"tiny-area": TinyArea,
	"ring-progress": RingProgress,
	progress: Progress,
	scatter: Scatter,
	histogram: Histogram,
	funnel: Funnel,
	stock: Stock
};
/**
* 在 mix 图表以及 facet 图表中，defaultOptions 进行复写简化
*/
var DEFAULT_OPTIONS_MAP = {
	pie: { label: false },
	column: { tooltip: { showMarkers: false } },
	bar: { tooltip: { showMarkers: false } }
};
/**
* 执行 plot 的 adaptor, 默认都带上 defaultOptions
* @param {string} plot
*/
function execPlotAdaptor(plot, view, options) {
	var cls = PLOT_CONSTRUCTOR[plot];
	if (!cls) {
		console.error("could not find ".concat(plot, " plot"));
		return;
	}
	var module$1 = PLOT_ADAPTORS[plot];
	module$1({
		chart: view,
		options: deepAssign({}, cls.getDefaultOptions(), get_default(DEFAULT_OPTIONS_MAP, plot, {}), options)
	});
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/mix/adaptor.js
/**
* geometry 处理
* @param params
*/
function multiView(params) {
	var chart = params.chart, options = params.options;
	var views = options.views, legend$17 = options.legend;
	each_default(views, function(v) {
		var region = v.region, data$2 = v.data, meta$22 = v.meta, axes = v.axes, coordinate$10 = v.coordinate, interactions = v.interactions, annotations = v.annotations, tooltip$10 = v.tooltip, geometries = v.geometries;
		var viewOfG2 = chart.createView({ region });
		viewOfG2.data(data$2);
		var scales = {};
		if (axes) each_default(axes, function(axis$21, field$5) {
			scales[field$5] = pick(axis$21, AXIS_META_CONFIG_KEYS);
		});
		scales = deepAssign({}, meta$22, scales);
		viewOfG2.scale(scales);
		if (!axes) viewOfG2.axis(false);
		else each_default(axes, function(axis$21, field$5) {
			viewOfG2.axis(field$5, axis$21);
		});
		viewOfG2.coordinate(coordinate$10);
		each_default(geometries, function(geometry$34) {
			var ext = geometry$10({
				chart: viewOfG2,
				options: geometry$34
			}).ext;
			var adjust$2 = geometry$34.adjust;
			if (adjust$2) ext.geometry.adjust(adjust$2);
		});
		each_default(interactions, function(interaction$9) {
			if (interaction$9.enable === false) viewOfG2.removeInteraction(interaction$9.type);
			else viewOfG2.interaction(interaction$9.type, interaction$9.cfg);
		});
		each_default(annotations, function(annotation$3) {
			viewOfG2.annotation()[annotation$3.type](__assign({}, annotation$3));
		});
		if (typeof v.animation === "boolean") viewOfG2.animate(false);
		else {
			viewOfG2.animate(true);
			each_default(viewOfG2.geometries, function(g) {
				g.animate(v.animation);
			});
		}
		if (tooltip$10) {
			viewOfG2.interaction("tooltip");
			viewOfG2.tooltip(tooltip$10);
		}
	});
	if (!legend$17) chart.legend(false);
	else each_default(legend$17, function(l, field$5) {
		chart.legend(field$5, l);
	});
	chart.tooltip(options.tooltip);
	return params;
}
/**
* 支持嵌套使用 g2plot 内置图表
* @param params
*/
function multiPlot(params) {
	var chart = params.chart, options = params.options;
	var plots = options.plots, _a$5 = options.data, data$2 = _a$5 === void 0 ? [] : _a$5;
	each_default(plots, function(plot) {
		var type = plot.type, region = plot.region, _a$6 = plot.options, options$1 = _a$6 === void 0 ? {} : _a$6, top = plot.top;
		var tooltip$10 = options$1.tooltip;
		if (top) {
			execPlotAdaptor(type, chart, __assign(__assign({}, options$1), { data: data$2 }));
			return;
		}
		var viewOfG2 = chart.createView(__assign({ region }, pick(options$1, PLOT_CONTAINER_OPTIONS)));
		if (tooltip$10) viewOfG2.interaction("tooltip");
		execPlotAdaptor(type, viewOfG2, __assign({ data: data$2 }, options$1));
	});
	return params;
}
/**
* 处理缩略轴的 adaptor (mix)
* @param params
*/
function slider$1(params) {
	var chart = params.chart, options = params.options;
	chart.option("slider", options.slider);
	return params;
}
/**
* 图适配器
* @param chart
* @param options
*/
function adaptor$20(params) {
	return flow(animation, multiView, multiPlot, interaction, animation, theme, tooltip, slider$1, annotation())(params);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/mix/interactions/utils.js
/**
* 获取图表元素对应字段的值
* @param element 图表元素
* @param field 字段名
* @ignore
*/
function getElementValue(element, field$5) {
	var record = element.getModel().data;
	var value$1;
	if (is_array_default(record)) value$1 = record[0][field$5];
	else value$1 = record[field$5];
	return value$1;
}
/**
* @ignore
* 清理 highlight 效果
* @param view View 或者 Chart
*/
function clearHighlight(view) {
	var elements = getAllElements(view);
	each_default(elements, function(el) {
		if (el.hasState("active")) el.setState("active", false);
		if (el.hasState("selected")) el.setState("selected", false);
		if (el.hasState("inactive")) el.setState("inactive", false);
	});
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/mix/interactions/association.js
/**
* 存在多个 view 时，view 之间的联动交互
*
* 提供四个反馈 action，均接受参数：linkField 关联字段，dim 维度
* 1. showTooltip
* 2. active
* 3. highlight
* 4. selected
*
* 附加，两个结束反馈 action：
* 1. hidetooltip
* 2. reset 清除激活和高亮状态
*/
var Association = function(_super) {
	__extends(Association$1, _super);
	function Association$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	/**
	* 获取关联的 elements
	*
	* - 如果 dim 参数存在，根据 dim 获取相应的 field。与 linkField 不匹配则 return
	* - 否则 dim 参数不存在，且 linkField 存在，则作为关联字段
	* - 否则若 linkField 不存在，则获取第一个分类字段
	* @returns EventItem[]
	*/
	Association$1.prototype.getAssociationItems = function(views, params) {
		var _a$5;
		var event = this.context.event;
		var _b = params || {}, linkField = _b.linkField, dim = _b.dim;
		var items = [];
		if ((_a$5 = event.data) === null || _a$5 === void 0 ? void 0 : _a$5.data) {
			var data_1 = event.data.data;
			each_default(views, function(v) {
				var _a$6, _b$1;
				var field$5 = linkField;
				if (dim === "x") field$5 = v.getXScale().field;
				else if (dim === "y") field$5 = (_a$6 = v.getYScales().find(function(s) {
					return s.field === field$5;
				})) === null || _a$6 === void 0 ? void 0 : _a$6.field;
				else if (!field$5) field$5 = (_b$1 = v.getGroupScales()[0]) === null || _b$1 === void 0 ? void 0 : _b$1.field;
				if (!field$5) return;
				var elements = map_default(getAllElements(v), function(ele) {
					var active = false;
					var inactive = false;
					var dataValue = is_array_default(data_1) ? get_default(data_1[0], field$5) : get_default(data_1, field$5);
					if (getElementValue(ele, field$5) === dataValue) active = true;
					else inactive = true;
					return {
						element: ele,
						view: v,
						active,
						inactive
					};
				});
				items.push.apply(items, elements);
			});
		}
		return items;
	};
	/**
	* 所有同一层级的 tooltip 显示
	*/
	Association$1.prototype.showTooltip = function(params) {
		var siblings = getSiblingViews(this.context.view);
		var elements = this.getAssociationItems(siblings, params);
		each_default(elements, function(ele) {
			if (ele.active) {
				var box$1 = ele.element.shape.getCanvasBBox();
				ele.view.showTooltip({
					x: box$1.minX + box$1.width / 2,
					y: box$1.minY + box$1.height / 2
				});
			}
		});
	};
	/**
	* 隐藏同一层级的 tooltip
	*/
	Association$1.prototype.hideTooltip = function() {
		var siblings = getSiblingViews(this.context.view);
		each_default(siblings, function(sibling) {
			sibling.hideTooltip();
		});
	};
	/**
	* 设置 active 状态
	*/
	Association$1.prototype.active = function(params) {
		var views = getViews(this.context.view);
		var items = this.getAssociationItems(views, params);
		each_default(items, function(item) {
			var active = item.active, element = item.element;
			if (active) element.setState("active", true);
		});
	};
	/**
	* 设置 selected 状态
	*/
	Association$1.prototype.selected = function(params) {
		var views = getViews(this.context.view);
		var items = this.getAssociationItems(views, params);
		each_default(items, function(item) {
			var active = item.active, element = item.element;
			if (active) element.setState("selected", true);
		});
	};
	/**
	* 进行高亮 => 设置 inactive 状态
	*/
	Association$1.prototype.highlight = function(params) {
		var views = getViews(this.context.view);
		var items = this.getAssociationItems(views, params);
		each_default(items, function(item) {
			var inactive = item.inactive, element = item.element;
			if (inactive) element.setState("inactive", true);
		});
	};
	Association$1.prototype.reset = function() {
		var views = getViews(this.context.view);
		each_default(views, function(v) {
			clearHighlight(v);
		});
	};
	return Association$1;
}(base_default$1);
registerAction("association", Association);
/**
* 相邻 view 的 active 联动（相同维值的 tooltip 联动）
*/
registerInteraction("association-active", {
	start: [{
		trigger: "element:mouseenter",
		action: "association:active"
	}],
	end: [{
		trigger: "element:mouseleave",
		action: "association:reset"
	}]
});
/**
* 相邻 view 的 active 联动（相同维值的 tooltip 联动）
*/
registerInteraction("association-selected", {
	start: [{
		trigger: "element:mouseenter",
		action: "association:selected"
	}],
	end: [{
		trigger: "element:mouseleave",
		action: "association:reset"
	}]
});
/**
* 相邻 view 的 highlight 联动, 突出当前 element
*/
registerInteraction("association-highlight", {
	start: [{
		trigger: "element:mouseenter",
		action: "association:highlight"
	}],
	end: [{
		trigger: "element:mouseleave",
		action: "association:reset"
	}]
});
/**
* 相邻 view 的 tooltip 联动，根据 groupField 进行关联（相同维值的 tooltip 联动）
*/
registerInteraction("association-tooltip", {
	start: [{
		trigger: "element:mousemove",
		action: "association:showTooltip"
	}],
	end: [{
		trigger: "element:mouseleave",
		action: "association:hideTooltip"
	}]
});

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/mix/index.js
/**
* 多图层图形，释放 G2 80% 的功能，可以用来做：
* 1. 图层叠加的图：
*   - 折线 + 置信度区间迭代
*   - 嵌套饼图
*   - ...
* 2. 图层划分的图
*   - 多维图
*   - 柱饼组合图
*   - ...
*/
var Mix = function(_super) {
	__extends(Mix$1, _super);
	function Mix$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		/** 图表类型 */
		_this.type = "mix";
		return _this;
	}
	/**
	* 获取适配器
	*/
	Mix$1.prototype.getSchemaAdaptor = function() {
		return adaptor$20;
	};
	return Mix$1;
}(Plot);

//#endregion
//#region node_modules/@antv/g2plot/esm/lab.js
/** 实验室图表所处的阶段 */
var Stage;
(function(Stage$1) {
	Stage$1["DEV"] = "DEV";
	Stage$1["BETA"] = "BETA";
	Stage$1["STABLE"] = "STABLE";
})(Stage || (Stage = {}));
/**
* 不同阶段打印一些消息给开发者
* @param stage
*/
function notice(stage, plotType) {
	console.warn(stage === Stage.DEV ? "Plot '".concat(plotType, "' is in DEV stage, just give us issues.") : stage === Stage.BETA ? "Plot '".concat(plotType, "' is in BETA stage, DO NOT use it in production env.") : stage === Stage.STABLE ? "Plot '".concat(plotType, "' is in STABLE stage, import it by \"import { ").concat(plotType, " } from '@antv/g2plot'\".") : "invalid Stage type.");
}
/**
* 实验室图表，实验室中的图表分成不同的阶段。
*/
var Lab = function() {
	function Lab$1() {}
	Object.defineProperty(Lab$1, "MultiView", {
		get: function() {
			notice(Stage.STABLE, "MultiView");
			return Mix;
		},
		enumerable: false,
		configurable: true
	});
	return Lab$1;
}();

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/bidirectional-bar/constant.js
var FIRST_AXES_VIEW = "first-axes-view";
var SECOND_AXES_VIEW = "second-axes-view";
/** 对称条形图的分组 key 值 */
var SERIES_FIELD_KEY = "series-field-key";

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/bidirectional-bar/utils.js
/**
* bidirectional-bar 处理数据, 通过 SERIES_FIELD_KEY 字段分成左右数据
* @param xField
* @param yField
* @param data
*/
function transformData$7(xField, yField, seriesField, data$2, reverse) {
	var hopeData = [];
	yField.forEach(function(d) {
		data$2.forEach(function(k) {
			var _a$6;
			var obj = (_a$6 = {}, _a$6[xField] = k[xField], _a$6[seriesField] = d, _a$6[d] = k[d], _a$6);
			hopeData.push(obj);
		});
	});
	var groupData = Object.values(group_by_default(hopeData, seriesField));
	var _a$5 = groupData[0], data1 = _a$5 === void 0 ? [] : _a$5, _b = groupData[1], data2 = _b === void 0 ? [] : _b;
	return reverse ? [data1.reverse(), data2.reverse()] : [data1, data2];
}
/**
* 是否横向，默认空为横向
* @param layout
*/
function isHorizontal(layout$1) {
	return layout$1 !== "vertical";
}
/**
* 多 view 进行同步 padding 的自定义逻辑
* @param chart
* @param views
* @param p
*/
function syncViewPadding(chart, views, p) {
	var v1 = views[0], v2 = views[1];
	var p1 = v1.autoPadding;
	var p2 = v2.autoPadding;
	var _a$5 = chart.__axisPosition, layout$1 = _a$5.layout, position = _a$5.position;
	if (isHorizontal(layout$1) && position === "top") {
		/**
		* 保证 v1 的 left 和 v2 right 的间隔相等，因为 v1 有轴
		* position top 即为 v1 左边，中间间距设置就为 0
		*/
		v1.autoPadding = p.instance(p1.top, 0, p1.bottom, p1.left);
		v2.autoPadding = p.instance(p2.top, p1.left, p2.bottom, 0);
	}
	if (isHorizontal(layout$1) && position === "bottom") {
		/**
		* 保证 v1 的 left 和 v2 right 的间隔相等，因为 v1 有轴
		* position bottom 即为 v1 的右边，v1 right = right / 2  v2 left = right / 2
		* + 5 是为了 让那个轴不要太贴近了，更好看
		*/
		v1.autoPadding = p.instance(p1.top, p1.right / 2 + 5, p1.bottom, p1.left);
		v2.autoPadding = p.instance(p2.top, p2.right, p2.bottom, p1.right / 2 + 5);
	}
	if (!isHorizontal(layout$1) && position === "bottom") {
		/**
		* 保证 v1 的 left 和 v2 left 的间隔相等 left 取最大值
		* position bottom 即为 v1 下边，v1 bottom = bottom / 2  v2 top = bottom / 2
		* + 5 是为了 让那个轴不要太贴近了，更好看
		*/
		var left$1 = p1.left >= p2.left ? p1.left : p2.left;
		v1.autoPadding = p.instance(p1.top, p1.right, p1.bottom / 2 + 5, left$1);
		v2.autoPadding = p.instance(p1.bottom / 2 + 5, p2.right, p2.bottom, left$1);
	}
	if (!isHorizontal(layout$1) && position === "top") {
		var left$1 = p1.left >= p2.left ? p1.left : p2.left;
		v1.autoPadding = p.instance(p1.top, p1.right, 0, left$1);
		v2.autoPadding = p.instance(0, p2.right, p1.top, left$1);
	}
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/bidirectional-bar/adaptor.js
/**
* geometry 处理
* @param params
*/
function geometry$15(params) {
	var chart = params.chart, options = params.options;
	var data$2 = options.data, xField = options.xField, yField = options.yField, color$2 = options.color, barStyle = options.barStyle, widthRatio = options.widthRatio, legend$17 = options.legend, layout$1 = options.layout;
	var groupData = transformData$7(xField, yField, SERIES_FIELD_KEY, data$2, isHorizontal(layout$1));
	if (legend$17) chart.legend(SERIES_FIELD_KEY, legend$17);
	else if (legend$17 === false) chart.legend(false);
	var firstView;
	var secondView;
	var firstViewData = groupData[0], secondViewData = groupData[1];
	if (isHorizontal(layout$1)) {
		firstView = chart.createView({
			region: {
				start: {
					x: 0,
					y: 0
				},
				end: {
					x: .5,
					y: 1
				}
			},
			id: FIRST_AXES_VIEW
		});
		firstView.coordinate().transpose().reflect("x");
		secondView = chart.createView({
			region: {
				start: {
					x: .5,
					y: 0
				},
				end: {
					x: 1,
					y: 1
				}
			},
			id: SECOND_AXES_VIEW
		});
		secondView.coordinate().transpose();
		firstView.data(firstViewData);
		secondView.data(secondViewData);
	} else {
		firstView = chart.createView({
			region: {
				start: {
					x: 0,
					y: 0
				},
				end: {
					x: 1,
					y: .5
				}
			},
			id: FIRST_AXES_VIEW
		});
		secondView = chart.createView({
			region: {
				start: {
					x: 0,
					y: .5
				},
				end: {
					x: 1,
					y: 1
				}
			},
			id: SECOND_AXES_VIEW
		});
		secondView.coordinate().reflect("y");
		firstView.data(firstViewData);
		secondView.data(secondViewData);
	}
	var left$1 = deepAssign({}, params, {
		chart: firstView,
		options: {
			widthRatio,
			xField,
			yField: yField[0],
			seriesField: SERIES_FIELD_KEY,
			interval: {
				color: color$2,
				style: barStyle
			}
		}
	});
	interval(left$1);
	var right$1 = deepAssign({}, params, {
		chart: secondView,
		options: {
			xField,
			yField: yField[1],
			seriesField: SERIES_FIELD_KEY,
			widthRatio,
			interval: {
				color: color$2,
				style: barStyle
			}
		}
	});
	interval(right$1);
	return params;
}
/**
* meta 配置
* - 对称条形图对数据进行了处理，通过 SERIES_FIELD_KEY 来对两条 yField 数据进行分类
* @param params
*/
function meta$12(params) {
	var _a$5, _b, _c;
	var options = params.options, chart = params.chart;
	var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
	var firstView = findViewById(chart, FIRST_AXES_VIEW);
	var secondView = findViewById(chart, SECOND_AXES_VIEW);
	var aliasMap = {};
	keys_default((options === null || options === void 0 ? void 0 : options.meta) || {}).map(function(metaKey) {
		if (get_default(options === null || options === void 0 ? void 0 : options.meta, [metaKey, "alias"])) aliasMap[metaKey] = options.meta[metaKey].alias;
	});
	chart.scale((_a$5 = {}, _a$5[SERIES_FIELD_KEY] = {
		sync: true,
		formatter: function(v) {
			return get_default(aliasMap, v, v);
		}
	}, _a$5));
	scale((_b = {}, _b[xField] = xAxis, _b[yField[0]] = yAxis[yField[0]], _b))(deepAssign({}, params, { chart: firstView }));
	scale((_c = {}, _c[xField] = xAxis, _c[yField[1]] = yAxis[yField[1]], _c))(deepAssign({}, params, { chart: secondView }));
	return params;
}
/**
* axis 配置
* @param params
*/
function axis$14(params) {
	var chart = params.chart, options = params.options;
	var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField, layout$1 = options.layout;
	var firstView = findViewById(chart, FIRST_AXES_VIEW);
	var secondView = findViewById(chart, SECOND_AXES_VIEW);
	if ((xAxis === null || xAxis === void 0 ? void 0 : xAxis.position) === "bottom") secondView.axis(xField, __assign(__assign({}, xAxis), { label: { formatter: function() {
		return "";
	} } }));
	else secondView.axis(xField, false);
	if (xAxis === false) firstView.axis(xField, false);
	else firstView.axis(xField, __assign({ position: isHorizontal(layout$1) ? "top" : "bottom" }, xAxis));
	if (yAxis === false) {
		firstView.axis(yField[0], false);
		secondView.axis(yField[1], false);
	} else {
		firstView.axis(yField[0], yAxis[yField[0]]);
		secondView.axis(yField[1], yAxis[yField[1]]);
	}
	/**
	*  这个注入，主要是在syncViewPadding时候拿到相对应的配置：布局和轴的位置
	*  TODO 之后希望 g2 View 对象可以开放 setter 可以设置一些需要的东西
	*/
	chart.__axisPosition = {
		position: firstView.getOptions().axes[xField].position,
		layout: layout$1
	};
	return params;
}
/**
* interaction 配置
* @param params
*/
function interaction$6(params) {
	var chart = params.chart;
	interaction(deepAssign({}, params, { chart: findViewById(chart, FIRST_AXES_VIEW) }));
	interaction(deepAssign({}, params, { chart: findViewById(chart, SECOND_AXES_VIEW) }));
	return params;
}
/**
* limitInPlot
* @param params
*/
function limitInPlot$2(params) {
	var chart = params.chart, options = params.options;
	var yField = options.yField, yAxis = options.yAxis;
	limitInPlot(deepAssign({}, params, {
		chart: findViewById(chart, FIRST_AXES_VIEW),
		options: { yAxis: yAxis[yField[0]] }
	}));
	limitInPlot(deepAssign({}, params, {
		chart: findViewById(chart, SECOND_AXES_VIEW),
		options: { yAxis: yAxis[yField[1]] }
	}));
	return params;
}
/**
* theme
* @param params
*/
function theme$2(params) {
	var chart = params.chart;
	theme(deepAssign({}, params, { chart: findViewById(chart, FIRST_AXES_VIEW) }));
	theme(deepAssign({}, params, { chart: findViewById(chart, SECOND_AXES_VIEW) }));
	theme(params);
	return params;
}
/**
* animation
* @param params
*/
function animation$5(params) {
	var chart = params.chart;
	animation(deepAssign({}, params, { chart: findViewById(chart, FIRST_AXES_VIEW) }));
	animation(deepAssign({}, params, { chart: findViewById(chart, SECOND_AXES_VIEW) }));
	return params;
}
/**
* label 配置 (1. 设置 offset 偏移量默认值 2. leftView 偏移量需要 *= -1)
* @param params
*/
function label$8(params) {
	var _this = this;
	var _a$5, _b;
	var chart = params.chart, options = params.options;
	var label$16 = options.label, yField = options.yField, layout$1 = options.layout;
	var firstView = findViewById(chart, FIRST_AXES_VIEW);
	var secondView = findViewById(chart, SECOND_AXES_VIEW);
	var leftGeometry = findGeometry(firstView, "interval");
	var rightGeometry = findGeometry(secondView, "interval");
	if (!label$16) {
		leftGeometry.label(false);
		rightGeometry.label(false);
	} else {
		var callback = label$16.callback, cfg_1 = __rest(label$16, ["callback"]);
		/** ---- 设置默认配置 ---- */
		if (!cfg_1.position) cfg_1.position = "middle";
		if (cfg_1.offset === void 0) cfg_1.offset = 2;
		/** ---- leftView label 设置 ---- */
		var leftLabelCfg = __assign({}, cfg_1);
		if (isHorizontal(layout$1)) {
			var textAlign = ((_a$5 = leftLabelCfg.style) === null || _a$5 === void 0 ? void 0 : _a$5.textAlign) || (cfg_1.position === "middle" ? "center" : "left");
			cfg_1.style = deepAssign({}, cfg_1.style, { textAlign });
			leftLabelCfg.style = deepAssign({}, leftLabelCfg.style, { textAlign: {
				left: "right",
				right: "left",
				center: "center"
			}[textAlign] });
		} else {
			var positionMap_1 = {
				top: "bottom",
				bottom: "top",
				middle: "middle"
			};
			if (typeof cfg_1.position === "string") cfg_1.position = positionMap_1[cfg_1.position];
			else if (typeof cfg_1.position === "function") cfg_1.position = function() {
				var args = [];
				for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
				return positionMap_1[cfg_1.position.apply(_this, args)];
			};
			var textBaseline = ((_b = leftLabelCfg.style) === null || _b === void 0 ? void 0 : _b.textBaseline) || "bottom";
			leftLabelCfg.style = deepAssign({}, leftLabelCfg.style, { textBaseline });
			cfg_1.style = deepAssign({}, cfg_1.style, { textBaseline: {
				top: "bottom",
				bottom: "top",
				middle: "middle"
			}[textBaseline] });
		}
		leftGeometry.label({
			fields: [yField[0]],
			callback,
			cfg: transformLabel(leftLabelCfg)
		});
		rightGeometry.label({
			fields: [yField[1]],
			callback,
			cfg: transformLabel(cfg_1)
		});
	}
	return params;
}
/**
* 对称条形图适配器
* @param chart
* @param options
*/
function adaptor$19(params) {
	return flow(geometry$15, meta$12, axis$14, limitInPlot$2, theme$2, label$8, tooltip, interaction$6, animation$5)(params);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/bidirectional-bar/index.js
var BidirectionalBar = function(_super) {
	__extends(BidirectionalBar$1, _super);
	function BidirectionalBar$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		/** 图表类型 */
		_this.type = "bidirectional-bar";
		return _this;
	}
	/**
	* 获取 默认配置项
	* 供外部使用
	*/
	BidirectionalBar$1.getDefaultOptions = function() {
		return deepAssign({}, _super.getDefaultOptions.call(this), { syncViewPadding });
	};
	/**
	* @override
	*/
	BidirectionalBar$1.prototype.changeData = function(data$2) {
		if (data$2 === void 0) data$2 = [];
		this.chart.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, event_default.fromData(this.chart, VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
		this.updateOption({ data: data$2 });
		var _a$5 = this.options, xField = _a$5.xField, yField = _a$5.yField, layout$1 = _a$5.layout;
		var groupData = transformData$7(xField, yField, SERIES_FIELD_KEY, data$2, isHorizontal(layout$1));
		var firstViewData = groupData[0], secondViewData = groupData[1];
		var firstView = findViewById(this.chart, FIRST_AXES_VIEW);
		var secondView = findViewById(this.chart, SECOND_AXES_VIEW);
		firstView.data(firstViewData);
		secondView.data(secondViewData);
		this.chart.render(true);
		this.chart.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, event_default.fromData(this.chart, VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
	};
	BidirectionalBar$1.prototype.getDefaultOptions = function() {
		return BidirectionalBar$1.getDefaultOptions();
	};
	/**
	* 获取对称条形图的适配器
	*/
	BidirectionalBar$1.prototype.getSchemaAdaptor = function() {
		return adaptor$19;
	};
	/** 对称条形图分类字段 */
	BidirectionalBar$1.SERIES_FIELD_KEY = SERIES_FIELD_KEY;
	return BidirectionalBar$1;
}(Plot);

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/box/constant.js
var _a;
var BOX_RANGE = "$$range$$";
var BOX_RANGE_ALIAS = "low-q1-median-q3-high";
var BOX_SYNC_NAME = "$$y_outliers$$";
var OUTLIERS_VIEW_ID = "outliers_view";
/**
* 面积图默认配置项
*/
var DEFAULT_OPTIONS$20 = deepAssign({}, Plot.getDefaultOptions(), {
	meta: (_a = {}, _a[BOX_RANGE] = {
		min: 0,
		alias: BOX_RANGE_ALIAS
	}, _a),
	interactions: [{ type: "active-region" }],
	tooltip: {
		showMarkers: false,
		shared: true
	},
	boxStyle: { lineWidth: 1 }
});

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/box/utils.js
/**
* @desc 将数据转换为 box 需要的的图表数据,如果yField为数组,从data中解构出对应数组值并写入data,否则直接返回data
* @param data
* @param yField
*/
var transformData$6 = function(data$2, yField) {
	var newData = data$2;
	if (Array.isArray(yField)) {
		var low_1 = yField[0], q1_1 = yField[1], median_1 = yField[2], q3_1 = yField[3], high_1 = yField[4];
		newData = map_default(data$2, function(obj) {
			obj[BOX_RANGE] = [
				obj[low_1],
				obj[q1_1],
				obj[median_1],
				obj[q3_1],
				obj[high_1]
			];
			return obj;
		});
	}
	return newData;
};

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/box/adaptor.js
/**
* 字段
* @param params
*/
function field(params) {
	var chart = params.chart, options = params.options;
	var xField = options.xField, yField = options.yField, groupField = options.groupField, color$2 = options.color, tooltip$10 = options.tooltip, boxStyle = options.boxStyle;
	chart.data(transformData$6(options.data, yField));
	var yFieldName = is_array_default(yField) ? BOX_RANGE : yField;
	var rawFields = yField ? is_array_default(yField) ? yField : [yField] : [];
	var tooltipOptions = tooltip$10;
	if (tooltipOptions !== false) tooltipOptions = deepAssign({}, { fields: is_array_default(yField) ? yField : [] }, tooltipOptions);
	var ext = schema(deepAssign({}, params, { options: {
		xField,
		yField: yFieldName,
		seriesField: groupField,
		tooltip: tooltipOptions,
		rawFields,
		label: false,
		schema: {
			shape: "box",
			color: color$2,
			style: boxStyle
		}
	} })).ext;
	if (groupField) ext.geometry.adjust("dodge");
	return params;
}
/**
* 创建异常点 view
*/
function outliersPoint(params) {
	var chart = params.chart, options = params.options;
	var xField = options.xField, data$2 = options.data, outliersField = options.outliersField, outliersStyle = options.outliersStyle, padding$2 = options.padding, label$16 = options.label;
	if (!outliersField) return params;
	var outliersView = chart.createView({
		padding: padding$2,
		id: OUTLIERS_VIEW_ID
	});
	var outliersViewData = data$2.reduce(function(ret, datum) {
		datum[outliersField].forEach(function(d) {
			var _a$5;
			return ret.push(__assign(__assign({}, datum), (_a$5 = {}, _a$5[outliersField] = d, _a$5)));
		});
		return ret;
	}, []);
	outliersView.data(outliersViewData);
	point({
		chart: outliersView,
		options: {
			xField,
			yField: outliersField,
			point: {
				shape: "circle",
				style: outliersStyle
			},
			label: label$16
		}
	});
	outliersView.axis(false);
	return params;
}
/**
* meta 配置
* @param params
*/
function meta$11(params) {
	var _a$5, _b;
	var chart = params.chart, options = params.options;
	var meta$22 = options.meta, xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField, outliersField = options.outliersField;
	var yFieldName = Array.isArray(yField) ? BOX_RANGE : yField;
	var baseMeta = {};
	if (outliersField) {
		var syncName = BOX_SYNC_NAME;
		baseMeta = (_a$5 = {}, _a$5[outliersField] = {
			sync: syncName,
			nice: true
		}, _a$5[yFieldName] = {
			sync: syncName,
			nice: true
		}, _a$5);
	}
	var scales = deepAssign(baseMeta, meta$22, (_b = {}, _b[xField] = pick(xAxis, AXIS_META_CONFIG_KEYS), _b[yFieldName] = pick(yAxis, AXIS_META_CONFIG_KEYS), _b));
	chart.scale(scales);
	return params;
}
/**
* axis 配置
* @param params
*/
function axis$13(params) {
	var chart = params.chart, options = params.options;
	var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
	var yFieldName = Array.isArray(yField) ? BOX_RANGE : yField;
	if (xAxis === false) chart.axis(xField, false);
	else chart.axis(xField, xAxis);
	if (yAxis === false) chart.axis(BOX_RANGE, false);
	else chart.axis(yFieldName, yAxis);
	return params;
}
/**
* legend 配置
* @param params
*/
function legend$10(params) {
	var chart = params.chart, options = params.options;
	var legend$17 = options.legend, groupField = options.groupField;
	if (groupField) if (legend$17) chart.legend(groupField, legend$17);
	else chart.legend(groupField, { position: "bottom" });
	else chart.legend(false);
	return params;
}
/**
* 箱型图适配器
* @param params
*/
function adaptor$18(params) {
	return flow(field, outliersPoint, meta$11, axis$13, legend$10, tooltip, annotation(), interaction, animation, theme)(params);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/box/index.js
var Box = function(_super) {
	__extends(Box$1, _super);
	function Box$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		/** 图表类型 */
		_this.type = "box";
		return _this;
	}
	/**
	* 获取 默认配置项
	* 供外部使用
	*/
	Box$1.getDefaultOptions = function() {
		return DEFAULT_OPTIONS$20;
	};
	/**
	* @override
	* @param data
	*/
	Box$1.prototype.changeData = function(data$2) {
		this.updateOption({ data: data$2 });
		var yField = this.options.yField;
		var outliersView = this.chart.views.find(function(v) {
			return v.id === OUTLIERS_VIEW_ID;
		});
		if (outliersView) outliersView.data(data$2);
		this.chart.changeData(transformData$6(data$2, yField));
	};
	/**
	* 获取 箱型图 默认配置项
	*/
	Box$1.prototype.getDefaultOptions = function() {
		return Box$1.getDefaultOptions();
	};
	/**
	* 获取 箱型图 的适配器
	*/
	Box$1.prototype.getSchemaAdaptor = function() {
		return adaptor$18;
	};
	return Box$1;
}(Plot);

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/bullet/utils.js
/**
* 获取分类字段 key 值 一个分类值的时候， 返回非索引 key 值，在 tooltip 不做索引区分
* @param values 数据量
* @param field 指标字段
* @param index 索引
* @returns string
*/
function getSeriesFieldKey(values$1, field$5, index) {
	return values$1.length > 1 ? "".concat(field$5, "_").concat(index) : "".concat(field$5);
}
/**
* bullet 处理数据
* @param options
*/
function transformData$5(options) {
	var data$2 = options.data, xField = options.xField, measureField = options.measureField, rangeField = options.rangeField, targetField = options.targetField, layout$1 = options.layout;
	var ds = [];
	var scales = [];
	data$2.forEach(function(item, index) {
		var rangeValues = [item[rangeField]].flat();
		rangeValues.sort(function(a, b) {
			return a - b;
		});
		rangeValues.forEach(function(d, i) {
			var _a$5;
			var range = i === 0 ? d : rangeValues[i] - rangeValues[i - 1];
			ds.push((_a$5 = { rKey: "".concat(rangeField, "_").concat(i) }, _a$5[xField] = xField ? item[xField] : String(index), _a$5[rangeField] = range, _a$5));
		});
		var measureValues = [item[measureField]].flat();
		measureValues.forEach(function(d, i) {
			var _a$5;
			ds.push((_a$5 = { mKey: getSeriesFieldKey(measureValues, measureField, i) }, _a$5[xField] = xField ? item[xField] : String(index), _a$5[measureField] = d, _a$5));
		});
		var targetValues = [item[targetField]].flat();
		targetValues.forEach(function(d, i) {
			var _a$5;
			ds.push((_a$5 = { tKey: getSeriesFieldKey(targetValues, targetField, i) }, _a$5[xField] = xField ? item[xField] : String(index), _a$5[targetField] = d, _a$5));
		});
		scales.push(item[rangeField], item[measureField], item[targetField]);
	});
	var min$2 = Math.min.apply(Math, scales.flat(Infinity));
	var max$2 = Math.max.apply(Math, scales.flat(Infinity));
	min$2 = min$2 > 0 ? 0 : min$2;
	if (layout$1 === "vertical") ds.reverse();
	return {
		min: min$2,
		max: max$2,
		ds
	};
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/bullet/adaptor.js
/**
* geometry 处理
* @param params
*/
function geometry$14(params) {
	var chart = params.chart, options = params.options;
	var bulletStyle = options.bulletStyle, targetField = options.targetField, rangeField = options.rangeField, measureField = options.measureField, xField = options.xField, color$2 = options.color, layout$1 = options.layout, size$1 = options.size, label$16 = options.label;
	var _a$5 = transformData$5(options), min$2 = _a$5.min, max$2 = _a$5.max, ds = _a$5.ds;
	chart.data(ds);
	var r = deepAssign({}, params, { options: {
		xField,
		yField: rangeField,
		seriesField: "rKey",
		isStack: true,
		label: get_default(label$16, "range"),
		interval: {
			color: get_default(color$2, "range"),
			style: get_default(bulletStyle, "range"),
			size: get_default(size$1, "range")
		}
	} });
	interval(r);
	chart.geometries[0].tooltip(false);
	var m = deepAssign({}, params, { options: {
		xField,
		yField: measureField,
		seriesField: "mKey",
		isStack: true,
		label: get_default(label$16, "measure"),
		interval: {
			color: get_default(color$2, "measure"),
			style: get_default(bulletStyle, "measure"),
			size: get_default(size$1, "measure")
		}
	} });
	interval(m);
	var t = deepAssign({}, params, { options: {
		xField,
		yField: targetField,
		seriesField: "tKey",
		label: get_default(label$16, "target"),
		point: {
			color: get_default(color$2, "target"),
			style: get_default(bulletStyle, "target"),
			size: is_function_default(get_default(size$1, "target")) ? function(data$2) {
				return get_default(size$1, "target")(data$2) / 2;
			} : get_default(size$1, "target") / 2,
			shape: layout$1 === "horizontal" ? "line" : "hyphen"
		}
	} });
	point(t);
	if (layout$1 === "horizontal") chart.coordinate().transpose();
	return __assign(__assign({}, params), { ext: { data: {
		min: min$2,
		max: max$2
	} } });
}
/**
* meta 配置
* @param params
*/
function meta$10(params) {
	var _a$5, _b;
	var options = params.options, ext = params.ext;
	var xAxis = options.xAxis, yAxis = options.yAxis, targetField = options.targetField, rangeField = options.rangeField, measureField = options.measureField, xField = options.xField;
	var extData = ext.data;
	return flow(scale((_a$5 = {}, _a$5[xField] = xAxis, _a$5[measureField] = yAxis, _a$5), (_b = {}, _b[measureField] = {
		min: extData === null || extData === void 0 ? void 0 : extData.min,
		max: extData === null || extData === void 0 ? void 0 : extData.max,
		sync: true
	}, _b[targetField] = { sync: "".concat(measureField) }, _b[rangeField] = { sync: "".concat(measureField) }, _b)))(params);
}
/**
* axis 配置
* @param params
*/
function axis$12(params) {
	var chart = params.chart, options = params.options;
	var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, measureField = options.measureField, rangeField = options.rangeField, targetField = options.targetField;
	chart.axis("".concat(rangeField), false);
	chart.axis("".concat(targetField), false);
	if (xAxis === false) chart.axis("".concat(xField), false);
	else chart.axis("".concat(xField), xAxis);
	if (yAxis === false) chart.axis("".concat(measureField), false);
	else chart.axis("".concat(measureField), yAxis);
	return params;
}
/**
* legend 配置
* @param params
*/
function legend$9(params) {
	var chart = params.chart;
	var legend$17 = params.options.legend;
	chart.removeInteraction("legend-filter");
	chart.legend(legend$17);
	chart.legend("rKey", false);
	chart.legend("mKey", false);
	chart.legend("tKey", false);
	return params;
}
/**
* label 配置
* @param params
*/
function label$7(params) {
	var chart = params.chart, options = params.options;
	var label$16 = options.label, measureField = options.measureField, targetField = options.targetField, rangeField = options.rangeField;
	var _a$5 = chart.geometries, rangeGeometry = _a$5[0], measureGeometry = _a$5[1], targetGeometry = _a$5[2];
	if (get_default(label$16, "range")) rangeGeometry.label("".concat(rangeField), __assign({ layout: [{ type: "limit-in-plot" }] }, transformLabel(label$16.range)));
	else rangeGeometry.label(false);
	if (get_default(label$16, "measure")) measureGeometry.label("".concat(measureField), __assign({ layout: [{ type: "limit-in-plot" }] }, transformLabel(label$16.measure)));
	else measureGeometry.label(false);
	if (get_default(label$16, "target")) targetGeometry.label("".concat(targetField), __assign({ layout: [{ type: "limit-in-plot" }] }, transformLabel(label$16.target)));
	else targetGeometry.label(false);
	return params;
}
/**
* 子弹图适配器
* @param chart
* @param options
*/
function adaptor$17(params) {
	flow(geometry$14, meta$10, axis$12, legend$9, theme, label$7, tooltip, interaction, animation)(params);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/bullet/constant.js
/**
* 默认配置项
*/
var DEFAULT_OPTIONS$19 = deepAssign({}, Plot.getDefaultOptions(), {
	layout: "horizontal",
	size: {
		range: 30,
		measure: 20,
		target: 20
	},
	xAxis: {
		tickLine: false,
		line: null
	},
	bulletStyle: { range: { fillOpacity: .5 } },
	label: { measure: { position: "right" } },
	tooltip: { showMarkers: false }
});

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/bullet/index.js
var Bullet = function(_super) {
	__extends(Bullet$1, _super);
	function Bullet$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		/** 图表类型 */
		_this.type = "bullet";
		return _this;
	}
	/**
	* 获取 子弹图 默认配置项
	* 供外部使用
	*/
	Bullet$1.getDefaultOptions = function() {
		return DEFAULT_OPTIONS$19;
	};
	Bullet$1.prototype.changeData = function(data$2) {
		this.updateOption({ data: data$2 });
		var _a$5 = transformData$5(this.options), min$2 = _a$5.min, max$2 = _a$5.max, ds = _a$5.ds;
		meta$10({
			options: this.options,
			ext: { data: {
				min: min$2,
				max: max$2
			} },
			chart: this.chart
		});
		this.chart.changeData(ds);
	};
	/**
	* 获取子弹图的适配器
	*/
	Bullet$1.prototype.getSchemaAdaptor = function() {
		return adaptor$17;
	};
	/**
	* 获取 子弹图 默认配置
	*/
	Bullet$1.prototype.getDefaultOptions = function() {
		return Bullet$1.getDefaultOptions();
	};
	return Bullet$1;
}(Plot);

//#endregion
//#region node_modules/@antv/g2plot/esm/utils/transform/chord.js
var DEFAULT_OPTIONS$18 = {
	y: 0,
	nodeWidthRatio: .05,
	weight: false,
	nodePaddingRatio: .1,
	id: function(node) {
		return node.id;
	},
	source: function(edge$1) {
		return edge$1.source;
	},
	target: function(edge$1) {
		return edge$1.target;
	},
	sourceWeight: function(edge$1) {
		return edge$1.value || 1;
	},
	targetWeight: function(edge$1) {
		return edge$1.value || 1;
	},
	sortBy: null
};
/**
* 处理节点的value、edges
* @param nodeById
* @param edges
* @param options
*/
function processGraph(nodeById, edges, options) {
	for_in_default(nodeById, function(node, id$1) {
		node.inEdges = edges.filter(function(edge$1) {
			return "".concat(options.target(edge$1)) === "".concat(id$1);
		});
		node.outEdges = edges.filter(function(edge$1) {
			return "".concat(options.source(edge$1)) === "".concat(id$1);
		});
		node.edges = node.outEdges.concat(node.inEdges);
		node.frequency = node.edges.length;
		node.value = 0;
		node.inEdges.forEach(function(edge$1) {
			node.value += options.targetWeight(edge$1);
		});
		node.outEdges.forEach(function(edge$1) {
			node.value += options.sourceWeight(edge$1);
		});
	});
}
/**
* 节点排序
* @param nodes
* @param options
*/
function sortNodes(nodes, options) {
	var method = {
		weight: function(a, b) {
			return b.value - a.value;
		},
		frequency: function(a, b) {
			return b.frequency - a.frequency;
		},
		id: function(a, b) {
			return "".concat(options.id(a)).localeCompare("".concat(options.id(b)));
		}
	}[options.sortBy];
	if (!method && is_function_default(options.sortBy)) method = options.sortBy;
	if (method) nodes.sort(method);
}
function layoutNodes(nodes, options) {
	var len = nodes.length;
	if (!len) throw new TypeError("Invalid nodes: it's empty!");
	if (options.weight) {
		var nodePaddingRatio_1 = options.nodePaddingRatio;
		if (nodePaddingRatio_1 < 0 || nodePaddingRatio_1 >= 1) throw new TypeError("Invalid nodePaddingRatio: it must be in range [0, 1)!");
		var margin_1 = nodePaddingRatio_1 / (2 * len);
		var nodeWidthRatio_1 = options.nodeWidthRatio;
		if (nodeWidthRatio_1 <= 0 || nodeWidthRatio_1 >= 1) throw new TypeError("Invalid nodeWidthRatio: it must be in range (0, 1)!");
		var totalValue_1 = 0;
		nodes.forEach(function(node) {
			totalValue_1 += node.value;
		});
		nodes.forEach(function(node) {
			node.weight = node.value / totalValue_1;
			node.width = node.weight * (1 - nodePaddingRatio_1);
			node.height = nodeWidthRatio_1;
		});
		nodes.forEach(function(node, index) {
			var deltaX = 0;
			for (var i = index - 1; i >= 0; i--) deltaX += nodes[i].width + 2 * margin_1;
			var minX = node.minX = margin_1 + deltaX;
			var maxX = node.maxX = node.minX + node.width;
			var minY = node.minY = options.y - nodeWidthRatio_1 / 2;
			var maxY$1 = node.maxY = minY + nodeWidthRatio_1;
			node.x = [
				minX,
				maxX,
				maxX,
				minX
			];
			node.y = [
				minY,
				minY,
				maxY$1,
				maxY$1
			];
		});
	} else {
		var deltaX_1 = 1 / len;
		nodes.forEach(function(node, index) {
			node.x = (index + .5) * deltaX_1;
			node.y = options.y;
		});
	}
	return nodes;
}
function locatingEdges(nodeById, edges, options) {
	if (options.weight) {
		var valueById_1 = {};
		for_in_default(nodeById, function(node, id$1) {
			valueById_1[id$1] = node.value;
		});
		edges.forEach(function(edge$1) {
			var sId = options.source(edge$1);
			var tId = options.target(edge$1);
			var sNode = nodeById[sId];
			var tNode = nodeById[tId];
			if (sNode && tNode) {
				var sValue = valueById_1[sId];
				var currentSValue = options.sourceWeight(edge$1);
				var sStart = sNode.minX + (sNode.value - sValue) / sNode.value * sNode.width;
				var sEnd = sStart + currentSValue / sNode.value * sNode.width;
				valueById_1[sId] -= currentSValue;
				var tValue = valueById_1[tId];
				var currentTValue = options.targetWeight(edge$1);
				var tStart = tNode.minX + (tNode.value - tValue) / tNode.value * tNode.width;
				var tEnd = tStart + currentTValue / tNode.value * tNode.width;
				valueById_1[tId] -= currentTValue;
				var y = options.y;
				edge$1.x = [
					sStart,
					sEnd,
					tStart,
					tEnd
				];
				edge$1.y = [
					y,
					y,
					y,
					y
				];
				edge$1.source = sNode;
				edge$1.target = tNode;
			}
		});
	} else edges.forEach(function(edge$1) {
		var sNode = nodeById[options.source(edge$1)];
		var tNode = nodeById[options.target(edge$1)];
		if (sNode && tNode) {
			edge$1.x = [sNode.x, tNode.x];
			edge$1.y = [sNode.y, tNode.y];
			edge$1.source = sNode;
			edge$1.target = tNode;
		}
	});
	return edges;
}
function getDefaultOptions$1(options) {
	return mix({}, DEFAULT_OPTIONS$18, options);
}
function chordLayout(chordLayoutOptions, chordLayoutInputData) {
	var options = getDefaultOptions$1(chordLayoutOptions);
	var nodeById = {};
	var nodes = chordLayoutInputData.nodes;
	var links = chordLayoutInputData.links;
	nodes.forEach(function(node) {
		var id$1 = options.id(node);
		nodeById[id$1] = node;
	});
	processGraph(nodeById, links, options);
	sortNodes(nodes, options);
	var outputNodes = layoutNodes(nodes, options);
	var outputLinks = locatingEdges(nodeById, links, options);
	return {
		nodes: outputNodes,
		links: outputLinks
	};
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/chord/constant.js
var X_FIELD$2 = "x";
var Y_FIELD$2 = "y";
var NODE_COLOR_FIELD = "name";
var EDGE_COLOR_FIELD = "source";
var DEFAULT_OPTIONS$17 = {
	nodeStyle: {
		opacity: 1,
		fillOpacity: 1,
		lineWidth: 1
	},
	edgeStyle: {
		opacity: .5,
		lineWidth: 2
	},
	label: {
		fields: ["x", "name"],
		callback: function(x, name) {
			return {
				offsetX: (x[0] + x[1]) / 2 > .5 ? -4 : 4,
				content: name
			};
		},
		labelEmit: true,
		style: { fill: "#8c8c8c" }
	},
	tooltip: {
		showTitle: false,
		showMarkers: false,
		fields: [
			"source",
			"target",
			"value",
			"isNode"
		],
		showContent: function(items) {
			return !get_default(items, [
				0,
				"data",
				"isNode"
			]);
		},
		formatter: function(datum) {
			var source = datum.source, target = datum.target, value$1 = datum.value;
			return {
				name: "".concat(source, " -> ").concat(target),
				value: value$1
			};
		}
	},
	interactions: [{ type: "element-active" }],
	weight: true,
	nodePaddingRatio: .1,
	nodeWidthRatio: .05
};

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/chord/adaptor.js
function transformData$4(params) {
	var options = params.options;
	var data$2 = options.data, sourceField = options.sourceField, targetField = options.targetField, weightField = options.weightField, nodePaddingRatio = options.nodePaddingRatio, nodeWidthRatio = options.nodeWidthRatio, _a$5 = options.rawFields, rawFields = _a$5 === void 0 ? [] : _a$5;
	var chordLayoutInputData = transformDataToNodeLinkData(data$2, sourceField, targetField, weightField);
	var _b = chordLayout({
		weight: true,
		nodePaddingRatio,
		nodeWidthRatio
	}, chordLayoutInputData), nodes = _b.nodes, links = _b.links;
	var nodesData = nodes.map(function(node) {
		return __assign(__assign({}, pick(node, __spreadArray([
			"id",
			"x",
			"y",
			"name"
		], rawFields, true))), { isNode: true });
	});
	var edgesData = links.map(function(link) {
		return __assign(__assign({
			source: link.source.name,
			target: link.target.name,
			name: link.source.name || link.target.name
		}, pick(link, __spreadArray([
			"x",
			"y",
			"value"
		], rawFields, true))), { isNode: false });
	});
	return __assign(__assign({}, params), { ext: __assign(__assign({}, params.ext), { chordData: {
		nodesData,
		edgesData
	} }) });
}
/**
* scale配置
* @param params 参数
*/
function scale$2(params) {
	var _a$5;
	params.chart.scale((_a$5 = {
		x: {
			sync: true,
			nice: true
		},
		y: {
			sync: true,
			nice: true,
			max: 1
		}
	}, _a$5[NODE_COLOR_FIELD] = { sync: "color" }, _a$5[EDGE_COLOR_FIELD] = { sync: "color" }, _a$5));
	return params;
}
/**
* axis配置
* @param params 参数
*/
function axis$11(params) {
	params.chart.axis(false);
	return params;
}
/**
* legend配置
* @param params 参数
*/
function legend$8(params) {
	params.chart.legend(false);
	return params;
}
/**
* tooltip配置
* @param params 参数
*/
function tooltip$5(params) {
	var chart = params.chart;
	var tooltip$10 = params.options.tooltip;
	chart.tooltip(tooltip$10);
	return params;
}
/**
* coordinate配置
* @param params 参数
*/
function coordinate$4(params) {
	params.chart.coordinate("polar").reflect("y");
	return params;
}
/**
* nodeGeometry配置
* @param params 参数
*/
function nodeGeometry(params) {
	var chart = params.chart, options = params.options;
	var nodesData = params.ext.chordData.nodesData;
	var nodeStyle = options.nodeStyle, label$16 = options.label, tooltip$10 = options.tooltip;
	var nodeView = chart.createView();
	nodeView.data(nodesData);
	polygon({
		chart: nodeView,
		options: {
			xField: X_FIELD$2,
			yField: Y_FIELD$2,
			seriesField: NODE_COLOR_FIELD,
			polygon: { style: nodeStyle },
			label: label$16,
			tooltip: tooltip$10
		}
	});
	return params;
}
/**
* edgeGeometry配置
* @param params 参数
*/
function edgeGeometry(params) {
	var chart = params.chart, options = params.options;
	var edgesData = params.ext.chordData.edgesData;
	var edgeStyle = options.edgeStyle, tooltip$10 = options.tooltip;
	var edgeView = chart.createView();
	edgeView.data(edgesData);
	edge({
		chart: edgeView,
		options: {
			xField: X_FIELD$2,
			yField: Y_FIELD$2,
			seriesField: EDGE_COLOR_FIELD,
			edge: {
				style: edgeStyle,
				shape: "arc"
			},
			tooltip: tooltip$10
		}
	});
	return params;
}
function animation$4(params) {
	var chart = params.chart;
	var animation$6 = params.options.animation;
	addViewAnimation(chart, animation$6, getAllGeometriesRecursively(chart));
	return params;
}
/**
* 弦图适配器
* @param chart
* @param options
*/
function adaptor$16(params) {
	return flow(theme, transformData$4, coordinate$4, scale$2, axis$11, legend$8, tooltip$5, edgeGeometry, nodeGeometry, interaction, state, animation$4)(params);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/chord/index.js
/**
*  弦图 Chord
*/
var Chord = function(_super) {
	__extends(Chord$1, _super);
	function Chord$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		/** 图表类型 */
		_this.type = "chord";
		return _this;
	}
	/**
	* 获取 面积图 默认配置项
	* 供外部使用
	*/
	Chord$1.getDefaultOptions = function() {
		return DEFAULT_OPTIONS$17;
	};
	Chord$1.prototype.getDefaultOptions = function() {
		return Chord$1.getDefaultOptions();
	};
	/**
	* 获取适配器
	*/
	Chord$1.prototype.getSchemaAdaptor = function() {
		return adaptor$16;
	};
	return Chord$1;
}(Plot);

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/circle-packing/constant.js
/** 默认的源字段 */
var RAW_FIELDS$1 = [
	"x",
	"y",
	"r",
	"name",
	"value",
	"path",
	"depth"
];
var DEFAULT_OPTIONS$15 = {
	colorField: "name",
	autoFit: true,
	pointStyle: {
		lineWidth: 0,
		stroke: "#fff"
	},
	legend: false,
	hierarchyConfig: {
		size: [1, 1],
		padding: 0
	},
	label: {
		fields: ["name"],
		layout: { type: "limit-in-shape" }
	},
	tooltip: {
		showMarkers: false,
		showTitle: false
	},
	drilldown: { enabled: false }
};

//#endregion
//#region node_modules/@antv/g2plot/esm/interactions/actions/drill-down.js
var PADDING = 4;
var PADDING_LEFT = 0;
var PADDING_TOP = 5;
/** Group name of breadCrumb: 面包屑 */
var BREAD_CRUMB_NAME = "drilldown-bread-crumb";
var DEFAULT_BREAD_CRUMB_CONFIG = {
	position: "top-left",
	dividerText: "/",
	textStyle: {
		fontSize: 12,
		fill: "rgba(0, 0, 0, 0.65)",
		cursor: "pointer"
	},
	activeTextStyle: { fill: "#87B5FF" }
};
/**
* hierarchy 数据转换的参数
*/
var HIERARCHY_DATA_TRANSFORM_PARAMS = "hierarchy-data-transform-params";
/**
* @description 下钻交互的 action
* @author liuzhenying
*
* 适用于：hierarchy plot
*/
var DrillDownAction = function(_super) {
	__extends(DrillDownAction$1, _super);
	function DrillDownAction$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		/** Action name */
		_this.name = "drill-down";
		_this.historyCache = [];
		_this.breadCrumbGroup = null;
		_this.breadCrumbCfg = DEFAULT_BREAD_CRUMB_CONFIG;
		return _this;
	}
	/**
	* 点击事件, 下钻数据，并绘制面包屑
	*/
	DrillDownAction$1.prototype.click = function() {
		var data$2 = get_default(this.context, [
			"event",
			"data",
			"data"
		]);
		if (!data$2) return false;
		this.drill(data$2);
		this.drawBreadCrumb();
	};
	/**
	* 重置位置，初始化及触发 chart  afterchangesize 回调时使用
	*/
	DrillDownAction$1.prototype.resetPosition = function() {
		if (!this.breadCrumbGroup) return;
		var coordinate$10 = this.context.view.getCoordinate();
		var breadCrumbGroup = this.breadCrumbGroup;
		var bbox = breadCrumbGroup.getBBox();
		var position = this.getButtonCfg().position;
		var point$1 = {
			x: coordinate$10.start.x,
			y: coordinate$10.end.y - (bbox.height + PADDING_TOP * 2)
		};
		if (coordinate$10.isPolar) point$1 = {
			x: 0,
			y: 0
		};
		if (position === "bottom-left") point$1 = {
			x: coordinate$10.start.x,
			y: coordinate$10.start.y
		};
		/** PADDING_LEFT, PADDING_TOP 与画布边缘的距离 */
		var matrix = Util.transform(null, [[
			"t",
			point$1.x + PADDING_LEFT,
			point$1.y + bbox.height + PADDING_TOP
		]]);
		breadCrumbGroup.setMatrix(matrix);
	};
	/**
	* 返回上一层
	*/
	DrillDownAction$1.prototype.back = function() {
		if (size(this.historyCache)) this.backTo(this.historyCache.slice(0, -1));
	};
	/**
	* 重置
	*/
	DrillDownAction$1.prototype.reset = function() {
		if (this.historyCache[0]) this.backTo(this.historyCache.slice(0, 1));
		this.historyCache = [];
		this.hideCrumbGroup();
	};
	/**
	* 下钻数据并更新 view 显示层
	* @param nodeInfo 下钻数据
	*/
	DrillDownAction$1.prototype.drill = function(nodeInfo) {
		var view = this.context.view;
		var transformData$9 = get_default(view, [
			"interactions",
			"drill-down",
			"cfg",
			"transformData"
		], function(v) {
			return v;
		});
		var drillData = transformData$9(__assign({ data: nodeInfo.data }, nodeInfo[HIERARCHY_DATA_TRANSFORM_PARAMS]));
		view.changeData(drillData);
		var historyCache = [];
		var node = nodeInfo;
		while (node) {
			var nodeData = node.data;
			historyCache.unshift({
				id: "".concat(nodeData.name, "_").concat(node.height, "_").concat(node.depth),
				name: nodeData.name,
				children: transformData$9(__assign({ data: nodeData }, nodeInfo[HIERARCHY_DATA_TRANSFORM_PARAMS]))
			});
			node = node.parent;
		}
		this.historyCache = (this.historyCache || []).slice(0, -1).concat(historyCache);
	};
	/**
	* 回退事件，点击面包屑时触发
	* @param historyCache 当前要回退到的历史
	*/
	DrillDownAction$1.prototype.backTo = function(historyCache) {
		if (!historyCache || historyCache.length <= 0) return;
		var view = this.context.view;
		var data$2 = last(historyCache).children;
		view.changeData(data$2);
		if (historyCache.length > 1) {
			this.historyCache = historyCache;
			this.drawBreadCrumb();
		} else {
			this.historyCache = [];
			this.hideCrumbGroup();
		}
	};
	/**
	* 获取 mix 默认的配置和用户配置
	*/
	DrillDownAction$1.prototype.getButtonCfg = function() {
		var view = this.context.view;
		var drillDownConfig = get_default(view, [
			"interactions",
			"drill-down",
			"cfg",
			"drillDownConfig"
		]);
		return deepAssign(this.breadCrumbCfg, drillDownConfig === null || drillDownConfig === void 0 ? void 0 : drillDownConfig.breadCrumb, this.cfg);
	};
	/**
	* 显示面包屑
	*/
	DrillDownAction$1.prototype.drawBreadCrumb = function() {
		this.drawBreadCrumbGroup();
		this.resetPosition();
		this.breadCrumbGroup.show();
	};
	/**
	* 绘制 Button 和 文本
	*/
	DrillDownAction$1.prototype.drawBreadCrumbGroup = function() {
		var _this = this;
		var config = this.getButtonCfg();
		var cache$2 = this.historyCache;
		if (!this.breadCrumbGroup) this.breadCrumbGroup = this.context.view.foregroundGroup.addGroup({ name: BREAD_CRUMB_NAME });
		else this.breadCrumbGroup.clear();
		var left$1 = 0;
		cache$2.forEach(function(record, index) {
			var textShape = _this.breadCrumbGroup.addShape({
				type: "text",
				id: record.id,
				name: "".concat(BREAD_CRUMB_NAME, "_").concat(record.name, "_text"),
				attrs: __assign(__assign({ text: index === 0 && !is_nil_default(config.rootText) ? config.rootText : record.name }, config.textStyle), {
					x: left$1,
					y: 0
				})
			});
			var textShapeBox = textShape.getBBox();
			left$1 += textShapeBox.width + PADDING;
			textShape.on("click", function(event) {
				var _a$5;
				var targetId = event.target.get("id");
				if (targetId !== ((_a$5 = last(cache$2)) === null || _a$5 === void 0 ? void 0 : _a$5.id)) {
					var newHistoryCache = cache$2.slice(0, cache$2.findIndex(function(d) {
						return d.id === targetId;
					}) + 1);
					_this.backTo(newHistoryCache);
				}
			});
			textShape.on("mouseenter", function(event) {
				var _a$5;
				if (event.target.get("id") !== ((_a$5 = last(cache$2)) === null || _a$5 === void 0 ? void 0 : _a$5.id)) textShape.attr(config.activeTextStyle);
				else textShape.attr({ cursor: "default" });
			});
			textShape.on("mouseleave", function() {
				textShape.attr(config.textStyle);
			});
			if (index < cache$2.length - 1) {
				var dividerBox = _this.breadCrumbGroup.addShape({
					type: "text",
					name: "".concat(config.name, "_").concat(record.name, "_divider"),
					attrs: __assign(__assign({ text: config.dividerText }, config.textStyle), {
						x: left$1,
						y: 0
					})
				}).getBBox();
				left$1 += dividerBox.width + PADDING;
			}
		});
	};
	/**
	* 隐藏面包屑
	*/
	DrillDownAction$1.prototype.hideCrumbGroup = function() {
		if (this.breadCrumbGroup) this.breadCrumbGroup.hide();
	};
	/**
	* @override
	* destroy: 销毁资源
	*/
	DrillDownAction$1.prototype.destroy = function() {
		if (this.breadCrumbGroup) this.breadCrumbGroup.remove();
		_super.prototype.destroy.call(this);
	};
	return DrillDownAction$1;
}(base_default$1);

//#endregion
//#region node_modules/d3-hierarchy/src/cluster.js
function defaultSeparation$1(a, b) {
	return a.parent === b.parent ? 1 : 2;
}
function meanX(children) {
	return children.reduce(meanXReduce, 0) / children.length;
}
function meanXReduce(x, c) {
	return x + c.x;
}
function maxY(children) {
	return 1 + children.reduce(maxYReduce, 0);
}
function maxYReduce(y, c) {
	return Math.max(y, c.y);
}
function leafLeft(node) {
	var children;
	while (children = node.children) node = children[0];
	return node;
}
function leafRight(node) {
	var children;
	while (children = node.children) node = children[children.length - 1];
	return node;
}
function cluster_default() {
	var separation = defaultSeparation$1, dx = 1, dy = 1, nodeSize = false;
	function cluster(root) {
		var previousNode, x = 0;
		root.eachAfter(function(node) {
			var children = node.children;
			if (children) {
				node.x = meanX(children);
				node.y = maxY(children);
			} else {
				node.x = previousNode ? x += separation(node, previousNode) : 0;
				node.y = 0;
				previousNode = node;
			}
		});
		var left$1 = leafLeft(root), right$1 = leafRight(root), x0 = left$1.x - separation(left$1, right$1) / 2, x1 = right$1.x + separation(right$1, left$1) / 2;
		return root.eachAfter(nodeSize ? function(node) {
			node.x = (node.x - root.x) * dx;
			node.y = (root.y - node.y) * dy;
		} : function(node) {
			node.x = (node.x - x0) / (x1 - x0) * dx;
			node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
		});
	}
	cluster.separation = function(x) {
		return arguments.length ? (separation = x, cluster) : separation;
	};
	cluster.size = function(x) {
		return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : nodeSize ? null : [dx, dy];
	};
	cluster.nodeSize = function(x) {
		return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : nodeSize ? [dx, dy] : null;
	};
	return cluster;
}

//#endregion
//#region node_modules/d3-hierarchy/src/hierarchy/count.js
function count(node) {
	var sum = 0, children = node.children, i = children && children.length;
	if (!i) sum = 1;
	else while (--i >= 0) sum += children[i].value;
	node.value = sum;
}
function count_default() {
	return this.eachAfter(count);
}

//#endregion
//#region node_modules/d3-hierarchy/src/hierarchy/each.js
function each_default$1(callback, that) {
	let index = -1;
	for (const node of this) callback.call(that, node, ++index, this);
	return this;
}

//#endregion
//#region node_modules/d3-hierarchy/src/hierarchy/eachBefore.js
function eachBefore_default(callback, that) {
	var node = this, nodes = [node], children, i, index = -1;
	while (node = nodes.pop()) {
		callback.call(that, node, ++index, this);
		if (children = node.children) for (i = children.length - 1; i >= 0; --i) nodes.push(children[i]);
	}
	return this;
}

//#endregion
//#region node_modules/d3-hierarchy/src/hierarchy/eachAfter.js
function eachAfter_default(callback, that) {
	var node = this, nodes = [node], next = [], children, i, n, index = -1;
	while (node = nodes.pop()) {
		next.push(node);
		if (children = node.children) for (i = 0, n = children.length; i < n; ++i) nodes.push(children[i]);
	}
	while (node = next.pop()) callback.call(that, node, ++index, this);
	return this;
}

//#endregion
//#region node_modules/d3-hierarchy/src/hierarchy/find.js
function find_default$1(callback, that) {
	let index = -1;
	for (const node of this) if (callback.call(that, node, ++index, this)) return node;
}

//#endregion
//#region node_modules/d3-hierarchy/src/hierarchy/sum.js
function sum_default(value$1) {
	return this.eachAfter(function(node) {
		var sum = +value$1(node.data) || 0, children = node.children, i = children && children.length;
		while (--i >= 0) sum += children[i].value;
		node.value = sum;
	});
}

//#endregion
//#region node_modules/d3-hierarchy/src/hierarchy/sort.js
function sort_default(compare$1) {
	return this.eachBefore(function(node) {
		if (node.children) node.children.sort(compare$1);
	});
}

//#endregion
//#region node_modules/d3-hierarchy/src/hierarchy/path.js
function path_default(end) {
	var start = this, ancestor = leastCommonAncestor(start, end), nodes = [start];
	while (start !== ancestor) {
		start = start.parent;
		nodes.push(start);
	}
	var k = nodes.length;
	while (end !== ancestor) {
		nodes.splice(k, 0, end);
		end = end.parent;
	}
	return nodes;
}
function leastCommonAncestor(a, b) {
	if (a === b) return a;
	var aNodes = a.ancestors(), bNodes = b.ancestors(), c = null;
	a = aNodes.pop();
	b = bNodes.pop();
	while (a === b) {
		c = a;
		a = aNodes.pop();
		b = bNodes.pop();
	}
	return c;
}

//#endregion
//#region node_modules/d3-hierarchy/src/hierarchy/ancestors.js
function ancestors_default() {
	var node = this, nodes = [node];
	while (node = node.parent) nodes.push(node);
	return nodes;
}

//#endregion
//#region node_modules/d3-hierarchy/src/hierarchy/descendants.js
function descendants_default() {
	return Array.from(this);
}

//#endregion
//#region node_modules/d3-hierarchy/src/hierarchy/leaves.js
function leaves_default() {
	var leaves = [];
	this.eachBefore(function(node) {
		if (!node.children) leaves.push(node);
	});
	return leaves;
}

//#endregion
//#region node_modules/d3-hierarchy/src/hierarchy/links.js
function links_default() {
	var root = this, links = [];
	root.each(function(node) {
		if (node !== root) links.push({
			source: node.parent,
			target: node
		});
	});
	return links;
}

//#endregion
//#region node_modules/d3-hierarchy/src/hierarchy/iterator.js
function* iterator_default() {
	var node = this, current, next = [node], children, i, n;
	do {
		current = next.reverse(), next = [];
		while (node = current.pop()) {
			yield node;
			if (children = node.children) for (i = 0, n = children.length; i < n; ++i) next.push(children[i]);
		}
	} while (next.length);
}

//#endregion
//#region node_modules/d3-hierarchy/src/hierarchy/index.js
function hierarchy(data$2, children) {
	if (data$2 instanceof Map) {
		data$2 = [void 0, data$2];
		if (children === void 0) children = mapChildren;
	} else if (children === void 0) children = objectChildren;
	var root = new Node(data$2), node, nodes = [root], child, childs, i, n;
	while (node = nodes.pop()) if ((childs = children(node.data)) && (n = (childs = Array.from(childs)).length)) {
		node.children = childs;
		for (i = n - 1; i >= 0; --i) {
			nodes.push(child = childs[i] = new Node(childs[i]));
			child.parent = node;
			child.depth = node.depth + 1;
		}
	}
	return root.eachBefore(computeHeight);
}
function node_copy() {
	return hierarchy(this).eachBefore(copyData);
}
function objectChildren(d) {
	return d.children;
}
function mapChildren(d) {
	return Array.isArray(d) ? d[1] : null;
}
function copyData(node) {
	if (node.data.value !== void 0) node.value = node.data.value;
	node.data = node.data.data;
}
function computeHeight(node) {
	var height = 0;
	do
		node.height = height;
	while ((node = node.parent) && node.height < ++height);
}
function Node(data$2) {
	this.data = data$2;
	this.depth = this.height = 0;
	this.parent = null;
}
Node.prototype = hierarchy.prototype = {
	constructor: Node,
	count: count_default,
	each: each_default$1,
	eachAfter: eachAfter_default,
	eachBefore: eachBefore_default,
	find: find_default$1,
	sum: sum_default,
	sort: sort_default,
	path: path_default,
	ancestors: ancestors_default,
	descendants: descendants_default,
	leaves: leaves_default,
	links: links_default,
	copy: node_copy,
	[Symbol.iterator]: iterator_default
};

//#endregion
//#region node_modules/d3-hierarchy/src/array.js
function array_default(x) {
	return typeof x === "object" && "length" in x ? x : Array.from(x);
}
function shuffle(array) {
	var m = array.length, t, i;
	while (m) {
		i = Math.random() * m-- | 0;
		t = array[m];
		array[m] = array[i];
		array[i] = t;
	}
	return array;
}

//#endregion
//#region node_modules/d3-hierarchy/src/pack/enclose.js
function enclose_default(circles) {
	var i = 0, n = (circles = shuffle(Array.from(circles))).length, B = [], p, e;
	while (i < n) {
		p = circles[i];
		if (e && enclosesWeak(e, p)) ++i;
		else e = encloseBasis(B = extendBasis(B, p)), i = 0;
	}
	return e;
}
function extendBasis(B, p) {
	var i, j;
	if (enclosesWeakAll(p, B)) return [p];
	for (i = 0; i < B.length; ++i) if (enclosesNot(p, B[i]) && enclosesWeakAll(encloseBasis2(B[i], p), B)) return [B[i], p];
	for (i = 0; i < B.length - 1; ++i) for (j = i + 1; j < B.length; ++j) if (enclosesNot(encloseBasis2(B[i], B[j]), p) && enclosesNot(encloseBasis2(B[i], p), B[j]) && enclosesNot(encloseBasis2(B[j], p), B[i]) && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) return [
		B[i],
		B[j],
		p
	];
	throw new Error();
}
function enclosesNot(a, b) {
	var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;
	return dr < 0 || dr * dr < dx * dx + dy * dy;
}
function enclosesWeak(a, b) {
	var dr = a.r - b.r + Math.max(a.r, b.r, 1) * 1e-9, dx = b.x - a.x, dy = b.y - a.y;
	return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function enclosesWeakAll(a, B) {
	for (var i = 0; i < B.length; ++i) if (!enclosesWeak(a, B[i])) return false;
	return true;
}
function encloseBasis(B) {
	switch (B.length) {
		case 1: return encloseBasis1(B[0]);
		case 2: return encloseBasis2(B[0], B[1]);
		case 3: return encloseBasis3(B[0], B[1], B[2]);
	}
}
function encloseBasis1(a) {
	return {
		x: a.x,
		y: a.y,
		r: a.r
	};
}
function encloseBasis2(a, b) {
	var x1 = a.x, y1 = a.y, r1 = a.r, x2 = b.x, y2 = b.y, r2 = b.r, x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1, l = Math.sqrt(x21 * x21 + y21 * y21);
	return {
		x: (x1 + x2 + x21 / l * r21) / 2,
		y: (y1 + y2 + y21 / l * r21) / 2,
		r: (l + r1 + r2) / 2
	};
}
function encloseBasis3(a, b, c) {
	var x1 = a.x, y1 = a.y, r1 = a.r, x2 = b.x, y2 = b.y, r2 = b.r, x3 = c.x, y3 = c.y, r3 = c.r, a2 = x1 - x2, a3 = x1 - x3, b2$1 = y1 - y2, b3$1 = y1 - y3, c2 = r2 - r1, c3 = r3 - r1, d1 = x1 * x1 + y1 * y1 - r1 * r1, d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2, d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3, ab = a3 * b2$1 - a2 * b3$1, xa = (b2$1 * d3 - b3$1 * d2) / (ab * 2) - x1, xb = (b3$1 * c2 - b2$1 * c3) / ab, ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1, yb = (a2 * c3 - a3 * c2) / ab, A = xb * xb + yb * yb - 1, B = 2 * (r1 + xa * xb + ya * yb), C = xa * xa + ya * ya - r1 * r1, r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
	return {
		x: x1 + xa + xb * r,
		y: y1 + ya + yb * r,
		r
	};
}

//#endregion
//#region node_modules/d3-hierarchy/src/pack/siblings.js
function place(b, a, c) {
	var dx = b.x - a.x, x, a2, dy = b.y - a.y, y, b2$1, d2 = dx * dx + dy * dy;
	if (d2) {
		a2 = a.r + c.r, a2 *= a2;
		b2$1 = b.r + c.r, b2$1 *= b2$1;
		if (a2 > b2$1) {
			x = (d2 + b2$1 - a2) / (2 * d2);
			y = Math.sqrt(Math.max(0, b2$1 / d2 - x * x));
			c.x = b.x - x * dx - y * dy;
			c.y = b.y - x * dy + y * dx;
		} else {
			x = (d2 + a2 - b2$1) / (2 * d2);
			y = Math.sqrt(Math.max(0, a2 / d2 - x * x));
			c.x = a.x + x * dx - y * dy;
			c.y = a.y + x * dy + y * dx;
		}
	} else {
		c.x = a.x + c.r;
		c.y = a.y;
	}
}
function intersects(a, b) {
	var dr = a.r + b.r - 1e-6, dx = b.x - a.x, dy = b.y - a.y;
	return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function score(node) {
	var a = node._, b = node.next._, ab = a.r + b.r, dx = (a.x * b.r + b.x * a.r) / ab, dy = (a.y * b.r + b.y * a.r) / ab;
	return dx * dx + dy * dy;
}
function Node$1(circle$1) {
	this._ = circle$1;
	this.next = null;
	this.previous = null;
}
function packEnclose(circles) {
	if (!(n = (circles = array_default(circles)).length)) return 0;
	var a = circles[0], b, c, n, aa, ca, i, j, k, sj, sk;
	a.x = 0, a.y = 0;
	if (!(n > 1)) return a.r;
	b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
	if (!(n > 2)) return a.r + b.r;
	place(b, a, c = circles[2]);
	a = new Node$1(a), b = new Node$1(b), c = new Node$1(c);
	a.next = c.previous = b;
	b.next = a.previous = c;
	c.next = b.previous = a;
	pack: for (i = 3; i < n; ++i) {
		place(a._, b._, c = circles[i]), c = new Node$1(c);
		j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
		do
			if (sj <= sk) {
				if (intersects(j._, c._)) {
					b = j, a.next = b, b.previous = a, --i;
					continue pack;
				}
				sj += j._.r, j = j.next;
			} else {
				if (intersects(k._, c._)) {
					a = k, a.next = b, b.previous = a, --i;
					continue pack;
				}
				sk += k._.r, k = k.previous;
			}
		while (j !== k.next);
		c.previous = a, c.next = b, a.next = b.previous = b = c;
		aa = score(a);
		while ((c = c.next) !== b) if ((ca = score(c)) < aa) a = c, aa = ca;
		b = a.next;
	}
	a = [b._], c = b;
	while ((c = c.next) !== b) a.push(c._);
	c = enclose_default(a);
	for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;
	return c.r;
}
function siblings_default(circles) {
	packEnclose(circles);
	return circles;
}

//#endregion
//#region node_modules/d3-hierarchy/src/accessors.js
function optional(f) {
	return f == null ? null : required(f);
}
function required(f) {
	if (typeof f !== "function") throw new Error();
	return f;
}

//#endregion
//#region node_modules/d3-hierarchy/src/constant.js
function constantZero() {
	return 0;
}
function constant_default(x) {
	return function() {
		return x;
	};
}

//#endregion
//#region node_modules/d3-hierarchy/src/pack/index.js
function defaultRadius(d) {
	return Math.sqrt(d.value);
}
function pack_default() {
	var radius = null, dx = 1, dy = 1, padding$2 = constantZero;
	function pack$1(root) {
		root.x = dx / 2, root.y = dy / 2;
		if (radius) root.eachBefore(radiusLeaf(radius)).eachAfter(packChildren(padding$2, .5)).eachBefore(translateChild(1));
		else root.eachBefore(radiusLeaf(defaultRadius)).eachAfter(packChildren(constantZero, 1)).eachAfter(packChildren(padding$2, root.r / Math.min(dx, dy))).eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
		return root;
	}
	pack$1.radius = function(x) {
		return arguments.length ? (radius = optional(x), pack$1) : radius;
	};
	pack$1.size = function(x) {
		return arguments.length ? (dx = +x[0], dy = +x[1], pack$1) : [dx, dy];
	};
	pack$1.padding = function(x) {
		return arguments.length ? (padding$2 = typeof x === "function" ? x : constant_default(+x), pack$1) : padding$2;
	};
	return pack$1;
}
function radiusLeaf(radius) {
	return function(node) {
		if (!node.children) node.r = Math.max(0, +radius(node) || 0);
	};
}
function packChildren(padding$2, k) {
	return function(node) {
		if (children = node.children) {
			var children, i, n = children.length, r = padding$2(node) * k || 0, e;
			if (r) for (i = 0; i < n; ++i) children[i].r += r;
			e = packEnclose(children);
			if (r) for (i = 0; i < n; ++i) children[i].r -= r;
			node.r = e + r;
		}
	};
}
function translateChild(k) {
	return function(node) {
		var parent = node.parent;
		node.r *= k;
		if (parent) {
			node.x = parent.x + k * node.x;
			node.y = parent.y + k * node.y;
		}
	};
}

//#endregion
//#region node_modules/d3-hierarchy/src/treemap/round.js
function round_default(node) {
	node.x0 = Math.round(node.x0);
	node.y0 = Math.round(node.y0);
	node.x1 = Math.round(node.x1);
	node.y1 = Math.round(node.y1);
}

//#endregion
//#region node_modules/d3-hierarchy/src/treemap/dice.js
function dice_default(parent, x0, y0, x1, y1) {
	var nodes = parent.children, node, i = -1, n = nodes.length, k = parent.value && (x1 - x0) / parent.value;
	while (++i < n) {
		node = nodes[i], node.y0 = y0, node.y1 = y1;
		node.x0 = x0, node.x1 = x0 += node.value * k;
	}
}

//#endregion
//#region node_modules/d3-hierarchy/src/partition.js
function partition_default() {
	var dx = 1, dy = 1, padding$2 = 0, round$1 = false;
	function partition$1(root) {
		var n = root.height + 1;
		root.x0 = root.y0 = padding$2;
		root.x1 = dx;
		root.y1 = dy / n;
		root.eachBefore(positionNode(dy, n));
		if (round$1) root.eachBefore(round_default);
		return root;
	}
	function positionNode(dy$1, n) {
		return function(node) {
			if (node.children) dice_default(node, node.x0, dy$1 * (node.depth + 1) / n, node.x1, dy$1 * (node.depth + 2) / n);
			var x0 = node.x0, y0 = node.y0, x1 = node.x1 - padding$2, y1 = node.y1 - padding$2;
			if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
			if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
			node.x0 = x0;
			node.y0 = y0;
			node.x1 = x1;
			node.y1 = y1;
		};
	}
	partition$1.round = function(x) {
		return arguments.length ? (round$1 = !!x, partition$1) : round$1;
	};
	partition$1.size = function(x) {
		return arguments.length ? (dx = +x[0], dy = +x[1], partition$1) : [dx, dy];
	};
	partition$1.padding = function(x) {
		return arguments.length ? (padding$2 = +x, partition$1) : padding$2;
	};
	return partition$1;
}

//#endregion
//#region node_modules/d3-hierarchy/src/stratify.js
var preroot = { depth: -1 }, ambiguous = {};
function defaultId$1(d) {
	return d.id;
}
function defaultParentId(d) {
	return d.parentId;
}
function stratify_default() {
	var id$1 = defaultId$1, parentId = defaultParentId;
	function stratify(data$2) {
		var nodes = Array.from(data$2), n = nodes.length, d, i, root, parent, node, nodeId, nodeKey, nodeByKey = /* @__PURE__ */ new Map();
		for (i = 0; i < n; ++i) {
			d = nodes[i], node = nodes[i] = new Node(d);
			if ((nodeId = id$1(d, i, data$2)) != null && (nodeId += "")) {
				nodeKey = node.id = nodeId;
				nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
			}
			if ((nodeId = parentId(d, i, data$2)) != null && (nodeId += "")) node.parent = nodeId;
		}
		for (i = 0; i < n; ++i) {
			node = nodes[i];
			if (nodeId = node.parent) {
				parent = nodeByKey.get(nodeId);
				if (!parent) throw new Error("missing: " + nodeId);
				if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
				if (parent.children) parent.children.push(node);
				else parent.children = [node];
				node.parent = parent;
			} else {
				if (root) throw new Error("multiple roots");
				root = node;
			}
		}
		if (!root) throw new Error("no root");
		root.parent = preroot;
		root.eachBefore(function(node$1) {
			node$1.depth = node$1.parent.depth + 1;
			--n;
		}).eachBefore(computeHeight);
		root.parent = null;
		if (n > 0) throw new Error("cycle");
		return root;
	}
	stratify.id = function(x) {
		return arguments.length ? (id$1 = required(x), stratify) : id$1;
	};
	stratify.parentId = function(x) {
		return arguments.length ? (parentId = required(x), stratify) : parentId;
	};
	return stratify;
}

//#endregion
//#region node_modules/d3-hierarchy/src/tree.js
function defaultSeparation(a, b) {
	return a.parent === b.parent ? 1 : 2;
}
function nextLeft(v) {
	var children = v.children;
	return children ? children[0] : v.t;
}
function nextRight(v) {
	var children = v.children;
	return children ? children[children.length - 1] : v.t;
}
function moveSubtree(wm, wp, shift) {
	var change = shift / (wp.i - wm.i);
	wp.c -= change;
	wp.s += shift;
	wm.c += change;
	wp.z += shift;
	wp.m += shift;
}
function executeShifts(v) {
	var shift = 0, change = 0, children = v.children, i = children.length, w;
	while (--i >= 0) {
		w = children[i];
		w.z += shift;
		w.m += shift;
		shift += w.s + (change += w.c);
	}
}
function nextAncestor(vim, v, ancestor) {
	return vim.a.parent === v.parent ? vim.a : ancestor;
}
function TreeNode(node, i) {
	this._ = node;
	this.parent = null;
	this.children = null;
	this.A = null;
	this.a = this;
	this.z = 0;
	this.m = 0;
	this.c = 0;
	this.s = 0;
	this.t = null;
	this.i = i;
}
TreeNode.prototype = Object.create(Node.prototype);
function treeRoot(root) {
	var tree = new TreeNode(root, 0), node, nodes = [tree], child, children, i, n;
	while (node = nodes.pop()) if (children = node._.children) {
		node.children = new Array(n = children.length);
		for (i = n - 1; i >= 0; --i) {
			nodes.push(child = node.children[i] = new TreeNode(children[i], i));
			child.parent = node;
		}
	}
	(tree.parent = new TreeNode(null, 0)).children = [tree];
	return tree;
}
function tree_default() {
	var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = null;
	function tree(root) {
		var t = treeRoot(root);
		t.eachAfter(firstWalk), t.parent.m = -t.z;
		t.eachBefore(secondWalk);
		if (nodeSize) root.eachBefore(sizeNode);
		else {
			var left$1 = root, right$1 = root, bottom = root;
			root.eachBefore(function(node) {
				if (node.x < left$1.x) left$1 = node;
				if (node.x > right$1.x) right$1 = node;
				if (node.depth > bottom.depth) bottom = node;
			});
			var s = left$1 === right$1 ? 1 : separation(left$1, right$1) / 2, tx = s - left$1.x, kx = dx / (right$1.x + s + tx), ky = dy / (bottom.depth || 1);
			root.eachBefore(function(node) {
				node.x = (node.x + tx) * kx;
				node.y = node.depth * ky;
			});
		}
		return root;
	}
	function firstWalk(v) {
		var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
		if (children) {
			executeShifts(v);
			var midpoint = (children[0].z + children[children.length - 1].z) / 2;
			if (w) {
				v.z = w.z + separation(v._, w._);
				v.m = v.z - midpoint;
			} else v.z = midpoint;
		} else if (w) v.z = w.z + separation(v._, w._);
		v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
	}
	function secondWalk(v) {
		v._.x = v.z + v.parent.m;
		v.m += v.parent.m;
	}
	function apportion(v, w, ancestor) {
		if (w) {
			var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
			while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
				vom = nextLeft(vom);
				vop = nextRight(vop);
				vop.a = v;
				shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
				if (shift > 0) {
					moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
					sip += shift;
					sop += shift;
				}
				sim += vim.m;
				sip += vip.m;
				som += vom.m;
				sop += vop.m;
			}
			if (vim && !nextRight(vop)) {
				vop.t = vim;
				vop.m += sim - sop;
			}
			if (vip && !nextLeft(vom)) {
				vom.t = vip;
				vom.m += sip - som;
				ancestor = v;
			}
		}
		return ancestor;
	}
	function sizeNode(node) {
		node.x *= dx;
		node.y = node.depth * dy;
	}
	tree.separation = function(x) {
		return arguments.length ? (separation = x, tree) : separation;
	};
	tree.size = function(x) {
		return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : nodeSize ? null : [dx, dy];
	};
	tree.nodeSize = function(x) {
		return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : nodeSize ? [dx, dy] : null;
	};
	return tree;
}

//#endregion
//#region node_modules/d3-hierarchy/src/treemap/slice.js
function slice_default(parent, x0, y0, x1, y1) {
	var nodes = parent.children, node, i = -1, n = nodes.length, k = parent.value && (y1 - y0) / parent.value;
	while (++i < n) {
		node = nodes[i], node.x0 = x0, node.x1 = x1;
		node.y0 = y0, node.y1 = y0 += node.value * k;
	}
}

//#endregion
//#region node_modules/d3-hierarchy/src/treemap/squarify.js
var phi = (1 + Math.sqrt(5)) / 2;
function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
	var rows = [], nodes = parent.children, row, nodeValue, i0 = 0, i1 = 0, n = nodes.length, dx, dy, value$1 = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;
	while (i0 < n) {
		dx = x1 - x0, dy = y1 - y0;
		do
			sumValue = nodes[i1++].value;
		while (!sumValue && i1 < n);
		minValue = maxValue = sumValue;
		alpha = Math.max(dy / dx, dx / dy) / (value$1 * ratio);
		beta = sumValue * sumValue * alpha;
		minRatio = Math.max(maxValue / beta, beta / minValue);
		for (; i1 < n; ++i1) {
			sumValue += nodeValue = nodes[i1].value;
			if (nodeValue < minValue) minValue = nodeValue;
			if (nodeValue > maxValue) maxValue = nodeValue;
			beta = sumValue * sumValue * alpha;
			newRatio = Math.max(maxValue / beta, beta / minValue);
			if (newRatio > minRatio) {
				sumValue -= nodeValue;
				break;
			}
			minRatio = newRatio;
		}
		rows.push(row = {
			value: sumValue,
			dice: dx < dy,
			children: nodes.slice(i0, i1)
		});
		if (row.dice) dice_default(row, x0, y0, x1, value$1 ? y0 += dy * sumValue / value$1 : y1);
		else slice_default(row, x0, y0, value$1 ? x0 += dx * sumValue / value$1 : x1, y1);
		value$1 -= sumValue, i0 = i1;
	}
	return rows;
}
var squarify_default = (function custom(ratio) {
	function squarify(parent, x0, y0, x1, y1) {
		squarifyRatio(ratio, parent, x0, y0, x1, y1);
	}
	squarify.ratio = function(x) {
		return custom((x = +x) > 1 ? x : 1);
	};
	return squarify;
})(phi);

//#endregion
//#region node_modules/d3-hierarchy/src/treemap/index.js
function treemap_default() {
	var tile = squarify_default, round$1 = false, dx = 1, dy = 1, paddingStack = [0], paddingInner = constantZero, paddingTop = constantZero, paddingRight = constantZero, paddingBottom = constantZero, paddingLeft = constantZero;
	function treemap$1(root) {
		root.x0 = root.y0 = 0;
		root.x1 = dx;
		root.y1 = dy;
		root.eachBefore(positionNode);
		paddingStack = [0];
		if (round$1) root.eachBefore(round_default);
		return root;
	}
	function positionNode(node) {
		var p = paddingStack[node.depth], x0 = node.x0 + p, y0 = node.y0 + p, x1 = node.x1 - p, y1 = node.y1 - p;
		if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
		if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
		node.x0 = x0;
		node.y0 = y0;
		node.x1 = x1;
		node.y1 = y1;
		if (node.children) {
			p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
			x0 += paddingLeft(node) - p;
			y0 += paddingTop(node) - p;
			x1 -= paddingRight(node) - p;
			y1 -= paddingBottom(node) - p;
			if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
			if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
			tile(node, x0, y0, x1, y1);
		}
	}
	treemap$1.round = function(x) {
		return arguments.length ? (round$1 = !!x, treemap$1) : round$1;
	};
	treemap$1.size = function(x) {
		return arguments.length ? (dx = +x[0], dy = +x[1], treemap$1) : [dx, dy];
	};
	treemap$1.tile = function(x) {
		return arguments.length ? (tile = required(x), treemap$1) : tile;
	};
	treemap$1.padding = function(x) {
		return arguments.length ? treemap$1.paddingInner(x).paddingOuter(x) : treemap$1.paddingInner();
	};
	treemap$1.paddingInner = function(x) {
		return arguments.length ? (paddingInner = typeof x === "function" ? x : constant_default(+x), treemap$1) : paddingInner;
	};
	treemap$1.paddingOuter = function(x) {
		return arguments.length ? treemap$1.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap$1.paddingTop();
	};
	treemap$1.paddingTop = function(x) {
		return arguments.length ? (paddingTop = typeof x === "function" ? x : constant_default(+x), treemap$1) : paddingTop;
	};
	treemap$1.paddingRight = function(x) {
		return arguments.length ? (paddingRight = typeof x === "function" ? x : constant_default(+x), treemap$1) : paddingRight;
	};
	treemap$1.paddingBottom = function(x) {
		return arguments.length ? (paddingBottom = typeof x === "function" ? x : constant_default(+x), treemap$1) : paddingBottom;
	};
	treemap$1.paddingLeft = function(x) {
		return arguments.length ? (paddingLeft = typeof x === "function" ? x : constant_default(+x), treemap$1) : paddingLeft;
	};
	return treemap$1;
}

//#endregion
//#region node_modules/d3-hierarchy/src/treemap/binary.js
function binary_default(parent, x0, y0, x1, y1) {
	var nodes = parent.children, i, n = nodes.length, sum, sums = new Array(n + 1);
	for (sums[0] = sum = i = 0; i < n; ++i) sums[i + 1] = sum += nodes[i].value;
	partition$1(0, n, parent.value, x0, y0, x1, y1);
	function partition$1(i$1, j, value$1, x0$1, y0$1, x1$1, y1$1) {
		if (i$1 >= j - 1) {
			var node = nodes[i$1];
			node.x0 = x0$1, node.y0 = y0$1;
			node.x1 = x1$1, node.y1 = y1$1;
			return;
		}
		var valueOffset = sums[i$1], valueTarget = value$1 / 2 + valueOffset, k = i$1 + 1, hi = j - 1;
		while (k < hi) {
			var mid$1 = k + hi >>> 1;
			if (sums[mid$1] < valueTarget) k = mid$1 + 1;
			else hi = mid$1;
		}
		if (valueTarget - sums[k - 1] < sums[k] - valueTarget && i$1 + 1 < k) --k;
		var valueLeft = sums[k] - valueOffset, valueRight = value$1 - valueLeft;
		if (x1$1 - x0$1 > y1$1 - y0$1) {
			var xk = value$1 ? (x0$1 * valueRight + x1$1 * valueLeft) / value$1 : x1$1;
			partition$1(i$1, k, valueLeft, x0$1, y0$1, xk, y1$1);
			partition$1(k, j, valueRight, xk, y0$1, x1$1, y1$1);
		} else {
			var yk = value$1 ? (y0$1 * valueRight + y1$1 * valueLeft) / value$1 : y1$1;
			partition$1(i$1, k, valueLeft, x0$1, y0$1, x1$1, yk);
			partition$1(k, j, valueRight, x0$1, yk, x1$1, y1$1);
		}
	}
}

//#endregion
//#region node_modules/d3-hierarchy/src/treemap/sliceDice.js
function sliceDice_default(parent, x0, y0, x1, y1) {
	(parent.depth & 1 ? slice_default : dice_default)(parent, x0, y0, x1, y1);
}

//#endregion
//#region node_modules/d3-hierarchy/src/treemap/resquarify.js
var resquarify_default = (function custom(ratio) {
	function resquarify(parent, x0, y0, x1, y1) {
		if ((rows = parent._squarify) && rows.ratio === ratio) {
			var rows, row, nodes, i, j = -1, n, m = rows.length, value$1 = parent.value;
			while (++j < m) {
				row = rows[j], nodes = row.children;
				for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;
				if (row.dice) dice_default(row, x0, y0, x1, value$1 ? y0 += (y1 - y0) * row.value / value$1 : y1);
				else slice_default(row, x0, y0, value$1 ? x0 += (x1 - x0) * row.value / value$1 : x1, y1);
				value$1 -= row.value;
			}
		} else {
			parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);
			rows.ratio = ratio;
		}
	}
	resquarify.ratio = function(x) {
		return custom((x = +x) > 1 ? x : 1);
	};
	return resquarify;
})(phi);

//#endregion
//#region node_modules/d3-hierarchy/src/index.js
var src_exports = /* @__PURE__ */ __export({
	cluster: () => cluster_default,
	hierarchy: () => hierarchy,
	pack: () => pack_default,
	packEnclose: () => enclose_default,
	packSiblings: () => siblings_default,
	partition: () => partition_default,
	stratify: () => stratify_default,
	tree: () => tree_default,
	treemap: () => treemap_default,
	treemapBinary: () => binary_default,
	treemapDice: () => dice_default,
	treemapResquarify: () => resquarify_default,
	treemapSlice: () => slice_default,
	treemapSliceDice: () => sliceDice_default,
	treemapSquarify: () => squarify_default
});

//#endregion
//#region node_modules/@antv/g2plot/esm/utils/hierarchy/util.js
/** export 一些字段常量 */
/** 在同层级，同一父节点下的节点索引顺序 */
var NODE_INDEX_FIELD = "nodeIndex";
/** child 节点数量 */
var CHILD_NODE_COUNT = "childNodeCount";
/** 节点的祖先节点 */
var NODE_ANCESTORS_FIELD = "nodeAncestor";
var INVALID_FIELD_ERR_MSG = "Invalid field: it must be a string!";
function getField(options, defaultField) {
	var field$5 = options.field, fields = options.fields;
	if (is_string_default(field$5)) return field$5;
	if (is_array_default(field$5)) {
		console.warn(INVALID_FIELD_ERR_MSG);
		return field$5[0];
	}
	console.warn("".concat(INVALID_FIELD_ERR_MSG, " will try to get fields instead."));
	if (is_string_default(fields)) return fields;
	if (is_array_default(fields) && fields.length) return fields[0];
	if (defaultField) return defaultField;
	throw new TypeError(INVALID_FIELD_ERR_MSG);
}
function getAllNodes(root) {
	var nodes = [];
	if (root && root.each) {
		var parent_1;
		var index_1;
		root.each(function(node) {
			var _a$5, _b;
			if (node.parent !== parent_1) {
				parent_1 = node.parent;
				index_1 = 0;
			} else index_1 += 1;
			node[NODE_ANCESTORS_FIELD] = filter_default((((_a$5 = node.ancestors) === null || _a$5 === void 0 ? void 0 : _a$5.call(node)) || []).map(function(d) {
				return nodes.find(function(n) {
					return n.name === d.name;
				}) || d;
			}), function(_a$6) {
				var depth = _a$6.depth;
				return depth > 0 && depth < node.depth;
			});
			node[CHILD_NODE_COUNT] = ((_b = node.children) === null || _b === void 0 ? void 0 : _b.length) || 0;
			node[NODE_INDEX_FIELD] = index_1;
			nodes.push(node);
		});
	} else if (root && root.eachNode) root.eachNode(function(node) {
		nodes.push(node);
	});
	return nodes;
}

//#endregion
//#region node_modules/@antv/g2plot/esm/utils/hierarchy/pack.js
var DEFAULT_OPTIONS$16 = {
	field: "value",
	as: [
		"x",
		"y",
		"r"
	],
	sort: function(a, b) {
		return b.value - a.value;
	}
};
function pack(data$2, options) {
	options = mix({}, DEFAULT_OPTIONS$16, options);
	var as = options.as;
	if (!is_array_default(as) || as.length !== 3) throw new TypeError("Invalid as: it must be an array with 3 strings (e.g. [ \"x\", \"y\", \"r\" ])!");
	var field$5;
	try {
		field$5 = getField(options);
	} catch (e) {
		console.warn(e);
	}
	var packLayout = function(data$3) {
		return pack_default().size(options.size).padding(options.padding)(hierarchy(data$3).sum(function(d) {
			return d[field$5];
		}).sort(options.sort));
	};
	var root = packLayout(data$2);
	var x = as[0];
	var y = as[1];
	var r = as[2];
	root.each(function(node) {
		node[x] = node.x;
		node[y] = node.y;
		node[r] = node.r;
	});
	return getAllNodes(root);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/circle-packing/utils.js
/**
* circle-packing 数据转换
* @param options
*/
function transformData$3(options) {
	var data$2 = options.data, hierarchyConfig = options.hierarchyConfig, _a$5 = options.rawFields, rawFields = _a$5 === void 0 ? [] : _a$5, enableDrillDown = options.enableDrillDown;
	var nodes = pack(data$2, __assign(__assign({}, hierarchyConfig), {
		field: "value",
		as: [
			"x",
			"y",
			"r"
		]
	}));
	var result = [];
	nodes.forEach(function(node) {
		var _a$6;
		var path = node.data.name;
		var ancestorNode = __assign({}, node);
		while (ancestorNode.depth > 1) {
			path = "".concat((_a$6 = ancestorNode.parent.data) === null || _a$6 === void 0 ? void 0 : _a$6.name, " / ").concat(path);
			ancestorNode = ancestorNode.parent;
		}
		if (enableDrillDown && node.depth > 2) return null;
		var nodeInfo = deepAssign({}, node.data, __assign(__assign(__assign({}, pick(node.data, rawFields)), { path }), node));
		nodeInfo.ext = hierarchyConfig;
		nodeInfo[HIERARCHY_DATA_TRANSFORM_PARAMS] = {
			hierarchyConfig,
			rawFields,
			enableDrillDown
		};
		result.push(nodeInfo);
	});
	return result;
}
/**
* 根据传入的 padding 和 现有的 画布大小， 输出针对圆形视图布局需要的 finalPadding 以及 finalSize
* @param params
*/
function resolvePaddingForCircle(padding$2, appendPadding, containerSize) {
	var tempPadding = resolveAllPadding([padding$2, appendPadding]);
	var top = tempPadding[0], right$1 = tempPadding[1], bottom = tempPadding[2], left$1 = tempPadding[3];
	var width = containerSize.width, height = containerSize.height;
	var wSize = width - (left$1 + right$1);
	var hSize = height - (top + bottom);
	var minSize = Math.min(wSize, hSize);
	var restWidthPadding = (wSize - minSize) / 2;
	var restHeightPadding = (hSize - minSize) / 2;
	var finalTop = top + restHeightPadding;
	var finalRight = right$1 + restWidthPadding;
	var finalBottom = bottom + restHeightPadding;
	var finalLeft = left$1 + restWidthPadding;
	return {
		finalPadding: [
			finalTop,
			finalRight,
			finalBottom,
			finalLeft
		],
		finalSize: minSize < 0 ? 0 : minSize
	};
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/circle-packing/adaptor.js
/**
* 获取默认 option
* @param params
*/
function defaultOptions$3(params) {
	var chart = params.chart;
	var diameter = Math.min(chart.viewBBox.width, chart.viewBBox.height);
	return deepAssign({ options: { size: function(_a$5) {
		return _a$5.r * diameter;
	} } }, params);
}
/**
* padding 配置
* @param params
*/
function padding$1(params) {
	var options = params.options, chart = params.chart;
	var containerSize = chart.viewBBox;
	var padding$2 = options.padding, appendPadding = options.appendPadding, drilldown = options.drilldown;
	var tempAppendPadding = appendPadding;
	if (drilldown === null || drilldown === void 0 ? void 0 : drilldown.enabled) {
		var appendPaddingByDrilldown = getAdjustAppendPadding(chart.appendPadding, get_default(drilldown, ["breadCrumb", "position"]));
		tempAppendPadding = resolveAllPadding([appendPaddingByDrilldown, appendPadding]);
	}
	chart.padding = resolvePaddingForCircle(padding$2, tempAppendPadding, containerSize).finalPadding;
	chart.appendPadding = 0;
	return params;
}
/**
* 字段
* @param params
*/
function geometry$13(params) {
	var chart = params.chart, options = params.options;
	var padding$2 = chart.padding, appendPadding = chart.appendPadding;
	var color$2 = options.color, colorField = options.colorField, pointStyle = options.pointStyle, hierarchyConfig = options.hierarchyConfig, sizeField = options.sizeField, _a$5 = options.rawFields, rawFields = _a$5 === void 0 ? [] : _a$5, drilldown = options.drilldown;
	var data$2 = transformData$3({
		data: options.data,
		hierarchyConfig,
		enableDrillDown: drilldown === null || drilldown === void 0 ? void 0 : drilldown.enabled,
		rawFields
	});
	chart.data(data$2);
	var containerSize = chart.viewBBox;
	var finalSize = resolvePaddingForCircle(padding$2, appendPadding, containerSize).finalSize;
	var circleSize = function(_a$6) {
		return _a$6.r * finalSize;
	};
	if (sizeField) circleSize = function(d) {
		return d[sizeField] * finalSize;
	};
	point(deepAssign({}, params, { options: {
		xField: "x",
		yField: "y",
		seriesField: colorField,
		sizeField,
		rawFields: __spreadArray(__spreadArray([], RAW_FIELDS$1, true), rawFields, true),
		point: {
			color: color$2,
			style: pointStyle,
			shape: "circle",
			size: circleSize
		}
	} }));
	return params;
}
/**
* meta 配置
* @param params
*/
function meta$9(params) {
	return flow(scale({}, {
		x: {
			min: 0,
			max: 1,
			minLimit: 0,
			maxLimit: 1,
			nice: true
		},
		y: {
			min: 0,
			max: 1,
			minLimit: 0,
			maxLimit: 1,
			nice: true
		}
	}))(params);
}
/**
* tooltip 配置
* @param params
*/
function tooltip$4(params) {
	var chart = params.chart;
	var tooltip$10 = params.options.tooltip;
	if (tooltip$10 === false) chart.tooltip(false);
	else {
		var tooltipOptions = tooltip$10;
		if (!get_default(tooltip$10, "fields")) tooltipOptions = deepAssign({}, { customItems: function(items) {
			return items.map(function(item) {
				var scales = get_default(chart.getOptions(), "scales");
				var nameFormatter = get_default(scales, ["name", "formatter"], function(v) {
					return v;
				});
				var valueFormatter = get_default(scales, ["value", "formatter"], function(v) {
					return v;
				});
				return __assign(__assign({}, item), {
					name: nameFormatter(item.data.name),
					value: valueFormatter(item.data.value)
				});
			});
		} }, tooltipOptions);
		chart.tooltip(tooltipOptions);
	}
	return params;
}
/**
* 坐标轴, 默认关闭
* @param params
*/
function axis$10(params) {
	params.chart.axis(false);
	return params;
}
function adaptorInteraction$2(options) {
	var drilldown = options.drilldown, _a$5 = options.interactions, interactions = _a$5 === void 0 ? [] : _a$5;
	if (drilldown === null || drilldown === void 0 ? void 0 : drilldown.enabled) return deepAssign({}, options, { interactions: __spreadArray(__spreadArray([], interactions, true), [{
		type: "drill-down",
		cfg: {
			drillDownConfig: drilldown,
			transformData: transformData$3,
			enableDrillDown: true
		}
	}], false) });
	return options;
}
/**
* 交互配置
* @param params
* @returns
*/
function interaction$5(params) {
	var chart = params.chart, options = params.options;
	interaction({
		chart,
		options: adaptorInteraction$2(options)
	});
	return params;
}
/**
* 矩形树图
* @param chart
* @param options
*/
function adaptor$15(params) {
	return flow(pattern("pointStyle"), defaultOptions$3, padding$1, theme, meta$9, geometry$13, axis$10, legend, tooltip$4, interaction$5, animation, annotation())(params);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/interactions/drill-down.js
/**
* 判断是否为父节点
*/
function isParentNode(context) {
	var data$2 = get_default(context, [
		"event",
		"data",
		"data"
	], {});
	return is_array_default(data$2.children) && data$2.children.length > 0;
}
/**
* 判断是否在中心
*/
function inCenter(context) {
	var coordinate$10 = context.view.getCoordinate();
	var innerRadius = coordinate$10.innerRadius;
	if (innerRadius) {
		var _a$5 = context.event, x = _a$5.x, y = _a$5.y;
		var _b = coordinate$10.center, centerX = _b.x, centerY = _b.y;
		var r = coordinate$10.getRadius() * innerRadius;
		return Math.sqrt(Math.pow(centerX - x, 2) + Math.pow(centerY - y, 2)) < r;
	}
	return false;
}
registerAction("drill-down-action", DrillDownAction);
registerInteraction("drill-down", {
	showEnable: [
		{
			trigger: "element:mouseenter",
			action: "cursor:pointer",
			isEnable: isParentNode
		},
		{
			trigger: "element:mouseleave",
			action: "cursor:default"
		},
		{
			trigger: "element:mouseleave",
			action: "cursor:pointer",
			isEnable: inCenter
		}
	],
	start: [
		{
			trigger: "element:click",
			isEnable: isParentNode,
			action: ["drill-down-action:click"]
		},
		{
			trigger: "afterchangesize",
			action: ["drill-down-action:resetPosition"]
		},
		{
			trigger: "click",
			isEnable: inCenter,
			action: ["drill-down-action:back"]
		}
	]
});

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/circle-packing/index.js
/**
*  CirclePacking
* @usage hierarchy, proportions
*/
var CirclePacking = function(_super) {
	__extends(CirclePacking$1, _super);
	function CirclePacking$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		/** 图表类型 */
		_this.type = "circle-packing";
		return _this;
	}
	/**
	* 获取 面积图 默认配置项
	* 供外部使用
	*/
	CirclePacking$1.getDefaultOptions = function() {
		return DEFAULT_OPTIONS$15;
	};
	CirclePacking$1.prototype.getDefaultOptions = function() {
		return CirclePacking$1.getDefaultOptions();
	};
	/**
	* 获取适配器
	*/
	CirclePacking$1.prototype.getSchemaAdaptor = function() {
		return adaptor$15;
	};
	/**
	* 覆写父类的方法
	*/
	CirclePacking$1.prototype.triggerResize = function() {
		if (!this.chart.destroyed) {
			this.chart.forceFit();
			this.chart.clear();
			this.execAdaptor();
			this.chart.render(true);
		}
	};
	return CirclePacking$1;
}(Plot);

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/dual-axes/constant.js
var LEFT_AXES_VIEW = "left-axes-view";
var RIGHT_AXES_VIEW = "right-axes-view";
var DEFAULT_YAXIS_CONFIG = {
	nice: true,
	label: {
		autoHide: true,
		autoRotate: false
	}
};
var DEFAULT_LEFT_YAXIS_CONFIG = __assign(__assign({}, DEFAULT_YAXIS_CONFIG), { position: "left" });
var DEFAULT_RIGHT_YAXIS_CONFIG = __assign(__assign({}, DEFAULT_YAXIS_CONFIG), {
	position: "right",
	grid: null
});

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/dual-axes/types.js
var AxisType;
(function(AxisType$1) {
	AxisType$1["Left"] = "Left";
	AxisType$1["Right"] = "Right";
})(AxisType || (AxisType = {}));
var DualAxesGeometry;
(function(DualAxesGeometry$1) {
	DualAxesGeometry$1["Line"] = "line";
	DualAxesGeometry$1["Column"] = "column";
})(DualAxesGeometry || (DualAxesGeometry = {}));

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/dual-axes/util/option.js
/**
* 根据 GeometryOption 判断 geometry 是否为 line
*/
function isLine(geometryOption) {
	return get_default(geometryOption, "geometry") === DualAxesGeometry.Line;
}
/**
* 根据 GeometryOption 判断 geometry 是否为 Column
*/
function isColumn(geometryOption) {
	return get_default(geometryOption, "geometry") === DualAxesGeometry.Column;
}
/**
* 获取 GeometryOption
* @param geometryOption
* @param axis
*/
function getGeometryOption(xField, yField, geometryOption) {
	return isColumn(geometryOption) ? deepAssign({}, {
		geometry: DualAxesGeometry.Column,
		label: geometryOption.label && geometryOption.isRange ? { content: function(item) {
			var _a$5;
			return (_a$5 = item[yField]) === null || _a$5 === void 0 ? void 0 : _a$5.join("-");
		} } : void 0
	}, geometryOption) : __assign({ geometry: DualAxesGeometry.Line }, geometryOption);
}
/**
* 兼容一些属性 为 arr 和 obj 的两种情况， 如 yAxis，annotations
* 为了防止左右 yField 相同，导致变成 object 之后被覆盖，所以都转变成数组的形式
* @param yField
* @param transformAttribute
*/
function transformObjectToArray(yField, transformAttribute) {
	var y1 = yField[0], y2 = yField[1];
	if (is_array_default(transformAttribute)) {
		var a1_1 = transformAttribute[0], a2_1 = transformAttribute[1];
		return [a1_1, a2_1];
	}
	var a1 = get_default(transformAttribute, y1);
	var a2 = get_default(transformAttribute, y2);
	return [a1, a2];
}
/**
* 获取默认值
* @param yAxis
* @param axisType
*/
function getYAxisWithDefault(yAxis, axisType) {
	if (axisType === AxisType.Left) return yAxis === false ? false : deepAssign({}, DEFAULT_LEFT_YAXIS_CONFIG, yAxis);
	else if (axisType === AxisType.Right) return yAxis === false ? false : deepAssign({}, DEFAULT_RIGHT_YAXIS_CONFIG, yAxis);
	return yAxis;
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/dual-axes/util/geometry.js
/**
* 绘制单个图形
* @param params
*/
function drawSingleGeometry(params) {
	var options = params.options, chart = params.chart;
	var geometryOption = options.geometryOption;
	var isStack = geometryOption.isStack, color$2 = geometryOption.color, seriesField = geometryOption.seriesField, groupField = geometryOption.groupField, isGroup = geometryOption.isGroup;
	var FIELD_KEY = ["xField", "yField"];
	if (isLine(geometryOption)) {
		line(deepAssign({}, params, { options: __assign(__assign(__assign({}, pick(options, FIELD_KEY)), geometryOption), { line: {
			color: geometryOption.color,
			style: geometryOption.lineStyle
		} }) }));
		point(deepAssign({}, params, { options: __assign(__assign(__assign({}, pick(options, FIELD_KEY)), geometryOption), { point: geometryOption.point && __assign({
			color: color$2,
			shape: "circle"
		}, geometryOption.point) }) }));
		var adjust_1 = [];
		if (isGroup) adjust_1.push({
			type: "dodge",
			dodgeBy: groupField || seriesField,
			customOffset: 0
		});
		if (isStack) adjust_1.push({ type: "stack" });
		if (adjust_1.length) each_default(chart.geometries, function(g) {
			g.adjust(adjust_1);
		});
	}
	if (isColumn(geometryOption)) adaptor$14(deepAssign({}, params, { options: __assign(__assign(__assign({}, pick(options, FIELD_KEY)), geometryOption), {
		widthRatio: geometryOption.columnWidthRatio,
		interval: __assign(__assign({}, pick(geometryOption, ["color"])), { style: geometryOption.columnStyle })
	}) }));
	return params;
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/dual-axes/util/legend.js
/**
* 获取 view 的 legendItem，供存在不含有 seriesField 的图形使用
* @param params
*/
function getViewLegendItems(params) {
	var view = params.view, geometryOption = params.geometryOption, yField = params.yField, legend$17 = params.legend;
	var userMarker = get_default(legend$17, "marker");
	var geometry$34 = findGeometry(view, isLine(geometryOption) ? "line" : "interval");
	if (!geometryOption.seriesField) {
		var legendItemName = get_default(view, "options.scales.".concat(yField, ".alias")) || yField;
		var colorAttribute = geometry$34.getAttribute("color");
		var color$2 = view.getTheme().defaultColor;
		if (colorAttribute) color$2 = Util.getMappingValue(colorAttribute, legendItemName, get_default(colorAttribute, ["values", 0], color$2));
		var marker = (is_function_default(userMarker) ? userMarker : !is_empty_default(userMarker) && deepAssign({}, { style: {
			stroke: color$2,
			fill: color$2
		} }, userMarker)) || (isLine(geometryOption) ? {
			symbol: function(x, y, r) {
				return [[
					"M",
					x - r,
					y
				], [
					"L",
					x + r,
					y
				]];
			},
			style: {
				lineWidth: 2,
				r: 6,
				stroke: color$2
			}
		} : {
			symbol: "square",
			style: { fill: color$2 }
		});
		return [{
			value: yField,
			name: legendItemName,
			marker,
			isGeometry: true,
			viewId: view.id
		}];
	}
	var attributes = geometry$34.getGroupAttributes();
	return reduce_default(attributes, function(items, attr) {
		var attrItems = Util.getLegendItems(view, geometry$34, attr, view.getTheme(), userMarker);
		return items.concat(attrItems);
	}, []);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/dual-axes/util/render-sider.js
/**
* 右侧 View 进行 slider 过滤
* 由于双轴图是多 View , 需要监听左侧 Slider 的 change 事件来同步右侧 View
* @param { View } view 右侧视图
* @param { number[] } sliderValue 滑块当前值
* @returns void
*/
var doSliderFilter = function(view, sliderValue) {
	var min$2 = sliderValue[0], max$2 = sliderValue[1];
	var data$2 = view.getOptions().data;
	var xScale = view.getXScale();
	var dataSize = size(data$2);
	if (!xScale || !dataSize) return;
	var isHorizontal$1 = true;
	var values$1 = values_of_key_default(data$2, xScale.field);
	var xValues = isHorizontal$1 ? values$1 : values$1.reverse();
	var xTickCount = size(xValues);
	var minIndex = Math.round(min$2 * (xTickCount - 1));
	var maxIndex = Math.round(max$2 * (xTickCount - 1));
	view.filter(xScale.field, function(value$1) {
		var idx = xValues.indexOf(value$1);
		return idx > -1 ? isBetween(idx, minIndex, maxIndex) : true;
	});
	view.getRootView().render(true);
};

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/dual-axes/adaptor.js
/**
* transformOptions，双轴图整体的取参逻辑如下
* 1. get index getOptions: 对应的是默认的图表参数，如 appendPadding，syncView 等
* 2. get adpator transformOption: 对应的是双轴图的默认参数，deepAssign 优先级从低到高如下
*    2.1 defaultoption，如 tooltip，legend
*    2.2 用户填写 options
*    2.3 根据用户填写的 options 补充的数组型 options，如 yaxis，GeometryOption，因为 deepAssign 无法 assign 数组
*
* @param params
*/
function transformOptions(params) {
	var _a$5;
	var options = params.options;
	var _b = options.geometryOptions, geometryOptions = _b === void 0 ? [] : _b, xField = options.xField, yField = options.yField;
	var allLine = every_default(geometryOptions, function(_a$6) {
		var geometry$34 = _a$6.geometry;
		return geometry$34 === DualAxesGeometry.Line || geometry$34 === void 0;
	});
	return deepAssign({}, { options: {
		geometryOptions: [],
		meta: (_a$5 = {}, _a$5[xField] = {
			type: "cat",
			sync: true,
			range: allLine ? [0, 1] : void 0
		}, _a$5),
		tooltip: {
			showMarkers: allLine,
			showCrosshairs: allLine,
			shared: true,
			crosshairs: { type: "x" }
		},
		interactions: !allLine ? [{ type: "legend-visible-filter" }, { type: "active-region" }] : [{ type: "legend-visible-filter" }],
		legend: { position: "top-left" }
	} }, params, { options: {
		yAxis: transformObjectToArray(yField, options.yAxis),
		geometryOptions: [getGeometryOption(xField, yField[0], geometryOptions[0]), getGeometryOption(xField, yField[1], geometryOptions[1])],
		annotations: transformObjectToArray(yField, options.annotations)
	} });
}
/**
* 创建 双轴图 中绘制图形的 view，提前创建是因为 theme 适配器的需要
* @param params
*/
function createViews(params) {
	var _a$5, _b;
	var chart = params.chart;
	var geometryOptions = params.options.geometryOptions;
	var SORT_MAP = {
		line: 0,
		column: 1
	};
	[{
		type: (_a$5 = geometryOptions[0]) === null || _a$5 === void 0 ? void 0 : _a$5.geometry,
		id: LEFT_AXES_VIEW
	}, {
		type: (_b = geometryOptions[1]) === null || _b === void 0 ? void 0 : _b.geometry,
		id: RIGHT_AXES_VIEW
	}].sort(function(a, b) {
		return -SORT_MAP[a.type] + SORT_MAP[b.type];
	}).forEach(function(g) {
		return chart.createView({ id: g.id });
	});
	return params;
}
/**
* 绘制图形
* @param params
*/
function geometry$12(params) {
	var chart = params.chart, options = params.options;
	var xField = options.xField, yField = options.yField, geometryOptions = options.geometryOptions, data$2 = options.data, tooltip$10 = options.tooltip;
	[__assign(__assign({}, geometryOptions[0]), {
		id: LEFT_AXES_VIEW,
		data: data$2[0],
		yField: yField[0]
	}), __assign(__assign({}, geometryOptions[1]), {
		id: RIGHT_AXES_VIEW,
		data: data$2[1],
		yField: yField[1]
	})].forEach(function(geometry$34) {
		var id$1 = geometry$34.id, data$3 = geometry$34.data, yField$1 = geometry$34.yField;
		var isPercent = isColumn(geometry$34) && geometry$34.isPercent;
		var formatData = isPercent ? percent(data$3, yField$1, xField, yField$1) : data$3;
		var view = findViewById(chart, id$1).data(formatData);
		var tooltipOptions = isPercent ? __assign({ formatter: function(datum) {
			return {
				name: datum[geometry$34.seriesField] || yField$1,
				value: (Number(datum[yField$1]) * 100).toFixed(2) + "%"
			};
		} }, tooltip$10) : tooltip$10;
		drawSingleGeometry({
			chart: view,
			options: {
				xField,
				yField: yField$1,
				tooltip: tooltipOptions,
				geometryOption: geometry$34
			}
		});
	});
	return params;
}
function color(params) {
	var _a$5;
	var chart = params.chart;
	var geometryOptions = params.options.geometryOptions;
	var themeColor = ((_a$5 = chart.getTheme()) === null || _a$5 === void 0 ? void 0 : _a$5.colors10) || [];
	var start = 0;
	chart.once("beforepaint", function() {
		each_default(geometryOptions, function(geometryOption, index) {
			var view = findViewById(chart, index === 0 ? LEFT_AXES_VIEW : RIGHT_AXES_VIEW);
			if (geometryOption.color) return;
			var groupScale = view.getGroupScales();
			var count$1 = get_default(groupScale, [
				0,
				"values",
				"length"
			], 1);
			var color$2 = themeColor.slice(start, start + count$1).concat(index === 0 ? [] : themeColor);
			view.geometries.forEach(function(geometry$34) {
				if (geometryOption.seriesField) geometry$34.color(geometryOption.seriesField, color$2);
				else geometry$34.color(color$2[0]);
			});
			start += count$1;
		});
		chart.render(true);
	});
	return params;
}
/**
* meta 配置
* @param params
*/
function meta$8(params) {
	var _a$5, _b;
	var chart = params.chart, options = params.options;
	var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
	scale((_a$5 = {}, _a$5[xField] = xAxis, _a$5[yField[0]] = yAxis[0], _a$5))(deepAssign({}, params, { chart: findViewById(chart, LEFT_AXES_VIEW) }));
	scale((_b = {}, _b[xField] = xAxis, _b[yField[1]] = yAxis[1], _b))(deepAssign({}, params, { chart: findViewById(chart, RIGHT_AXES_VIEW) }));
	return params;
}
/**
* axis 配置
* @param params
*/
function axis$9(params) {
	var chart = params.chart, options = params.options;
	var leftView = findViewById(chart, LEFT_AXES_VIEW);
	var rightView = findViewById(chart, RIGHT_AXES_VIEW);
	var xField = options.xField, yField = options.yField, xAxis = options.xAxis, yAxis = options.yAxis;
	chart.axis(xField, false);
	chart.axis(yField[0], false);
	chart.axis(yField[1], false);
	leftView.axis(xField, xAxis);
	leftView.axis(yField[0], getYAxisWithDefault(yAxis[0], AxisType.Left));
	rightView.axis(xField, false);
	rightView.axis(yField[1], getYAxisWithDefault(yAxis[1], AxisType.Right));
	return params;
}
/**
* tooltip 配置
* @param params
*/
function tooltip$3(params) {
	var chart = params.chart;
	var tooltip$10 = params.options.tooltip;
	var leftView = findViewById(chart, LEFT_AXES_VIEW);
	var rightView = findViewById(chart, RIGHT_AXES_VIEW);
	chart.tooltip(tooltip$10);
	leftView.tooltip({ shared: true });
	rightView.tooltip({ shared: true });
	return params;
}
/**
* interaction 配置
* @param params
*/
function interaction$4(params) {
	var chart = params.chart;
	interaction(deepAssign({}, params, { chart: findViewById(chart, LEFT_AXES_VIEW) }));
	interaction(deepAssign({}, params, { chart: findViewById(chart, RIGHT_AXES_VIEW) }));
	return params;
}
/**
* annotation 配置
* @param params
*/
function annotation$2(params) {
	var chart = params.chart;
	var annotations = params.options.annotations;
	var a1 = get_default(annotations, [0]);
	var a2 = get_default(annotations, [1]);
	annotation(a1)(deepAssign({}, params, {
		chart: findViewById(chart, LEFT_AXES_VIEW),
		options: { annotations: a1 }
	}));
	annotation(a2)(deepAssign({}, params, {
		chart: findViewById(chart, RIGHT_AXES_VIEW),
		options: { annotations: a2 }
	}));
	return params;
}
function theme$1(params) {
	var chart = params.chart;
	theme(deepAssign({}, params, { chart: findViewById(chart, LEFT_AXES_VIEW) }));
	theme(deepAssign({}, params, { chart: findViewById(chart, RIGHT_AXES_VIEW) }));
	theme(params);
	return params;
}
function animation$3(params) {
	var chart = params.chart;
	animation(deepAssign({}, params, { chart: findViewById(chart, LEFT_AXES_VIEW) }));
	animation(deepAssign({}, params, { chart: findViewById(chart, RIGHT_AXES_VIEW) }));
	return params;
}
/**
* 双轴图 limitInPlot
* @param params
*/
function limitInPlot$1(params) {
	var chart = params.chart;
	var yAxis = params.options.yAxis;
	limitInPlot(deepAssign({}, params, {
		chart: findViewById(chart, LEFT_AXES_VIEW),
		options: { yAxis: yAxis[0] }
	}));
	limitInPlot(deepAssign({}, params, {
		chart: findViewById(chart, RIGHT_AXES_VIEW),
		options: { yAxis: yAxis[1] }
	}));
	return params;
}
/**
* legend 配置
* 使用 custom，便于和类似于分组柱状图-单折线图的逻辑统一
* @param params
*/
function legend$7(params) {
	var chart = params.chart, options = params.options;
	var legend$17 = options.legend, geometryOptions = options.geometryOptions, yField = options.yField, data$2 = options.data;
	var leftView = findViewById(chart, LEFT_AXES_VIEW);
	var rightView = findViewById(chart, RIGHT_AXES_VIEW);
	if (legend$17 === false) chart.legend(false);
	else if (is_object_default(legend$17) && legend$17.custom === true) chart.legend(legend$17);
	else {
		var leftLegend_1 = get_default(geometryOptions, [0, "legend"], legend$17);
		var rightLegend_1 = get_default(geometryOptions, [1, "legend"], legend$17);
		chart.once("beforepaint", function() {
			var leftItems = data$2[0].length ? getViewLegendItems({
				view: leftView,
				geometryOption: geometryOptions[0],
				yField: yField[0],
				legend: leftLegend_1
			}) : [];
			var rightItems = data$2[1].length ? getViewLegendItems({
				view: rightView,
				geometryOption: geometryOptions[1],
				yField: yField[1],
				legend: rightLegend_1
			}) : [];
			chart.legend(deepAssign({}, legend$17, {
				custom: true,
				items: leftItems.concat(rightItems)
			}));
		});
		if (geometryOptions[0].seriesField) leftView.legend(geometryOptions[0].seriesField, leftLegend_1);
		if (geometryOptions[1].seriesField) rightView.legend(geometryOptions[1].seriesField, rightLegend_1);
		chart.on("legend-item:click", function(evt) {
			var delegateObject = get_default(evt, "gEvent.delegateObject", {});
			if (delegateObject && delegateObject.item) {
				var _a$5 = delegateObject.item, field_1 = _a$5.value, isGeometry = _a$5.isGeometry, viewId = _a$5.viewId;
				if (isGeometry) {
					if (find_index_default(yField, function(yF) {
						return yF === field_1;
					}) > -1) {
						var geometries = get_default(findViewById(chart, viewId), "geometries");
						each_default(geometries, function(g) {
							g.changeVisible(!delegateObject.item.unchecked);
						});
					}
				} else {
					var legendItem_1 = get_default(chart.getController("legend"), "option.items", []);
					each_default(chart.views, function(view) {
						var groupScale = view.getGroupScales();
						each_default(groupScale, function(scale$4) {
							if (scale$4.values && scale$4.values.indexOf(field_1) > -1) view.filter(scale$4.field, function(value$1) {
								return !find_default(legendItem_1, function(item) {
									return item.value === value$1;
								}).unchecked;
							});
						});
						chart.render(true);
					});
				}
			}
		});
	}
	return params;
}
/**
* 双轴图 slider 适配器
* @param params
*/
function slider(params) {
	var chart = params.chart;
	var slider$3 = params.options.slider;
	var leftView = findViewById(chart, LEFT_AXES_VIEW);
	var rightView = findViewById(chart, RIGHT_AXES_VIEW);
	if (slider$3) {
		leftView.option("slider", slider$3);
		leftView.on("slider:valuechanged", function(evt) {
			var _a$5 = evt.event, value$1 = _a$5.value, originValue = _a$5.originValue;
			if (is_equal_default(value$1, originValue)) return;
			doSliderFilter(rightView, value$1);
		});
		chart.once("afterpaint", function() {
			if (!is_boolean_default(slider$3)) {
				var start = slider$3.start, end = slider$3.end;
				if (start || end) doSliderFilter(rightView, [start, end]);
			}
		});
	}
	return params;
}
/**
* 双折线图适配器
* @param chart
* @param options
*/
function adaptor$13(params) {
	return flow(transformOptions, createViews, theme$1, geometry$12, meta$8, axis$9, limitInPlot$1, tooltip$3, interaction$4, annotation$2, animation$3, color, legend$7, slider)(params);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/dual-axes/index.js
var DualAxes = function(_super) {
	__extends(DualAxes$1, _super);
	function DualAxes$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		/** 图表类型: 双轴图 */
		_this.type = "dual-axes";
		return _this;
	}
	/**
	* 获取 双轴图 默认配置
	*/
	DualAxes$1.prototype.getDefaultOptions = function() {
		return deepAssign({}, _super.prototype.getDefaultOptions.call(this), {
			yAxis: [],
			syncViewPadding: true
		});
	};
	/**
	* 获取双轴图的适配器
	*/
	DualAxes$1.prototype.getSchemaAdaptor = function() {
		return adaptor$13;
	};
	return DualAxes$1;
}(Plot);

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/facet/utils.js
/**
*
* @param params 分面图 参数
* @returns facet eachView 的回调设置每个 view 的展示
*/
function execViewAdaptor(viewOfG2, options) {
	var data$2 = options.data, coordinate$10 = options.coordinate, interactions = options.interactions, annotations = options.annotations, animation$6 = options.animation, tooltip$10 = options.tooltip, axes = options.axes, meta$22 = options.meta, geometries = options.geometries;
	if (data$2) viewOfG2.data(data$2);
	var scales = {};
	if (axes) each_default(axes, function(axis$21, field$5) {
		scales[field$5] = pick(axis$21, AXIS_META_CONFIG_KEYS);
	});
	scales = deepAssign({}, meta$22, scales);
	viewOfG2.scale(scales);
	if (coordinate$10) viewOfG2.coordinate(coordinate$10);
	if (axes === false) viewOfG2.axis(false);
	else each_default(axes, function(axis$21, field$5) {
		viewOfG2.axis(field$5, axis$21);
	});
	each_default(geometries, function(geometry$34) {
		var ext = geometry$10({
			chart: viewOfG2,
			options: geometry$34
		}).ext;
		var adjust$2 = geometry$34.adjust;
		if (adjust$2) ext.geometry.adjust(adjust$2);
	});
	each_default(interactions, function(interaction$9) {
		if (interaction$9.enable === false) viewOfG2.removeInteraction(interaction$9.type);
		else viewOfG2.interaction(interaction$9.type, interaction$9.cfg);
	});
	each_default(annotations, function(annotation$3) {
		viewOfG2.annotation()[annotation$3.type](__assign({}, annotation$3));
	});
	addViewAnimation(viewOfG2, animation$6);
	if (tooltip$10) {
		viewOfG2.interaction("tooltip");
		viewOfG2.tooltip(tooltip$10);
	} else if (tooltip$10 === false) viewOfG2.removeInteraction("tooltip");
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/facet/adaptor.js
function facetAdaptor(params) {
	var chart = params.chart, options = params.options;
	var facetType = options.type, data$2 = options.data, fields = options.fields, eachView = options.eachView;
	var restFacetCfg = omit_default(options, [
		"type",
		"data",
		"fields",
		"eachView",
		"axes",
		"meta",
		"tooltip",
		"coordinate",
		"theme",
		"legend",
		"interactions",
		"annotations"
	]);
	chart.data(data$2);
	chart.facet(facetType, __assign(__assign({}, restFacetCfg), {
		fields,
		eachView: function(viewOfG2, facet) {
			var viewOptions = eachView(viewOfG2, facet);
			if (viewOptions.geometries) execViewAdaptor(viewOfG2, viewOptions);
			else {
				var plot = viewOptions;
				var plotOptions_1 = plot.options;
				[
					"seriesField",
					"colorField",
					"shapeField",
					"sizeField",
					"groupField"
				].forEach(function(key) {
					if (options[key] && typeof plotOptions_1[key] === "undefined") plotOptions_1[key] = options[key];
				});
				if (plotOptions_1.tooltip) viewOfG2.interaction("tooltip");
				execPlotAdaptor(plot.type, viewOfG2, plotOptions_1);
			}
		}
	}));
	return params;
}
function component(params) {
	var chart = params.chart, options = params.options;
	var axes = options.axes, meta$22 = options.meta, tooltip$10 = options.tooltip, coordinate$10 = options.coordinate, theme$3 = options.theme, legend$17 = options.legend, interactions = options.interactions, annotations = options.annotations, shapeField = options.shapeField, sizeField = options.sizeField, shapeLegend = options.shapeLegend, sizeLegend = options.sizeLegend;
	var scales = {};
	if (axes) each_default(axes, function(axis$21, field$5) {
		scales[field$5] = pick(axis$21, AXIS_META_CONFIG_KEYS);
	});
	scales = deepAssign({}, meta$22, scales);
	chart.scale(scales);
	chart.coordinate(coordinate$10);
	if (!axes) chart.axis(false);
	else each_default(axes, function(axis$21, field$5) {
		chart.axis(field$5, axis$21);
	});
	if (tooltip$10) {
		chart.interaction("tooltip");
		chart.tooltip(tooltip$10);
	} else if (tooltip$10 === false) chart.removeInteraction("tooltip");
	chart.legend(legend$17);
	var showLegend = legend$17 !== false;
	if (shapeField) if (shapeLegend) chart.legend(shapeField, shapeLegend);
	else chart.legend(shapeField, shapeLegend === false ? false : legend$17);
	if (sizeField) chart.legend(sizeField, sizeLegend ? sizeLegend : false);
	if (!showLegend && !shapeLegend && !sizeLegend) chart.legend(false);
	if (theme$3) chart.theme(theme$3);
	each_default(interactions, function(interaction$9) {
		if (interaction$9.enable === false) chart.removeInteraction(interaction$9.type);
		else chart.interaction(interaction$9.type, interaction$9.cfg);
	});
	each_default(annotations, function(annotation$3) {
		chart.annotation()[annotation$3.type](__assign({}, annotation$3));
	});
	return params;
}
/**
* 分面图适配器
* @param chart
* @param options
*/
function adaptor$12(params) {
	return flow(theme, facetAdaptor, component)(params);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/facet/constant.js
/**
* 分面图 默认配置项
*/
var DEFAULT_OPTIONS$14 = {
	title: { style: {
		fontSize: 12,
		fill: "rgba(0,0,0,0.65)"
	} },
	rowTitle: { style: {
		fontSize: 12,
		fill: "rgba(0,0,0,0.65)"
	} },
	columnTitle: { style: {
		fontSize: 12,
		fill: "rgba(0,0,0,0.65)"
	} }
};

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/facet/index.js
var Facet = function(_super) {
	__extends(Facet$2, _super);
	function Facet$2() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		/** 图表类型 */
		_this.type = "area";
		return _this;
	}
	/**
	* 获取 分面图 默认配置项
	* 供外部使用
	*/
	Facet$2.getDefaultOptions = function() {
		return DEFAULT_OPTIONS$14;
	};
	/**
	* 获取 分面图 默认配置
	*/
	Facet$2.prototype.getDefaultOptions = function() {
		return Facet$2.getDefaultOptions();
	};
	/**
	* 获取 分面图 的适配器
	*/
	Facet$2.prototype.getSchemaAdaptor = function() {
		return adaptor$12;
	};
	return Facet$2;
}(Plot);

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/heatmap/adaptor.js
function geometry$11(params) {
	var chart = params.chart, options = params.options;
	var data$2 = options.data, type = options.type, xField = options.xField, yField = options.yField, colorField = options.colorField, sizeField = options.sizeField, sizeRatio = options.sizeRatio, shape = options.shape, color$2 = options.color, tooltip$10 = options.tooltip, heatmapStyle = options.heatmapStyle, meta$22 = options.meta;
	chart.data(data$2);
	var geometryType = "polygon";
	if (type === "density") geometryType = "heatmap";
	var _a$5 = getTooltipMapping(tooltip$10, [
		xField,
		yField,
		colorField
	]), fields = _a$5.fields, formatter = _a$5.formatter;
	/**
	* The ratio between the actual size and the max available size, must be in range `[0,1]`.
	*
	* If the `sizeRatio` attribute is undefined or it exceeds the range,
	* `checkedSizeRatio` would be set to 1 as default.
	*/
	var checkedSizeRatio = 1;
	if (sizeRatio || sizeRatio === 0) if (!shape && !sizeField) console.warn("sizeRatio is not in effect: Must define shape or sizeField first");
	else if (sizeRatio < 0 || sizeRatio > 1) console.warn("sizeRatio is not in effect: It must be a number in [0,1]");
	else checkedSizeRatio = sizeRatio;
	geometry$10(deepAssign({}, params, { options: {
		type: geometryType,
		colorField,
		tooltipFields: fields,
		shapeField: sizeField || "",
		label: void 0,
		mapping: {
			tooltip: formatter,
			shape: shape && (sizeField ? function(dautm) {
				var field$5 = data$2.map(function(row) {
					return row[sizeField];
				});
				var _a$6 = (meta$22 === null || meta$22 === void 0 ? void 0 : meta$22[sizeField]) || {}, min$2 = _a$6.min, max$2 = _a$6.max;
				min$2 = is_number_default(min$2) ? min$2 : Math.min.apply(Math, field$5);
				max$2 = is_number_default(max$2) ? max$2 : Math.max.apply(Math, field$5);
				return [
					shape,
					(get_default(dautm, sizeField) - min$2) / (max$2 - min$2),
					checkedSizeRatio
				];
			} : function() {
				return [
					shape,
					1,
					checkedSizeRatio
				];
			}),
			color: color$2 || colorField && chart.getTheme().sequenceColors.join("-"),
			style: heatmapStyle
		}
	} }));
	return params;
}
/**
* meta 配置
* @param params
*/
function meta$7(params) {
	var _a$5;
	var options = params.options;
	var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
	return flow(scale((_a$5 = {}, _a$5[xField] = xAxis, _a$5[yField] = yAxis, _a$5)))(params);
}
/**
* axis 配置
* @param params
*/
function axis$8(params) {
	var chart = params.chart, options = params.options;
	var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
	if (xAxis === false) chart.axis(xField, false);
	else chart.axis(xField, xAxis);
	if (yAxis === false) chart.axis(yField, false);
	else chart.axis(yField, yAxis);
	return params;
}
/**
* legend 配置
* @param params
*/
function legend$6(params) {
	var chart = params.chart, options = params.options;
	var legend$17 = options.legend, colorField = options.colorField, sizeField = options.sizeField, sizeLegend = options.sizeLegend;
	/** legend 不为 false, 则展示图例, 优先展示 color 分类图例 */
	var showLegend = legend$17 !== false;
	if (colorField) chart.legend(colorField, showLegend ? legend$17 : false);
	if (sizeField) chart.legend(sizeField, sizeLegend === void 0 ? legend$17 : sizeLegend);
	/** 默认没有 sizeField，则隐藏连续图例 */
	if (!showLegend && !sizeLegend) chart.legend(false);
	return params;
}
/**
* fixme 后续确认下，数据标签的逻辑为啥和通用的不一致
* 数据标签
* @param params
*/
function label$6(params) {
	var chart = params.chart, options = params.options;
	var label$16 = options.label, colorField = options.colorField, type = options.type;
	var geometry$34 = findGeometry(chart, type === "density" ? "heatmap" : "polygon");
	if (!label$16) geometry$34.label(false);
	else if (colorField) {
		var callback = label$16.callback, cfg = __rest(label$16, ["callback"]);
		geometry$34.label({
			fields: [colorField],
			callback,
			cfg: transformLabel(cfg)
		});
	}
	return params;
}
/**
* 极坐标
* @param params
*/
function coordinate$3(params) {
	var _a$5, _b;
	var chart = params.chart, options = params.options;
	var coordinate$10 = options.coordinate, reflect = options.reflect;
	var coordinateOption = deepAssign({ actions: [] }, coordinate$10 !== null && coordinate$10 !== void 0 ? coordinate$10 : { type: "rect" });
	if (reflect) (_b = (_a$5 = coordinateOption.actions) === null || _a$5 === void 0 ? void 0 : _a$5.push) === null || _b === void 0 || _b.call(_a$5, ["reflect", reflect]);
	chart.coordinate(coordinateOption);
	return params;
}
/**
* 热力图适配器
* @param chart
* @param options
*/
function adaptor$11(params) {
	return flow(theme, pattern("heatmapStyle"), meta$7, coordinate$3, geometry$11, axis$8, legend$6, tooltip, label$6, annotation(), interaction, animation, state)(params);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/heatmap/constant.js
/**
* 色块图默认配置项
*/
var DEFAULT_OPTIONS$13 = deepAssign({}, Plot.getDefaultOptions(), {
	type: "polygon",
	legend: false,
	coordinate: { type: "rect" },
	xAxis: {
		tickLine: null,
		line: null,
		grid: {
			alignTick: false,
			line: { style: {
				lineWidth: 1,
				lineDash: null,
				stroke: "#f0f0f0"
			} }
		}
	},
	yAxis: { grid: {
		alignTick: false,
		line: { style: {
			lineWidth: 1,
			lineDash: null,
			stroke: "#f0f0f0"
		} }
	} }
});

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/heatmap/shapes/circle.js
registerShape("polygon", "circle", { draw: function(cfg, group$1) {
	var _a$5, _b;
	var cx = cfg.x;
	var cy = cfg.y;
	var points = this.parsePoints(cfg.points);
	var width = Math.abs(points[2].x - points[1].x);
	var height = Math.abs(points[1].y - points[0].y);
	var maxRadius = Math.min(width, height) / 2;
	var value$1 = Number(cfg.shape[1]);
	var sizeRatio = Number(cfg.shape[2]);
	var radius = maxRadius * Math.sqrt(sizeRatio) * Math.sqrt(value$1);
	var fill = ((_a$5 = cfg.style) === null || _a$5 === void 0 ? void 0 : _a$5.fill) || cfg.color || ((_b = cfg.defaultStyle) === null || _b === void 0 ? void 0 : _b.fill);
	return group$1.addShape("circle", { attrs: __assign(__assign(__assign({
		x: cx,
		y: cy,
		r: radius
	}, cfg.defaultStyle), cfg.style), { fill }) });
} });

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/heatmap/shapes/square.js
registerShape("polygon", "square", { draw: function(cfg, group$1) {
	var _a$5, _b;
	var cx = cfg.x;
	var cy = cfg.y;
	var points = this.parsePoints(cfg.points);
	var width = Math.abs(points[2].x - points[1].x);
	var height = Math.abs(points[1].y - points[0].y);
	var maxSideLength = Math.min(width, height);
	var value$1 = Number(cfg.shape[1]);
	var sizeRatio = Number(cfg.shape[2]);
	var sideLength = maxSideLength * Math.sqrt(sizeRatio) * Math.sqrt(value$1);
	var fill = ((_a$5 = cfg.style) === null || _a$5 === void 0 ? void 0 : _a$5.fill) || cfg.color || ((_b = cfg.defaultStyle) === null || _b === void 0 ? void 0 : _b.fill);
	return group$1.addShape("rect", { attrs: __assign(__assign(__assign({
		x: cx - sideLength / 2,
		y: cy - sideLength / 2,
		width: sideLength,
		height: sideLength
	}, cfg.defaultStyle), cfg.style), { fill }) });
} });

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/heatmap/index.js
var Heatmap = function(_super) {
	__extends(Heatmap$2, _super);
	function Heatmap$2() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		/** 图表类型 */
		_this.type = "heatmap";
		return _this;
	}
	/**
	* 获取 柱形图 默认配置项
	* 供外部使用
	*/
	Heatmap$2.getDefaultOptions = function() {
		return DEFAULT_OPTIONS$13;
	};
	/**
	* 获取直方图的适配器
	*/
	Heatmap$2.prototype.getSchemaAdaptor = function() {
		return adaptor$11;
	};
	/**
	* 获取 色块图 默认配置
	*/
	Heatmap$2.prototype.getDefaultOptions = function() {
		return Heatmap$2.getDefaultOptions();
	};
	return Heatmap$2;
}(Plot);

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/liquid/utils.js
var CAT_VALUE = "liquid";
/**
* 获取水波图数据
*/
function getLiquidData(percent$1) {
	return [{
		percent: percent$1,
		type: CAT_VALUE
	}];
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/liquid/adaptor.js
/**
* geometry 处理
* @param params
*/
function geometry$9(params) {
	var chart = params.chart, options = params.options;
	var percent$1 = options.percent, liquidStyle = options.liquidStyle, radius = options.radius, outline = options.outline, wave = options.wave, shape = options.shape, shapeStyle = options.shapeStyle, animation$6 = options.animation;
	chart.scale({ percent: {
		min: 0,
		max: 1
	} });
	chart.data(getLiquidData(percent$1));
	var color$2 = options.color || chart.getTheme().defaultColor;
	var p = deepAssign({}, params, { options: {
		xField: "type",
		yField: "percent",
		widthRatio: radius,
		interval: {
			color: color$2,
			style: liquidStyle,
			shape: "liquid-fill-gauge"
		}
	} });
	var geometry$34 = interval(p).ext.geometry;
	var background = chart.getTheme().background;
	var customInfo = {
		percent: percent$1,
		radius,
		outline,
		wave,
		shape,
		shapeStyle,
		background,
		animation: animation$6
	};
	geometry$34.customInfo(customInfo);
	chart.legend(false);
	chart.axis(false);
	chart.tooltip(false);
	return params;
}
/**
* 统计指标文档
* @param params
*/
function statistic(params, updated) {
	var chart = params.chart, options = params.options;
	var statistic$3 = options.statistic, percent$1 = options.percent, meta$22 = options.meta;
	chart.getController("annotation").clear(true);
	var metaFormatter = get_default(meta$22, ["percent", "formatter"]) || (function(v) {
		return "".concat((v * 100).toFixed(2), "%");
	});
	var contentOpt = statistic$3.content;
	if (contentOpt) contentOpt = deepAssign({}, contentOpt, { content: !is_nil_default(contentOpt.content) ? contentOpt.content : metaFormatter(percent$1) });
	renderStatistic(chart, {
		statistic: __assign(__assign({}, statistic$3), { content: contentOpt }),
		plotType: "liquid"
	}, { percent: percent$1 });
	if (updated) chart.render(true);
	return params;
}
/**
* 水波图适配器
* @param chart
* @param options
*/
function adaptor$10(params) {
	return flow(theme, pattern("liquidStyle"), geometry$9, statistic, scale({}), animation, interaction)(params);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/liquid/constants.js
/**
* 水波图默认配置项
*/
var DEFAULT_OPTIONS$12 = {
	radius: .9,
	statistic: {
		title: false,
		content: { style: {
			opacity: .75,
			fontSize: "30px",
			lineHeight: "30px",
			textAlign: "center"
		} }
	},
	outline: {
		border: 2,
		distance: 0
	},
	wave: {
		count: 3,
		length: 192
	},
	shape: "circle"
};

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/liquid/shapes/liquid.js
var DURATION = 5e3;
/**
* 一个线性映射的函数
* @param min
* @param max
* @param factor
*/
function lerp(min$2, max$2, factor) {
	return min$2 + (max$2 - min$2) * factor;
}
/**
* 波浪的 attrs
* @param cfg
*/
function getFillAttrs$2(cfg) {
	var attrs = __assign({ opacity: 1 }, cfg.style);
	if (cfg.color && !attrs.fill) attrs.fill = cfg.color;
	return attrs;
}
/**
* shape 的 attrs
* @param cfg
*/
function getLineAttrs(cfg) {
	var attrs = mix({}, {
		fill: "#fff",
		fillOpacity: 0,
		lineWidth: 4
	}, cfg.style);
	if (cfg.color && !attrs.stroke) attrs.stroke = cfg.color;
	if (is_number_default(cfg.opacity)) attrs.opacity = attrs.strokeOpacity = cfg.opacity;
	return attrs;
}
/**
* 用贝塞尔曲线模拟正弦波
* Using Bezier curves to fit sine wave.
* There is 4 control points for each curve of wave,
* which is at 1/4 wave length of the sine wave.
*
* The control points for a wave from (a) to (d) are a-b-c-d:
*          c *----* d
*     b *
*       |
* ... a * ..................
*
* whose positions are a: (0, 0), b: (0.5, 0.5), c: (1, 1), d: (PI / 2, 1)
*
* @param x          x position of the left-most point (a)
* @param stage      0-3, stating which part of the wave it is
* @param waveLength wave length of the sine wave
* @param amplitude  wave amplitude
* @return 正弦片段曲线
*/
function getWaterWavePositions(x, stage, waveLength, amplitude$1) {
	if (stage === 0) return [
		[x + 1 / 2 * waveLength / Math.PI / 2, amplitude$1 / 2],
		[x + 1 / 2 * waveLength / Math.PI, amplitude$1],
		[x + waveLength / 4, amplitude$1]
	];
	if (stage === 1) return [
		[x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), amplitude$1],
		[x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1), amplitude$1 / 2],
		[x + waveLength / 4, 0]
	];
	if (stage === 2) return [
		[x + 1 / 2 * waveLength / Math.PI / 2, -amplitude$1 / 2],
		[x + 1 / 2 * waveLength / Math.PI, -amplitude$1],
		[x + waveLength / 4, -amplitude$1]
	];
	return [
		[x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), -amplitude$1],
		[x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1), -amplitude$1 / 2],
		[x + waveLength / 4, 0]
	];
}
/**
* 获取水波路径
* @param radius          半径
* @param waterLevel      水位
* @param waveLength      波长
* @param phase           相位
* @param amplitude       震幅
* @param cx              圆心x
* @param cy              圆心y
* @return path            路径
* @reference http://gitlab.alipay-inc.com/datavis/g6/blob/1.2.0/src/graph/utils/path.js#L135
*/
function getWaterWavePath(radius, waterLevel, waveLength, phase, amplitude$1, cx, cy) {
	var curves = Math.ceil(2 * radius / waveLength * 4) * 4;
	var path = [];
	var _phase = phase;
	while (_phase < -Math.PI * 2) _phase += Math.PI * 2;
	while (_phase > 0) _phase -= Math.PI * 2;
	_phase = _phase / Math.PI / 2 * waveLength;
	var left$1 = cx - radius + _phase - radius * 2;
	/**
	* top-left corner as start point
	*
	* draws this point
	*  |
	* \|/
	*  ~~~~~~~~
	*  |      |
	*  +------+
	*/
	path.push([
		"M",
		left$1,
		waterLevel
	]);
	/**
	* top wave
	*
	* ~~~~~~~~ <- draws this sine wave
	* |      |
	* +------+
	*/
	var waveRight = 0;
	for (var c = 0; c < curves; ++c) {
		var stage = c % 4;
		var pos = getWaterWavePositions(c * waveLength / 4, stage, waveLength, amplitude$1);
		path.push([
			"C",
			pos[0][0] + left$1,
			-pos[0][1] + waterLevel,
			pos[1][0] + left$1,
			-pos[1][1] + waterLevel,
			pos[2][0] + left$1,
			-pos[2][1] + waterLevel
		]);
		if (c === curves - 1) waveRight = pos[2][0];
	}
	/**
	* top-right corner
	*
	*                       ~~~~~~~~
	* 3. draws this line -> |      | <- 1. draws this line
	*                       +------+
	*                          ^
	*                          |
	*                  2. draws this line
	*/
	path.push([
		"L",
		waveRight + left$1,
		cy + radius
	]);
	path.push([
		"L",
		left$1,
		cy + radius
	]);
	path.push(["Z"]);
	return path;
}
/**
* 添加水波
* @param x           中心x
* @param y           中心y
* @param level       水位等级 0～1
* @param waveCount   水波数
* @param waveAttrs      色值
* @param group       图组
* @param clip        用于剪切的图形
* @param radius      绘制图形的高度
* @param waveLength  波的长度
*/
function addWaterWave(x, y, level, waveCount, waveAttrs, group$1, clip, radius, waveLength, animation$6) {
	var fill = waveAttrs.fill, opacity = waveAttrs.opacity;
	var bbox = clip.getBBox();
	var width = bbox.maxX - bbox.minX;
	var height = bbox.maxY - bbox.minY;
	for (var idx = 0; idx < waveCount; idx++) {
		var factor = waveCount <= 1 ? 1 : idx / (waveCount - 1);
		var wave = group$1.addShape("path", {
			name: "waterwave-path",
			attrs: {
				path: getWaterWavePath(radius, bbox.minY + height * level, waveLength, 0, width / 32, x, y),
				fill,
				opacity: lerp(.2, .9, factor) * opacity
			}
		});
		try {
			if (animation$6 === false) return;
			var matrix = transform$2([[
				"t",
				waveLength,
				0
			]]);
			wave.stopAnimate();
			wave.animate({ matrix }, {
				duration: lerp(.5 * DURATION, DURATION, factor),
				repeat: true
			});
		} catch (e) {
			console.warn("off-screen group animate error!");
		}
	}
}
/**
*
* @param x 中心 x
* @param y 中心 y
* @param width 外接矩形的宽
* @param height 外接矩形的高
*/
function pin(x, y, width, height) {
	var w = width * 2 / 3;
	var h = Math.max(w, height);
	var r = w / 2;
	var cx = x;
	var cy = r + y - h / 2;
	var theta = Math.asin(r / ((h - r) * .85));
	var dy = Math.sin(theta) * r;
	var dx = Math.cos(theta) * r;
	var x0 = cx - dx;
	var y0 = cy + dy;
	var cpX = x;
	var cpY = cy + r / Math.sin(theta);
	return "\n      M ".concat(x0, " ").concat(y0, "\n      A ").concat(r, " ").concat(r, " 0 1 1 ").concat(x0 + dx * 2, " ").concat(y0, "\n      Q ").concat(cpX, " ").concat(cpY, " ").concat(x, " ").concat(y + h / 2, "\n      Q ").concat(cpX, " ").concat(cpY, " ").concat(x0, " ").concat(y0, "\n      Z \n    ");
}
/**
*
* @param x 中心 x
* @param y 中心 y
* @param width 外接矩形的宽
* @param height 外接矩形的高
*/
function circle(x, y, width, height) {
	var rx = width / 2;
	var ry = height / 2;
	return "\n      M ".concat(x, " ").concat(y - ry, " \n      a ").concat(rx, " ").concat(ry, " 0 1 0 0 ").concat(ry * 2, "\n      a ").concat(rx, " ").concat(ry, " 0 1 0 0 ").concat(-ry * 2, "\n      Z\n    ");
}
/**
*
* @param x 中心 x
* @param y 中心 y
* @param width 外接矩形的宽
* @param height 外接矩形的高
*/
function diamond(x, y, width, height) {
	var h = height / 2;
	var w = width / 2;
	return "\n      M ".concat(x, " ").concat(y - h, "\n      L ").concat(x + w, " ").concat(y, "\n      L ").concat(x, " ").concat(y + h, "\n      L ").concat(x - w, " ").concat(y, "\n      Z\n    ");
}
/**
*
* @param x 中心 x
* @param y 中心 y
* @param width 外接矩形的宽
* @param height 外接矩形的高
*/
function triangle(x, y, width, height) {
	var h = height / 2;
	var w = width / 2;
	return "\n      M ".concat(x, " ").concat(y - h, "\n      L ").concat(x + w, " ").concat(y + h, "\n      L ").concat(x - w, " ").concat(y + h, "\n      Z\n    ");
}
/**
*
* @param x 中心 x
* @param y 中心 y
* @param width 外接矩形的宽
* @param height 外接矩形的高
*/
function rect(x, y, width, height) {
	var GOLDEN_SECTION_RATIO = .618;
	var h = height / 2;
	var w = width / 2 * GOLDEN_SECTION_RATIO;
	return "\n      M ".concat(x - w, " ").concat(y - h, "\n      L ").concat(x + w, " ").concat(y - h, "\n      L ").concat(x + w, " ").concat(y + h, "\n      L ").concat(x - w, " ").concat(y + h, "\n      Z\n    ");
}
var builtInShapeByName = {
	pin,
	circle,
	diamond,
	triangle,
	rect
};
registerShape("interval", "liquid-fill-gauge", { draw: function(cfg, container) {
	var cx = .5;
	var cy = .5;
	var customInfo = cfg.customInfo;
	var _a$5 = customInfo, percent$1 = _a$5.percent, radio = _a$5.radius, shape = _a$5.shape, shapeStyle = _a$5.shapeStyle, background = _a$5.background, animation$6 = _a$5.animation;
	var outline = customInfo.outline;
	var wave = customInfo.wave;
	var border = outline.border, distance$7 = outline.distance;
	var waveCount = wave.count, waveLength = wave.length;
	var minX = reduce_default(cfg.points, function(r, p) {
		return Math.min(r, p.x);
	}, Infinity);
	var center$1 = this.parsePoint({
		x: cx,
		y: cy
	});
	var minXPoint = this.parsePoint({
		x: minX,
		y: cy
	});
	var halfWidth = center$1.x - minXPoint.x;
	var radius = Math.min(halfWidth, minXPoint.y * radio);
	var waveAttrs = getFillAttrs$2(cfg);
	var outlineAttrs = getLineAttrs(mix({}, cfg, outline));
	var innerRadius = radius - border / 2;
	var shapePath = (typeof shape === "function" ? shape : builtInShapeByName[shape] || builtInShapeByName["circle"])(center$1.x, center$1.y, innerRadius * 2, innerRadius * 2);
	if (shapeStyle) container.addShape("path", {
		name: "shape",
		attrs: __assign({ path: shapePath }, shapeStyle)
	});
	if (percent$1 > 0) {
		var waves = container.addGroup({ name: "waves" });
		var clipPath = waves.setClip({
			type: "path",
			attrs: { path: shapePath }
		});
		addWaterWave(center$1.x, center$1.y, 1 - cfg.points[1].y, waveCount, waveAttrs, waves, clipPath, radius * 2, waveLength, animation$6);
	}
	container.addShape("path", {
		name: "distance",
		attrs: {
			path: shapePath,
			fill: "transparent",
			lineWidth: border + distance$7 * 2,
			stroke: background === "transparent" ? "#fff" : background
		}
	});
	container.addShape("path", {
		name: "wrap",
		attrs: mix(outlineAttrs, {
			path: shapePath,
			fill: "transparent",
			lineWidth: border
		})
	});
	return container;
} });

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/liquid/index.js
/**
* 传说中的水波图
*/
var Liquid = function(_super) {
	__extends(Liquid$1, _super);
	function Liquid$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		/** 图表类型 */
		_this.type = "liquid";
		return _this;
	}
	/**
	* 获取 饼图 默认配置项
	* 供外部使用
	*/
	Liquid$1.getDefaultOptions = function() {
		return DEFAULT_OPTIONS$12;
	};
	/**
	* 获取 水波图 默认配置项, 供 base 获取
	*/
	Liquid$1.prototype.getDefaultOptions = function() {
		return Liquid$1.getDefaultOptions();
	};
	/**
	* 更新数据
	* @param percent
	*/
	Liquid$1.prototype.changeData = function(percent$1) {
		this.chart.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, event_default.fromData(this.chart, VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
		this.updateOption({ percent: percent$1 });
		this.chart.data(getLiquidData(percent$1));
		statistic({
			chart: this.chart,
			options: this.options
		}, true);
		this.chart.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, event_default.fromData(this.chart, VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
	};
	/**
	* 获取适配器
	*/
	Liquid$1.prototype.getSchemaAdaptor = function() {
		return adaptor$10;
	};
	return Liquid$1;
}(Plot);

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/radar/adaptor.js
/**
* geometry 配置处理
* @param params
*/
function geometry$8(params) {
	var chart = params.chart, options = params.options;
	var data$2 = options.data, lineStyle = options.lineStyle, color$2 = options.color, pointOptions = options.point, areaOptions = options.area;
	chart.data(data$2);
	var primary = deepAssign({}, params, { options: {
		line: {
			style: lineStyle,
			color: color$2
		},
		point: pointOptions ? __assign({ color: color$2 }, pointOptions) : pointOptions,
		area: areaOptions ? __assign({ color: color$2 }, areaOptions) : areaOptions,
		label: void 0
	} });
	var second = deepAssign({}, primary, { options: { tooltip: false } });
	var pointState = (pointOptions === null || pointOptions === void 0 ? void 0 : pointOptions.state) || options.state;
	var pointParams = deepAssign({}, primary, { options: {
		tooltip: false,
		state: pointState
	} });
	line(primary);
	point(pointParams);
	area(second);
	return params;
}
/**
* meta 配置
* @param params
*/
function meta$6(params) {
	var _a$5;
	var options = params.options;
	var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
	return flow(scale((_a$5 = {}, _a$5[xField] = xAxis, _a$5[yField] = yAxis, _a$5)))(params);
}
/**
* coord 配置
* @param params
*/
function coord(params) {
	var chart = params.chart, options = params.options;
	var radius = options.radius, startAngle = options.startAngle, endAngle = options.endAngle;
	chart.coordinate("polar", {
		radius,
		startAngle,
		endAngle
	});
	return params;
}
/**
* axis 配置
* @param params
*/
function axis$7(params) {
	var chart = params.chart, options = params.options;
	var xField = options.xField, xAxis = options.xAxis, yField = options.yField, yAxis = options.yAxis;
	chart.axis(xField, xAxis);
	chart.axis(yField, yAxis);
	return params;
}
/**
* label 配置
* @param params
*/
function label$5(params) {
	var chart = params.chart, options = params.options;
	var label$16 = options.label, yField = options.yField;
	var geometry$34 = findGeometry(chart, "line");
	if (!label$16) geometry$34.label(false);
	else {
		var fields = label$16.fields, callback = label$16.callback, cfg = __rest(label$16, ["fields", "callback"]);
		geometry$34.label({
			fields: fields || [yField],
			callback,
			cfg: transformLabel(cfg)
		});
	}
	return params;
}
/**
* 雷达图适配器
* @param chart
* @param options
*/
function adaptor$9(params) {
	return flow(geometry$8, meta$6, theme, coord, axis$7, legend, tooltip, label$5, interaction, animation, annotation())(params);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/radar/interactions/radar-tooltip-action.js
var RadarTooltipController = function(_super) {
	__extends(RadarTooltipController$1, _super);
	function RadarTooltipController$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	Object.defineProperty(RadarTooltipController$1.prototype, "name", {
		get: function() {
			return "radar-tooltip";
		},
		enumerable: false,
		configurable: true
	});
	RadarTooltipController$1.prototype.getTooltipItems = function(point$1) {
		var _a$5 = this.getTooltipCfg(), shared = _a$5.shared, cfgTitle = _a$5.title;
		var hintItems = _super.prototype.getTooltipItems.call(this, point$1);
		if (hintItems.length > 0) {
			var geometry_1 = this.view.geometries[0];
			var dataArray = geometry_1.dataArray;
			var title_1 = hintItems[0].name;
			var result_1 = [];
			dataArray.forEach(function(mappingData) {
				mappingData.forEach(function(d) {
					var item = Util.getTooltipItems(d, geometry_1)[0];
					if (!shared && item && item.name === title_1) {
						var displayTitle = is_nil_default(cfgTitle) ? title_1 : cfgTitle;
						result_1.push(__assign(__assign({}, item), {
							name: item.title,
							title: displayTitle
						}));
					} else if (shared && item) {
						var displayTitle = is_nil_default(cfgTitle) ? item.name || title_1 : cfgTitle;
						result_1.push(__assign(__assign({}, item), {
							name: item.title,
							title: displayTitle
						}));
					}
				});
			});
			return result_1;
		}
		return [];
	};
	return RadarTooltipController$1;
}(tooltip_default);
registerComponentController("radar-tooltip", RadarTooltipController);
/**
* 雷达图 tooltip 激活 action
*/
var RadarTooltipAction = function(_super) {
	__extends(RadarTooltipAction$1, _super);
	function RadarTooltipAction$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	RadarTooltipAction$1.prototype.init = function() {
		this.context.view.removeInteraction("tooltip");
	};
	RadarTooltipAction$1.prototype.show = function() {
		var event = this.context.event;
		this.getTooltipController().showTooltip({
			x: event.x,
			y: event.y
		});
	};
	RadarTooltipAction$1.prototype.hide = function() {
		this.getTooltipController().hideTooltip();
	};
	RadarTooltipAction$1.prototype.getTooltipController = function() {
		return this.context.view.getController("radar-tooltip");
	};
	return RadarTooltipAction$1;
}(base_default$1);

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/radar/interactions/index.js
registerAction("radar-tooltip", RadarTooltipAction);
registerInteraction("radar-tooltip", {
	start: [{
		trigger: "plot:mousemove",
		action: "radar-tooltip:show"
	}],
	end: [{
		trigger: "plot:mouseleave",
		action: "radar-tooltip:hide"
	}]
});

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/radar/index.js
var Radar = function(_super) {
	__extends(Radar$1, _super);
	function Radar$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		/** 图表类型 */
		_this.type = "radar";
		return _this;
	}
	/**
	* @override
	* @param data
	*/
	Radar$1.prototype.changeData = function(data$2) {
		this.updateOption({ data: data$2 });
		this.chart.changeData(data$2);
	};
	/**
	* 获取 雷达图 默认配置
	*/
	Radar$1.prototype.getDefaultOptions = function() {
		return deepAssign({}, _super.prototype.getDefaultOptions.call(this), {
			xAxis: {
				label: { offset: 15 },
				grid: { line: { type: "line" } }
			},
			yAxis: { grid: { line: { type: "circle" } } },
			legend: { position: "top" },
			tooltip: {
				shared: true,
				showCrosshairs: true,
				showMarkers: true,
				crosshairs: {
					type: "xy",
					line: { style: {
						stroke: "#565656",
						lineDash: [4]
					} },
					follow: true
				}
			}
		});
	};
	/**
	* 获取 雷达图 的适配器
	*/
	Radar$1.prototype.getSchemaAdaptor = function() {
		return adaptor$9;
	};
	return Radar$1;
}(Plot);

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/radial-bar/utils.js
function getScaleMax(maxAngle, yField, data$2) {
	var yData = data$2.map(function(item) {
		return item[yField];
	}).filter(function(v) {
		return v !== void 0;
	});
	var maxValue = yData.length > 0 ? Math.max.apply(Math, yData) : 0;
	var formatRadian = Math.abs(maxAngle) % 360;
	if (!formatRadian) return maxValue;
	return maxValue * 360 / formatRadian;
}
/**
* 获取堆叠之后的数据
*/
function getStackedData(data$2, xField, yField) {
	var stackedData = [];
	data$2.forEach(function(item) {
		var valueItem = stackedData.find(function(v) {
			return v[xField] === item[xField];
		});
		if (valueItem) valueItem[yField] += item[yField] || null;
		else stackedData.push(__assign({}, item));
	});
	return stackedData;
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/radial-bar/adaptor.js
/**
* geometry 处理
* @param params
*/
function geometry$7(params) {
	var chart = params.chart, options = params.options;
	var style = options.barStyle, color$2 = options.color, tooltip$10 = options.tooltip, colorField = options.colorField, type = options.type, xField = options.xField, yField = options.yField, data$2 = options.data, shape = options.shape;
	var processData$1 = processIllegalData(data$2, yField);
	chart.data(processData$1);
	var p = deepAssign({}, params, { options: {
		tooltip: tooltip$10,
		seriesField: colorField,
		interval: {
			style,
			color: color$2,
			shape: shape || (type === "line" ? "line" : "intervel")
		},
		minColumnWidth: options.minBarWidth,
		maxColumnWidth: options.maxBarWidth,
		columnBackground: options.barBackground
	} });
	interval(p);
	if (type === "line") point({
		chart,
		options: {
			xField,
			yField,
			seriesField: colorField,
			point: {
				shape: "circle",
				color: color$2
			}
		}
	});
	return params;
}
/**
* meta 配置
* @param params
*/
function meta$5(params) {
	var _a$5;
	var options = params.options;
	var yField = options.yField, xField = options.xField, data$2 = options.data, isStack = options.isStack, isGroup = options.isGroup, colorField = options.colorField, maxAngle = options.maxAngle;
	var actualData = isStack && !isGroup && colorField ? getStackedData(data$2, xField, yField) : data$2;
	var processData$1 = processIllegalData(actualData, yField);
	return flow(scale((_a$5 = {}, _a$5[yField] = {
		min: 0,
		max: getScaleMax(maxAngle, yField, processData$1)
	}, _a$5)))(params);
}
/**
* coordinate 配置
* @param params
*/
function coordinate$2(params) {
	var chart = params.chart, options = params.options;
	var radius = options.radius, innerRadius = options.innerRadius, startAngle = options.startAngle, endAngle = options.endAngle;
	chart.coordinate({
		type: "polar",
		cfg: {
			radius,
			innerRadius,
			startAngle,
			endAngle
		}
	}).transpose();
	return params;
}
/**
* axis 配置
* @param params
*/
function axis$6(params) {
	var chart = params.chart, options = params.options;
	var xField = options.xField, xAxis = options.xAxis;
	chart.axis(xField, xAxis);
	return params;
}
/**
* 数据标签
* @param params
*/
function label$4(params) {
	var chart = params.chart, options = params.options;
	var label$16 = options.label, yField = options.yField;
	var intervalGeometry = findGeometry(chart, "interval");
	if (!label$16) intervalGeometry.label(false);
	else {
		var callback = label$16.callback, cfg = __rest(label$16, ["callback"]);
		intervalGeometry.label({
			fields: [yField],
			callback,
			cfg: __assign(__assign({}, transformLabel(cfg)), { type: "polar" })
		});
	}
	return params;
}
/**
* 图适配器
* @param chart
* @param options
*/
function adaptor$8(params) {
	return flow(pattern("barStyle"), geometry$7, meta$5, axis$6, coordinate$2, interaction, animation, theme, tooltip, legend, annotation(), label$4)(params);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/radial-bar/constant.js
/**
* 玉珏图 默认配置项
*/
var DEFAULT_OPTIONS$11 = deepAssign({}, Plot.getDefaultOptions(), {
	interactions: [{ type: "element-active" }],
	legend: false,
	tooltip: { showMarkers: false },
	xAxis: {
		grid: null,
		tickLine: null,
		line: null
	},
	maxAngle: 240
});

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/radial-bar/index.js
/**
* 玉珏图
*/
var RadialBar = function(_super) {
	__extends(RadialBar$1, _super);
	function RadialBar$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		/** 图表类型 */
		_this.type = "radial-bar";
		return _this;
	}
	RadialBar$1.getDefaultOptions = function() {
		return DEFAULT_OPTIONS$11;
	};
	/**
	* @override
	* @param data
	*/
	RadialBar$1.prototype.changeData = function(data$2) {
		this.updateOption({ data: data$2 });
		meta$5({
			chart: this.chart,
			options: this.options
		});
		this.chart.changeData(data$2);
	};
	/**
	* 获取默认配置
	*/
	RadialBar$1.prototype.getDefaultOptions = function() {
		return RadialBar$1.getDefaultOptions();
	};
	/**
	* 获取适配器
	*/
	RadialBar$1.prototype.getSchemaAdaptor = function() {
		return adaptor$8;
	};
	return RadialBar$1;
}(Plot);

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/rose/adaptor.js
/**
* geometry 配置处理
* @param params
*/
function geometry$6(params) {
	var chart = params.chart, options = params.options;
	var data$2 = options.data, sectorStyle = options.sectorStyle, shape = options.shape, color$2 = options.color;
	chart.data(data$2);
	flow(interval)(deepAssign({}, params, { options: {
		marginRatio: 1,
		interval: {
			style: sectorStyle,
			color: color$2,
			shape
		}
	} }));
	return params;
}
/**
* label 配置
* @param params
*/
function label$3(params) {
	var chart = params.chart, options = params.options;
	var label$16 = options.label, xField = options.xField;
	var geometry$34 = findGeometry(chart, "interval");
	if (label$16 === false) geometry$34.label(false);
	else if (is_object_default(label$16)) {
		var callback = label$16.callback, fields = label$16.fields, cfg = __rest(label$16, ["callback", "fields"]);
		var offset = cfg.offset;
		var layout$1 = cfg.layout;
		if (offset === void 0 || offset >= 0) {
			layout$1 = layout$1 ? is_array_default(layout$1) ? layout$1 : [layout$1] : [];
			cfg.layout = filter_default(layout$1, function(v) {
				return v.type !== "limit-in-shape";
			});
			cfg.layout.length || delete cfg.layout;
		}
		geometry$34.label({
			fields: fields || [xField],
			callback,
			cfg: transformLabel(cfg)
		});
	} else {
		log(LEVEL.WARN, label$16 === null, "the label option must be an Object.");
		geometry$34.label({ fields: [xField] });
	}
	return params;
}
/**
* legend 配置
* @param params
*/
function legend$5(params) {
	var chart = params.chart, options = params.options;
	var legend$17 = options.legend, seriesField = options.seriesField;
	if (legend$17 === false) chart.legend(false);
	else if (seriesField) chart.legend(seriesField, legend$17);
	return params;
}
/**
* coord 配置
* @param params
*/
function coordinate$1(params) {
	var chart = params.chart, options = params.options;
	var radius = options.radius, innerRadius = options.innerRadius, startAngle = options.startAngle, endAngle = options.endAngle;
	chart.coordinate({
		type: "polar",
		cfg: {
			radius,
			innerRadius,
			startAngle,
			endAngle
		}
	});
	return params;
}
/**
* meta 配置
* @param params
*/
function meta$4(params) {
	var _a$5;
	var options = params.options;
	var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
	return flow(scale((_a$5 = {}, _a$5[xField] = xAxis, _a$5[yField] = yAxis, _a$5)))(params);
}
/**
* axis 配置
* @param params
*/
function axis$5(params) {
	var chart = params.chart, options = params.options;
	var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
	if (!xAxis) chart.axis(xField, false);
	else chart.axis(xField, xAxis);
	if (!yAxis) chart.axis(yField, false);
	else chart.axis(yField, yAxis);
	return params;
}
/**
* 玫瑰图适配器
* @param chart
* @param options
*/
function adaptor$7(params) {
	flow(pattern("sectorStyle"), geometry$6, meta$4, label$3, coordinate$1, axis$5, legend$5, tooltip, interaction, animation, theme, annotation(), state)(params);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/rose/constant.js
/**
* 玫瑰图 默认配置项
*/
var DEFAULT_OPTIONS$10 = deepAssign({}, Plot.getDefaultOptions(), {
	xAxis: false,
	yAxis: false,
	legend: {
		position: "right",
		radio: {}
	},
	sectorStyle: {
		stroke: "#fff",
		lineWidth: 1
	},
	label: { layout: { type: "limit-in-shape" } },
	tooltip: {
		shared: true,
		showMarkers: false
	},
	interactions: [{ type: "active-region" }]
});

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/rose/index.js
var Rose = function(_super) {
	__extends(Rose$1, _super);
	function Rose$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		/** 玫瑰图 */
		_this.type = "rose";
		return _this;
	}
	/**
	* 获取 玫瑰图 默认配置项
	* 供外部使用
	*/
	Rose$1.getDefaultOptions = function() {
		return DEFAULT_OPTIONS$10;
	};
	/**
	* @override
	* @param data
	*/
	Rose$1.prototype.changeData = function(data$2) {
		this.updateOption({ data: data$2 });
		this.chart.changeData(data$2);
	};
	/**
	* 获取默认的 options 配置项
	*/
	Rose$1.prototype.getDefaultOptions = function() {
		return Rose$1.getDefaultOptions();
	};
	/**
	* 获取 玫瑰图 的适配器
	*/
	Rose$1.prototype.getSchemaAdaptor = function() {
		return adaptor$7;
	};
	return Rose$1;
}(Plot);

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/sankey/constant.js
var X_FIELD$1 = "x";
var Y_FIELD$1 = "y";
var COLOR_FIELD = "name";
var NODES_VIEW_ID = "nodes";
var EDGES_VIEW_ID = "edges";

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/sankey/circle.js
/**
* 根据 edges 获取对应的 node 结构
*/
function getNodes(edges, sourceField, targetField) {
	var nodes = [];
	edges.forEach(function(e) {
		var source = e[sourceField];
		var target = e[targetField];
		if (!nodes.includes(source)) nodes.push(source);
		if (!nodes.includes(target)) nodes.push(target);
	});
	return nodes;
}
/**
* 根据 edges 获取对应的 dfs 邻接矩阵
*/
function getMatrix(edges, nodes, sourceField, targetField) {
	var graphMatrix = {};
	nodes.forEach(function(pre) {
		graphMatrix[pre] = {};
		nodes.forEach(function(next) {
			graphMatrix[pre][next] = 0;
		});
	});
	edges.forEach(function(edge$1) {
		graphMatrix[edge$1[sourceField]][edge$1[targetField]] = 1;
	});
	return graphMatrix;
}
/**
* 使用 DFS 思路切断桑基图数据中的环（会丢失数据），保证顺序
* @param data
* @param sourceField
* @param targetField
*/
function cutoffCircle(edges, sourceField, targetField) {
	if (!is_array_default(edges)) return [];
	var removedData = [];
	var nodes = getNodes(edges, sourceField, targetField);
	var graphMatrix = getMatrix(edges, nodes, sourceField, targetField);
	var visited = {};
	nodes.forEach(function(node) {
		visited[node] = 0;
	});
	function DFS(dfsNode) {
		visited[dfsNode] = 1;
		nodes.forEach(function(node) {
			if (graphMatrix[dfsNode][node] != 0) if (visited[node] == 1) removedData.push("".concat(dfsNode, "_").concat(node));
			else if (visited[node] == -1) return;
			else DFS(node);
		});
		visited[dfsNode] = -1;
	}
	nodes.forEach(function(node) {
		if (visited[node] == -1) return;
		DFS(node);
	});
	if (removedData.length !== 0) console.warn("sankey data contains circle, ".concat(removedData.length, " records removed."), removedData);
	return edges.filter(function(edge$1) {
		return removedData.findIndex(function(i) {
			return i === "".concat(edge$1[sourceField], "_").concat(edge$1[targetField]);
		}) < 0;
	});
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/sankey/sankey/align.js
function targetDepth(d) {
	return d.target.depth;
}
function left(node) {
	return node.depth;
}
function right(node, n) {
	return n - 1 - node.height;
}
function justify(node, n) {
	return node.sourceLinks.length ? node.depth : n - 1;
}
function center(node) {
	return node.targetLinks.length ? node.depth : node.sourceLinks.length ? min_by_default(node.sourceLinks, targetDepth) - 1 : 0;
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/sankey/sankey/helper.js
function constant(x) {
	return function() {
		return x;
	};
}
function sumBy(arr, func) {
	var r = 0;
	for (var i = 0; i < arr.length; i++) r += func(arr[i]);
	return r;
}
/**
* 计算最大值
* @param arr
* @param func
*/
function maxValueBy(arr, func) {
	var r = -Infinity;
	for (var i = 0; i < arr.length; i++) r = Math.max(func(arr[i]), r);
	return r;
}
/**
* 计算最小值
* @param arr
* @param func
*/
function minValueBy(arr, func) {
	var r = Infinity;
	for (var i = 0; i < arr.length; i++) r = Math.min(func(arr[i]), r);
	return r;
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/sankey/sankey/sankey.js
function ascendingSourceBreadth(a, b) {
	return ascendingBreadth(a.source, b.source) || a.index - b.index;
}
function ascendingTargetBreadth(a, b) {
	return ascendingBreadth(a.target, b.target) || a.index - b.index;
}
function ascendingBreadth(a, b) {
	return a.y0 - b.y0;
}
function value(d) {
	return d.value;
}
function defaultId(d) {
	return d.index;
}
function defaultNodes(graph) {
	return graph.nodes;
}
function defaultLinks(graph) {
	return graph.links;
}
function find(nodeById, id$1) {
	var node = nodeById.get(id$1);
	if (!node) throw new Error("missing: " + id$1);
	return node;
}
function computeLinkBreadths(_a$5) {
	var nodes = _a$5.nodes;
	for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
		var node = nodes_1[_i];
		var y0 = node.y0;
		var y1 = y0;
		for (var _b = 0, _c = node.sourceLinks; _b < _c.length; _b++) {
			var link = _c[_b];
			link.y0 = y0 + link.width / 2;
			y0 += link.width;
		}
		for (var _d = 0, _e = node.targetLinks; _d < _e.length; _d++) {
			var link = _e[_d];
			link.y1 = y1 + link.width / 2;
			y1 += link.width;
		}
	}
}
function Sankey$1() {
	var x0 = 0, y0 = 0, x1 = 1, y1 = 1;
	var dx = 24;
	var dy = 8, py;
	var id$1 = defaultId;
	var align = justify;
	var depth;
	var sort;
	var linkSort;
	var nodes = defaultNodes;
	var links = defaultLinks;
	var iterations = 6;
	function sankey(arg) {
		var graph = {
			nodes: nodes(arg),
			links: links(arg)
		};
		computeNodeLinks(graph);
		computeNodeValues(graph);
		computeNodeDepths(graph);
		computeNodeHeights(graph);
		computeNodeBreadths(graph);
		computeLinkBreadths(graph);
		return graph;
	}
	sankey.update = function(graph) {
		computeLinkBreadths(graph);
		return graph;
	};
	sankey.nodeId = function(_) {
		return arguments.length ? (id$1 = typeof _ === "function" ? _ : constant(_), sankey) : id$1;
	};
	sankey.nodeAlign = function(_) {
		return arguments.length ? (align = typeof _ === "function" ? _ : constant(_), sankey) : align;
	};
	sankey.nodeDepth = function(_) {
		return arguments.length ? (depth = typeof _ === "function" ? _ : _, sankey) : depth;
	};
	sankey.nodeSort = function(_) {
		return arguments.length ? (sort = _, sankey) : sort;
	};
	sankey.nodeWidth = function(_) {
		return arguments.length ? (dx = +_, sankey) : dx;
	};
	sankey.nodePadding = function(_) {
		return arguments.length ? (dy = py = +_, sankey) : dy;
	};
	sankey.nodes = function(_) {
		return arguments.length ? (nodes = typeof _ === "function" ? _ : constant(_), sankey) : nodes;
	};
	sankey.links = function(_) {
		return arguments.length ? (links = typeof _ === "function" ? _ : constant(_), sankey) : links;
	};
	sankey.linkSort = function(_) {
		return arguments.length ? (linkSort = _, sankey) : linkSort;
	};
	sankey.size = function(_) {
		return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], sankey) : [x1 - x0, y1 - y0];
	};
	sankey.extent = function(_) {
		return arguments.length ? (x0 = +_[0][0], x1 = +_[1][0], y0 = +_[0][1], y1 = +_[1][1], sankey) : [[x0, y0], [x1, y1]];
	};
	sankey.iterations = function(_) {
		return arguments.length ? (iterations = +_, sankey) : iterations;
	};
	function computeNodeLinks(_a$5) {
		var nodes$1 = _a$5.nodes, links$1 = _a$5.links;
		nodes$1.forEach(function(node, idx) {
			node.index = idx;
			node.sourceLinks = [];
			node.targetLinks = [];
		});
		var nodeById = new Map(nodes$1.map(function(d) {
			return [id$1(d), d];
		}));
		links$1.forEach(function(link, idx) {
			link.index = idx;
			var source = link.source, target = link.target;
			if (typeof source !== "object") source = link.source = find(nodeById, source);
			if (typeof target !== "object") target = link.target = find(nodeById, target);
			source.sourceLinks.push(link);
			target.targetLinks.push(link);
		});
		if (linkSort != null) for (var _i = 0, nodes_2 = nodes$1; _i < nodes_2.length; _i++) {
			var _b = nodes_2[_i], sourceLinks = _b.sourceLinks, targetLinks = _b.targetLinks;
			sourceLinks.sort(linkSort);
			targetLinks.sort(linkSort);
		}
	}
	function computeNodeValues(_a$5) {
		var nodes$1 = _a$5.nodes;
		for (var _i = 0, nodes_3 = nodes$1; _i < nodes_3.length; _i++) {
			var node = nodes_3[_i];
			node.value = node.fixedValue === void 0 ? Math.max(sumBy(node.sourceLinks, value), sumBy(node.targetLinks, value)) : node.fixedValue;
		}
	}
	function computeNodeDepths(_a$5) {
		var nodes$1 = _a$5.nodes;
		var n = nodes$1.length;
		var current = new Set(nodes$1);
		var next = /* @__PURE__ */ new Set();
		var x = 0;
		while (current.size) {
			current.forEach(function(node$1) {
				node$1.depth = x;
				for (var _i = 0, _a$6 = node$1.sourceLinks; _i < _a$6.length; _i++) {
					var target = _a$6[_i].target;
					next.add(target);
				}
			});
			if (++x > n) throw new Error("circular link");
			current = next;
			next = /* @__PURE__ */ new Set();
		}
		if (depth) {
			var maxDepth = Math.max(maxValueBy(nodes$1, function(d) {
				return d.depth;
			}) + 1, 0);
			var node = void 0;
			for (var i = 0; i < nodes$1.length; i++) {
				node = nodes$1[i];
				node.depth = depth.call(null, node, maxDepth);
			}
		}
	}
	function computeNodeHeights(_a$5) {
		var nodes$1 = _a$5.nodes;
		var n = nodes$1.length;
		var current = new Set(nodes$1);
		var next = /* @__PURE__ */ new Set();
		var x = 0;
		while (current.size) {
			current.forEach(function(node) {
				node.height = x;
				for (var _i = 0, _a$6 = node.targetLinks; _i < _a$6.length; _i++) {
					var source = _a$6[_i].source;
					next.add(source);
				}
			});
			if (++x > n) throw new Error("circular link");
			current = next;
			next = /* @__PURE__ */ new Set();
		}
	}
	function computeNodeLayers(_a$5) {
		var nodes$1 = _a$5.nodes;
		var x = Math.max(maxValueBy(nodes$1, function(d) {
			return d.depth;
		}) + 1, 0);
		var kx = (x1 - x0 - dx) / (x - 1);
		var columns = new Array(x).fill(0).map(function() {
			return [];
		});
		for (var _i = 0, nodes_4 = nodes$1; _i < nodes_4.length; _i++) {
			var node = nodes_4[_i];
			var i = Math.max(0, Math.min(x - 1, Math.floor(align.call(null, node, x))));
			node.layer = i;
			node.x0 = x0 + i * kx;
			node.x1 = node.x0 + dx;
			if (columns[i]) columns[i].push(node);
			else columns[i] = [node];
		}
		if (sort) for (var _b = 0, columns_1 = columns; _b < columns_1.length; _b++) columns_1[_b].sort(sort);
		return columns;
	}
	function initializeNodeBreadths(columns) {
		var ky = minValueBy(columns, function(c) {
			return (y1 - y0 - (c.length - 1) * py) / sumBy(c, value);
		});
		for (var _i = 0, columns_2 = columns; _i < columns_2.length; _i++) {
			var nodes_6 = columns_2[_i];
			var y = y0;
			for (var _a$5 = 0, nodes_5 = nodes_6; _a$5 < nodes_5.length; _a$5++) {
				var node = nodes_5[_a$5];
				node.y0 = y;
				node.y1 = y + node.value * ky;
				y = node.y1 + py;
				for (var _b = 0, _c = node.sourceLinks; _b < _c.length; _b++) {
					var link = _c[_b];
					link.width = link.value * ky;
				}
			}
			y = (y1 - y + py) / (nodes_6.length + 1);
			for (var i = 0; i < nodes_6.length; ++i) {
				var node = nodes_6[i];
				node.y0 += y * (i + 1);
				node.y1 += y * (i + 1);
			}
			reorderLinks(nodes_6);
		}
	}
	function computeNodeBreadths(graph) {
		var columns = computeNodeLayers(graph);
		py = Math.min(dy, (y1 - y0) / (maxValueBy(columns, function(c) {
			return c.length;
		}) - 1));
		initializeNodeBreadths(columns);
		for (var i = 0; i < iterations; ++i) {
			var alpha = Math.pow(.99, i);
			var beta = Math.max(1 - alpha, (i + 1) / iterations);
			relaxRightToLeft(columns, alpha, beta);
			relaxLeftToRight(columns, alpha, beta);
		}
	}
	function relaxLeftToRight(columns, alpha, beta) {
		for (var i = 1, n = columns.length; i < n; ++i) {
			var column = columns[i];
			for (var _i = 0, column_1 = column; _i < column_1.length; _i++) {
				var target = column_1[_i];
				var y = 0;
				var w = 0;
				for (var _a$5 = 0, _b = target.targetLinks; _a$5 < _b.length; _a$5++) {
					var _c = _b[_a$5], source = _c.source;
					var v = _c.value * (target.layer - source.layer);
					y += targetTop(source, target) * v;
					w += v;
				}
				if (!(w > 0)) continue;
				var dy_1 = (y / w - target.y0) * alpha;
				target.y0 += dy_1;
				target.y1 += dy_1;
				reorderNodeLinks(target);
			}
			if (sort === void 0) column.sort(ascendingBreadth);
			if (column.length) resolveCollisions(column, beta);
		}
	}
	function relaxRightToLeft(columns, alpha, beta) {
		for (var n = columns.length, i = n - 2; i >= 0; --i) {
			var column = columns[i];
			for (var _i = 0, column_2 = column; _i < column_2.length; _i++) {
				var source = column_2[_i];
				var y = 0;
				var w = 0;
				for (var _a$5 = 0, _b = source.sourceLinks; _a$5 < _b.length; _a$5++) {
					var _c = _b[_a$5], target = _c.target;
					var v = _c.value * (target.layer - source.layer);
					y += sourceTop(source, target) * v;
					w += v;
				}
				if (!(w > 0)) continue;
				var dy_2 = (y / w - source.y0) * alpha;
				source.y0 += dy_2;
				source.y1 += dy_2;
				reorderNodeLinks(source);
			}
			if (sort === void 0) column.sort(ascendingBreadth);
			if (column.length) resolveCollisions(column, beta);
		}
	}
	function resolveCollisions(nodes$1, alpha) {
		var i = nodes$1.length >> 1;
		var subject = nodes$1[i];
		resolveCollisionsBottomToTop(nodes$1, subject.y0 - py, i - 1, alpha);
		resolveCollisionsTopToBottom(nodes$1, subject.y1 + py, i + 1, alpha);
		resolveCollisionsBottomToTop(nodes$1, y1, nodes$1.length - 1, alpha);
		resolveCollisionsTopToBottom(nodes$1, y0, 0, alpha);
	}
	function resolveCollisionsTopToBottom(nodes$1, y, i, alpha) {
		for (; i < nodes$1.length; ++i) {
			var node = nodes$1[i];
			var dy_3 = (y - node.y0) * alpha;
			if (dy_3 > 1e-6) node.y0 += dy_3, node.y1 += dy_3;
			y = node.y1 + py;
		}
	}
	function resolveCollisionsBottomToTop(nodes$1, y, i, alpha) {
		for (; i >= 0; --i) {
			var node = nodes$1[i];
			var dy_4 = (node.y1 - y) * alpha;
			if (dy_4 > 1e-6) node.y0 -= dy_4, node.y1 -= dy_4;
			y = node.y0 - py;
		}
	}
	function reorderNodeLinks(_a$5) {
		var sourceLinks = _a$5.sourceLinks, targetLinks = _a$5.targetLinks;
		if (linkSort === void 0) {
			for (var _i = 0, targetLinks_1 = targetLinks; _i < targetLinks_1.length; _i++) targetLinks_1[_i].source.sourceLinks.sort(ascendingTargetBreadth);
			for (var _b = 0, sourceLinks_1 = sourceLinks; _b < sourceLinks_1.length; _b++) sourceLinks_1[_b].target.targetLinks.sort(ascendingSourceBreadth);
		}
	}
	function reorderLinks(nodes$1) {
		if (linkSort === void 0) for (var _i = 0, nodes_7 = nodes$1; _i < nodes_7.length; _i++) {
			var _a$5 = nodes_7[_i], sourceLinks = _a$5.sourceLinks, targetLinks = _a$5.targetLinks;
			sourceLinks.sort(ascendingTargetBreadth);
			targetLinks.sort(ascendingSourceBreadth);
		}
	}
	function targetTop(source, target) {
		var y = source.y0 - (source.sourceLinks.length - 1) * py / 2;
		for (var _i = 0, _a$5 = source.sourceLinks; _i < _a$5.length; _i++) {
			var _b = _a$5[_i], node = _b.target, width = _b.width;
			if (node === target) break;
			y += width + py;
		}
		for (var _c = 0, _d = target.targetLinks; _c < _d.length; _c++) {
			var _e = _d[_c], node = _e.source, width = _e.width;
			if (node === source) break;
			y -= width;
		}
		return y;
	}
	function sourceTop(source, target) {
		var y = target.y0 - (target.targetLinks.length - 1) * py / 2;
		for (var _i = 0, _a$5 = target.targetLinks; _i < _a$5.length; _i++) {
			var _b = _a$5[_i], node = _b.source, width = _b.width;
			if (node === source) break;
			y += width + py;
		}
		for (var _c = 0, _d = source.sourceLinks; _c < _d.length; _c++) {
			var _e = _d[_c], node = _e.target, width = _e.width;
			if (node === target) break;
			y -= width;
		}
		return y;
	}
	return sankey;
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/sankey/layout.js
var ALIGN_METHOD = {
	left,
	right,
	center,
	justify
};
/**
* 默认值
*/
var DEFAULT_OPTIONS$9 = {
	nodeId: function(node) {
		return node.index;
	},
	nodeAlign: "justify",
	nodeWidth: .008,
	nodePadding: .03,
	nodeSort: void 0
};
/**
* 获得 align function
* @param nodeAlign
* @param nodeDepth
*/
function getNodeAlignFunction(nodeAlign) {
	return (is_string_default(nodeAlign) ? ALIGN_METHOD[nodeAlign] : is_function_default(nodeAlign) ? nodeAlign : null) || justify;
}
function getDefaultOptions(sankeyLayoutOptions) {
	return mix({}, DEFAULT_OPTIONS$9, sankeyLayoutOptions);
}
/**
* 桑基图利用数据进行布局的函数，最终返回节点、边的位置（0 - 1 的信息）
* 将会修改 data 数据
* @param sankeyLayoutOptions
* @param data
*/
function sankeyLayout(sankeyLayoutOptions, data$2) {
	var options = getDefaultOptions(sankeyLayoutOptions);
	var nodeId = options.nodeId, nodeSort = options.nodeSort, nodeAlign = options.nodeAlign, nodeWidth = options.nodeWidth, nodePadding = options.nodePadding, nodeDepth = options.nodeDepth;
	var layoutData = Sankey$1().nodeSort(nodeSort).nodeWidth(nodeWidth).nodePadding(nodePadding).nodeDepth(nodeDepth).nodeAlign(getNodeAlignFunction(nodeAlign)).extent([[0, 0], [1, 1]]).nodeId(nodeId)(data$2);
	var nodes = layoutData.nodes.map(function(node) {
		var x0 = node.x0, x1 = node.x1, y0 = node.y0, y1 = node.y1;
		node.x = [
			x0,
			x1,
			x1,
			x0
		];
		node.y = [
			y0,
			y0,
			y1,
			y1
		];
		return node;
	}).filter(function(node) {
		return node.name !== null;
	});
	var links = layoutData.links.map(function(edge$1) {
		var source = edge$1.source, target = edge$1.target;
		var sx = source.x1;
		var tx = target.x0;
		edge$1.x = [
			sx,
			sx,
			tx,
			tx
		];
		var offset = edge$1.width / 2;
		edge$1.y = [
			edge$1.y0 + offset,
			edge$1.y0 - offset,
			edge$1.y1 + offset,
			edge$1.y1 - offset
		];
		return edge$1;
	}).filter(function(edge$1) {
		var source = edge$1.source, target = edge$1.target;
		return source.name !== null && target.name !== null;
	});
	return {
		nodes,
		links
	};
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/sankey/helper.js
/**
* 是否是 node-link 类型的数据结构
* @param dataTyp
* @returns
*/
function isNodeLink(dataType) {
	return dataType === "node-link";
}
function getNodeWidthRatio(nodeWidth, nodeWidthRatio, width) {
	return isRealNumber(nodeWidth) ? nodeWidth / width : nodeWidthRatio;
}
function getNodePaddingRatio(nodePadding, nodePaddingRatio, height) {
	return isRealNumber(nodePadding) ? nodePadding / height : nodePaddingRatio;
}
/**
* 将桑基图配置经过 layout，生成最终的 view 数据
* @param options
* @param width
* @param height
*/
function transformToViewsData(options, width, height) {
	var dataType = options.dataType, data$2 = options.data, sourceField = options.sourceField, targetField = options.targetField, weightField = options.weightField, nodeAlign = options.nodeAlign, nodeSort = options.nodeSort, nodePadding = options.nodePadding, nodePaddingRatio = options.nodePaddingRatio, nodeWidth = options.nodeWidth, nodeWidthRatio = options.nodeWidthRatio, nodeDepth = options.nodeDepth, _a$5 = options.rawFields, rawFields = _a$5 === void 0 ? [] : _a$5;
	var sankeyLayoutInputData;
	if (!isNodeLink(dataType)) sankeyLayoutInputData = transformDataToNodeLinkData(cutoffCircle(data$2, sourceField, targetField), sourceField, targetField, weightField, rawFields);
	else sankeyLayoutInputData = data$2;
	var _b = sankeyLayout({
		nodeAlign,
		nodePadding: getNodePaddingRatio(nodePadding, nodePaddingRatio, height),
		nodeWidth: getNodeWidthRatio(nodeWidth, nodeWidthRatio, width),
		nodeSort,
		nodeDepth
	}, sankeyLayoutInputData), nodes = _b.nodes, links = _b.links;
	return {
		nodes: nodes.map(function(node) {
			return __assign(__assign({}, pick(node, __spreadArray([
				"x",
				"y",
				"name"
			], rawFields, true))), { isNode: true });
		}),
		edges: links.map(function(link) {
			return __assign(__assign({
				source: link.source.name,
				target: link.target.name,
				name: link.source.name || link.target.name
			}, pick(link, __spreadArray([
				"x",
				"y",
				"value"
			], rawFields, true))), { isNode: false });
		})
	};
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/sankey/adaptor.js
/**
* 默认配置项 处理
* @param params
*/
function defaultOptions$2(params) {
	var _a$5 = params.options.rawFields, rawFields = _a$5 === void 0 ? [] : _a$5;
	return deepAssign({}, { options: {
		tooltip: { fields: uniq(__spreadArray([
			"name",
			"source",
			"target",
			"value",
			"isNode"
		], rawFields, true)) },
		label: { fields: uniq(__spreadArray(["x", "name"], rawFields, true)) }
	} }, params);
}
/**
* geometry 处理
* @param params
*/
function geometry$5(params) {
	var chart = params.chart, options = params.options;
	var color$2 = options.color, nodeStyle = options.nodeStyle, edgeStyle = options.edgeStyle, label$16 = options.label, tooltip$10 = options.tooltip, nodeState = options.nodeState, edgeState = options.edgeState, _a$5 = options.rawFields, rawFields = _a$5 === void 0 ? [] : _a$5;
	chart.legend(false);
	chart.tooltip(tooltip$10);
	chart.axis(false);
	chart.coordinate().reflect("y");
	var _b = transformToViewsData(options, chart.width, chart.height), nodes = _b.nodes, edges = _b.edges;
	var edgeView = chart.createView({ id: EDGES_VIEW_ID });
	edgeView.data(edges);
	edge({
		chart: edgeView,
		options: {
			xField: X_FIELD$1,
			yField: Y_FIELD$1,
			seriesField: COLOR_FIELD,
			rawFields: __spreadArray(["source", "target"], rawFields, true),
			edge: {
				color: color$2,
				style: edgeStyle,
				shape: "arc"
			},
			tooltip: tooltip$10,
			state: edgeState
		}
	});
	var nodeView = chart.createView({ id: NODES_VIEW_ID });
	nodeView.data(nodes);
	polygon({
		chart: nodeView,
		options: {
			xField: X_FIELD$1,
			yField: Y_FIELD$1,
			seriesField: COLOR_FIELD,
			polygon: {
				color: color$2,
				style: nodeStyle
			},
			label: label$16,
			tooltip: tooltip$10,
			state: nodeState
		}
	});
	chart.interaction("element-active");
	chart.scale({
		x: {
			sync: true,
			nice: true,
			min: 0,
			max: 1,
			minLimit: 0,
			maxLimit: 1
		},
		y: {
			sync: true,
			nice: true,
			min: 0,
			max: 1,
			minLimit: 0,
			maxLimit: 1
		},
		name: {
			sync: "color",
			type: "cat"
		}
	});
	return params;
}
/**
* 动画
* @param params
*/
function animation$2(params) {
	var chart = params.chart;
	var animation$6 = params.options.animation;
	var geometries = __spreadArray(__spreadArray([], chart.views[0].geometries, true), chart.views[1].geometries, true);
	addViewAnimation(chart, animation$6, geometries);
	return params;
}
/**
* 节点拖动
* @param params
*/
function nodeDraggable(params) {
	var chart = params.chart;
	var nodeDraggable$1 = params.options.nodeDraggable;
	var DRAG_INTERACTION = "sankey-node-draggable";
	if (nodeDraggable$1) chart.interaction(DRAG_INTERACTION);
	else chart.removeInteraction(DRAG_INTERACTION);
	return params;
}
/**
* Interaction 配置
* @param params
*/
function interaction$3(params) {
	var chart = params.chart, options = params.options;
	var _a$5 = options.interactions, interactions = _a$5 === void 0 ? [] : _a$5;
	var nodeInteractions = [].concat(interactions, options.nodeInteractions || []);
	var edgeInteractions = [].concat(interactions, options.edgeInteractions || []);
	var nodeView = findViewById(chart, NODES_VIEW_ID);
	var edgeView = findViewById(chart, EDGES_VIEW_ID);
	nodeInteractions.forEach(function(i) {
		if ((i === null || i === void 0 ? void 0 : i.enable) === false) nodeView.removeInteraction(i.type);
		else nodeView.interaction(i.type, i.cfg || {});
	});
	edgeInteractions.forEach(function(i) {
		if ((i === null || i === void 0 ? void 0 : i.enable) === false) edgeView.removeInteraction(i.type);
		else edgeView.interaction(i.type, i.cfg || {});
	});
	return params;
}
/**
* 图适配器
* @param chart
* @param options
*/
function adaptor$6(params) {
	return flow(defaultOptions$2, geometry$5, interaction$3, nodeDraggable, animation$2, theme)(params);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/sankey/interactions/actions/node-drag.js
var SankeyNodeDragAction = function(_super) {
	__extends(SankeyNodeDragAction$1, _super);
	function SankeyNodeDragAction$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		/**
		* 是否在拖拽中的标记
		*/
		_this.isDragging = false;
		return _this;
	}
	/**
	* 当前操作的是否是 element
	*/
	SankeyNodeDragAction$1.prototype.isNodeElement = function() {
		var shape = get_default(this.context, "event.target");
		if (shape) {
			var element = shape.get("element");
			return element && element.getModel().data.isNode;
		}
		return false;
	};
	SankeyNodeDragAction$1.prototype.getNodeView = function() {
		return findViewById(this.context.view, NODES_VIEW_ID);
	};
	SankeyNodeDragAction$1.prototype.getEdgeView = function() {
		return findViewById(this.context.view, EDGES_VIEW_ID);
	};
	/**
	* 获取当前操作的 index
	* @param element
	*/
	SankeyNodeDragAction$1.prototype.getCurrentDatumIdx = function(element) {
		return this.getNodeView().geometries[0].elements.indexOf(element);
	};
	/**
	* 点击下去，开始
	*/
	SankeyNodeDragAction$1.prototype.start = function() {
		if (this.isNodeElement()) {
			this.prevPoint = {
				x: get_default(this.context, "event.x"),
				y: get_default(this.context, "event.y")
			};
			var element = this.context.event.target.get("element");
			var idx = this.getCurrentDatumIdx(element);
			if (idx === -1) return;
			this.currentElementIdx = idx;
			this.context.isDragging = true;
			this.isDragging = true;
			this.prevNodeAnimateCfg = this.getNodeView().getOptions().animate;
			this.prevEdgeAnimateCfg = this.getEdgeView().getOptions().animate;
			this.getNodeView().animate(false);
			this.getEdgeView().animate(false);
		}
	};
	/**
	* 移动过程中，平移
	*/
	SankeyNodeDragAction$1.prototype.translate = function() {
		if (this.isDragging) {
			var chart = this.context.view;
			var currentPoint = {
				x: get_default(this.context, "event.x"),
				y: get_default(this.context, "event.y")
			};
			var x = currentPoint.x - this.prevPoint.x;
			var y = currentPoint.y - this.prevPoint.y;
			var nodeView = this.getNodeView();
			var element = nodeView.geometries[0].elements[this.currentElementIdx];
			if (element && element.getModel()) {
				var prevDatum = element.getModel().data;
				var data$2 = nodeView.getOptions().data;
				var coordinate$10 = nodeView.getCoordinate();
				var datumGap_1 = {
					x: x / coordinate$10.getWidth(),
					y: y / coordinate$10.getHeight()
				};
				var nextDatum = __assign(__assign({}, prevDatum), {
					x: prevDatum.x.map(function(x$1) {
						return x$1 += datumGap_1.x;
					}),
					y: prevDatum.y.map(function(y$1) {
						return y$1 += datumGap_1.y;
					})
				});
				var newData = __spreadArray([], data$2, true);
				newData[this.currentElementIdx] = nextDatum;
				nodeView.data(newData);
				var name_1 = prevDatum.name;
				var edgeView = this.getEdgeView();
				var edgeData = edgeView.getOptions().data;
				edgeData.forEach(function(datum) {
					if (datum.source === name_1) {
						datum.x[0] += datumGap_1.x;
						datum.x[1] += datumGap_1.x;
						datum.y[0] += datumGap_1.y;
						datum.y[1] += datumGap_1.y;
					}
					if (datum.target === name_1) {
						datum.x[2] += datumGap_1.x;
						datum.x[3] += datumGap_1.x;
						datum.y[2] += datumGap_1.y;
						datum.y[3] += datumGap_1.y;
					}
				});
				edgeView.data(edgeData);
				this.prevPoint = currentPoint;
				chart.render(true);
			}
		}
	};
	/**
	* 结论，清除状态
	*/
	SankeyNodeDragAction$1.prototype.end = function() {
		this.isDragging = false;
		this.context.isDragging = false;
		this.prevPoint = null;
		this.currentElementIdx = null;
		this.getNodeView().animate(this.prevNodeAnimateCfg);
		this.getEdgeView().animate(this.prevEdgeAnimateCfg);
	};
	return SankeyNodeDragAction$1;
}(base_default$1);

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/sankey/interactions/node-draggable.js
registerAction("sankey-node-drag", SankeyNodeDragAction);
registerInteraction("sankey-node-draggable", {
	showEnable: [{
		trigger: "polygon:mouseenter",
		action: "cursor:pointer"
	}, {
		trigger: "polygon:mouseleave",
		action: "cursor:default"
	}],
	start: [{
		trigger: "polygon:mousedown",
		action: "sankey-node-drag:start"
	}],
	processing: [{
		trigger: "plot:mousemove",
		action: "sankey-node-drag:translate"
	}, {
		isEnable: function(context) {
			return context.isDragging;
		},
		trigger: "plot:mousemove",
		action: "cursor:move"
	}],
	end: [{
		trigger: "plot:mouseup",
		action: "sankey-node-drag:end"
	}]
});

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/sankey/index.js
/**
*  桑基图 Sankey
*/
var Sankey = function(_super) {
	__extends(Sankey$2, _super);
	function Sankey$2() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		/** 图表类型 */
		_this.type = "sankey";
		return _this;
	}
	Sankey$2.getDefaultOptions = function() {
		return {
			appendPadding: 8,
			syncViewPadding: true,
			nodeStyle: {
				opacity: 1,
				fillOpacity: 1,
				lineWidth: 1
			},
			edgeStyle: {
				opacity: .3,
				lineWidth: 0
			},
			edgeState: { active: { style: {
				opacity: .8,
				lineWidth: 0
			} } },
			label: {
				formatter: function(_a$5) {
					return _a$5.name;
				},
				callback: function(x) {
					var isLast = x[1] === 1;
					return {
						style: {
							fill: "#545454",
							textAlign: isLast ? "end" : "start"
						},
						offsetX: isLast ? -8 : 8
					};
				},
				layout: [{ type: "hide-overlap" }]
			},
			tooltip: {
				showTitle: false,
				showMarkers: false,
				shared: false,
				showContent: function(items) {
					return !get_default(items, [
						0,
						"data",
						"isNode"
					]);
				},
				formatter: function(datum) {
					var source = datum.source, target = datum.target, value$1 = datum.value;
					return {
						name: source + " -> " + target,
						value: value$1
					};
				}
			},
			nodeWidthRatio: .008,
			nodePaddingRatio: .01,
			animation: {
				appear: { animation: "wave-in" },
				enter: { animation: "wave-in" }
			}
		};
	};
	/**
	* @override
	* @param data
	*/
	Sankey$2.prototype.changeData = function(data$2) {
		this.updateOption({ data: data$2 });
		var _a$5 = transformToViewsData(this.options, this.chart.width, this.chart.height), nodes = _a$5.nodes, edges = _a$5.edges;
		var nodesView = findViewById(this.chart, NODES_VIEW_ID);
		var edgesView = findViewById(this.chart, EDGES_VIEW_ID);
		nodesView.changeData(nodes);
		edgesView.changeData(edges);
	};
	/**
	* 获取适配器
	*/
	Sankey$2.prototype.getSchemaAdaptor = function() {
		return adaptor$6;
	};
	/**
	* 获取 条形图 默认配置
	*/
	Sankey$2.prototype.getDefaultOptions = function() {
		return Sankey$2.getDefaultOptions();
	};
	return Sankey$2;
}(Plot);

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/sunburst/constant.js
/**
* 祖先节点，非 root 根节点
*/
var SUNBURST_ANCESTOR_FIELD = "ancestor-node";
var SUNBURST_Y_FIELD = "value";
var SUNBURST_PATH_FIELD = "path";
/** 默认的源字段 */
var RAW_FIELDS = [
	SUNBURST_PATH_FIELD,
	NODE_INDEX_FIELD,
	NODE_ANCESTORS_FIELD,
	CHILD_NODE_COUNT,
	"name",
	"depth",
	"height"
];
/**
* 旭日图 默认配置项
*/
var DEFAULT_OPTIONS$6 = deepAssign({}, Plot.getDefaultOptions(), {
	innerRadius: 0,
	radius: .85,
	hierarchyConfig: { field: "value" },
	tooltip: {
		shared: true,
		showMarkers: false,
		offset: 20,
		showTitle: false
	},
	legend: false,
	sunburstStyle: {
		lineWidth: .5,
		stroke: "#FFF"
	},
	drilldown: { enabled: true }
});

//#endregion
//#region node_modules/@antv/g2plot/esm/utils/hierarchy/partition.js
var DEFAULT_OPTIONS$8 = {
	field: "value",
	size: [1, 1],
	round: false,
	padding: 0,
	sort: function(a, b) {
		return b.value - a.value;
	},
	as: ["x", "y"],
	ignoreParentValue: true
};
function partition(data$2, options) {
	options = mix({}, DEFAULT_OPTIONS$8, options);
	var as = options.as;
	if (!is_array_default(as) || as.length !== 2) throw new TypeError("Invalid as: it must be an array with 2 strings (e.g. [ \"x\", \"y\" ])!");
	var field$5;
	try {
		field$5 = getField(options);
	} catch (e) {
		console.warn(e);
	}
	var partition$1 = function(data$3) {
		return partition_default().size(options.size).round(options.round).padding(options.padding)(
			/**
			* d3Hierarchy 布局中需指定 sum 函数计算 node 值，规则是：从当前 node 开始以 post-order traversal 的次序为当前节点以及每个后代节点调用指定的 value 函数，并返回当前 node。
			* for example:
			* { node: 'parent', value: 10, children: [{node: 'child1', value: 5}, {node: 'child2', value: 5}, ]}
			* parent 所得的计算值是 sum(node(parent)) + sum(node(child1)) + sum(node(child2))
			* sum 函数中，d 为用户传入的 data, children 为保留字段
			*/
			hierarchy(data$3).sum(function(d) {
				return size(d.children) ? options.ignoreParentValue ? 0 : d[field$5] - reduce_default(d.children, function(a, b) {
					return a + b[field$5];
				}, 0) : d[field$5];
			}).sort(options.sort)
		);
	};
	var root = partition$1(data$2);
	var x = as[0];
	var y = as[1];
	root.each(function(node) {
		var _a$5, _b;
		node[x] = [
			node.x0,
			node.x1,
			node.x1,
			node.x0
		];
		node[y] = [
			node.y1,
			node.y1,
			node.y0,
			node.y0
		];
		node.name = node.name || ((_a$5 = node.data) === null || _a$5 === void 0 ? void 0 : _a$5.name) || ((_b = node.data) === null || _b === void 0 ? void 0 : _b.label);
		node.data.name = node.name;
		[
			"x0",
			"x1",
			"y0",
			"y1"
		].forEach(function(prop) {
			if (as.indexOf(prop) === -1) delete node[prop];
		});
	});
	return getAllNodes(root);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/utils/hierarchy/treemap.js
var DEFAULT_OPTIONS$7 = {
	field: "value",
	tile: "treemapSquarify",
	size: [1, 1],
	round: false,
	ignoreParentValue: true,
	padding: 0,
	paddingInner: 0,
	paddingOuter: 0,
	paddingTop: 0,
	paddingRight: 0,
	paddingBottom: 0,
	paddingLeft: 0,
	as: ["x", "y"],
	sort: function(a, b) {
		return b.value - a.value;
	},
	ratio: .5 * (1 + Math.sqrt(5))
};
function getTileMethod(tile, ratio) {
	return tile === "treemapSquarify" ? src_exports[tile].ratio(ratio) : src_exports[tile];
}
function treemap(data$2, options) {
	options = mix({}, DEFAULT_OPTIONS$7, options);
	var as = options.as;
	if (!is_array_default(as) || as.length !== 2) throw new TypeError("Invalid as: it must be an array with 2 strings (e.g. [ \"x\", \"y\" ])!");
	var field$5;
	try {
		field$5 = getField(options);
	} catch (e) {
		console.warn(e);
	}
	var tileMethod = getTileMethod(options.tile, options.ratio);
	var partition$1 = function(data$3) {
		return treemap_default().tile(tileMethod).size(options.size).round(options.round).padding(options.padding).paddingInner(options.paddingInner).paddingOuter(options.paddingOuter).paddingTop(options.paddingTop).paddingRight(options.paddingRight).paddingBottom(options.paddingBottom).paddingLeft(options.paddingLeft)(
			/**
			* d3Hierarchy 布局中需指定 sum 函数计算 node 值，规则是：从当前 node 开始以 post-order traversal 的次序为当前节点以及每个后代节点调用指定的 value 函数，并返回当前 node。
			* for example:
			* { node: 'parent', value: 10, children: [{node: 'child1', value: 5}, {node: 'child2', value: 5}, ]}
			* parent 所得的计算值是 sum(node(parent)) + sum(node(child1)) + sum(node(child2))
			* ignoreParentValue 为 true(默认) 时，父元素的值由子元素累加而来，该值为 0 + 5 + 5 = 10
			* ignoreParentValue 为 false 时，父元素的值由当前节点 及子元素累加而来，该值为 10 + 5 + 5 = 20
			* sum 函数中，d 为用户传入的 data, children 为保留字段
			*/
			hierarchy(data$3).sum(function(d) {
				return options.ignoreParentValue && d.children ? 0 : d[field$5];
			}).sort(options.sort)
		);
	};
	var root = partition$1(data$2);
	var x = as[0];
	var y = as[1];
	root.each(function(node) {
		node[x] = [
			node.x0,
			node.x1,
			node.x1,
			node.x0
		];
		node[y] = [
			node.y1,
			node.y1,
			node.y0,
			node.y0
		];
		[
			"x0",
			"x1",
			"y0",
			"y1"
		].forEach(function(prop) {
			if (as.indexOf(prop) === -1) delete node[prop];
		});
	});
	return getAllNodes(root);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/sunburst/utils.js
/**
* sunburst 处理数据
* @param options
*/
function transformData$2(options) {
	var data$2 = options.data, colorField = options.colorField, rawFields = options.rawFields, _a$5 = options.hierarchyConfig, hierarchyConfig = _a$5 === void 0 ? {} : _a$5;
	var activeDepth = hierarchyConfig.activeDepth;
	var transform$7 = {
		partition,
		treemap
	};
	var seriesField = options.seriesField;
	var type = options.type || "partition";
	var nodes = transform$7[type](data$2, __assign(__assign({ field: seriesField || "value" }, omit_default(hierarchyConfig, ["activeDepth"])), {
		type: "hierarchy.".concat(type),
		as: ["x", "y"]
	}));
	var result = [];
	nodes.forEach(function(node) {
		var _a$6;
		var _b, _c, _d, _e, _f;
		if (node.depth === 0) return null;
		if (activeDepth > 0 && node.depth > activeDepth) return null;
		var path = node.data.name;
		var ancestorNode = __assign({}, node);
		while (ancestorNode.depth > 1) {
			path = "".concat((_b = ancestorNode.parent.data) === null || _b === void 0 ? void 0 : _b.name, " / ").concat(path);
			ancestorNode = ancestorNode.parent;
		}
		var nodeInfo = __assign(__assign(__assign({}, pick(node.data, __spreadArray(__spreadArray([], rawFields || [], true), [hierarchyConfig.field], false))), (_a$6 = {}, _a$6[SUNBURST_PATH_FIELD] = path, _a$6[SUNBURST_ANCESTOR_FIELD] = ancestorNode.data.name, _a$6)), node);
		if (seriesField) nodeInfo[seriesField] = node.data[seriesField] || ((_d = (_c = node.parent) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d[seriesField]);
		if (colorField) nodeInfo[colorField] = node.data[colorField] || ((_f = (_e = node.parent) === null || _e === void 0 ? void 0 : _e.data) === null || _f === void 0 ? void 0 : _f[colorField]);
		nodeInfo.ext = hierarchyConfig;
		nodeInfo[HIERARCHY_DATA_TRANSFORM_PARAMS] = {
			hierarchyConfig,
			colorField,
			rawFields
		};
		result.push(nodeInfo);
	});
	return result;
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/sunburst/adaptor.js
/**
* geometry 配置处理
* @param params
*/
function geometry$4(params) {
	var chart = params.chart, options = params.options;
	var color$2 = options.color, _a$5 = options.colorField, colorField = _a$5 === void 0 ? SUNBURST_ANCESTOR_FIELD : _a$5, sunburstStyle = options.sunburstStyle, _b = options.rawFields, rawFields = _b === void 0 ? [] : _b, shape = options.shape;
	var data$2 = transformData$2(options);
	chart.data(data$2);
	var style;
	if (sunburstStyle) style = function(datum) {
		return deepAssign({}, { fillOpacity: Math.pow(.85, datum.depth) }, is_function_default(sunburstStyle) ? sunburstStyle(datum) : sunburstStyle);
	};
	polygon(deepAssign({}, params, { options: {
		xField: "x",
		yField: "y",
		seriesField: colorField,
		rawFields: uniq(__spreadArray(__spreadArray([], RAW_FIELDS, true), rawFields, true)),
		polygon: {
			color: color$2,
			style,
			shape
		}
	} }));
	return params;
}
/**
* axis 配置
* @param params
*/
function axis$4(params) {
	params.chart.axis(false);
	return params;
}
/**
* 数据标签
* @param params
*/
function label$2(params) {
	var chart = params.chart;
	var label$16 = params.options.label;
	var geometry$34 = findGeometry(chart, "polygon");
	if (!label$16) geometry$34.label(false);
	else {
		var _a$5 = label$16.fields, fields = _a$5 === void 0 ? ["name"] : _a$5, callback = label$16.callback, cfg = __rest(label$16, ["fields", "callback"]);
		geometry$34.label({
			fields,
			callback,
			cfg: transformLabel(cfg)
		});
	}
	return params;
}
/**
* coord 配置
* @param params
*/
function coordinate(params) {
	var chart = params.chart, options = params.options;
	var innerRadius = options.innerRadius, radius = options.radius, reflect = options.reflect;
	var coord$1 = chart.coordinate({
		type: "polar",
		cfg: {
			innerRadius,
			radius
		}
	});
	if (reflect) coord$1.reflect(reflect);
	return params;
}
/**
* meta 配置
* @param params
*/
function meta$3(params) {
	var _a$5;
	var options = params.options;
	var hierarchyConfig = options.hierarchyConfig, meta$22 = options.meta;
	return flow(scale({}, (_a$5 = {}, _a$5[SUNBURST_Y_FIELD] = get_default(meta$22, get_default(hierarchyConfig, ["field"], "value")), _a$5)))(params);
}
/**
* tooltip 配置
* @param params
*/
function tooltip$2(params) {
	var chart = params.chart;
	var tooltip$10 = params.options.tooltip;
	if (tooltip$10 === false) chart.tooltip(false);
	else {
		var tooltipOptions = tooltip$10;
		if (!get_default(tooltip$10, "fields")) tooltipOptions = deepAssign({}, { customItems: function(items) {
			return items.map(function(item) {
				var scales = get_default(chart.getOptions(), "scales");
				var pathFormatter = get_default(scales, [SUNBURST_PATH_FIELD, "formatter"], function(v) {
					return v;
				});
				var valueFormatter = get_default(scales, [SUNBURST_Y_FIELD, "formatter"], function(v) {
					return v;
				});
				return __assign(__assign({}, item), {
					name: pathFormatter(item.data[SUNBURST_PATH_FIELD]),
					value: valueFormatter(item.data.value)
				});
			});
		} }, tooltipOptions);
		chart.tooltip(tooltipOptions);
	}
	return params;
}
function adaptorInteraction$1(options) {
	var drilldown = options.drilldown, _a$5 = options.interactions, interactions = _a$5 === void 0 ? [] : _a$5;
	if (drilldown === null || drilldown === void 0 ? void 0 : drilldown.enabled) return deepAssign({}, options, { interactions: __spreadArray(__spreadArray([], interactions, true), [{
		type: "drill-down",
		cfg: {
			drillDownConfig: drilldown,
			transformData: transformData$2
		}
	}], false) });
	return options;
}
/**
* 交互配置
* @param params
* @returns
*/
function interaction$2(params) {
	var chart = params.chart, options = params.options;
	var drilldown = options.drilldown;
	interaction({
		chart,
		options: adaptorInteraction$1(options)
	});
	if (drilldown === null || drilldown === void 0 ? void 0 : drilldown.enabled) chart.appendPadding = getAdjustAppendPadding(chart.appendPadding, get_default(drilldown, ["breadCrumb", "position"]));
	return params;
}
/**
* 旭日图适配器
* @param chart
* @param options
*/
function adaptor$5(params) {
	return flow(theme, pattern("sunburstStyle"), geometry$4, axis$4, meta$3, legend, coordinate, tooltip$2, label$2, interaction$2, animation, annotation())(params);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/sunburst/index.js
var Sunburst = function(_super) {
	__extends(Sunburst$1, _super);
	function Sunburst$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		/** 图表类型 */
		_this.type = "sunburst";
		return _this;
	}
	/**
	* 获取 旭日图 默认配置项
	* 供外部使用
	*/
	Sunburst$1.getDefaultOptions = function() {
		return DEFAULT_OPTIONS$6;
	};
	/**
	* 获取 旭日图 默认配置
	*/
	Sunburst$1.prototype.getDefaultOptions = function() {
		return Sunburst$1.getDefaultOptions();
	};
	/**
	* 获取旭日图的适配器
	*/
	Sunburst$1.prototype.getSchemaAdaptor = function() {
		return adaptor$5;
	};
	/** 旭日图 节点的祖先节点 */
	Sunburst$1.SUNBURST_ANCESTOR_FIELD = SUNBURST_ANCESTOR_FIELD;
	/** 旭日图 节点的路径 */
	Sunburst$1.SUNBURST_PATH_FIELD = SUNBURST_PATH_FIELD;
	/** 节点的祖先节点 */
	Sunburst$1.NODE_ANCESTORS_FIELD = NODE_ANCESTORS_FIELD;
	return Sunburst$1;
}(Plot);

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/treemap/utils.js
function findInteraction(interactions, interactionType) {
	if (!is_array_default(interactions)) return void 0;
	return interactions.find(function(i) {
		return i.type === interactionType;
	});
}
function enableInteraction(interactions, interactionType) {
	var interaction$9 = findInteraction(interactions, interactionType);
	return interaction$9 && interaction$9.enable !== false;
}
/**
* 是否允许下钻交互
* @param interactions
* @param interactionType
* @returns
*/
function enableDrillInteraction(options) {
	var interactions = options.interactions, drilldown = options.drilldown;
	return get_default(drilldown, "enabled") || enableInteraction(interactions, "treemap-drill-down");
}
function resetDrillDown(chart) {
	var drillDownInteraction = chart.interactions["drill-down"];
	if (!drillDownInteraction) return;
	drillDownInteraction.context.actions.find(function(i) {
		return i.name === "drill-down-action";
	}).reset();
}
function transformData$1(options) {
	var data$2 = options.data, colorField = options.colorField, enableDrillDown = options.enableDrillDown, hierarchyConfig = options.hierarchyConfig;
	var nodes = treemap(data$2, __assign(__assign({}, hierarchyConfig), {
		type: "hierarchy.treemap",
		field: "value",
		as: ["x", "y"]
	}));
	var result = [];
	nodes.forEach(function(node) {
		if (node.depth === 0) return null;
		if (enableDrillDown && node.depth !== 1) return null;
		if (!enableDrillDown && node.children) return null;
		var curPath = node.ancestors().map(function(n) {
			return {
				data: n.data,
				height: n.height,
				value: n.value
			};
		});
		var path = enableDrillDown && is_array_default(data$2.path) ? curPath.concat(data$2.path.slice(1)) : curPath;
		var nodeInfo = Object.assign({}, node.data, __assign({
			x: node.x,
			y: node.y,
			depth: node.depth,
			value: node.value,
			path
		}, node));
		if (!node.data[colorField] && node.parent) {
			var ancestorNode = node.ancestors().find(function(n) {
				return n.data[colorField];
			});
			nodeInfo[colorField] = ancestorNode === null || ancestorNode === void 0 ? void 0 : ancestorNode.data[colorField];
		} else nodeInfo[colorField] = node.data[colorField];
		nodeInfo[HIERARCHY_DATA_TRANSFORM_PARAMS] = {
			hierarchyConfig,
			colorField,
			enableDrillDown
		};
		result.push(nodeInfo);
	});
	return result;
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/treemap/adaptor.js
/**
* 获取默认 option
* @param params
*/
function defaultOptions$1(params) {
	var colorField = params.options.colorField;
	return deepAssign({ options: {
		rawFields: ["value"],
		tooltip: {
			fields: [
				"name",
				"value",
				colorField,
				"path"
			],
			formatter: function(data$2) {
				return {
					name: data$2.name,
					value: data$2.value
				};
			}
		}
	} }, params);
}
/**
* 字段
* @param params
*/
function geometry$3(params) {
	var chart = params.chart, options = params.options;
	var color$2 = options.color, colorField = options.colorField, rectStyle = options.rectStyle, hierarchyConfig = options.hierarchyConfig, rawFields = options.rawFields;
	var data$2 = transformData$1({
		data: options.data,
		colorField: options.colorField,
		enableDrillDown: enableDrillInteraction(options),
		hierarchyConfig
	});
	chart.data(data$2);
	polygon(deepAssign({}, params, { options: {
		xField: "x",
		yField: "y",
		seriesField: colorField,
		rawFields,
		polygon: {
			color: color$2,
			style: rectStyle
		}
	} }));
	chart.coordinate().reflect("y");
	return params;
}
/**
* 坐标轴
* @param params
*/
function axis$3(params) {
	params.chart.axis(false);
	return params;
}
function adaptorInteraction(options) {
	var drilldown = options.drilldown, _a$5 = options.interactions, interactions = _a$5 === void 0 ? [] : _a$5;
	if (enableDrillInteraction(options)) return deepAssign({}, options, { interactions: __spreadArray(__spreadArray([], interactions, true), [{
		type: "drill-down",
		cfg: {
			drillDownConfig: drilldown,
			transformData: transformData$1
		}
	}], false) });
	return options;
}
/**
* Interaction 配置
* @param params
*/
function interaction$1(params) {
	var chart = params.chart, options = params.options;
	var interactions = options.interactions, drilldown = options.drilldown;
	interaction({
		chart,
		options: adaptorInteraction(options)
	});
	var viewZoomInteraction = findInteraction(interactions, "view-zoom");
	if (viewZoomInteraction) if (viewZoomInteraction.enable !== false) chart.getCanvas().on("mousewheel", function(ev) {
		ev.preventDefault();
	});
	else chart.getCanvas().off("mousewheel");
	if (enableDrillInteraction(options)) chart.appendPadding = getAdjustAppendPadding(chart.appendPadding, get_default(drilldown, ["breadCrumb", "position"]));
	return params;
}
/**
* 矩形树图
* @param chart
* @param options
*/
function adaptor$4(params) {
	return flow(defaultOptions$1, theme, pattern("rectStyle"), geometry$3, axis$3, legend, tooltip, interaction$1, animation, annotation())(params);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/treemap/constant.js
var DEFAULT_OPTIONS$5 = {
	colorField: "name",
	rectStyle: {
		lineWidth: 1,
		stroke: "#fff"
	},
	hierarchyConfig: { tile: "treemapSquarify" },
	label: {
		fields: ["name"],
		layout: { type: "limit-in-shape" }
	},
	tooltip: {
		showMarkers: false,
		showTitle: false
	},
	drilldown: {
		enabled: false,
		breadCrumb: {
			position: "bottom-left",
			rootText: "初始",
			dividerText: "/",
			textStyle: {
				fontSize: 12,
				fill: "rgba(0, 0, 0, 0.65)",
				cursor: "pointer"
			},
			activeTextStyle: { fill: "#87B5FF" }
		}
	}
};

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/treemap/index.js
var Treemap = function(_super) {
	__extends(Treemap$1, _super);
	function Treemap$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		/** 图表类型 */
		_this.type = "treemap";
		return _this;
	}
	/**
	* 获取 矩阵树图 默认配置项
	* 供外部使用
	*/
	Treemap$1.getDefaultOptions = function() {
		return DEFAULT_OPTIONS$5;
	};
	/**
	* changeData
	*/
	Treemap$1.prototype.changeData = function(data$2) {
		var _a$5 = this.options, colorField = _a$5.colorField, interactions = _a$5.interactions, hierarchyConfig = _a$5.hierarchyConfig;
		this.updateOption({ data: data$2 });
		var transData = transformData$1({
			data: data$2,
			colorField,
			enableDrillDown: enableInteraction(interactions, "treemap-drill-down"),
			hierarchyConfig
		});
		this.chart.changeData(transData);
		resetDrillDown(this.chart);
	};
	/**
	* 获取 矩阵树图 默认配置
	*/
	Treemap$1.prototype.getDefaultOptions = function() {
		return Treemap$1.getDefaultOptions();
	};
	Treemap$1.prototype.getSchemaAdaptor = function() {
		return adaptor$4;
	};
	return Treemap$1;
}(Plot);

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/venn/constant.js
var ID_FIELD = "id";
var PATH_FIELD = "path";
/**
* 韦恩图 默认配置项
*/
var DEFAULT_OPTIONS$4 = {
	appendPadding: [
		10,
		0,
		20,
		0
	],
	blendMode: "multiply",
	tooltip: {
		showTitle: false,
		showMarkers: false,
		fields: ["id", "size"],
		formatter: function(datum) {
			return {
				name: datum.id,
				value: datum.size
			};
		}
	},
	legend: { position: "top-left" },
	label: { style: {
		textAlign: "center",
		fill: "#fff"
	} },
	interactions: [{
		type: "legend-filter",
		enable: false
	}],
	state: {
		active: { style: { stroke: "#000" } },
		selected: { style: {
			stroke: "#000",
			lineWidth: 2
		} },
		inactive: { style: {
			fillOpacity: .3,
			strokeOpacity: .3
		} }
	},
	defaultInteractions: ["tooltip", "venn-legend-active"]
};

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/venn/interactions/util.js
/** tofront: 同步所有元素的位置  */
function placeElementsOrdered(view) {
	if (!view) return;
	view.geometries[0].elements.forEach(function(elem) {
		elem.shape.toFront();
	});
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/venn/interactions/actions/active.js
var VennElementActive = function(_super) {
	__extends(VennElementActive$1, _super);
	function VennElementActive$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	/**
	* 同步所有元素的位置
	*/
	VennElementActive$1.prototype.syncElementsPos = function() {
		placeElementsOrdered(this.context.view);
	};
	/** 激活图形元素 */
	VennElementActive$1.prototype.active = function() {
		_super.prototype.active.call(this);
		this.syncElementsPos();
	};
	/** toggle 图形元素激活状态 */
	VennElementActive$1.prototype.toggle = function() {
		_super.prototype.toggle.call(this);
		this.syncElementsPos();
	};
	/** 重置 */
	VennElementActive$1.prototype.reset = function() {
		_super.prototype.reset.call(this);
		this.syncElementsPos();
	};
	return VennElementActive$1;
}(getActionClass("element-active"));

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/venn/interactions/actions/highlight.js
var VennElementHighlight = function(_super) {
	__extends(VennElementHighlight$1, _super);
	function VennElementHighlight$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	/**
	* 同步所有元素的位置
	*/
	VennElementHighlight$1.prototype.syncElementsPos = function() {
		placeElementsOrdered(this.context.view);
	};
	/** 高亮图形元素 */
	VennElementHighlight$1.prototype.highlight = function() {
		_super.prototype.highlight.call(this);
		this.syncElementsPos();
	};
	/** toggle 图形元素高亮状态 */
	VennElementHighlight$1.prototype.toggle = function() {
		_super.prototype.toggle.call(this);
		this.syncElementsPos();
	};
	/** 清楚 */
	VennElementHighlight$1.prototype.clear = function() {
		_super.prototype.clear.call(this);
		this.syncElementsPos();
	};
	/** 重置 */
	VennElementHighlight$1.prototype.reset = function() {
		_super.prototype.reset.call(this);
		this.syncElementsPos();
	};
	return VennElementHighlight$1;
}(getActionClass("element-highlight"));

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/venn/interactions/actions/selected.js
var ElementSelectedAction = getActionClass("element-selected");
var ElementSingleSelectedAction = getActionClass("element-single-selected");
/**
* 韦恩图元素 多选交互
*/
var VennElementSelected = function(_super) {
	__extends(VennElementSelected$1, _super);
	function VennElementSelected$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	/**
	* 同步所有元素的位置
	*/
	VennElementSelected$1.prototype.syncElementsPos = function() {
		placeElementsOrdered(this.context.view);
	};
	/** 激活图形元素 */
	VennElementSelected$1.prototype.selected = function() {
		_super.prototype.selected.call(this);
		this.syncElementsPos();
	};
	/** toggle 图形元素激活状态 */
	VennElementSelected$1.prototype.toggle = function() {
		_super.prototype.toggle.call(this);
		this.syncElementsPos();
	};
	/** 重置 */
	VennElementSelected$1.prototype.reset = function() {
		_super.prototype.reset.call(this);
		this.syncElementsPos();
	};
	return VennElementSelected$1;
}(ElementSelectedAction);
/**
* 韦恩图元素 单选交互
*/
var VennElementSingleSelected = function(_super) {
	__extends(VennElementSingleSelected$1, _super);
	function VennElementSingleSelected$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	/**
	* 同步所有元素的位置
	*/
	VennElementSingleSelected$1.prototype.syncElementsPos = function() {
		placeElementsOrdered(this.context.view);
	};
	/** 激活图形元素 */
	VennElementSingleSelected$1.prototype.selected = function() {
		_super.prototype.selected.call(this);
		this.syncElementsPos();
	};
	/** toggle 图形元素激活状态 */
	VennElementSingleSelected$1.prototype.toggle = function() {
		_super.prototype.toggle.call(this);
		this.syncElementsPos();
	};
	/** 重置 */
	VennElementSingleSelected$1.prototype.reset = function() {
		_super.prototype.reset.call(this);
		this.syncElementsPos();
	};
	return VennElementSingleSelected$1;
}(ElementSingleSelectedAction);

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/venn/interactions/index.js
/** ================== 注册交互反馈 aciton ================== */
registerAction("venn-element-active", VennElementActive);
registerAction("venn-element-highlight", VennElementHighlight);
registerAction("venn-element-selected", VennElementSelected);
registerAction("venn-element-single-selected", VennElementSingleSelected);
/** ================== 注册交互 ================== */
registerInteraction("venn-element-active", {
	start: [{
		trigger: "element:mouseenter",
		action: "venn-element-active:active"
	}],
	end: [{
		trigger: "element:mouseleave",
		action: "venn-element-active:reset"
	}]
});
registerInteraction("venn-element-highlight", {
	start: [{
		trigger: "element:mouseenter",
		action: "venn-element-highlight:highlight"
	}],
	end: [{
		trigger: "element:mouseleave",
		action: "venn-element-highlight:reset"
	}]
});
registerInteraction("venn-element-selected", {
	start: [{
		trigger: "element:click",
		action: "venn-element-selected:toggle"
	}],
	rollback: [{
		trigger: "dblclick",
		action: ["venn-element-selected:reset"]
	}]
});
registerInteraction("venn-element-single-selected", {
	start: [{
		trigger: "element:click",
		action: "venn-element-single-selected:toggle"
	}],
	rollback: [{
		trigger: "dblclick",
		action: ["venn-element-single-selected:reset"]
	}]
});
registerInteraction("venn-legend-active", {
	start: [{
		trigger: "legend-item:mouseenter",
		action: ["list-active:active", "venn-element-active:active"]
	}],
	end: [{
		trigger: "legend-item:mouseleave",
		action: ["list-active:reset", "venn-element-active:reset"]
	}]
});
registerInteraction("venn-legend-highlight", {
	start: [{
		trigger: "legend-item:mouseenter",
		action: ["legend-item-highlight:highlight", "venn-element-highlight:highlight"]
	}],
	end: [{
		trigger: "legend-item:mouseleave",
		action: ["legend-item-highlight:reset", "venn-element-highlight:reset"]
	}]
});

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/venn/label.js
var VennLabel = function(_super) {
	__extends(VennLabel$1, _super);
	function VennLabel$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	/**
	* 获取每个 label 的位置
	* @param labelCfg
	* @param mappingData
	* @param index
	* @returns label point
	*/
	VennLabel$1.prototype.getLabelPoint = function(labelCfg, mappingData, index) {
		var _a$5 = labelCfg.data, x = _a$5.x, y = _a$5.y;
		var _b = labelCfg.customLabelInfo, offsetX = _b.offsetX, offsetY = _b.offsetY;
		return {
			content: labelCfg.content[index],
			x: x + offsetX,
			y: y + offsetY
		};
	};
	return VennLabel$1;
}(base_default);
registerGeometryLabel("venn", VennLabel);

//#endregion
//#region node_modules/@antv/path-util/esm/parse-path-string.js
var SPACES = "	\n\v\f\r \xA0 ᠎             　\u2028\u2029";
var PATH_COMMAND = new RegExp("([a-z])[" + SPACES + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + SPACES + "]*,?[" + SPACES + "]*)+)", "ig");
var PATH_VALUES = new RegExp("(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[" + SPACES + "]*,?[" + SPACES + "]*", "ig");
function parsePathString(pathString) {
	if (!pathString) return null;
	if (isArray_default(pathString)) return pathString;
	var paramCounts = {
		a: 7,
		c: 6,
		o: 2,
		h: 1,
		l: 2,
		m: 2,
		r: 4,
		q: 4,
		s: 4,
		t: 2,
		v: 1,
		u: 3,
		z: 0
	};
	var data$2 = [];
	String(pathString).replace(PATH_COMMAND, function(a, b, c) {
		var params = [];
		var name = b.toLowerCase();
		c.replace(PATH_VALUES, function(a$1, b$1) {
			b$1 && params.push(+b$1);
		});
		if (name === "m" && params.length > 2) {
			data$2.push([b].concat(params.splice(0, 2)));
			name = "l";
			b = b === "m" ? "l" : "L";
		}
		if (name === "o" && params.length === 1) data$2.push([b, params[0]]);
		if (name === "r") data$2.push([b].concat(params));
		else while (params.length >= paramCounts[name]) {
			data$2.push([b].concat(params.splice(0, paramCounts[name])));
			if (!paramCounts[name]) break;
		}
		return "";
	});
	return data$2;
}

//#endregion
//#region node_modules/@antv/path-util/esm/process/arc-2-cubic.js
var TAU = Math.PI * 2;

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/venn/shape.js
/**
* 获取填充属性
* @param cfg 图形绘制数据
*/
function getFillAttrs$1(cfg) {
	return deepAssign({}, cfg.defaultStyle, { fill: cfg.color }, cfg.style);
}
registerShape("schema", "venn", {
	draw: function(cfg, container) {
		var data$2 = cfg.data;
		var segments = parsePathString(data$2[PATH_FIELD]);
		var fillAttrs = getFillAttrs$1(cfg);
		var group$1 = container.addGroup({ name: "venn-shape" });
		group$1.addShape("path", {
			attrs: __assign(__assign({}, fillAttrs), { path: segments }),
			name: "venn-path"
		});
		var _a$5 = cfg.customInfo, offsetX = _a$5.offsetX, offsetY = _a$5.offsetY;
		var matrix = Util.transform(null, [[
			"t",
			offsetX,
			offsetY
		]]);
		group$1.setMatrix(matrix);
		return group$1;
	},
	getMarker: function(markerCfg) {
		var color$2 = markerCfg.color;
		return {
			symbol: "circle",
			style: {
				lineWidth: 0,
				stroke: color$2,
				fill: color$2,
				r: 4
			}
		};
	}
});

//#endregion
//#region node_modules/@antv/g2plot/esm/utils/color/blend.js
var each = function(f) {
	return function(c0, c1) {
		var out = [];
		out[0] = f(c0[0], c1[0]);
		out[1] = f(c0[1], c1[1]);
		out[2] = f(c0[2], c1[2]);
		return out;
	};
};
/**
* 混合方法集合
*/
var blendObject = {
	normal: function(a) {
		return a;
	},
	multiply: function(a, b) {
		return a * b / 255;
	},
	screen: function(a, b) {
		return 255 * (1 - (1 - a / 255) * (1 - b / 255));
	},
	overlay: function(a, b) {
		return b < 128 ? 2 * a * b / 255 : 255 * (1 - 2 * (1 - a / 255) * (1 - b / 255));
	},
	darken: function(a, b) {
		return a > b ? b : a;
	},
	lighten: function(a, b) {
		return a > b ? a : b;
	},
	dodge: function(a, b) {
		if (a === 255) return 255;
		a = 255 * (b / 255) / (1 - a / 255);
		return a > 255 ? 255 : a;
	},
	burn: function(a, b) {
		if (b === 255) return 255;
		else if (a === 0) return 0;
		else return 255 * (1 - Math.min(1, (1 - b / 255) / (a / 255)));
	}
};
/**
* 获取混合方法
*/
var innerBlend = function(mode) {
	if (!blendObject[mode]) throw new Error("unknown blend mode " + mode);
	return blendObject[mode];
};
/**
* 混合颜色，并处理透明度情况
* 参考：https://www.w3.org/TR/compositing/#blending
* @param c0
* @param c1
* @param mode 混合模式
* @return rbga
*/
function blend(c0, c1, mode) {
	if (mode === void 0) mode = "normal";
	var blendRgbArr = each(innerBlend(mode))(colorToArr(c0), colorToArr(c1));
	var _a$5 = colorToArr(c0), r0 = _a$5[0], g0 = _a$5[1], b0$1 = _a$5[2], a0 = _a$5[3];
	var _b = colorToArr(c1), r1 = _b[0], g1 = _b[1], b1$1 = _b[2], a1 = _b[3];
	var a = Number((a0 + a1 * (1 - a0)).toFixed(2));
	var r = Math.round((a0 * (1 - a1) * (r0 / 255) + a0 * a1 * (blendRgbArr[0] / 255) + (1 - a0) * a1 * (r1 / 255)) / a * 255);
	var g = Math.round((a0 * (1 - a1) * (g0 / 255) + a0 * a1 * (blendRgbArr[1] / 255) + (1 - a0) * a1 * (g1 / 255)) / a * 255);
	var b = Math.round((a0 * (1 - a1) * (b0$1 / 255) + a0 * a1 * (blendRgbArr[2] / 255) + (1 - a0) * a1 * (b1$1 / 255)) / a * 255);
	return "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(a, ")");
}
/**
* 统一颜色输入的格式 [r, g, b, a]
* 参考：https://www.w3.org/TR/compositing/#blending
* @param c color
* @return [r, g, b, a]
*/
function colorToArr(c) {
	var color$2 = c.replace("/s+/g", "");
	var rgbaArr;
	if (typeof color$2 === "string" && !color$2.startsWith("rgba") && !color$2.startsWith("#")) return rgbaArr = esm_default.rgb2arr(esm_default.toRGB(color$2)).concat([1]);
	if (color$2.startsWith("rgba")) rgbaArr = color$2.replace("rgba(", "").replace(")", "").split(",");
	if (color$2.startsWith("#")) rgbaArr = esm_default.rgb2arr(color$2).concat([1]);
	return rgbaArr.map(function(item, index) {
		return index === 3 ? Number(item) : item | 0;
	});
}

//#endregion
//#region node_modules/fmin/src/bisect.js
/** finds the zeros of a function, given two starting points (which must
* have opposite signs */
function bisect(f, a, b, parameters) {
	parameters = parameters || {};
	var maxIterations = parameters.maxIterations || 100, tolerance$2 = parameters.tolerance || 1e-10, fA = f(a), fB = f(b), delta = b - a;
	if (fA * fB > 0) throw "Initial bisect points must have opposite signs";
	if (fA === 0) return a;
	if (fB === 0) return b;
	for (var i = 0; i < maxIterations; ++i) {
		delta /= 2;
		var mid$1 = a + delta, fMid = f(mid$1);
		if (fMid * fA >= 0) a = mid$1;
		if (Math.abs(delta) < tolerance$2 || fMid === 0) return mid$1;
	}
	return a + delta;
}

//#endregion
//#region node_modules/fmin/src/blas1.js
function zeros(x) {
	var r = new Array(x);
	for (var i = 0; i < x; ++i) r[i] = 0;
	return r;
}
function zerosM(x, y) {
	return zeros(x).map(function() {
		return zeros(y);
	});
}
function dot(a, b) {
	var ret = 0;
	for (var i = 0; i < a.length; ++i) ret += a[i] * b[i];
	return ret;
}
function norm2(a) {
	return Math.sqrt(dot(a, a));
}
function scale$1(ret, value$1, c) {
	for (var i = 0; i < value$1.length; ++i) ret[i] = value$1[i] * c;
}
function weightedSum(ret, w1, v1, w2, v2) {
	for (var j = 0; j < ret.length; ++j) ret[j] = w1 * v1[j] + w2 * v2[j];
}

//#endregion
//#region node_modules/fmin/src/nelderMead.js
/** minimizes a function using the downhill simplex method */
function nelderMead(f, x0, parameters) {
	parameters = parameters || {};
	var maxIterations = parameters.maxIterations || x0.length * 200, nonZeroDelta = parameters.nonZeroDelta || 1.05, zeroDelta = parameters.zeroDelta || .001, minErrorDelta = parameters.minErrorDelta || 1e-6, minTolerance = parameters.minErrorDelta || 1e-5, rho = parameters.rho !== void 0 ? parameters.rho : 1, chi = parameters.chi !== void 0 ? parameters.chi : 2, psi = parameters.psi !== void 0 ? parameters.psi : -.5, sigma = parameters.sigma !== void 0 ? parameters.sigma : .5, maxDiff;
	var N = x0.length, simplex = new Array(N + 1);
	simplex[0] = x0;
	simplex[0].fx = f(x0);
	simplex[0].id = 0;
	for (var i = 0; i < N; ++i) {
		var point$1 = x0.slice();
		point$1[i] = point$1[i] ? point$1[i] * nonZeroDelta : zeroDelta;
		simplex[i + 1] = point$1;
		simplex[i + 1].fx = f(point$1);
		simplex[i + 1].id = i + 1;
	}
	function updateSimplex(value$1) {
		for (var i$1 = 0; i$1 < value$1.length; i$1++) simplex[N][i$1] = value$1[i$1];
		simplex[N].fx = value$1.fx;
	}
	var sortOrder = function(a, b) {
		return a.fx - b.fx;
	};
	var centroid = x0.slice(), reflected = x0.slice(), contracted = x0.slice(), expanded = x0.slice();
	for (var iteration = 0; iteration < maxIterations; ++iteration) {
		simplex.sort(sortOrder);
		if (parameters.history) {
			var sortedSimplex = simplex.map(function(x) {
				var state$1 = x.slice();
				state$1.fx = x.fx;
				state$1.id = x.id;
				return state$1;
			});
			sortedSimplex.sort(function(a, b) {
				return a.id - b.id;
			});
			parameters.history.push({
				x: simplex[0].slice(),
				fx: simplex[0].fx,
				simplex: sortedSimplex
			});
		}
		maxDiff = 0;
		for (i = 0; i < N; ++i) maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i] - simplex[1][i]));
		if (Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta && maxDiff < minTolerance) break;
		for (i = 0; i < N; ++i) {
			centroid[i] = 0;
			for (var j = 0; j < N; ++j) centroid[i] += simplex[j][i];
			centroid[i] /= N;
		}
		var worst = simplex[N];
		weightedSum(reflected, 1 + rho, centroid, -rho, worst);
		reflected.fx = f(reflected);
		if (reflected.fx < simplex[0].fx) {
			weightedSum(expanded, 1 + chi, centroid, -chi, worst);
			expanded.fx = f(expanded);
			if (expanded.fx < reflected.fx) updateSimplex(expanded);
			else updateSimplex(reflected);
		} else if (reflected.fx >= simplex[N - 1].fx) {
			var shouldReduce = false;
			if (reflected.fx > worst.fx) {
				weightedSum(contracted, 1 + psi, centroid, -psi, worst);
				contracted.fx = f(contracted);
				if (contracted.fx < worst.fx) updateSimplex(contracted);
				else shouldReduce = true;
			} else {
				weightedSum(contracted, 1 - psi * rho, centroid, psi * rho, worst);
				contracted.fx = f(contracted);
				if (contracted.fx < reflected.fx) updateSimplex(contracted);
				else shouldReduce = true;
			}
			if (shouldReduce) {
				if (sigma >= 1) break;
				for (i = 1; i < simplex.length; ++i) {
					weightedSum(simplex[i], 1 - sigma, simplex[0], sigma, simplex[i]);
					simplex[i].fx = f(simplex[i]);
				}
			}
		} else updateSimplex(reflected);
	}
	simplex.sort(sortOrder);
	return {
		fx: simplex[0].fx,
		x: simplex[0]
	};
}

//#endregion
//#region node_modules/fmin/src/linesearch.js
function wolfeLineSearch(f, pk, current, next, a, c1, c2) {
	var phi0 = current.fx, phiPrime0 = dot(current.fxprime, pk), phi$1 = phi0, phi_old = phi0, phiPrime = phiPrime0, a0 = 0;
	a = a || 1;
	c1 = c1 || 1e-6;
	c2 = c2 || .1;
	function zoom$1(a_lo, a_high, phi_lo) {
		for (var iteration$1 = 0; iteration$1 < 16; ++iteration$1) {
			a = (a_lo + a_high) / 2;
			weightedSum(next.x, 1, current.x, a, pk);
			phi$1 = next.fx = f(next.x, next.fxprime);
			phiPrime = dot(next.fxprime, pk);
			if (phi$1 > phi0 + c1 * a * phiPrime0 || phi$1 >= phi_lo) a_high = a;
			else {
				if (Math.abs(phiPrime) <= -c2 * phiPrime0) return a;
				if (phiPrime * (a_high - a_lo) >= 0) a_high = a_lo;
				a_lo = a;
				phi_lo = phi$1;
			}
		}
		return 0;
	}
	for (var iteration = 0; iteration < 10; ++iteration) {
		weightedSum(next.x, 1, current.x, a, pk);
		phi$1 = next.fx = f(next.x, next.fxprime);
		phiPrime = dot(next.fxprime, pk);
		if (phi$1 > phi0 + c1 * a * phiPrime0 || iteration && phi$1 >= phi_old) return zoom$1(a0, a, phi_old);
		if (Math.abs(phiPrime) <= -c2 * phiPrime0) return a;
		if (phiPrime >= 0) return zoom$1(a, a0, phi$1);
		phi_old = phi$1;
		a0 = a;
		a *= 2;
	}
	return a;
}

//#endregion
//#region node_modules/fmin/src/conjugateGradient.js
function conjugateGradient(f, initial, params) {
	var current = {
		x: initial.slice(),
		fx: 0,
		fxprime: initial.slice()
	}, next = {
		x: initial.slice(),
		fx: 0,
		fxprime: initial.slice()
	}, yk = initial.slice(), pk, temp, a = 1, maxIterations;
	params = params || {};
	maxIterations = params.maxIterations || initial.length * 20;
	current.fx = f(current.x, current.fxprime);
	pk = current.fxprime.slice();
	scale$1(pk, current.fxprime, -1);
	for (var i = 0; i < maxIterations; ++i) {
		a = wolfeLineSearch(f, pk, current, next, a);
		if (params.history) params.history.push({
			x: current.x.slice(),
			fx: current.fx,
			fxprime: current.fxprime.slice(),
			alpha: a
		});
		if (!a) scale$1(pk, current.fxprime, -1);
		else {
			weightedSum(yk, 1, next.fxprime, -1, current.fxprime);
			var delta_k = dot(current.fxprime, current.fxprime), beta_k = Math.max(0, dot(yk, next.fxprime) / delta_k);
			weightedSum(pk, beta_k, pk, -1, next.fxprime);
			temp = current;
			current = next;
			next = temp;
		}
		if (norm2(current.fxprime) <= 1e-5) break;
	}
	if (params.history) params.history.push({
		x: current.x.slice(),
		fx: current.fx,
		fxprime: current.fxprime.slice(),
		alpha: a
	});
	return current;
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/venn/layout/circleintersection.js
var SMALL$1 = 1e-10;
/** Returns the intersection area of a bunch of circles (where each circle
is an object having an x,y and radius property) */
function intersectionArea(circles, stats) {
	var intersectionPoints = getIntersectionPoints(circles);
	var innerPoints = intersectionPoints.filter(function(p$1) {
		return containedInCircles(p$1, circles);
	});
	var arcArea = 0, polygonArea = 0, i;
	var arcs = [];
	if (innerPoints.length > 1) {
		var center$1 = getCenter(innerPoints);
		for (i = 0; i < innerPoints.length; ++i) {
			var p = innerPoints[i];
			p.angle = Math.atan2(p.x - center$1.x, p.y - center$1.y);
		}
		innerPoints.sort(function(a$1, b) {
			return b.angle - a$1.angle;
		});
		var p2 = innerPoints[innerPoints.length - 1];
		for (i = 0; i < innerPoints.length; ++i) {
			var p1 = innerPoints[i];
			polygonArea += (p2.x + p1.x) * (p1.y - p2.y);
			var midPoint = {
				x: (p1.x + p2.x) / 2,
				y: (p1.y + p2.y) / 2
			};
			var arc$1 = null;
			for (var j = 0; j < p1.parentIndex.length; ++j) if (p2.parentIndex.indexOf(p1.parentIndex[j]) > -1) {
				var circle$1 = circles[p1.parentIndex[j]], a1 = Math.atan2(p1.x - circle$1.x, p1.y - circle$1.y), a2 = Math.atan2(p2.x - circle$1.x, p2.y - circle$1.y);
				var angleDiff = a2 - a1;
				if (angleDiff < 0) angleDiff += 2 * Math.PI;
				var a = a2 - angleDiff / 2;
				var width = distance(midPoint, {
					x: circle$1.x + circle$1.radius * Math.sin(a),
					y: circle$1.y + circle$1.radius * Math.cos(a)
				});
				if (width > circle$1.radius * 2) width = circle$1.radius * 2;
				if (arc$1 === null || arc$1.width > width) arc$1 = {
					circle: circle$1,
					width,
					p1,
					p2
				};
			}
			if (arc$1 !== null) {
				arcs.push(arc$1);
				arcArea += circleArea(arc$1.circle.radius, arc$1.width);
				p2 = p1;
			}
		}
	} else {
		var smallest = circles[0];
		for (i = 1; i < circles.length; ++i) if (circles[i].radius < smallest.radius) smallest = circles[i];
		var disjoint = false;
		for (i = 0; i < circles.length; ++i) if (distance(circles[i], smallest) > Math.abs(smallest.radius - circles[i].radius)) {
			disjoint = true;
			break;
		}
		if (disjoint) arcArea = polygonArea = 0;
		else {
			arcArea = smallest.radius * smallest.radius * Math.PI;
			arcs.push({
				circle: smallest,
				p1: {
					x: smallest.x,
					y: smallest.y + smallest.radius
				},
				p2: {
					x: smallest.x - SMALL$1,
					y: smallest.y + smallest.radius
				},
				width: smallest.radius * 2
			});
		}
	}
	polygonArea /= 2;
	if (stats) {
		stats.area = arcArea + polygonArea;
		stats.arcArea = arcArea;
		stats.polygonArea = polygonArea;
		stats.arcs = arcs;
		stats.innerPoints = innerPoints;
		stats.intersectionPoints = intersectionPoints;
	}
	return arcArea + polygonArea;
}
/** returns whether a point is contained by all of a list of circles */
function containedInCircles(point$1, circles) {
	for (var i = 0; i < circles.length; ++i) if (distance(point$1, circles[i]) > circles[i].radius + SMALL$1) return false;
	return true;
}
/** Gets all intersection points between a bunch of circles */
function getIntersectionPoints(circles) {
	var ret = [];
	for (var i = 0; i < circles.length; ++i) for (var j = i + 1; j < circles.length; ++j) {
		var intersect$2 = circleCircleIntersection(circles[i], circles[j]);
		for (var k = 0; k < intersect$2.length; ++k) {
			var p = intersect$2[k];
			p.parentIndex = [i, j];
			ret.push(p);
		}
	}
	return ret;
}
/** Circular segment area calculation. See http://mathworld.wolfram.com/CircularSegment.html */
function circleArea(r, width) {
	return r * r * Math.acos(1 - width / r) - (r - width) * Math.sqrt(width * (2 * r - width));
}
/** euclidean distance between two points */
function distance(p1, p2) {
	return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));
}
/** Returns the overlap area of two circles of radius r1 and r2 - that
have their centers separated by distance d. Simpler faster
circle intersection for only two circles */
function circleOverlap(r1, r2, d) {
	if (d >= r1 + r2) return 0;
	if (d <= Math.abs(r1 - r2)) return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);
	var w1 = r1 - (d * d - r2 * r2 + r1 * r1) / (2 * d), w2 = r2 - (d * d - r1 * r1 + r2 * r2) / (2 * d);
	return circleArea(r1, w1) + circleArea(r2, w2);
}
/** Given two circles (containing a x/y/radius attributes),
returns the intersecting points if possible.
note: doesn't handle cases where there are infinitely many
intersection points (circles are equivalent):, or only one intersection point*/
function circleCircleIntersection(p1, p2) {
	var d = distance(p1, p2), r1 = p1.radius, r2 = p2.radius;
	if (d >= r1 + r2 || d <= Math.abs(r1 - r2)) return [];
	var a = (r1 * r1 - r2 * r2 + d * d) / (2 * d), h = Math.sqrt(r1 * r1 - a * a), x0 = p1.x + a * (p2.x - p1.x) / d, y0 = p1.y + a * (p2.y - p1.y) / d, rx = -(p2.y - p1.y) * (h / d), ry = -(p2.x - p1.x) * (h / d);
	return [{
		x: x0 + rx,
		y: y0 - ry
	}, {
		x: x0 - rx,
		y: y0 + ry
	}];
}
/** Returns the center of a bunch of points */
function getCenter(points) {
	var center$1 = {
		x: 0,
		y: 0
	};
	for (var i = 0; i < points.length; ++i) {
		center$1.x += points[i].x;
		center$1.y += points[i].y;
	}
	center$1.x /= points.length;
	center$1.y /= points.length;
	return center$1;
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/venn/layout/diagram.js
function circleMargin(current, interior, exterior) {
	var margin = interior[0].radius - distance(interior[0], current), i, m;
	for (i = 1; i < interior.length; ++i) {
		m = interior[i].radius - distance(interior[i], current);
		if (m <= margin) margin = m;
	}
	for (i = 0; i < exterior.length; ++i) {
		m = distance(exterior[i], current) - exterior[i].radius;
		if (m <= margin) margin = m;
	}
	return margin;
}
function computeTextCentre(interior, exterior) {
	var points = [];
	var i;
	for (i = 0; i < interior.length; ++i) {
		var c = interior[i];
		points.push({
			x: c.x,
			y: c.y
		});
		points.push({
			x: c.x + c.radius / 2,
			y: c.y
		});
		points.push({
			x: c.x - c.radius / 2,
			y: c.y
		});
		points.push({
			x: c.x,
			y: c.y + c.radius / 2
		});
		points.push({
			x: c.x,
			y: c.y - c.radius / 2
		});
	}
	var initial = points[0], margin = circleMargin(points[0], interior, exterior);
	for (i = 1; i < points.length; ++i) {
		var m = circleMargin(points[i], interior, exterior);
		if (m >= margin) {
			initial = points[i];
			margin = m;
		}
	}
	var solution = nelderMead(function(p) {
		return -1 * circleMargin({
			x: p[0],
			y: p[1]
		}, interior, exterior);
	}, [initial.x, initial.y], {
		maxIterations: 500,
		minErrorDelta: 1e-10
	}).x;
	var ret = {
		x: solution[0],
		y: solution[1]
	};
	var valid = true;
	for (i = 0; i < interior.length; ++i) if (distance(ret, interior[i]) > interior[i].radius) {
		valid = false;
		break;
	}
	for (i = 0; i < exterior.length; ++i) if (distance(ret, exterior[i]) < exterior[i].radius) {
		valid = false;
		break;
	}
	if (!valid) if (interior.length == 1) ret = {
		x: interior[0].x,
		y: interior[0].y
	};
	else {
		var areaStats = {};
		intersectionArea(interior, areaStats);
		if (areaStats.arcs.length === 0) ret = {
			x: 0,
			y: -1e3,
			disjoint: true
		};
		else if (areaStats.arcs.length == 1) ret = {
			x: areaStats.arcs[0].circle.x,
			y: areaStats.arcs[0].circle.y
		};
		else if (exterior.length) ret = computeTextCentre(interior, []);
		else ret = getCenter(areaStats.arcs.map(function(a) {
			return a.p1;
		}));
	}
	return ret;
}
function getOverlappingCircles(circles) {
	var ret = {}, circleids = [];
	for (var circleid in circles) {
		circleids.push(circleid);
		ret[circleid] = [];
	}
	for (var i = 0; i < circleids.length; i++) {
		var a = circles[circleids[i]];
		for (var j = i + 1; j < circleids.length; ++j) {
			var b = circles[circleids[j]], d = distance(a, b);
			if (d + b.radius <= a.radius + 1e-10) ret[circleids[j]].push(circleids[i]);
			else if (d + a.radius <= b.radius + 1e-10) ret[circleids[i]].push(circleids[j]);
		}
	}
	return ret;
}
function computeTextCentres(circles, areas) {
	var ret = {}, overlapped = getOverlappingCircles(circles);
	for (var i = 0; i < areas.length; ++i) {
		var area$1 = areas[i].sets, areaids = {}, exclude = {};
		for (var j = 0; j < area$1.length; ++j) {
			areaids[area$1[j]] = true;
			var overlaps = overlapped[area$1[j]];
			for (var k = 0; k < overlaps.length; ++k) exclude[overlaps[k]] = true;
		}
		var interior = [], exterior = [];
		for (var setid in circles) if (setid in areaids) interior.push(circles[setid]);
		else if (!(setid in exclude)) exterior.push(circles[setid]);
		var centre = computeTextCentre(interior, exterior);
		ret[area$1] = centre;
		if (centre.disjoint && areas[i].size > 0) console.log("WARNING: area " + area$1 + " not represented on screen");
	}
	return ret;
}
/**
* 根据圆心(x, y) 半径 r 返回圆的绘制 path
* @param x 圆心点 x
* @param y 圆心点 y
* @param r 圆的半径
* @returns 圆的 path
*/
function circlePath(x, y, r) {
	var ret = [];
	var x0 = x - r;
	var y0 = y;
	ret.push("M", x0, y0);
	ret.push("A", r, r, 0, 1, 0, x0 + 2 * r, y0);
	ret.push("A", r, r, 0, 1, 0, x0, y0);
	return ret.join(" ");
}
/** returns a svg path of the intersection area of a bunch of circles */
function intersectionAreaPath(circles) {
	var stats = {};
	intersectionArea(circles, stats);
	var arcs = stats.arcs;
	if (arcs.length === 0) return "M 0 0";
	else if (arcs.length == 1) {
		var circle$1 = arcs[0].circle;
		return circlePath(circle$1.x, circle$1.y, circle$1.radius);
	} else {
		var ret = [
			"\nM",
			arcs[0].p2.x,
			arcs[0].p2.y
		];
		for (var i = 0; i < arcs.length; ++i) {
			var arc$1 = arcs[i], r = arc$1.circle.radius, wide = arc$1.width > r;
			ret.push("\nA", r, r, 0, wide ? 1 : 0, 1, arc$1.p1.x, arc$1.p1.y);
		}
		return ret.join(" ");
	}
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/venn/layout/layout.js
/** given a list of set objects, and their corresponding overlaps.
updates the (x, y, radius) attribute on each set such that their positions
roughly correspond to the desired overlaps */
function venn(areas, parameters) {
	parameters = parameters || {};
	parameters.maxIterations = parameters.maxIterations || 500;
	var initialLayout = parameters.initialLayout || bestInitialLayout;
	var loss = parameters.lossFunction || lossFunction;
	areas = addMissingAreas(areas);
	var circles = initialLayout(areas, parameters);
	var initial = [], setids = [];
	var setid;
	for (setid in circles) if (circles.hasOwnProperty(setid)) {
		initial.push(circles[setid].x);
		initial.push(circles[setid].y);
		setids.push(setid);
	}
	var positions = nelderMead(function(values$1) {
		var current = {};
		for (var i$1 = 0; i$1 < setids.length; ++i$1) {
			var setid_1 = setids[i$1];
			current[setid_1] = {
				x: values$1[2 * i$1],
				y: values$1[2 * i$1 + 1],
				radius: circles[setid_1].radius
			};
		}
		return loss(current, areas);
	}, initial, parameters).x;
	for (var i = 0; i < setids.length; ++i) {
		setid = setids[i];
		circles[setid].x = positions[2 * i];
		circles[setid].y = positions[2 * i + 1];
	}
	return circles;
}
var SMALL = 1e-10;
/** Returns the distance necessary for two circles of radius r1 + r2 to
have the overlap area 'overlap' */
function distanceFromIntersectArea(r1, r2, overlap$1) {
	if (Math.min(r1, r2) * Math.min(r1, r2) * Math.PI <= overlap$1 + SMALL) return Math.abs(r1 - r2);
	return bisect(function(distance$7) {
		return circleOverlap(r1, r2, distance$7) - overlap$1;
	}, 0, r1 + r2);
}
/** Missing pair-wise intersection area data can cause problems:
treating as an unknown means that sets will be laid out overlapping,
which isn't what people expect. To reflect that we want disjoint sets
here, set the overlap to 0 for all missing pairwise set intersections */
function addMissingAreas(areas) {
	areas = areas.slice();
	var ids = [], pairs = {};
	var i, j, a, b;
	for (i = 0; i < areas.length; ++i) {
		var area$1 = areas[i];
		if (area$1.sets.length == 1) ids.push(area$1.sets[0]);
		else if (area$1.sets.length == 2) {
			a = area$1.sets[0];
			b = area$1.sets[1];
			pairs[[a, b]] = true;
			pairs[[b, a]] = true;
		}
	}
	ids.sort(function(a$1, b$1) {
		return a$1 > b$1 ? 1 : -1;
	});
	for (i = 0; i < ids.length; ++i) {
		a = ids[i];
		for (j = i + 1; j < ids.length; ++j) {
			b = ids[j];
			if (!([a, b] in pairs)) areas.push({
				sets: [a, b],
				size: 0
			});
		}
	}
	return areas;
}
function getDistanceMatrices(areas, sets, setids) {
	var distances = zerosM(sets.length, sets.length), constraints = zerosM(sets.length, sets.length);
	areas.filter(function(x) {
		return x.sets.length == 2;
	}).map(function(current) {
		var left$1 = setids[current.sets[0]], right$1 = setids[current.sets[1]], r1 = Math.sqrt(sets[left$1].size / Math.PI), r2 = Math.sqrt(sets[right$1].size / Math.PI), distance$7 = distanceFromIntersectArea(r1, r2, current.size);
		distances[left$1][right$1] = distances[right$1][left$1] = distance$7;
		var c = 0;
		if (current.size + 1e-10 >= Math.min(sets[left$1].size, sets[right$1].size)) c = 1;
		else if (current.size <= 1e-10) c = -1;
		constraints[left$1][right$1] = constraints[right$1][left$1] = c;
	});
	return {
		distances,
		constraints
	};
}
function constrainedMDSGradient(x, fxprime, distances, constraints) {
	var loss = 0, i;
	for (i = 0; i < fxprime.length; ++i) fxprime[i] = 0;
	for (i = 0; i < distances.length; ++i) {
		var xi = x[2 * i], yi = x[2 * i + 1];
		for (var j = i + 1; j < distances.length; ++j) {
			var xj = x[2 * j], yj = x[2 * j + 1], dij = distances[i][j], constraint = constraints[i][j];
			var squaredDistance = (xj - xi) * (xj - xi) + (yj - yi) * (yj - yi), distance_1 = Math.sqrt(squaredDistance), delta = squaredDistance - dij * dij;
			if (constraint > 0 && distance_1 <= dij || constraint < 0 && distance_1 >= dij) continue;
			loss += 2 * delta * delta;
			fxprime[2 * i] += 4 * delta * (xi - xj);
			fxprime[2 * i + 1] += 4 * delta * (yi - yj);
			fxprime[2 * j] += 4 * delta * (xj - xi);
			fxprime[2 * j + 1] += 4 * delta * (yj - yi);
		}
	}
	return loss;
}
function bestInitialLayout(areas, params) {
	var initial = greedyLayout(areas, params);
	var loss = params.lossFunction || lossFunction;
	if (areas.length >= 8) {
		var constrained = constrainedMDSLayout(areas, params), constrainedLoss = loss(constrained, areas), greedyLoss = loss(initial, areas);
		if (constrainedLoss + 1e-8 < greedyLoss) initial = constrained;
	}
	return initial;
}
function constrainedMDSLayout(areas, params) {
	params = params || {};
	var restarts = params.restarts || 10;
	var sets = [], setids = {};
	var i;
	for (i = 0; i < areas.length; ++i) {
		var area$1 = areas[i];
		if (area$1.sets.length == 1) {
			setids[area$1.sets[0]] = sets.length;
			sets.push(area$1);
		}
	}
	var matrices = getDistanceMatrices(areas, sets, setids);
	var distances = matrices.distances;
	var constraints = matrices.constraints;
	var norm = norm2(distances.map(norm2)) / distances.length;
	distances = distances.map(function(row) {
		return row.map(function(value$1) {
			return value$1 / norm;
		});
	});
	var obj = function(x, fxprime) {
		return constrainedMDSGradient(x, fxprime, distances, constraints);
	};
	var best, current;
	for (i = 0; i < restarts; ++i) {
		var initial = zeros(distances.length * 2).map(Math.random);
		current = conjugateGradient(obj, initial, params);
		if (!best || current.fx < best.fx) best = current;
	}
	var positions = best.x;
	var circles = {};
	for (i = 0; i < sets.length; ++i) {
		var set = sets[i];
		circles[set.sets[0]] = {
			x: positions[2 * i] * norm,
			y: positions[2 * i + 1] * norm,
			radius: Math.sqrt(set.size / Math.PI)
		};
	}
	if (params.history) for (i = 0; i < params.history.length; ++i) scale$1(params.history[i].x, norm);
	return circles;
}
/** Lays out a Venn diagram greedily, going from most overlapped sets to
least overlapped, attempting to position each new set such that the
overlapping areas to already positioned sets are basically right */
function greedyLayout(areas, params) {
	var loss = params && params.lossFunction ? params.lossFunction : lossFunction;
	var circles = {}, setOverlaps = {};
	var set;
	for (var i = 0; i < areas.length; ++i) {
		var area$1 = areas[i];
		if (area$1.sets.length == 1) {
			set = area$1.sets[0];
			circles[set] = {
				x: 1e10,
				y: 1e10,
				rowid: Object.keys(circles).length,
				size: area$1.size,
				radius: Math.sqrt(area$1.size / Math.PI)
			};
			setOverlaps[set] = [];
		}
	}
	areas = areas.filter(function(a) {
		return a.sets.length == 2;
	});
	for (var i = 0; i < areas.length; ++i) {
		var current = areas[i];
		var weight = current.hasOwnProperty("weight") ? current.weight : 1;
		var left$1 = current.sets[0], right$1 = current.sets[1];
		if (current.size + SMALL >= Math.min(circles[left$1].size, circles[right$1].size)) weight = 0;
		setOverlaps[left$1].push({
			set: right$1,
			size: current.size,
			weight
		});
		setOverlaps[right$1].push({
			set: left$1,
			size: current.size,
			weight
		});
	}
	var mostOverlapped = [];
	for (set in setOverlaps) if (setOverlaps.hasOwnProperty(set)) {
		var size$1 = 0;
		for (var i = 0; i < setOverlaps[set].length; ++i) size$1 += setOverlaps[set][i].size * setOverlaps[set][i].weight;
		mostOverlapped.push({
			set,
			size: size$1
		});
	}
	function sortOrder(a, b) {
		return b.size - a.size;
	}
	mostOverlapped.sort(sortOrder);
	var positioned = {};
	function isPositioned(element) {
		return element.set in positioned;
	}
	function positionSet(point$1, index) {
		circles[index].x = point$1.x;
		circles[index].y = point$1.y;
		positioned[index] = true;
	}
	positionSet({
		x: 0,
		y: 0
	}, mostOverlapped[0].set);
	for (var i = 1; i < mostOverlapped.length; ++i) {
		var setIndex = mostOverlapped[i].set, overlap$1 = setOverlaps[setIndex].filter(isPositioned);
		set = circles[setIndex];
		overlap$1.sort(sortOrder);
		if (overlap$1.length === 0) throw "ERROR: missing pairwise overlap information";
		var points = [];
		for (var j = 0; j < overlap$1.length; ++j) {
			var p1 = circles[overlap$1[j].set], d1 = distanceFromIntersectArea(set.radius, p1.radius, overlap$1[j].size);
			points.push({
				x: p1.x + d1,
				y: p1.y
			});
			points.push({
				x: p1.x - d1,
				y: p1.y
			});
			points.push({
				y: p1.y + d1,
				x: p1.x
			});
			points.push({
				y: p1.y - d1,
				x: p1.x
			});
			for (var k = j + 1; k < overlap$1.length; ++k) {
				var p2 = circles[overlap$1[k].set], d2 = distanceFromIntersectArea(set.radius, p2.radius, overlap$1[k].size);
				var extraPoints = circleCircleIntersection({
					x: p1.x,
					y: p1.y,
					radius: d1
				}, {
					x: p2.x,
					y: p2.y,
					radius: d2
				});
				for (var l = 0; l < extraPoints.length; ++l) points.push(extraPoints[l]);
			}
		}
		var bestLoss = 1e50, bestPoint = points[0];
		for (var j = 0; j < points.length; ++j) {
			circles[setIndex].x = points[j].x;
			circles[setIndex].y = points[j].y;
			var localLoss = loss(circles, areas);
			if (localLoss < bestLoss) {
				bestLoss = localLoss;
				bestPoint = points[j];
			}
		}
		positionSet(bestPoint, setIndex);
	}
	return circles;
}
/** Given a bunch of sets, and the desired overlaps between these sets - computes
the distance from the actual overlaps to the desired overlaps. Note that
this method ignores overlaps of more than 2 circles */
function lossFunction(sets, overlaps) {
	var output = 0;
	function getCircles(indices) {
		return indices.map(function(i$1) {
			return sets[i$1];
		});
	}
	for (var i = 0; i < overlaps.length; ++i) {
		var area$1 = overlaps[i];
		var overlap$1 = void 0;
		if (area$1.sets.length == 1) continue;
		else if (area$1.sets.length == 2) {
			var left$1 = sets[area$1.sets[0]], right$1 = sets[area$1.sets[1]];
			overlap$1 = circleOverlap(left$1.radius, right$1.radius, distance(left$1, right$1));
		} else overlap$1 = intersectionArea(getCircles(area$1.sets));
		var weight = area$1.hasOwnProperty("weight") ? area$1.weight : 1;
		output += weight * (overlap$1 - area$1.size) * (overlap$1 - area$1.size);
	}
	return output;
}
function getBoundingBox(circles) {
	var minMax = function(d) {
		var hi = Math.max.apply(null, circles.map(function(c) {
			return c[d] + c.radius;
		})), lo = Math.min.apply(null, circles.map(function(c) {
			return c[d] - c.radius;
		}));
		return {
			max: hi,
			min: lo
		};
	};
	return {
		xRange: minMax("x"),
		yRange: minMax("y")
	};
}
/** Scales a solution from venn.venn or venn.greedyLayout such that it fits in
a rectangle of width/height - with padding around the borders. also
centers the diagram in the available space at the same time */
function scaleSolution(solution, width, height, padding$2) {
	var circles = [], setids = [];
	for (var setid in solution) if (solution.hasOwnProperty(setid)) {
		setids.push(setid);
		circles.push(solution[setid]);
	}
	width -= 2 * padding$2;
	height -= 2 * padding$2;
	var bounds = getBoundingBox(circles), xRange = bounds.xRange, yRange = bounds.yRange;
	if (xRange.max == xRange.min || yRange.max == yRange.min) {
		console.log("not scaling solution: zero size detected");
		return solution;
	}
	var xScaling = width / (xRange.max - xRange.min), yScaling = height / (yRange.max - yRange.min), scaling = Math.min(yScaling, xScaling), xOffset = (width - (xRange.max - xRange.min) * scaling) / 2, yOffset = (height - (yRange.max - yRange.min) * scaling) / 2;
	var scaled = {};
	for (var i = 0; i < circles.length; ++i) {
		var circle$1 = circles[i];
		scaled[setids[i]] = {
			radius: scaling * circle$1.radius,
			x: padding$2 + xOffset + (circle$1.x - xRange.min) * scaling,
			y: padding$2 + yOffset + (circle$1.y - yRange.min) * scaling
		};
	}
	return scaled;
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/venn/utils.js
/**
* 获取 颜色映射
* @usage colorMap.get(id) => color
*
* @returns Map<string, string>
*/
var getColorMap = memoize_default((function(colorPalette, data$2, blendMode, setsField) {
	var colorMap$1 = /* @__PURE__ */ new Map();
	var colorPaletteLen = colorPalette.length;
	data$2.forEach(function(d, idx) {
		if (d[setsField].length === 1) colorMap$1.set(d[ID_FIELD], colorPalette[(idx + colorPaletteLen) % colorPaletteLen]);
		else {
			/** 一般都是可以获取到颜色的，如果不正确 就是输入了非法数据 */
			var colorArr = d[setsField].map(function(id$1) {
				return colorMap$1.get(id$1);
			});
			colorMap$1.set(d[ID_FIELD], colorArr.slice(1).reduce(function(a, b) {
				return blend(a, b, blendMode);
			}, colorArr[0]));
		}
	});
	return colorMap$1;
}), function() {
	var params = [];
	for (var _i = 0; _i < arguments.length; _i++) params[_i] = arguments[_i];
	return JSON.stringify(params);
});
/**
* 给韦恩图数据进行布局
*
* @param data
* @param width
* @param height
* @param padding
* @returns 韦恩图数据
*/
function layoutVennData(options, width, height, padding$2) {
	if (padding$2 === void 0) padding$2 = 0;
	var data$2 = options.data, setsField = options.setsField, sizeField = options.sizeField;
	if (data$2.length === 0) {
		log(LEVEL.WARN, false, "warn: %s", "数据不能为空");
		return [];
	}
	var vennData = data$2.map(function(d) {
		var _a$5;
		return __assign(__assign({}, d), (_a$5 = {
			sets: d[setsField] || [],
			size: d[sizeField]
		}, _a$5[PATH_FIELD] = "", _a$5[ID_FIELD] = "", _a$5));
	});
	vennData.sort(function(a, b) {
		return a.sets.length - b.sets.length;
	});
	var solution = venn(vennData);
	var circles = scaleSolution(solution, width, height, padding$2);
	var textCenters = computeTextCentres(circles, vennData);
	vennData.forEach(function(row) {
		var sets = row.sets;
		var id$1 = sets.join(",");
		row[ID_FIELD] = id$1;
		var setCircles = sets.map(function(set) {
			return circles[set];
		});
		var path = intersectionAreaPath(setCircles);
		if (!/[zZ]$/.test(path)) path += " Z";
		row[PATH_FIELD] = path;
		var center$1 = textCenters[id$1] || {
			x: 0,
			y: 0
		};
		mix(row, center$1);
	});
	return vennData;
}
/**
* 检查是否存在 非法元素
* @param legalArr 合法集合：['A', 'B']
* @param testArr 检查集合：['A', 'B', 'C'] or ['A', 'C']（存在非法 'C'）
* @return boolean
*/
function islegalSets(legalArr, testArr) {
	for (var i = 0; i < testArr.length; i++) if (!legalArr.includes(testArr[i])) return false;
	return true;
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/venn/adaptor.js
/** 图例默认预留空间 */
var LEGEND_SPACE = 40;
/**
* 获取 color 映射
*/
function colorMap(params, data$2, colorPalette) {
	var chart = params.chart, options = params.options;
	var blendMode = options.blendMode, setsField = options.setsField;
	var _a$5 = chart.getTheme(), colors10 = _a$5.colors10, colors20 = _a$5.colors20;
	var palette = colorPalette;
	if (!is_array_default(palette)) palette = data$2.filter(function(d) {
		return d[setsField].length === 1;
	}).length <= 10 ? colors10 : colors20;
	var map$3 = getColorMap(palette, data$2, blendMode, setsField);
	return function(id$1) {
		return map$3.get(id$1) || palette[0];
	};
}
/**
* color options 转换
*/
function transformColor(params, data$2) {
	var color$2 = params.options.color;
	if (typeof color$2 !== "function") {
		var map_1 = colorMap(params, data$2, typeof color$2 === "string" ? [color$2] : color$2);
		return function(datum) {
			return map_1(datum[ID_FIELD]);
		};
	}
	return color$2;
}
/**
* 处理 padding
*/
function padding(params) {
	var chart = params.chart, options = params.options;
	var legend$17 = options.legend, appendPadding = options.appendPadding, padding$2 = options.padding;
	var tempPadding = normalPadding(appendPadding);
	if (legend$17 !== false) tempPadding = getAdjustAppendPadding(appendPadding, get_default(legend$17, "position"), LEGEND_SPACE);
	chart.appendPadding = resolveAllPadding([tempPadding, padding$2]);
	return params;
}
/**
* 处理非法数据
* @param params
*/
function data$1(params) {
	var data$2 = params.options["data"];
	if (!data$2) {
		log(LEVEL.WARN, false, "warn: %s", "数据不能为空");
		data$2 = [];
	}
	var currSets = data$2.filter(function(datum) {
		return datum.sets.length === 1;
	}).map(function(datum) {
		return datum.sets[0];
	});
	var filterSets = data$2.filter(function(datum) {
		var sets = datum.sets;
		return islegalSets(currSets, sets);
	});
	if (!is_equal_default(filterSets, data$2)) log(LEVEL.WARN, false, "warn: %s", "交集中不能出现不存在的集合, 请输入合法数据");
	return deep_mix_default({}, params, { options: { data: filterSets } });
}
/**
* geometry 处理
* @param params
*/
function geometry$2(params) {
	var chart = params.chart, options = params.options;
	var pointStyle = options.pointStyle, setsField = options.setsField, sizeField = options.sizeField;
	var _a$5 = normalPadding(chart.appendPadding), t = _a$5[0], r = _a$5[1], b = _a$5[2], l = _a$5[3];
	var customInfo = {
		offsetX: l,
		offsetY: t
	};
	var _b = chart.viewBBox, width = _b.width, height = _b.height;
	var vennData = layoutVennData(options, Math.max(width - (r + l), 0), Math.max(height - (t + b), 0), 0);
	chart.data(vennData);
	var geometry$34 = schema(deepAssign({}, params, { options: {
		xField: "x",
		yField: "y",
		sizeField,
		seriesField: ID_FIELD,
		rawFields: [setsField, sizeField],
		schema: {
			shape: "venn",
			style: pointStyle
		}
	} })).ext.geometry;
	geometry$34.customInfo(customInfo);
	var colorOptions = transformColor(params, vennData);
	if (typeof colorOptions === "function") geometry$34.color(ID_FIELD, function(id$1) {
		var datum = vennData.find(function(d) {
			return d[ID_FIELD] === id$1;
		});
		var defaultColor = colorMap(params, vennData)(id$1);
		return colorOptions(datum, defaultColor);
	});
	return params;
}
/**
* 处理 label
* @param params
*/
function label$1(params) {
	var chart = params.chart;
	var label$16 = params.options.label;
	var _a$5 = normalPadding(chart.appendPadding), t = _a$5[0];
	var customLabelInfo = {
		offsetX: _a$5[3],
		offsetY: t
	};
	var geometry$34 = findGeometry(chart, "schema");
	if (!label$16) geometry$34.label(false);
	else {
		var callback = label$16.callback, cfg = __rest(label$16, ["callback"]);
		geometry$34.label({
			fields: ["id"],
			callback,
			cfg: deep_mix_default({}, transformLabel(cfg), {
				type: "venn",
				customLabelInfo
			})
		});
	}
	return params;
}
/**
* legend 配置
* @param params
*/
function legend$4(params) {
	var chart = params.chart, options = params.options;
	var legend$17 = options.legend, sizeField = options.sizeField;
	chart.legend(ID_FIELD, legend$17);
	chart.legend(sizeField, false);
	return params;
}
/**
* 默认关闭坐标轴
* @param params
*/
function axis$2(params) {
	params.chart.axis(false);
	return params;
}
/**
* 韦恩图 interaction 交互适配器
*/
function vennInteraction(params) {
	var options = params.options, chart = params.chart;
	var interactions = options.interactions;
	if (interactions) {
		var MAP_1 = {
			"legend-active": "venn-legend-active",
			"legend-highlight": "venn-legend-highlight"
		};
		interaction(deepAssign({}, params, { options: { interactions: interactions.map(function(i) {
			return __assign(__assign({}, i), { type: MAP_1[i.type] || i.type });
		}) } }));
	}
	chart.removeInteraction("legend-active");
	chart.removeInteraction("legend-highlight");
	return params;
}
/**
* 图适配器
* @param chart
* @param options
*/
function adaptor$3(params) {
	return flow(padding, theme, data$1, geometry$2, label$1, scale({}), legend$4, axis$2, tooltip, vennInteraction, animation)(params);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/venn/index.js
/**
* 这个是一个图表开发的 模板代码！
*/
var Venn = function(_super) {
	__extends(Venn$1, _super);
	function Venn$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		/** 图表类型 */
		_this.type = "venn";
		return _this;
	}
	Venn$1.getDefaultOptions = function() {
		return DEFAULT_OPTIONS$4;
	};
	/**
	* 获取 韦恩图 默认配置
	*/
	Venn$1.prototype.getDefaultOptions = function() {
		return Venn$1.getDefaultOptions();
	};
	/**
	* 获取适配器
	*/
	Venn$1.prototype.getSchemaAdaptor = function() {
		return adaptor$3;
	};
	/**
	* 覆写父类的方法
	*/
	Venn$1.prototype.triggerResize = function() {
		if (!this.chart.destroyed) {
			this.chart.forceFit();
			this.chart.clear();
			this.execAdaptor();
			this.chart.render(true);
		}
	};
	return Venn$1;
}(Plot);

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/violin/constant.js
var X_FIELD = "x";
var VIOLIN_Y_FIELD = "violinY";
var VIOLIN_SIZE_FIELD = "violinSize";
var MIN_MAX_FIELD = "minMax";
var QUANTILE_FIELD = "quantile";
var MEDIAN_FIELD = "median";
var VIOLIN_VIEW_ID = "violin_view";
var MIN_MAX_VIEW_ID = "min_max_view";
var QUANTILE_VIEW_ID = "quantile_view";
var MEDIAN_VIEW_ID = "median_view";
var DEFAULT_OPTIONS$3 = deepAssign({}, Plot.getDefaultOptions(), {
	syncViewPadding: true,
	kde: {
		type: "triangular",
		sampleSize: 32,
		width: 3
	},
	violinStyle: {
		lineWidth: 1,
		fillOpacity: .3,
		strokeOpacity: .75
	},
	xAxis: {
		grid: { line: null },
		tickLine: { alignTick: false }
	},
	yAxis: { grid: { line: { style: {
		lineWidth: .5,
		lineDash: [4, 4]
	} } } },
	legend: { position: "top-left" },
	tooltip: { showMarkers: false }
});

//#endregion
//#region node_modules/pdfast/src/helper.js
var require_helper = /* @__PURE__ */ __commonJS({ "node_modules/pdfast/src/helper.js": ((exports, module) => {
	var self$2 = module.exports;
	module.exports.isNumber = function(x) {
		return typeof x === "number";
	};
	module.exports.findMin = function(arr) {
		if (arr.length === 0) return Infinity;
		var curr = arr[0];
		for (var i = 1; i < arr.length; i++) curr = Math.min(curr, arr[i]);
		return curr;
	};
	module.exports.findMax = function(arr) {
		if (arr.length === 0) return -Infinity;
		var curr = arr[0];
		for (var i = 1; i < arr.length; i++) curr = Math.max(curr, arr[i]);
		return curr;
	};
	module.exports.findMinMulti = function(arr) {
		var curr = self$2.findMin(arr[0]);
		for (var i = 1; i < arr.length; i++) curr = Math.min(curr, self$2.findMin(arr[i]));
		return curr;
	};
	module.exports.findMaxMulti = function(arr) {
		var curr = self$2.findMax(arr[0]);
		for (var i = 1; i < arr.length; i++) curr = Math.max(curr, self$2.findMax(arr[i]));
		return curr;
	};
	module.exports.inside = function(min$2, max$2, x) {
		return min$2 <= x && x <= max$2;
	};
}) });

//#endregion
//#region node_modules/pdfast/src/index.js
var require_src = /* @__PURE__ */ __commonJS({ "node_modules/pdfast/src/index.js": ((exports, module) => {
	var DEFAULT_SIZE = 50;
	var DEFAULT_WIDTH = 2;
	var LN_2 = Math.log(2);
	var self$1 = module.exports;
	var helper = require_helper();
	function kernel(x) {
		return 1 - Math.abs(x);
	}
	/**
	* Get min and max value for the pdf, covering all arr data range while respecting options' data
	* @param arr
	* @param options
	* @returns {*}
	*/
	module.exports.getUnifiedMinMax = function(arr, options) {
		return self$1.getUnifiedMinMaxMulti([arr], options);
	};
	module.exports.getUnifiedMinMaxMulti = function(arrMulti, options) {
		options = options || {};
		var relaxMin = false;
		var relaxMax = false;
		var width = helper.isNumber(options.width) ? options.width : DEFAULT_WIDTH;
		var size$1 = helper.isNumber(options.size) ? options.size : DEFAULT_SIZE;
		var min$2 = helper.isNumber(options.min) ? options.min : (relaxMin = true, helper.findMinMulti(arrMulti));
		var max$2 = helper.isNumber(options.max) ? options.max : (relaxMax = true, helper.findMaxMulti(arrMulti));
		var step = (max$2 - min$2) / (size$1 - 1);
		if (relaxMin) min$2 = min$2 - 2 * width * step;
		if (relaxMax) max$2 = max$2 + 2 * width * step;
		return {
			min: min$2,
			max: max$2
		};
	};
	module.exports.create = function(arr, options) {
		options = options || {};
		if (!arr || arr.length === 0) return [];
		var size$1 = helper.isNumber(options.size) ? options.size : DEFAULT_SIZE;
		var width = helper.isNumber(options.width) ? options.width : DEFAULT_WIDTH;
		var normalizedMinMax = self$1.getUnifiedMinMax(arr, {
			size: size$1,
			width,
			min: options.min,
			max: options.max
		});
		var min$2 = normalizedMinMax.min;
		var range = normalizedMinMax.max - min$2;
		var step = range / (size$1 - 1);
		if (range === 0) return [{
			x: min$2,
			y: 1
		}];
		var buckets = [];
		for (var i = 0; i < size$1; i++) buckets.push({
			x: min$2 + i * step,
			y: 0
		});
		var xToBucket = function(x) {
			return Math.floor((x - min$2) / step);
		};
		var partialArea = generatePartialAreas(kernel, width);
		var fullArea = partialArea[width];
		var c = partialArea[width - 1] - partialArea[width - 2];
		var initalValue = 0;
		arr.forEach(function(x) {
			var bucket = xToBucket(x);
			if (bucket + width < 0 || bucket - width >= buckets.length) return;
			var start = Math.max(bucket - width, 0);
			var mid$1 = bucket;
			var end = Math.min(bucket + width, buckets.length - 1);
			var leftBlockCount = start - (bucket - width);
			var rightBlockCount = bucket + width - end;
			var spilledAreaLeft = partialArea[-width - 1 + leftBlockCount] || 0;
			var spilledAreaRight = partialArea[-width - 1 + rightBlockCount] || 0;
			var weight = fullArea / (fullArea - spilledAreaLeft - spilledAreaRight);
			if (leftBlockCount > 0) initalValue += weight * (leftBlockCount - 1) * c;
			var startGradPos = Math.max(0, bucket - width + 1);
			if (helper.inside(0, buckets.length - 1, startGradPos)) buckets[startGradPos].y += weight * 1 * c;
			if (helper.inside(0, buckets.length - 1, mid$1 + 1)) buckets[mid$1 + 1].y -= weight * 2 * c;
			if (helper.inside(0, buckets.length - 1, end + 1)) buckets[end + 1].y += weight * 1 * c;
		});
		var accumulator = initalValue;
		var gradAccumulator = 0;
		var area$1 = 0;
		buckets.forEach(function(bucket) {
			gradAccumulator += bucket.y;
			accumulator += gradAccumulator;
			bucket.y = accumulator;
			area$1 += accumulator;
		});
		if (area$1 > 0) buckets.forEach(function(bucket) {
			bucket.y /= area$1;
		});
		return buckets;
	};
	function generatePartialAreas(kernel$1, width) {
		var partialAreas = {};
		var accumulator = 0;
		for (var i = -width; i <= width; i++) {
			accumulator += kernel$1(i / width);
			partialAreas[i] = accumulator;
		}
		return partialAreas;
	}
	module.exports.getExpectedValueFromPdf = function(pdf$1) {
		if (!pdf$1 || pdf$1.length === 0) return;
		var expected = 0;
		pdf$1.forEach(function(obj) {
			expected += obj.x * obj.y;
		});
		return expected;
	};
	module.exports.getXWithLeftTailArea = function(pdf$1, area$1) {
		if (!pdf$1 || pdf$1.length === 0) return;
		var accumulator = 0;
		var last$1 = 0;
		for (var i = 0; i < pdf$1.length; i++) {
			last$1 = i;
			accumulator += pdf$1[i].y;
			if (accumulator >= area$1) break;
		}
		return pdf$1[last$1].x;
	};
	module.exports.getPerplexity = function(pdf$1) {
		if (!pdf$1 || pdf$1.length === 0) return;
		var entropy = 0;
		pdf$1.forEach(function(obj) {
			var ln = Math.log(obj.y);
			if (isFinite(ln)) entropy += obj.y * ln;
		});
		entropy = -entropy / LN_2;
		return Math.pow(2, entropy);
	};
}) });

//#endregion
//#region node_modules/@antv/g2plot/esm/utils/transform/quantile.js
var import_src = /* @__PURE__ */ __toESM(require_src());
/**
* This is the internal implementation of quantiles: when you know
* that the order is sorted, you don't need to re-sort it, and the computations
* are faster.
*
* @param {Array<number>} x sample of one or more data points
* @param {number} p desired quantile: a number between 0 to 1, inclusive
* @returns {number} quantile value
* @throws {Error} if p ix outside of the range from 0 to 1
* @throws {Error} if x is empty
* @example
* quantileSorted([3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20], 0.5); // => 9
*/
function quantileSorted(x, p) {
	var idx = x.length * p;
	if (x.length === 0) throw new Error("quantile requires at least one data point.");
	else if (p < 0 || p > 1) throw new Error("quantiles must be between 0 and 1");
	else if (p === 1) return x[x.length - 1];
	else if (p === 0) return x[0];
	else if (idx % 1 !== 0) return x[Math.ceil(idx) - 1];
	else if (x.length % 2 === 0) return (x[idx - 1] + x[idx]) / 2;
	else return x[idx];
}
/**
* 交换数组位置
* @param arr T[]
* @param i number
* @param j number
*/
function swap(arr, i, j) {
	var tmp = arr[i];
	arr[i] = arr[j];
	arr[j] = tmp;
}
/**
* Rearrange items in `arr` so that all items in `[left, k]` range are the smallest.
* The `k`-th element will have the `(k - left + 1)`-th smallest value in `[left, right]`.
*
* Implements Floyd-Rivest selection algorithm https://en.wikipedia.org/wiki/Floyd-Rivest_algorithm
*
* @param {Array<number>} arr input array
* @param {number} k pivot index
* @param {number} [left] left index
* @param {number} [right] right index
* @returns {void} mutates input array
* @example
* var arr = [65, 28, 59, 33, 21, 56, 22, 95, 50, 12, 90, 53, 28, 77, 39];
* quickselect(arr, 8);
* // = [39, 28, 28, 33, 21, 12, 22, 50, 53, 56, 59, 65, 90, 77, 95]
*/
function quickselect(arr, k, left$1, right$1) {
	left$1 = left$1 || 0;
	right$1 = right$1 || arr.length - 1;
	while (right$1 > left$1) {
		if (right$1 - left$1 > 600) {
			var n = right$1 - left$1 + 1;
			var m = k - left$1 + 1;
			var z = Math.log(n);
			var s = .5 * Math.exp(2 * z / 3);
			var sd = .5 * Math.sqrt(z * s * (n - s) / n);
			if (m - n / 2 < 0) sd *= -1;
			var newLeft = Math.max(left$1, Math.floor(k - m * s / n + sd));
			var newRight = Math.min(right$1, Math.floor(k + (n - m) * s / n + sd));
			quickselect(arr, k, newLeft, newRight);
		}
		var t = arr[k];
		var i = left$1;
		var j = right$1;
		swap(arr, left$1, k);
		if (arr[right$1] > t) swap(arr, left$1, right$1);
		while (i < j) {
			swap(arr, i, j);
			i++;
			j--;
			while (arr[i] < t) i++;
			while (arr[j] > t) j--;
		}
		if (arr[left$1] === t) swap(arr, left$1, j);
		else {
			j++;
			swap(arr, j, right$1);
		}
		if (j <= k) left$1 = j + 1;
		if (k <= j) right$1 = j - 1;
	}
}
function quantile(x, p) {
	var copy = x.slice();
	if (Array.isArray(p)) {
		multiQuantileSelect(copy, p);
		var results = [];
		for (var i = 0; i < p.length; i++) results[i] = quantileSorted(copy, p[i]);
		return results;
	} else {
		var idx = quantileIndex(copy.length, p);
		quantileSelect(copy, idx, 0, copy.length - 1);
		return quantileSorted(copy, p);
	}
}
function quantileSelect(arr, k, left$1, right$1) {
	if (k % 1 === 0) quickselect(arr, k, left$1, right$1);
	else {
		k = Math.floor(k);
		quickselect(arr, k, left$1, right$1);
		quickselect(arr, k + 1, k + 1, right$1);
	}
}
function multiQuantileSelect(arr, p) {
	var indices = [0];
	for (var i = 0; i < p.length; i++) indices.push(quantileIndex(arr.length, p[i]));
	indices.push(arr.length - 1);
	indices.sort(compare);
	var stack = [0, indices.length - 1];
	while (stack.length) {
		var r = Math.ceil(stack.pop());
		var l = Math.floor(stack.pop());
		if (r - l <= 1) continue;
		var m = Math.floor((l + r) / 2);
		quantileSelect(arr, indices[m], Math.floor(indices[l]), Math.ceil(indices[r]));
		stack.push(l, m, m, r);
	}
}
function compare(a, b) {
	return a - b;
}
function quantileIndex(len, p) {
	var idx = len * p;
	if (p === 1) return len - 1;
	else if (p === 0) return 0;
	else if (idx % 1 !== 0) return Math.ceil(idx) - 1;
	else if (len % 2 === 0) return idx - .5;
	else return idx;
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/violin/utils.js
var toBoxValue = function(values$1) {
	return {
		low: min_default(values$1),
		high: max_default(values$1),
		q1: quantile(values$1, .25),
		q3: quantile(values$1, .75),
		median: quantile(values$1, [.5]),
		minMax: [min_default(values$1), max_default(values$1)],
		quantile: [quantile(values$1, .25), quantile(values$1, .75)]
	};
};
var toViolinValue = function(values$1, pdfOptions) {
	var pdfResults = import_src.default.create(values$1, pdfOptions);
	return {
		violinSize: pdfResults.map(function(result) {
			return result.y;
		}),
		violinY: pdfResults.map(function(result) {
			return result.x;
		})
	};
};
var transformViolinData = function(options) {
	var xField = options.xField, yField = options.yField, seriesField = options.seriesField, data$2 = options.data, kde = options.kde;
	/** 生成概率密度函数的配置 */
	var pdfOptions = {
		min: kde.min,
		max: kde.max,
		size: kde.sampleSize,
		width: kde.width
	};
	if (!seriesField) {
		var group_1 = group_by_default(data$2, xField);
		return Object.keys(group_1).map(function(x) {
			var values$1 = group_1[x].map(function(record) {
				return record[yField];
			});
			return __assign(__assign({ x }, toViolinValue(values$1, pdfOptions)), toBoxValue(values$1));
		});
	}
	var resultList = [];
	var seriesGroup = group_by_default(data$2, seriesField);
	Object.keys(seriesGroup).forEach(function(series) {
		var group$1 = group_by_default(seriesGroup[series], xField);
		return Object.keys(group$1).forEach(function(key) {
			var _a$5;
			var values$1 = group$1[key].map(function(record) {
				return record[yField];
			});
			resultList.push(__assign(__assign((_a$5 = { x: key }, _a$5[seriesField] = series, _a$5), toViolinValue(values$1, pdfOptions)), toBoxValue(values$1)));
		});
	});
	return resultList;
};

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/violin/adaptor.js
var TOOLTIP_FIELDS = [
	"low",
	"high",
	"q1",
	"q3",
	"median"
];
var adjustCfg = [{
	type: "dodge",
	marginRatio: 1 / 32
}];
/** 处理数据 */
function data(params) {
	var chart = params.chart, options = params.options;
	chart.data(transformViolinData(options));
	return params;
}
/** 小提琴轮廓 */
function violinView(params) {
	var chart = params.chart, options = params.options;
	var seriesField = options.seriesField, color$2 = options.color, _a$5 = options.shape, shape = _a$5 === void 0 ? "violin" : _a$5, violinStyle = options.violinStyle, tooltip$10 = options.tooltip, state$1 = options.state;
	var view = chart.createView({ id: VIOLIN_VIEW_ID });
	violin({
		chart: view,
		options: {
			xField: X_FIELD,
			yField: VIOLIN_Y_FIELD,
			seriesField: seriesField ? seriesField : X_FIELD,
			sizeField: VIOLIN_SIZE_FIELD,
			tooltip: __assign({ fields: TOOLTIP_FIELDS }, tooltip$10),
			violin: {
				style: violinStyle,
				color: color$2,
				shape
			},
			state: state$1
		}
	});
	view.geometries[0].adjust(adjustCfg);
	return params;
}
/** 箱线 */
function boxView(params) {
	var chart = params.chart, options = params.options;
	var seriesField = options.seriesField, color$2 = options.color, tooltip$10 = options.tooltip, box$1 = options.box;
	if (box$1 === false) return params;
	var minMaxView = chart.createView({ id: MIN_MAX_VIEW_ID });
	interval({
		chart: minMaxView,
		options: {
			xField: X_FIELD,
			yField: MIN_MAX_FIELD,
			seriesField: seriesField ? seriesField : X_FIELD,
			tooltip: __assign({ fields: TOOLTIP_FIELDS }, tooltip$10),
			state: typeof box$1 === "object" ? box$1.state : {},
			interval: {
				color: color$2,
				size: 1,
				style: { lineWidth: 0 }
			}
		}
	});
	minMaxView.geometries[0].adjust(adjustCfg);
	var quantileView = chart.createView({ id: QUANTILE_VIEW_ID });
	interval({
		chart: quantileView,
		options: {
			xField: X_FIELD,
			yField: QUANTILE_FIELD,
			seriesField: seriesField ? seriesField : X_FIELD,
			tooltip: __assign({ fields: TOOLTIP_FIELDS }, tooltip$10),
			state: typeof box$1 === "object" ? box$1.state : {},
			interval: {
				color: color$2,
				size: 8,
				style: { fillOpacity: 1 }
			}
		}
	});
	quantileView.geometries[0].adjust(adjustCfg);
	var medianView = chart.createView({ id: MEDIAN_VIEW_ID });
	point({
		chart: medianView,
		options: {
			xField: X_FIELD,
			yField: MEDIAN_FIELD,
			seriesField: seriesField ? seriesField : X_FIELD,
			tooltip: __assign({ fields: TOOLTIP_FIELDS }, tooltip$10),
			state: typeof box$1 === "object" ? box$1.state : {},
			point: {
				color: color$2,
				size: 1,
				style: {
					fill: "white",
					lineWidth: 0
				}
			}
		}
	});
	medianView.geometries[0].adjust(adjustCfg);
	quantileView.axis(false);
	minMaxView.axis(false);
	medianView.axis(false);
	medianView.legend(false);
	minMaxView.legend(false);
	quantileView.legend(false);
	return params;
}
/**
* meta 配置
*/
function meta$2(params) {
	var _a$5;
	var chart = params.chart, options = params.options;
	var meta$22 = options.meta, xAxis = options.xAxis, yAxis = options.yAxis;
	var scales = deepAssign({}, meta$22, (_a$5 = {}, _a$5[X_FIELD] = __assign(__assign({ sync: true }, pick(xAxis, AXIS_META_CONFIG_KEYS)), { type: "cat" }), _a$5[VIOLIN_Y_FIELD] = __assign({ sync: true }, pick(yAxis, AXIS_META_CONFIG_KEYS)), _a$5[MIN_MAX_FIELD] = __assign({ sync: VIOLIN_Y_FIELD }, pick(yAxis, AXIS_META_CONFIG_KEYS)), _a$5[QUANTILE_FIELD] = __assign({ sync: VIOLIN_Y_FIELD }, pick(yAxis, AXIS_META_CONFIG_KEYS)), _a$5[MEDIAN_FIELD] = __assign({ sync: VIOLIN_Y_FIELD }, pick(yAxis, AXIS_META_CONFIG_KEYS)), _a$5));
	chart.scale(scales);
	return params;
}
/**
* axis 配置
*/
function axis$1(params) {
	var chart = params.chart, options = params.options;
	var xAxis = options.xAxis, yAxis = options.yAxis;
	var view = findViewById(chart, VIOLIN_VIEW_ID);
	if (xAxis === false) view.axis(X_FIELD, false);
	else view.axis(X_FIELD, xAxis);
	if (yAxis === false) view.axis(VIOLIN_Y_FIELD, false);
	else view.axis(VIOLIN_Y_FIELD, yAxis);
	chart.axis(false);
	return params;
}
/**
*
* @param params
* @returns
*/
function legend$3(params) {
	var chart = params.chart, options = params.options;
	var legend$17 = options.legend, seriesField = options.seriesField, shape = options.shape;
	if (legend$17 === false) chart.legend(false);
	else {
		var legendField_1 = seriesField ? seriesField : X_FIELD;
		var legendOptions = omit_default(legend$17, ["selected"]);
		if (!shape || !shape.startsWith("hollow")) {
			if (!get_default(legendOptions, [
				"marker",
				"style",
				"lineWidth"
			])) set_default(legendOptions, [
				"marker",
				"style",
				"lineWidth"
			], 0);
		}
		chart.legend(legendField_1, legendOptions);
		if (get_default(legend$17, "selected")) each_default(chart.views, function(view) {
			return view.legend(legendField_1, legend$17);
		});
	}
	return params;
}
/**
* annotation, apply to violin view.
* @param params
* @returns
*/
function annotation$1(params) {
	var chart = params.chart;
	var violinView$1 = findViewById(chart, VIOLIN_VIEW_ID);
	annotation()(__assign(__assign({}, params), { chart: violinView$1 }));
	return params;
}
/**
* 动画
* @param params
*/
function animation$1(params) {
	var chart = params.chart;
	var animation$6 = params.options.animation;
	each_default(chart.views, function(view) {
		addViewAnimation(view, animation$6);
	});
	return params;
}
/**
* 小提琴图适配器
* @param params
*/
function adaptor$2(params) {
	return flow(theme, data, violinView, boxView, meta$2, tooltip, axis$1, legend$3, interaction, annotation$1, animation$1)(params);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/violin/index.js
var Violin = function(_super) {
	__extends(Violin$2, _super);
	function Violin$2() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		/** 图表类型 */
		_this.type = "violin";
		return _this;
	}
	/**
	* 获取 默认配置项
	* 供外部使用
	*/
	Violin$2.getDefaultOptions = function() {
		return DEFAULT_OPTIONS$3;
	};
	/**
	* @override
	*/
	Violin$2.prototype.changeData = function(data$2) {
		this.updateOption({ data: data$2 });
		this.chart.changeData(transformViolinData(this.options));
	};
	/**
	* 获取 小提琴图 默认配置项
	*/
	Violin$2.prototype.getDefaultOptions = function() {
		return Violin$2.getDefaultOptions();
	};
	/**
	* 获取 小提琴图 的适配器
	*/
	Violin$2.prototype.getSchemaAdaptor = function() {
		return adaptor$2;
	};
	return Violin$2;
}(Plot);

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/waterfall/constant.js
var Y_FIELD = "$$yField$$";
var DIFF_FIELD = "$$diffField$$";
var ABSOLUTE_FIELD = "$$absoluteField$$";
var IS_TOTAL = "$$isTotal$$";
/**
* 瀑布图 默认配置项
*/
var DEFAULT_OPTIONS$2 = {
	label: {},
	leaderLine: { style: {
		lineWidth: 1,
		stroke: "#8c8c8c",
		lineDash: [4, 2]
	} },
	total: { style: { fill: "rgba(0, 0, 0, 0.25)" } },
	interactions: [{ type: "element-active" }],
	risingFill: "#f4664a",
	fallingFill: "#30bf78",
	waterfallStyle: { fill: "rgba(0, 0, 0, 0.25)" },
	yAxis: { grid: { line: { style: { lineDash: [4, 2] } } } }
};

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/waterfall/shape.js
/**
* 获取柱子 path
* @param points
*/
function getRectPath(points) {
	var path = [];
	for (var i = 0; i < points.length; i++) {
		var point$1 = points[i];
		if (point$1) {
			var action = i === 0 ? "M" : "L";
			path.push([
				action,
				point$1.x,
				point$1.y
			]);
		}
	}
	var first = points[0];
	path.push([
		"L",
		first.x,
		first.y
	]);
	path.push(["z"]);
	return path;
}
/**
* 获取填充属性
* @param cfg 图形绘制数据
*/
function getFillAttrs(cfg) {
	return deepAssign({}, cfg.defaultStyle, cfg.style, { fill: cfg.color });
}
registerShape("interval", "waterfall", { draw: function(cfg, container) {
	var customInfo = cfg.customInfo, points = cfg.points, nextPoints = cfg.nextPoints;
	var group$1 = container.addGroup();
	var rectPath$1 = this.parsePath(getRectPath(points));
	var fillAttrs = getFillAttrs(cfg);
	group$1.addShape("path", { attrs: __assign(__assign({}, fillAttrs), { path: rectPath$1 }) });
	var leaderLineCfg = get_default(customInfo, "leaderLine");
	if (leaderLineCfg && nextPoints) {
		var linkPath = [[
			"M",
			points[2].x,
			points[2].y
		], [
			"L",
			nextPoints[0].x,
			nextPoints[0].y
		]];
		if (points[2].y === nextPoints[1].y) linkPath[1] = [
			"L",
			nextPoints[1].x,
			nextPoints[1].y
		];
		linkPath = this.parsePath(linkPath);
		group$1.addShape("path", { attrs: __assign({ path: linkPath }, leaderLineCfg.style || {}) });
	}
	return group$1;
} });

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/waterfall/utils.js
/**
* @desc 数据处理函数，统一将数据处理成[start, end]
* @param data
* @param xField
* @param yField
* @param totalLabel
*/
function processData(data$2, xField, yField, newYField, total) {
	var _a$5;
	var newData = [];
	reduce_default(data$2, function(r, d) {
		var _a$6;
		log(LEVEL.WARN, is_number_default(d[yField]), "".concat(d[yField], " is not a valid number"));
		var value$1 = is_undefined_default(d[yField]) ? null : d[yField];
		newData.push(__assign(__assign({}, d), (_a$6 = {}, _a$6[newYField] = [r, r + value$1], _a$6)));
		return r + value$1;
	}, 0);
	if (newData.length && total) {
		var sum = get_default(newData, [
			[data$2.length - 1],
			newYField,
			[1]
		]);
		newData.push((_a$5 = {}, _a$5[xField] = total.label, _a$5[yField] = sum, _a$5[newYField] = [0, sum], _a$5));
	}
	return newData;
}
/**
* 处理为 瀑布图 数据
*/
function transformData(data$2, xField, yField, total) {
	return processData(data$2, xField, yField, Y_FIELD, total).map(function(d, dIdx) {
		var _a$5;
		if (!is_object_default(d)) return d;
		return __assign(__assign({}, d), (_a$5 = {}, _a$5[ABSOLUTE_FIELD] = d[Y_FIELD][1], _a$5[DIFF_FIELD] = d[Y_FIELD][1] - d[Y_FIELD][0], _a$5[IS_TOTAL] = dIdx === data$2.length, _a$5));
	});
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/waterfall/adaptor.js
/**
*  处理默认配置项
* @param params
* @returns
*/
function defaultOptions(params) {
	var _a$5 = params.options, locale = _a$5.locale, total = _a$5.total;
	var localeTotalLabel = getLocale(locale).get(["waterfall", "total"]);
	if (total && typeof total.label !== "string" && localeTotalLabel) params.options.total.label = localeTotalLabel;
	return params;
}
/**
* 字段
* @param params
*/
function geometry$1(params) {
	var chart = params.chart, options = params.options;
	var data$2 = options.data, xField = options.xField, yField = options.yField, total = options.total, leaderLine = options.leaderLine, columnWidthRatio = options.columnWidthRatio, waterfallStyle = options.waterfallStyle, risingFill = options.risingFill, fallingFill = options.fallingFill, color$2 = options.color, shape = options.shape, customInfo = options.customInfo;
	chart.data(transformData(data$2, xField, yField, total));
	var p = deepAssign({}, params, { options: {
		xField,
		yField: Y_FIELD,
		seriesField: xField,
		rawFields: [
			yField,
			DIFF_FIELD,
			IS_TOTAL,
			Y_FIELD
		],
		widthRatio: columnWidthRatio,
		interval: {
			style: waterfallStyle,
			shape: shape || "waterfall",
			color: color$2 || function(datum) {
				if (get_default(datum, [IS_TOTAL])) return get_default(total, ["style", "fill"], "");
				return get_default(datum, [Y_FIELD, 1]) - get_default(datum, [Y_FIELD, 0]) > 0 ? risingFill : fallingFill;
			}
		}
	} });
	interval(p).ext.geometry.customInfo(__assign(__assign({}, customInfo), { leaderLine }));
	return params;
}
/**
* meta 配置
* @param params
*/
function meta$1(params) {
	var _a$5, _b;
	var options = params.options;
	var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField, meta$22 = options.meta;
	var Y_FIELD_META = deepAssign({}, { alias: yField }, get_default(meta$22, yField));
	return flow(scale((_a$5 = {}, _a$5[xField] = xAxis, _a$5[yField] = yAxis, _a$5[Y_FIELD] = yAxis, _a$5), deepAssign({}, meta$22, (_b = {}, _b[Y_FIELD] = Y_FIELD_META, _b[DIFF_FIELD] = Y_FIELD_META, _b[ABSOLUTE_FIELD] = Y_FIELD_META, _b))))(params);
}
/**
* axis 配置
* @param params
*/
function axis(params) {
	var chart = params.chart, options = params.options;
	var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
	if (xAxis === false) chart.axis(xField, false);
	else chart.axis(xField, xAxis);
	if (yAxis === false) {
		chart.axis(yField, false);
		chart.axis(Y_FIELD, false);
	} else {
		chart.axis(yField, yAxis);
		chart.axis(Y_FIELD, yAxis);
	}
	return params;
}
/**
* legend 配置 todo 添加 hover 交互
* @param params
*/
function legend$2(params) {
	var chart = params.chart, options = params.options;
	var legend$17 = options.legend, total = options.total, risingFill = options.risingFill, fallingFill = options.fallingFill, locale = options.locale;
	var i18n = getLocale(locale);
	if (legend$17 === false) chart.legend(false);
	else {
		var items = [{
			name: i18n.get(["general", "increase"]),
			value: "increase",
			marker: {
				symbol: "square",
				style: {
					r: 5,
					fill: risingFill
				}
			}
		}, {
			name: i18n.get(["general", "decrease"]),
			value: "decrease",
			marker: {
				symbol: "square",
				style: {
					r: 5,
					fill: fallingFill
				}
			}
		}];
		if (total) items.push({
			name: total.label || "",
			value: "total",
			marker: {
				symbol: "square",
				style: deepAssign({}, { r: 5 }, get_default(total, "style"))
			}
		});
		chart.legend(deepAssign({}, {
			custom: true,
			position: "top",
			items
		}, legend$17));
		chart.removeInteraction("legend-filter");
	}
	return params;
}
/**
* 数据标签
* @param params
*/
function label(params) {
	var chart = params.chart, options = params.options;
	var label$16 = options.label, labelMode = options.labelMode, xField = options.xField;
	var geometry$34 = findGeometry(chart, "interval");
	if (!label$16) geometry$34.label(false);
	else {
		var callback = label$16.callback, cfg = __rest(label$16, ["callback"]);
		geometry$34.label({
			fields: labelMode === "absolute" ? [ABSOLUTE_FIELD, xField] : [DIFF_FIELD, xField],
			callback,
			cfg: transformLabel(cfg)
		});
	}
	return params;
}
/**
* tooltip 配置
* @param params
*/
function tooltip$1(params) {
	var chart = params.chart, options = params.options;
	var tooltip$10 = options.tooltip, xField = options.xField, yField = options.yField;
	if (tooltip$10 !== false) {
		chart.tooltip(__assign({
			showCrosshairs: false,
			showMarkers: false,
			shared: true,
			fields: [yField]
		}, tooltip$10));
		var geometry_1 = chart.geometries[0];
		(tooltip$10 === null || tooltip$10 === void 0 ? void 0 : tooltip$10.formatter) ? geometry_1.tooltip("".concat(xField, "*").concat(yField), tooltip$10.formatter) : geometry_1.tooltip(yField);
	} else chart.tooltip(false);
	return params;
}
/**
* 瀑布图适配器
* @param params
*/
function adaptor$1(params) {
	return flow(defaultOptions, theme, geometry$1, meta$1, axis, legend$2, tooltip$1, label, state, interaction, animation, annotation())(params);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/waterfall/index.js
/**
* 瀑布图
*/
var Waterfall = function(_super) {
	__extends(Waterfall$1, _super);
	function Waterfall$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		/** 图表类型 */
		_this.type = "waterfall";
		return _this;
	}
	/**
	* 获取 瀑布图 默认配置项
	* 供外部使用
	*/
	Waterfall$1.getDefaultOptions = function() {
		return DEFAULT_OPTIONS$2;
	};
	/**
	* @override
	* @param data
	*/
	Waterfall$1.prototype.changeData = function(data$2) {
		var _a$5 = this.options, xField = _a$5.xField, yField = _a$5.yField, total = _a$5.total;
		this.updateOption({ data: data$2 });
		this.chart.changeData(transformData(data$2, xField, yField, total));
	};
	/**
	* 获取 瀑布图 的适配器
	*/
	Waterfall$1.prototype.getSchemaAdaptor = function() {
		return adaptor$1;
	};
	/**
	* 获取 瀑布图 的默认配置
	*/
	Waterfall$1.prototype.getDefaultOptions = function() {
		return Waterfall$1.getDefaultOptions();
	};
	return Waterfall$1;
}(Plot);

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/word-cloud/constant.js
/** 词云图 color 通道映射字段 */
var WORD_CLOUD_COLOR_FIELD = "color";
/**
* 词云图 默认配置项
*/
var DEFAULT_OPTIONS = deepAssign({}, Plot.getDefaultOptions(), {
	timeInterval: 2e3,
	legend: false,
	tooltip: {
		showTitle: false,
		showMarkers: false,
		showCrosshairs: false,
		fields: [
			"text",
			"value",
			WORD_CLOUD_COLOR_FIELD
		],
		formatter: function(datum) {
			return {
				name: datum.text,
				value: datum.value
			};
		}
	},
	wordStyle: {
		fontFamily: "Verdana",
		fontWeight: "normal",
		padding: 1,
		fontSize: [12, 60],
		rotation: [0, 90],
		rotationSteps: 2,
		rotateRatio: .5
	}
});

//#endregion
//#region node_modules/@antv/g2plot/esm/utils/transform/word-cloud.js
var DEFAULT_OPTIONS$1 = {
	font: function() {
		return "serif";
	},
	padding: 1,
	size: [500, 500],
	spiral: "archimedean",
	timeInterval: 3e3
};
/**
* 根据对应的数据对象，计算每个
* 词语在画布中的渲染位置，并返回
* 计算后的数据对象
* @param words
* @param options
*/
function wordCloud(words, options) {
	options = mix({}, DEFAULT_OPTIONS$1, options);
	return transform$1(words, options);
}
/**
* 抛出没有混入默认配置的方法，用于测试。
* @param words
* @param options
*/
function transform$1(words, options) {
	var layout$1 = tagCloud();
	[
		"font",
		"fontSize",
		"fontWeight",
		"padding",
		"rotate",
		"size",
		"spiral",
		"timeInterval",
		"random"
	].forEach(function(key) {
		if (!is_nil_default(options[key])) layout$1[key](options[key]);
	});
	layout$1.words(words);
	if (options.imageMask) layout$1.createMask(options.imageMask);
	var tags = layout$1.start()._tags;
	tags.forEach(function(tag) {
		tag.x += options.size[0] / 2;
		tag.y += options.size[1] / 2;
	});
	var _a$5 = options.size, w = _a$5[0], h = _a$5[1];
	tags.push({
		text: "",
		value: 0,
		x: 0,
		y: 0,
		opacity: 0
	});
	tags.push({
		text: "",
		value: 0,
		x: w,
		y: h,
		opacity: 0
	});
	return tags;
}
var cloudRadians = Math.PI / 180, cw = 64, ch = 2048;
function cloudText(d) {
	return d.text;
}
function cloudFont() {
	return "serif";
}
function cloudFontNormal() {
	return "normal";
}
function cloudFontSize(d) {
	return d.value;
}
function cloudRotate() {
	return ~~(Math.random() * 2) * 90;
}
function cloudPadding() {
	return 1;
}
function cloudSprite(contextAndRatio, d, data$2, di) {
	if (d.sprite) return;
	var c = contextAndRatio.context, ratio = contextAndRatio.ratio;
	c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
	var x = 0, y = 0, maxh = 0;
	var n = data$2.length;
	--di;
	while (++di < n) {
		d = data$2[di];
		c.save();
		c.font = d.style + " " + d.weight + " " + ~~((d.size + 1) / ratio) + "px " + d.font;
		var w = c.measureText(d.text + "m").width * ratio, h = d.size << 1;
		if (d.rotate) {
			var sr = Math.sin(d.rotate * cloudRadians), cr = Math.cos(d.rotate * cloudRadians), wcr = w * cr, wsr = w * sr, hcr = h * cr, hsr = h * sr;
			w = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 31 >> 5 << 5;
			h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
		} else w = w + 31 >> 5 << 5;
		if (h > maxh) maxh = h;
		if (x + w >= cw << 5) {
			x = 0;
			y += maxh;
			maxh = 0;
		}
		if (y + h >= ch) break;
		c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);
		if (d.rotate) c.rotate(d.rotate * cloudRadians);
		c.fillText(d.text, 0, 0);
		if (d.padding) {
			c.lineWidth = 2 * d.padding;
			c.strokeText(d.text, 0, 0);
		}
		c.restore();
		d.width = w;
		d.height = h;
		d.xoff = x;
		d.yoff = y;
		d.x1 = w >> 1;
		d.y1 = h >> 1;
		d.x0 = -d.x1;
		d.y0 = -d.y1;
		d.hasText = true;
		x += w;
	}
	var pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data, sprite = [];
	while (--di >= 0) {
		d = data$2[di];
		if (!d.hasText) continue;
		var w = d.width, w32 = w >> 5;
		var h = d.y1 - d.y0;
		for (var i = 0; i < h * w32; i++) sprite[i] = 0;
		x = d.xoff;
		if (x == null) return;
		y = d.yoff;
		var seen = 0, seenRow = -1;
		for (var j = 0; j < h; j++) {
			for (var i = 0; i < w; i++) {
				var k = w32 * j + (i >> 5), m = pixels[(y + j) * (cw << 5) + (x + i) << 2] ? 1 << 31 - i % 32 : 0;
				sprite[k] |= m;
				seen |= m;
			}
			if (seen) seenRow = j;
			else {
				d.y0++;
				h--;
				j--;
				y++;
			}
		}
		d.y1 = d.y0 + seenRow;
		d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);
	}
}
function cloudCollide(tag, board, sw) {
	sw >>= 5;
	var sprite = tag.sprite, w = tag.width >> 5, lx = tag.x - (w << 4), sx = lx & 127, msx = 32 - sx, h = tag.y1 - tag.y0;
	var x = (tag.y + tag.y0) * sw + (lx >> 5), last$1;
	for (var j = 0; j < h; j++) {
		last$1 = 0;
		for (var i = 0; i <= w; i++) if ((last$1 << msx | (i < w ? (last$1 = sprite[j * w + i]) >>> sx : 0)) & board[x + i]) return true;
		x += sw;
	}
	return false;
}
function cloudBounds(bounds, d) {
	var b0$1 = bounds[0], b1$1 = bounds[1];
	if (d.x + d.x0 < b0$1.x) b0$1.x = d.x + d.x0;
	if (d.y + d.y0 < b0$1.y) b0$1.y = d.y + d.y0;
	if (d.x + d.x1 > b1$1.x) b1$1.x = d.x + d.x1;
	if (d.y + d.y1 > b1$1.y) b1$1.y = d.y + d.y1;
}
function collideRects(a, b) {
	return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;
}
function archimedeanSpiral(size$1) {
	var e = size$1[0] / size$1[1];
	return function(t) {
		return [e * (t *= .1) * Math.cos(t), t * Math.sin(t)];
	};
}
function rectangularSpiral(size$1) {
	var dy = 4, dx = dy * size$1[0] / size$1[1];
	var x = 0, y = 0;
	return function(t) {
		var sign = t < 0 ? -1 : 1;
		switch (Math.sqrt(1 + 4 * sign * t) - sign & 3) {
			case 0:
				x += dx;
				break;
			case 1:
				y += dy;
				break;
			case 2:
				x -= dx;
				break;
			default:
				y -= dy;
				break;
		}
		return [x, y];
	};
}
function zeroArray(n) {
	var a = [];
	var i = -1;
	while (++i < n) a[i] = 0;
	return a;
}
function cloudCanvas() {
	return document.createElement("canvas");
}
function functor(d) {
	return is_function_default(d) ? d : function() {
		return d;
	};
}
var spirals = {
	archimedean: archimedeanSpiral,
	rectangular: rectangularSpiral
};
function tagCloud() {
	var size$1 = [256, 256], font = cloudFont, fontSize = cloudFontSize, fontWeight = cloudFontNormal, rotate$2 = cloudRotate, padding$2 = cloudPadding, spiral = archimedeanSpiral, random = Math.random, words = [], timeInterval = Infinity;
	var text = cloudText;
	var fontStyle = cloudFontNormal;
	var canvas = cloudCanvas;
	var cloud = {};
	cloud.start = function() {
		var width = size$1[0], height = size$1[1];
		var contextAndRatio = getContext(canvas()), board = cloud.board ? cloud.board : zeroArray((size$1[0] >> 5) * size$1[1]), n = words.length, tags = [], data$2 = words.map(function(d, i$1, data$3) {
			d.text = text.call(this, d, i$1, data$3);
			d.font = font.call(this, d, i$1, data$3);
			d.style = fontStyle.call(this, d, i$1, data$3);
			d.weight = fontWeight.call(this, d, i$1, data$3);
			d.rotate = rotate$2.call(this, d, i$1, data$3);
			d.size = ~~fontSize.call(this, d, i$1, data$3);
			d.padding = padding$2.call(this, d, i$1, data$3);
			return d;
		}).sort(function(a, b) {
			return b.size - a.size;
		});
		var i = -1, bounds = !cloud.board ? null : [{
			x: 0,
			y: 0
		}, {
			x: width,
			y: height
		}];
		step();
		function step() {
			var start = Date.now();
			while (Date.now() - start < timeInterval && ++i < n) {
				var d = data$2[i];
				d.x = width * (random() + .5) >> 1;
				d.y = height * (random() + .5) >> 1;
				cloudSprite(contextAndRatio, d, data$2, i);
				if (d.hasText && place$1(board, d, bounds)) {
					tags.push(d);
					if (bounds) {
						if (!cloud.hasImage) cloudBounds(bounds, d);
					} else bounds = [{
						x: d.x + d.x0,
						y: d.y + d.y0
					}, {
						x: d.x + d.x1,
						y: d.y + d.y1
					}];
					d.x -= size$1[0] >> 1;
					d.y -= size$1[1] >> 1;
				}
			}
			cloud._tags = tags;
			cloud._bounds = bounds;
		}
		return cloud;
	};
	function getContext(canvas$1) {
		canvas$1.width = canvas$1.height = 1;
		var ratio = Math.sqrt(canvas$1.getContext("2d", { willReadFrequently: true }).getImageData(0, 0, 1, 1).data.length >> 2);
		canvas$1.width = (cw << 5) / ratio;
		canvas$1.height = ch / ratio;
		var context = canvas$1.getContext("2d", { willReadFrequently: true });
		context.fillStyle = context.strokeStyle = "red";
		context.textAlign = "center";
		return {
			context,
			ratio
		};
	}
	function place$1(board, tag, bounds) {
		var startX = tag.x, startY = tag.y, maxDelta = Math.sqrt(size$1[0] * size$1[0] + size$1[1] * size$1[1]), s = spiral(size$1), dt = random() < .5 ? 1 : -1;
		var dxdy, t = -dt, dx, dy;
		while (dxdy = s(t += dt)) {
			dx = ~~dxdy[0];
			dy = ~~dxdy[1];
			if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta) break;
			tag.x = startX + dx;
			tag.y = startY + dy;
			if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size$1[0] || tag.y + tag.y1 > size$1[1]) continue;
			if (!bounds || !cloudCollide(tag, board, size$1[0])) {
				if (!bounds || collideRects(tag, bounds)) {
					var sprite = tag.sprite, w = tag.width >> 5, sw = size$1[0] >> 5, lx = tag.x - (w << 4), sx = lx & 127, msx = 32 - sx, h = tag.y1 - tag.y0;
					var last$1 = void 0, x = (tag.y + tag.y0) * sw + (lx >> 5);
					for (var j = 0; j < h; j++) {
						last$1 = 0;
						for (var i = 0; i <= w; i++) board[x + i] |= last$1 << msx | (i < w ? (last$1 = sprite[j * w + i]) >>> sx : 0);
						x += sw;
					}
					delete tag.sprite;
					return true;
				}
			}
		}
		return false;
	}
	cloud.createMask = function(img) {
		var can = document.createElement("canvas");
		var width = size$1[0], height = size$1[1];
		if (!width || !height) return;
		var w32 = width >> 5;
		var board = zeroArray((width >> 5) * height);
		can.width = width;
		can.height = height;
		var cxt = can.getContext("2d");
		cxt.drawImage(img, 0, 0, img.width, img.height, 0, 0, width, height);
		var imageData = cxt.getImageData(0, 0, width, height).data;
		for (var j = 0; j < height; j++) for (var i = 0; i < width; i++) {
			var k = w32 * j + (i >> 5);
			var tmp = j * width + i << 2;
			var m = imageData[tmp] >= 250 && imageData[tmp + 1] >= 250 && imageData[tmp + 2] >= 250 ? 1 << 31 - i % 32 : 0;
			board[k] |= m;
		}
		cloud.board = board;
		cloud.hasImage = true;
	};
	cloud.timeInterval = function(_) {
		timeInterval = _ == null ? Infinity : _;
	};
	cloud.words = function(_) {
		words = _;
	};
	cloud.size = function(_) {
		size$1 = [+_[0], +_[1]];
	};
	cloud.font = function(_) {
		font = functor(_);
	};
	cloud.fontWeight = function(_) {
		fontWeight = functor(_);
	};
	cloud.rotate = function(_) {
		rotate$2 = functor(_);
	};
	cloud.spiral = function(_) {
		spiral = spirals[_] || _;
	};
	cloud.fontSize = function(_) {
		fontSize = functor(_);
	};
	cloud.padding = function(_) {
		padding$2 = functor(_);
	};
	cloud.random = function(_) {
		random = functor(_);
	};
	return cloud;
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/word-cloud/utils.js
/**
* 用 DataSet 转换词云图数据
* @param params
*/
function transform(params) {
	var rawOptions = params.options, chart = params.chart;
	var _a$5 = chart, width = _a$5.width, height = _a$5.height, chartPadding = _a$5.padding, appendPadding = _a$5.appendPadding, ele = _a$5.ele;
	var data$2 = rawOptions.data, imageMask = rawOptions.imageMask, wordField = rawOptions.wordField, weightField = rawOptions.weightField, colorField = rawOptions.colorField, wordStyle = rawOptions.wordStyle, timeInterval = rawOptions.timeInterval, random = rawOptions.random, spiral = rawOptions.spiral, _b = rawOptions.autoFit, autoFit = _b === void 0 ? true : _b, placementStrategy = rawOptions.placementStrategy;
	if (!data$2 || !data$2.length) return [];
	var fontFamily = wordStyle.fontFamily, fontWeight = wordStyle.fontWeight, padding$2 = wordStyle.padding, fontSize = wordStyle.fontSize;
	var arr = getSingleKeyValues(data$2, weightField);
	var range = [min(arr), max(arr)];
	var words = data$2.map(function(datum) {
		return {
			text: datum[wordField],
			value: datum[weightField],
			color: datum[colorField],
			datum
		};
	});
	var options = {
		imageMask,
		font: fontFamily,
		fontSize: getFontSizeMapping(fontSize, range),
		fontWeight,
		size: getSize({
			width,
			height,
			padding: chartPadding,
			appendPadding,
			autoFit,
			container: ele
		}),
		padding: padding$2,
		timeInterval,
		random,
		spiral,
		rotate: getRotate(rawOptions)
	};
	if (is_function_default(placementStrategy)) {
		var result = words.map(function(word$1, index, words$1) {
			return __assign(__assign(__assign({}, word$1), {
				hasText: !!word$1.text,
				font: functor(options.font)(word$1, index, words$1),
				weight: functor(options.fontWeight)(word$1, index, words$1),
				rotate: functor(options.rotate)(word$1, index, words$1),
				size: functor(options.fontSize)(word$1, index, words$1),
				style: "normal"
			}), placementStrategy.call(chart, word$1, index, words$1));
		});
		result.push({
			text: "",
			value: 0,
			x: 0,
			y: 0,
			opacity: 0
		});
		result.push({
			text: "",
			value: 0,
			x: options.size[0],
			y: options.size[1],
			opacity: 0
		});
		return result;
	}
	return wordCloud(words, options);
}
/**
* 获取最终的实际绘图尺寸：[width, height]
* @param chart
*/
function getSize(options) {
	var width = options.width, height = options.height;
	var container = options.container, autoFit = options.autoFit, padding$2 = options.padding, appendPadding = options.appendPadding;
	if (autoFit) {
		var containerSize = getContainerSize(container);
		width = containerSize.width;
		height = containerSize.height;
	}
	width = width || 400;
	height = height || 400;
	var _a$5 = resolvePadding({
		padding: padding$2,
		appendPadding
	}), top = _a$5[0], right$1 = _a$5[1], bottom = _a$5[2], left$1 = _a$5[3];
	return [width - (left$1 + right$1), height - (top + bottom)];
}
/**
* 根据图表的 padding 和 appendPadding 计算出图表的最终 padding
* @param chart
*/
function resolvePadding(options) {
	var padding$2 = normalPadding(options.padding);
	var appendPadding = normalPadding(options.appendPadding);
	var top = padding$2[0] + appendPadding[0];
	var right$1 = padding$2[1] + appendPadding[1];
	var bottom = padding$2[2] + appendPadding[2];
	var left$1 = padding$2[3] + appendPadding[3];
	return [
		top,
		right$1,
		bottom,
		left$1
	];
}
/**
* 处理 imageMask 可能为 url 字符串的情况
* @param  {HTMLImageElement | string} img
* @return {Promise}
*/
function processImageMask(img) {
	return new Promise(function(res, rej) {
		if (img instanceof HTMLImageElement) {
			res(img);
			return;
		}
		if (is_string_default(img)) {
			var image_1 = new Image();
			image_1.crossOrigin = "anonymous";
			image_1.src = img;
			image_1.onload = function() {
				res(image_1);
			};
			image_1.onerror = function() {
				log(LEVEL.ERROR, false, "image %s load failed !!!", img);
				rej();
			};
			return;
		}
		log(LEVEL.WARN, img === void 0, "The type of imageMask option must be String or HTMLImageElement.");
		rej();
	});
}
/**
* 把用户提供的 fontSize 值转换成符合 DataSet 要求的值
* @param options
* @param range
*/
function getFontSizeMapping(fontSize, range) {
	if (is_function_default(fontSize)) return fontSize;
	if (is_array_default(fontSize)) {
		var fMin_1 = fontSize[0], fMax_1 = fontSize[1];
		if (!range) return function() {
			return (fMax_1 + fMin_1) / 2;
		};
		var min_1 = range[0], max_1 = range[1];
		if (max_1 === min_1) return function() {
			return (fMax_1 + fMin_1) / 2;
		};
		return function fontSize$1(_a$5) {
			var value$1 = _a$5.value;
			return (fMax_1 - fMin_1) / (max_1 - min_1) * (value$1 - min_1) + fMin_1;
		};
	}
	return function() {
		return fontSize;
	};
}
function getSingleKeyValues(data$2, key) {
	return data$2.map(function(v) {
		return v[key];
	}).filter(function(v) {
		if (typeof v === "number" && !isNaN(v)) return true;
		return false;
	});
}
/**
* 把用户提供的关于旋转角度的字段值转换成符合 DataSet 要求的值
* @param options
*/
function getRotate(options) {
	var _a$5 = resolveRotate(options), rotation = _a$5.rotation, rotationSteps = _a$5.rotationSteps;
	if (!is_array_default(rotation)) return rotation;
	var min$2 = rotation[0];
	var max$2 = rotation[1];
	var perSize = rotationSteps === 1 ? 0 : (max$2 - min$2) / (rotationSteps - 1);
	return function rotate$2() {
		if (max$2 === min$2) return max$2;
		return Math.floor(Math.random() * rotationSteps) * perSize;
	};
}
/**
* 确保值在要求范围内
* @param options
*/
function resolveRotate(options) {
	var rotationSteps = options.wordStyle.rotationSteps;
	if (rotationSteps < 1) {
		log(LEVEL.WARN, false, "The rotationSteps option must be greater than or equal to 1.");
		rotationSteps = 1;
	}
	return {
		rotation: options.wordStyle.rotation,
		rotationSteps
	};
}
/**
* 传入一个元素为数字的数组，
* 返回该数组中值最小的数字。
* @param numbers
*/
function min(numbers) {
	return Math.min.apply(Math, numbers);
}
/**
* 传入一个元素为数字的数组，
* 返回该数组中值最大的数字。
* @param numbers
*/
function max(numbers) {
	return Math.max.apply(Math, numbers);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/word-cloud/adaptor.js
/**
* geometry 配置处理
* @param params
*/
function geometry(params) {
	var chart = params.chart, options = params.options;
	var colorField = options.colorField, color$2 = options.color;
	var data$2 = transform(params);
	chart.data(data$2);
	var p = deepAssign({}, params, { options: {
		xField: "x",
		yField: "y",
		seriesField: colorField && WORD_CLOUD_COLOR_FIELD,
		rawFields: is_function_default(color$2) && __spreadArray(__spreadArray([], get_default(options, "rawFields", []), true), ["datum"], false),
		point: {
			color: color$2,
			shape: "word-cloud"
		}
	} });
	point(p).ext.geometry.label(false);
	chart.coordinate().reflect("y");
	chart.axis(false);
	return params;
}
/**
* meta 配置
* @param params
*/
function meta(params) {
	return flow(scale({
		x: { nice: false },
		y: { nice: false }
	}))(params);
}
/**
* 词云图 legend 配置
* @param params
*/
function legend$1(params) {
	var chart = params.chart, options = params.options;
	var legend$17 = options.legend, colorField = options.colorField;
	if (legend$17 === false) chart.legend(false);
	else if (colorField) chart.legend(WORD_CLOUD_COLOR_FIELD, legend$17);
	return params;
}
/**
* 词云图适配器
* @param chart
* @param options
*/
function adaptor(params) {
	flow(geometry, meta, tooltip, legend$1, interaction, animation, theme, state)(params);
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/word-cloud/shapes/word-cloud.js
registerShape("point", "word-cloud", { draw: function(cfg, group$1) {
	var cx = cfg.x;
	var cy = cfg.y;
	var shape = group$1.addShape("text", { attrs: __assign(__assign({}, getTextAttrs(cfg)), {
		x: cx,
		y: cy
	}) });
	var rotate$2 = cfg.data.rotate;
	if (typeof rotate$2 === "number") Util.rotate(shape, rotate$2 * Math.PI / 180);
	return shape;
} });
function getTextAttrs(cfg) {
	return {
		fontSize: cfg.data.size,
		text: cfg.data.text,
		textAlign: "center",
		fontFamily: cfg.data.font,
		fontWeight: cfg.data.weight,
		fill: cfg.color || cfg.defaultStyle.stroke,
		textBaseline: "alphabetic"
	};
}

//#endregion
//#region node_modules/@antv/g2plot/esm/plots/word-cloud/index.js
var WordCloud = function(_super) {
	__extends(WordCloud$1, _super);
	function WordCloud$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		/** 词云图 */
		_this.type = "word-cloud";
		return _this;
	}
	/**
	* 获取 词云图 默认配置项
	* 供外部使用
	*/
	WordCloud$1.getDefaultOptions = function() {
		return DEFAULT_OPTIONS;
	};
	/**
	* @override
	* @param data
	*/
	WordCloud$1.prototype.changeData = function(data$2) {
		this.updateOption({ data: data$2 });
		if (this.options.imageMask) this.render();
		else this.chart.changeData(transform({
			chart: this.chart,
			options: this.options
		}));
	};
	/**
	* 获取默认的 options 配置项
	*/
	WordCloud$1.prototype.getDefaultOptions = function() {
		return WordCloud$1.getDefaultOptions();
	};
	/**
	* 覆写父类方法，词云图需要加载图片资源，所以需要异步渲染
	*/
	WordCloud$1.prototype.render = function() {
		var _this = this;
		return new Promise(function(res) {
			var imageMask = _this.options.imageMask;
			if (!imageMask) {
				_super.prototype.render.call(_this);
				res();
				return;
			}
			var handler = function(img) {
				_this.options = __assign(__assign({}, _this.options), { imageMask: img || null });
				_super.prototype.render.call(_this);
				res();
			};
			processImageMask(imageMask).then(handler).catch(handler);
		});
	};
	/**
	* 获取 词云图 的适配器
	*/
	WordCloud$1.prototype.getSchemaAdaptor = function() {
		return adaptor;
	};
	/**
	* 覆写父类的方法，因为词云图使用 单独的函数 进行布局，原理上有些不一样
	*/
	WordCloud$1.prototype.triggerResize = function() {
		var _this = this;
		if (!this.chart.destroyed) {
			this.execAdaptor();
			window.setTimeout(function() {
				_super.prototype.triggerResize.call(_this);
			});
		}
	};
	return WordCloud$1;
}(Plot);

//#endregion
//#region node_modules/@antv/g2plot/esm/plugin/index.js
/**
* 给 G2Plot 提供非常简单的开放开发的机制。目的是能够让社区和业务上自己基于 G2Plot 开发自己的定制图表库。主要分成几类图表：
* 1. 领域专业的图表，内部同学因为没有场景，不一定能做的完善。
* 2. 定制业务的图表，不具备通用性
* 3. 趣味性的可视化组件
* 然后官方可以根据社区的情况，可以进行一些官方推荐和采纳。
*
* 如果使用？
*
* ```ts
* import { P } from '@antv/g2plot';
* import { GeoWorldMap, GeoWorldMapOptions } from 'g2plot-geo-world-map';
*
* const plot = new P('container', {
*   geoJson: '',
*   longitude: '',
*   latitude: '',
* }, GeoWorldMap, defaultOptions);
*
* plot.render();
* ```
*/
var P = function(_super) {
	__extends(P$1, _super);
	/**
	* 相比普通图表增加 adaptor 参数。
	* @param container
	* @param options
	* @param adaptor
	* @param defaultOptions
	*/
	function P$1(container, options, adaptor$35, defaultOptions$7) {
		var _this = _super.call(this, container, deepAssign({}, defaultOptions$7, options)) || this;
		/** 统一为 any plot */
		_this.type = "g2-plot";
		_this.defaultOptions = defaultOptions$7;
		_this.adaptor = adaptor$35;
		return _this;
	}
	/**
	* 实现父类方法，直接使用传入的
	*/
	P$1.prototype.getDefaultOptions = function() {
		return this.defaultOptions;
	};
	/**
	* 实现父类方法，直接使用传入的
	*/
	P$1.prototype.getSchemaAdaptor = function() {
		return this.adaptor;
	};
	return P$1;
}(Plot);

//#endregion
//#region node_modules/@antv/g2plot/esm/index.js
var version = "2.4.35";
/** default locale register */
registerLocale("en-US", EN_US_LOCALE);
registerLocale("zh-CN", ZH_CN_LOCALE);
var adaptors = {
	scale,
	legend,
	tooltip,
	annotation,
	interaction,
	theme,
	animation
};

//#endregion
export { Area, Bar, BidirectionalBar, Box, Bullet, Chord, CirclePacking, Column, DualAxes, FUNNEL_CONVERSATION as FUNNEL_CONVERSATION_FIELD, Facet, Funnel, esm_exports as G2, Gauge, Heatmap, Histogram, Lab, Line, Liquid, Mix, Mix as MultiView, P, Pie, Plot, Progress, Radar, RadialBar, RingProgress, Rose, Sankey, Scatter, Stock, Sunburst, TinyArea, TinyColumn, TinyLine, Treemap, Venn, Violin, Waterfall, WordCloud, adaptors, addWaterWave, area, flow, getCanvasPattern, interval, line, measureTextWidth, point, polygon, registerLocale, schema, setGlobal, version };
//# sourceMappingURL=@antv_g2plot.js.map