import * as vue from 'vue';
import { UnwrapRef } from 'vue';
import { CloneFn } from './cloned.js';
import './shared.js';

interface UseVModelOptions<T> {
    /**
       * When passive is set to `true`, it will use `watch` to sync with props and ref.
       * Instead of relying on the `v-model` or `.sync` to work.
       *
       * @default false
       */
    passive?: boolean;
    /**
       * When eventName is set, it's value will be used to overwrite the emit event name.
       *
       * @default undefined
       */
    eventName?: string;
    /**
       * Attempting to check for changes of properties in a deeply nested object or array.
       * Apply only when `passive` option is set to `true`
       *
       * @default false
       */
    deep?: boolean;
    /**
       * Defining default value for return ref when no value is passed.
       *
       * @default undefined
       */
    defaultValue?: T;
    /**
       * Clone the props.
       * Accepts a custom clone function.
       * When setting to `true`, it will use `JSON.parse(JSON.stringify(value))` to clone.
       *
       * @default false
       */
    clone?: boolean | CloneFn<T>;
}
/**
 * Shorthand for v-model binding, props + emit -> ref
 *
 * @see https://vueuse.org/useVModel
 * @param props
 * @param key (default 'value' in Vue 2 and 'modelValue' in Vue 3)
 * @param emit
 */
declare function useVModel<P extends object, K extends keyof P, Name extends string>(props: P, key?: K, emit?: (name: Name, ...args: any[]) => void, options?: UseVModelOptions<P[K]>): vue.Ref<UnwrapRef<P[K]>> | vue.WritableComputedRef<P[K]>;

export { UseVModelOptions, useVModel };
