import { Ref, ComputedRef, WatchOptions, WatchSource } from 'vue';

/**
 * Void function
 */
type Fn = () => void;
/**
 * Any function
 */
type AnyFn = (...args: any[]) => any;
/**
 * A ref that allow to set null or undefined
 */
type RemovableRef<T> = Omit<Ref<T>, 'value'> & {
    get value(): T;
    set value(value: T | null | undefined);
};
/**
 * Maybe it's a ref, or a plain value
 *
 * ```ts
 * type MaybeRef<T> = T | Ref<T>
 * ```
 */
type MaybeRef<T> = T | Ref<T>;
/**
 * Maybe it's a ref, or a plain value, or a getter function
 *
 * ```ts
 * type MaybeComputedRef<T> = (() => T) | T | Ref<T> | ComputedRef<T>
 * ```
 */
type MaybeComputedRef<T> = MaybeReadonlyRef<T> | MaybeRef<T>;
/**
 * Maybe it's a computed ref, or a getter function
 *
 * ```ts
 * type MaybeReadonlyRef<T> = (() => T) | ComputedRef<T>
 * ```
 */
type MaybeReadonlyRef<T> = (() => T) | ComputedRef<T>;
/**
 * Make all the nested attributes of an object or array to MaybeRef<T>
 *
 * Good for accepting options that will be wrapped with `reactive` or `ref`
 *
 * ```ts
 * UnwrapRef<DeepMaybeRef<T>> === T
 * ```
 */
type DeepMaybeRef<T> = T extends Ref<infer V> ? MaybeRef<V> : T extends Array<any> | object ? {
    [K in keyof T]: DeepMaybeRef<T[K]>;
} : MaybeRef<T>;
type Arrayable<T> = T[] | T;
/**
 * Infers the element type of an array
 */
type ElementOf<T> = T extends (infer E)[] ? E : never;
type ShallowUnwrapRef<T> = T extends Ref<infer P> ? P : T;
type Awaitable<T> = Promise<T> | T;
type ArgumentsType<T> = T extends (...args: infer U) => any ? U : never;
type PromisifyFn<T extends AnyFn> = (...args: ArgumentsType<T>) => Promise<ReturnType<T>>;
interface Pausable {
    /**
       * A ref indicate whether a pausable instance is active
       */
    isActive: Readonly<Ref<boolean>>;
    /**
       * Temporary pause the effect from executing
       */
    pause: Fn;
    /**
       * Resume the effects
       */
    resume: Fn;
}
interface Stoppable<StartFnArgs extends any[] = any[]> {
    /**
       * A ref indicate whether a stoppable instance is executing
       */
    isPending: Readonly<Ref<boolean>>;
    /**
       * Stop the effect from executing
       */
    stop: Fn;
    /**
       * Start the effects
       */
    start: (...args: StartFnArgs) => void;
}
interface ConfigurableFlush {
    /**
       * Timing for monitoring changes, refer to WatchOptions for more details
       *
       * @default 'pre'
       */
    flush?: WatchOptions['flush'];
}
interface ConfigurableFlushSync {
    /**
       * Timing for monitoring changes, refer to WatchOptions for more details.
       * Unlike `watch()`, the default is set to `sync`
       *
       * @default 'sync'
       */
    flush?: WatchOptions['flush'];
}
type MapSources<T> = {
    [K in keyof T]: T[K] extends WatchSource<infer V> ? V : never;
};
type MapOldSources<T, Immediate> = {
    [K in keyof T]: T[K] extends WatchSource<infer V> ? Immediate extends true ? V | undefined : V : never;
};

export { AnyFn, ArgumentsType, Arrayable, Awaitable, ConfigurableFlush, ConfigurableFlushSync, DeepMaybeRef, ElementOf, Fn, MapOldSources, MapSources, MaybeComputedRef, MaybeReadonlyRef, MaybeRef, Pausable, PromisifyFn, RemovableRef, ShallowUnwrapRef, Stoppable };
