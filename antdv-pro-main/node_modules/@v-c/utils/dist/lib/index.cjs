var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/lib/index.ts
var lib_exports = {};
__export(lib_exports, {
  canUseDom: () => can_use_dom_default,
  classNames: () => class_names_default,
  createGlobalState: () => createGlobalState,
  createInjectionState: () => createInjectionState,
  createSharedComposable: () => createSharedComposable,
  delayTimer: () => delayTimer,
  safeNextick: () => safeNextick,
  tryOnScopeDispose: () => tryOnScopeDispose,
  useClipboard: () => useClipboard,
  useCloned: () => useCloned,
  useState: () => useState,
  useVModel: () => useVModel
});
module.exports = __toCommonJS(lib_exports);

// src/lib/hooks/cloned.ts
var import_vue = require("vue");
function cloneFnJSON(source) {
  return JSON.parse(JSON.stringify(source));
}
function useCloned(source, options = {}) {
  const cloned = (0, import_vue.ref)({});
  const {
    manual,
    clone = cloneFnJSON,
    // watch options
    deep = true,
    immediate = true
  } = options;
  function sync() {
    cloned.value = clone((0, import_vue.unref)(source));
  }
  if (!manual && (0, import_vue.isRef)(source)) {
    (0, import_vue.watch)(source, sync, {
      ...options,
      deep,
      immediate
    });
  } else {
    sync();
  }
  return { cloned, sync };
}

// src/lib/hooks/v-model.ts
var import_vue2 = require("vue");

// src/base.ts
var isString = (val) => typeof val === "string";
var isFunction = (val) => typeof val === "function";
var isArray = (val) => Array.isArray(val);
var isDef = (val) => typeof val !== "undefined";
var isObject = (val) => Object.prototype.toString.call(val) === "[object Object]";

// src/lib/hooks/v-model.ts
function useVModel(props, key, emit, options = {}) {
  const {
    clone = false,
    passive = false,
    eventName,
    deep = false,
    defaultValue
  } = options;
  const vm = (0, import_vue2.getCurrentInstance)();
  const _emit = emit || vm?.emit || vm?.$emit?.bind(vm) || vm?.proxy?.$emit?.bind(vm?.proxy);
  let event = eventName;
  if (!key)
    key = "modelValue";
  event = eventName || event || `update:${key.toString()}`;
  const cloneFn = (val) => !clone ? val : isFunction(clone) ? clone(val) : cloneFnJSON(val);
  const getValue = () => isDef(props[key]) ? cloneFn(props[key]) : defaultValue;
  if (passive) {
    const initialValue = getValue();
    const proxy = (0, import_vue2.ref)(initialValue);
    (0, import_vue2.watch)(
      () => props[key],
      (v) => proxy.value = cloneFn(v)
    );
    (0, import_vue2.watch)(
      proxy,
      (v) => {
        if (v !== props[key] || deep)
          _emit(event, v);
      },
      { deep }
    );
    return proxy;
  } else {
    return (0, import_vue2.computed)({
      get() {
        return getValue();
      },
      set(value) {
        _emit(event, value);
      }
    });
  }
}

// src/lib/hooks/state.ts
var import_vue3 = require("vue");
var useState = (defaultValue) => {
  const destroyRef = (0, import_vue3.ref)(false);
  const state = (0, import_vue3.ref)();
  if (isFunction(defaultValue))
    state.value = defaultValue();
  else
    state.value = defaultValue;
  (0, import_vue3.onMounted)(() => {
    destroyRef.value = false;
  });
  (0, import_vue3.onBeforeUnmount)(() => {
    destroyRef.value = true;
  });
  const safeSetState = (nextValue, ignoreDestroy = false) => {
    if (ignoreDestroy && destroyRef.value)
      return;
    if (isFunction(nextValue))
      state.value = nextValue(state.value);
    else
      state.value = nextValue;
  };
  return [state, safeSetState];
};

// src/lib/hooks/clipboard.ts
var import_vue4 = require("vue");

// src/lib/clipboard.ts
function makeError() {
  return new DOMException("The request is not allowed", "NotAllowedError");
}
async function copyClipboardApi(text) {
  if (!navigator.clipboard)
    throw makeError();
  return navigator.clipboard.writeText(text);
}
async function copyExecCommand(text) {
  const span = document.createElement("span");
  span.textContent = text;
  span.style.whiteSpace = "pre";
  span.style.webkitUserSelect = "auto";
  span.style.userSelect = "all";
  document.body.appendChild(span);
  const selection = window.getSelection();
  const range = window.document.createRange();
  selection.removeAllRanges();
  range.selectNode(span);
  selection.addRange(range);
  let success = false;
  try {
    success = window.document.execCommand("copy");
  } finally {
    selection.removeAllRanges();
    window.document.body.removeChild(span);
  }
  if (!success)
    throw makeError();
}
async function clipboardCopy(text) {
  try {
    await copyClipboardApi(text);
  } catch (err) {
    try {
      await copyExecCommand(text);
    } catch (err2) {
      throw err2 || err || makeError();
    }
  }
}

// src/lib/hooks/clipboard.ts
var useClipboard = (delay = 3e3) => {
  const copied = (0, import_vue4.ref)(false);
  const copy = (text) => {
    const copyText = (0, import_vue4.unref)(text);
    clipboardCopy(copyText).then(() => {
      copied.value = true;
      const timer = setTimeout(() => {
        copied.value = false;
        clearTimeout(timer);
      }, delay);
    });
  };
  return {
    copied,
    copy
  };
};

// src/lib/hooks/create-injection-state.ts
var import_vue5 = require("vue");
function createInjectionState(composable) {
  const key = Symbol("InjectionState");
  const useProvidingState = (...args) => {
    const state = composable(...args);
    (0, import_vue5.provide)(key, state);
    return state;
  };
  const useInjectedState = (defaultState) => (0, import_vue5.inject)(key, defaultState);
  return [useProvidingState, useInjectedState];
}

// src/lib/can-use-dom.ts
function canUseDom() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
var can_use_dom_default = canUseDom;

// src/lib/class-names.ts
function classNames(...args) {
  const classes = [];
  for (let i = 0; i < args.length; i++) {
    const value = args[i];
    if (!value)
      continue;
    if (isString(value)) {
      classes.push(value);
    } else if (isArray(value)) {
      for (let i2 = 0; i2 < value.length; i2++) {
        const inner = classNames(value[i2]);
        if (inner)
          classes.push(inner);
      }
    } else if (isObject(value)) {
      for (const name in value) {
        if (value[name])
          classes.push(name);
      }
    }
  }
  return classes.join(" ");
}
var class_names_default = classNames;

// src/lib/safe-next-tick.ts
var delayTimer = async (delay = 0) => {
  return new Promise((resolve) => {
    const timer = setTimeout(() => {
      resolve(true);
      clearTimeout(timer);
    }, delay);
  });
};
async function safeNextick(fn, option) {
  await delayTimer(option?.delay);
  if (fn && isFunction(fn))
    fn();
}

// src/lib/hooks/create-global-state.ts
var import_vue6 = require("vue");
function createGlobalState(stateFactory) {
  let initialized = false;
  let state;
  const scope = (0, import_vue6.effectScope)(true);
  return () => {
    if (!initialized) {
      state = scope.run(stateFactory);
      initialized = true;
    }
    return state;
  };
}

// src/lib/hooks/create-shared-composable.ts
var import_vue8 = require("vue");

// src/lib/hooks/try-on-scope-dispose.ts
var import_vue7 = require("vue");
function tryOnScopeDispose(fn) {
  if ((0, import_vue7.getCurrentScope)()) {
    (0, import_vue7.onScopeDispose)(fn);
    return true;
  }
  return false;
}

// src/lib/hooks/create-shared-composable.ts
function createSharedComposable(composable) {
  let subscribers = 0;
  let state;
  let scope;
  const dispose = () => {
    subscribers -= 1;
    if (scope && subscribers <= 0) {
      scope.stop();
      state = void 0;
      scope = void 0;
    }
  };
  return (...args) => {
    subscribers += 1;
    if (!state) {
      scope = (0, import_vue8.effectScope)(true);
      state = scope.run(() => composable(...args));
    }
    tryOnScopeDispose(dispose);
    return state;
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  canUseDom,
  classNames,
  createGlobalState,
  createInjectionState,
  createSharedComposable,
  delayTimer,
  safeNextick,
  tryOnScopeDispose,
  useClipboard,
  useCloned,
  useState,
  useVModel
});
