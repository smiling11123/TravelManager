import {
  can_use_dom_default
} from "./chunk-QJ2CZK2Z.js";
import {
  contains
} from "./chunk-HN3FVSOV.js";

// src/dom/dynamic-css.ts
var APPEND_ORDER = "data-vc-order";
var MARK_KEY = "vc-util-key";
var containerCache = /* @__PURE__ */ new Map();
function getMark({ mark } = {}) {
  if (mark)
    return mark.startsWith("data-") ? mark : `data-${mark}`;
  return MARK_KEY;
}
function getContainer(option) {
  if (option.attachTo)
    return option.attachTo;
  const head = document.querySelector("head");
  return head || document.body;
}
function getOrder(prepend) {
  if (prepend === "queue")
    return "prependQueue";
  return prepend ? "prepend" : "append";
}
function findStyles(container) {
  return Array.from(
    (containerCache.get(container) || container).children
  ).filter((node) => node.tagName === "STYLE");
}
function injectCSS(css, option = {}) {
  if (!can_use_dom_default())
    return null;
  const { csp, prepend } = option;
  const styleNode = document.createElement("style");
  styleNode.setAttribute(APPEND_ORDER, getOrder(prepend));
  if (csp?.nonce)
    styleNode.nonce = csp?.nonce;
  styleNode.innerHTML = css;
  const container = getContainer(option);
  const { firstChild } = container;
  if (prepend) {
    if (prepend === "queue") {
      const existStyle = findStyles(container).filter(
        (node) => ["prepend", "prependQueue"].includes(node.getAttribute(APPEND_ORDER))
      );
      if (existStyle.length) {
        container.insertBefore(
          styleNode,
          existStyle[existStyle.length - 1].nextSibling
        );
        return styleNode;
      }
    }
    container.insertBefore(styleNode, firstChild);
  } else {
    container.appendChild(styleNode);
  }
  return styleNode;
}
function findExistNode(key, option = {}) {
  const container = getContainer(option);
  return findStyles(container).find(
    (node) => node.getAttribute(getMark(option)) === key
  );
}
function removeCSS(key, option = {}) {
  const existNode = findExistNode(key, option);
  if (existNode) {
    const container = getContainer(option);
    container.removeChild(existNode);
  }
}
function syncRealContainer(container, option) {
  const cachedRealContainer = containerCache.get(container);
  if (!cachedRealContainer || !contains(document, cachedRealContainer)) {
    const placeholderStyle = injectCSS("", option);
    const { parentNode } = placeholderStyle;
    containerCache.set(container, parentNode);
    container.removeChild(placeholderStyle);
  }
}
function clearContainerCache() {
  containerCache.clear();
}
function updateCSS(css, key, option = {}) {
  const container = getContainer(option);
  syncRealContainer(container, option);
  const existNode = findExistNode(key, option);
  if (existNode) {
    if (option.csp?.nonce && existNode.nonce !== option.csp?.nonce)
      existNode.nonce = option.csp?.nonce;
    if (existNode.innerHTML !== css)
      existNode.innerHTML = css;
    return existNode;
  }
  const newNode = injectCSS(css, option);
  newNode.setAttribute(getMark(option), key);
  return newNode;
}

export {
  injectCSS,
  removeCSS,
  clearContainerCache,
  updateCSS
};
