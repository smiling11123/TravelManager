import {
  isBaseType
} from "./chunk-AHWDZYGD.js";
import {
  cloneDeep
} from "./chunk-DZXUIR45.js";

// src/get.ts
var get = (obj, key) => {
  if (!obj)
    return void 0;
  const info = obj[key];
  const keys = key.split(".");
  if (info)
    return info;
  if (keys.length === 1)
    return void 0;
  const popKeys = cloneDeep(keys);
  let objData;
  const objKeys = [];
  while (popKeys.length > 0) {
    const keyInfo = popKeys.pop();
    objKeys.unshift(keyInfo);
    const popKey = popKeys.join(".");
    const popInfo = obj[popKey];
    if (popInfo) {
      objData = popInfo;
      break;
    }
  }
  if (!objData)
    return void 0;
  if (objKeys.length === 1)
    return objData[objKeys[0]];
  const allKey = objKeys.join(".");
  const allData = objData[allKey];
  if (allData && isBaseType(allData))
    return allData;
  if (!objData[objKeys[0]])
    return get(objData, objKeys.join("."));
  while (objKeys.length > 1) {
    const firstKey = objKeys.shift();
    const info2 = objData[firstKey];
    if (info2 && isBaseType(info2))
      return info2;
    if (info2 && typeof info2 === "object")
      return get(info2, objKeys.join("."));
    if (objKeys.length === 0)
      break;
  }
  return info;
};
var getArr = (entity, path) => {
  let current = entity;
  for (let i = 0; i < path.length; i += 1) {
    if (current === null || current === void 0)
      return void 0;
    current = current[path[i]];
  }
  return current;
};

// src/set.ts
function internalSet(entity, paths, value, removeIfUndefined) {
  if (!paths.length)
    return value;
  const [path, ...restPath] = paths;
  let clone;
  if (!entity && typeof path === "number")
    clone = [];
  else if (Array.isArray(entity))
    clone = [...entity];
  else
    clone = { ...entity };
  if (removeIfUndefined && value === void 0 && restPath.length === 1)
    delete clone[path][restPath[0]];
  else
    clone[path] = internalSet(clone[path], restPath, value, removeIfUndefined);
  return clone;
}
function set(entity, paths, value, removeIfUndefined = false) {
  if (paths.length && removeIfUndefined && value === void 0 && !getArr(entity, paths.slice(0, -1)))
    return entity;
  return internalSet(entity, paths, value, removeIfUndefined);
}
function isObject(obj) {
  return typeof obj === "object" && obj !== null && Object.getPrototypeOf(obj) === Object.prototype;
}
function createEmpty(source) {
  return Array.isArray(source) ? [] : {};
}
function merge(...sources) {
  let clone = createEmpty(sources[0]);
  sources.forEach((src) => {
    const loopSet = /* @__PURE__ */ new Set();
    function internalMerge(path) {
      const value = getArr(src, path);
      const isArr = Array.isArray(value);
      if (isArr || isObject(value)) {
        if (!loopSet.has(value)) {
          loopSet.add(value);
          const originValue = getArr(clone, path);
          if (isArr) {
            clone = set(clone, path, []);
          } else if (!originValue || typeof originValue !== "object") {
            clone = set(clone, path, createEmpty(value));
          }
          Object.keys(value).forEach((key) => {
            internalMerge([...path, key]);
          });
        }
      } else {
        clone = set(clone, path, value);
      }
    }
    internalMerge([]);
  });
  return clone;
}

export {
  set,
  merge,
  get,
  getArr
};
