var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/hook/use-frame.ts
var use_frame_exports = {};
__export(use_frame_exports, {
  useLayoutState: () => useLayoutState,
  useTimeoutLock: () => useTimeoutLock
});
module.exports = __toCommonJS(use_frame_exports);
var import_vue = require("vue");

// src/raf.ts
var raf = (callback) => setTimeout(callback, 16);
var caf = (num) => clearTimeout(num);
if (typeof window !== "undefined" && "requestAnimationFrame" in window) {
  raf = (callback) => window.requestAnimationFrame(callback);
  caf = (handle) => window.cancelAnimationFrame(handle);
}
var rafUUID = 0;
var rafIds = /* @__PURE__ */ new Map();
function cleanup(id) {
  rafIds.delete(id);
}
function wrapperRaf(callback, times = 1) {
  rafUUID += 1;
  const id = rafUUID;
  function callRef(leftTimes) {
    if (leftTimes === 0) {
      cleanup(id);
      callback();
    } else {
      const realId = raf(() => {
        callRef(leftTimes - 1);
      });
      rafIds.set(id, realId);
    }
  }
  callRef(times);
  return id;
}
wrapperRaf.cancel = (id) => {
  const realId = rafIds.get(id);
  cleanup(realId);
  return caf(realId);
};

// src/hook/use-frame.ts
function useLayoutState(defaultState) {
  const stateRef = (0, import_vue.shallowRef)(defaultState);
  let rafId;
  const updateBatchRef = (0, import_vue.shallowRef)([]);
  function setFrameState(updater) {
    updateBatchRef.value.push(updater);
    wrapperRaf.cancel(rafId);
    rafId = wrapperRaf(() => {
      const prevBatch = updateBatchRef.value;
      updateBatchRef.value = [];
      prevBatch.forEach((batchUpdater) => {
        stateRef.value = batchUpdater(stateRef.value);
      });
    });
  }
  (0, import_vue.onBeforeUnmount)(() => {
    wrapperRaf.cancel(rafId);
  });
  return [stateRef, setFrameState];
}
function useTimeoutLock(defaultState) {
  const frameRef = (0, import_vue.ref)(defaultState || null);
  const timeoutRef = (0, import_vue.ref)();
  function cleanUp() {
    clearTimeout(timeoutRef.value);
  }
  function setState(newState) {
    frameRef.value = newState;
    cleanUp();
    timeoutRef.value = setTimeout(() => {
      frameRef.value = null;
      timeoutRef.value = void 0;
    }, 100);
  }
  function getState() {
    return frameRef.value;
  }
  (0, import_vue.onBeforeUnmount)(() => {
    cleanUp();
  });
  return [setState, getState];
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  useLayoutState,
  useTimeoutLock
});
