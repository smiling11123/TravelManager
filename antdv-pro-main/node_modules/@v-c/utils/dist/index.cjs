var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  KeyCode: () => key_code_default,
  addClass: () => addClass,
  animation: () => animation,
  anyType: () => anyType,
  arrayType: () => arrayType,
  backLastFocusNode: () => backLastFocusNode,
  booleanType: () => booleanType,
  call: () => call,
  canUseDom: () => can_use_dom_default,
  classNames: () => class_names_default,
  clearContainerCache: () => clearContainerCache,
  clearLastFocusNode: () => clearLastFocusNode,
  cloneDeep: () => import_lodash.default,
  contains: () => contains,
  createGlobalState: () => createGlobalState,
  createInjectionState: () => createInjectionState,
  createSharedComposable: () => createSharedComposable,
  delayTimer: () => delayTimer,
  eventType: () => eventType,
  filterEmpty: () => filterEmpty,
  findDOMNode: () => find_dom_node_default,
  findDomNode: () => find_dom_node_default,
  flatten: () => flatten,
  functionType: () => functionType,
  get: () => get,
  getArr: () => getArr,
  getClientSize: () => getClientSize,
  getCss: () => getCss,
  getDocSize: () => getDocSize,
  getEventValue: () => getEventValue,
  getFocusNodeList: () => getFocusNodeList,
  getOffset: () => getOffset,
  getOuterHeight: () => getOuterHeight,
  getOuterWidth: () => getOuterWidth,
  getScroll: () => getScroll,
  getSlot: () => getSlot,
  getSlotsProps: () => getSlotsProps,
  hasClass: () => hasClass,
  hasSlotProps: () => hasSlotProps,
  injectCSS: () => injectCSS,
  isArray: () => isArray,
  isBaseType: () => isBaseType,
  isBoolean: () => isBoolean,
  isDate: () => isDate,
  isDef: () => isDef,
  isEmptyElement: () => isEmptyElement,
  isEqual: () => import_lodash2.default,
  isFunction: () => isFunction,
  isNodeVShowFalse: () => isNodeVShowFalse,
  isNull: () => isNull,
  isNumber: () => isNumber,
  isObject: () => isObject,
  isString: () => isString,
  isStyleSupport: () => isStyleSupport,
  isSymbol: () => isSymbol,
  isUndefined: () => isUndefined,
  isUrl: () => isUrl,
  isValidElement: () => isValidElement,
  isVisible: () => is_visible_default,
  limitTabRange: () => limitTabRange,
  merge: () => import_lodash3.default,
  note: () => note,
  noteOnce: () => noteOnce,
  numberType: () => numberType,
  objectType: () => objectType,
  omit: () => omit,
  pick: () => pick,
  raf: () => wrapperRaf,
  removeCSS: () => removeCSS,
  removeClass: () => removeClass,
  resetWarned: () => resetWarned,
  runAsyncEvent: () => runAsyncEvent,
  runEvent: () => runEvent,
  safeNextick: () => safeNextick,
  saveLastFocusNode: () => saveLastFocusNode,
  set: () => set,
  setCss: () => setCss,
  someType: () => someType,
  stringType: () => stringType,
  styleNames: () => styleNames,
  toArray: () => toArray,
  transition: () => transition,
  tryOnScopeDispose: () => tryOnScopeDispose,
  tuple: () => tuple,
  tupleArr: () => tupleArr,
  tupleNum: () => tupleNum,
  tupleNumArr: () => tupleNumArr,
  updateCSS: () => updateCSS,
  useClipboard: () => useClipboard,
  useCloned: () => useCloned,
  useState: () => useState,
  useVModel: () => useVModel,
  vNodeType: () => vNodeType,
  warning: () => warning,
  warningOnce: () => warningOnce
});
module.exports = __toCommonJS(src_exports);

// src/base.ts
var isString = (val) => typeof val === "string";
var isNumber = (val) => typeof val === "number";
var isBoolean = (val) => typeof val === "boolean";
var isFunction = (val) => typeof val === "function";
var isArray = (val) => Array.isArray(val);
var isUndefined = (val) => typeof val === "undefined";
var isDef = (val) => typeof val !== "undefined";
var isNull = (val) => val === null;
var isSymbol = (val) => typeof val === "symbol";
var isObject = (val) => Object.prototype.toString.call(val) === "[object Object]";
var isDate = (val) => Object.prototype.toString.call(val) === "[object Date]";
var isBaseType = (val) => {
  return isString(val) || isNumber(val) || isBoolean(val) || isSymbol(val) || isUndefined(val) || isNull(val);
};
var tuple = (...args) => args;
var tupleNum = (...args) => args;
function pick(obj, keys = [], rest) {
  const newObj = {};
  const names = Object.getOwnPropertyNames(obj);
  names.forEach((name) => {
    if (keys.includes(name))
      newObj[name] = obj[name];
  });
  return Object.assign(newObj, rest);
}
function omit(object, keys = [], rest) {
  if (object === null || object === void 0)
    return rest || object;
  const omitedObject = {};
  const originalKeys = Object.getOwnPropertyNames(object);
  originalKeys.forEach((originalKey) => {
    if (!keys.includes(originalKey))
      omitedObject[originalKey] = object[originalKey];
  });
  return Object.assign(omitedObject, rest);
}
var isUrl = (val) => {
  const reg = /^(https?|mailto|tel|file):/;
  return reg.test(val);
};
var tupleArr = (...args) => args;
var tupleNumArr = (...args) => args;
var toArray = (val) => {
  return isArray(val) ? val : [val];
};

// src/type-util.ts
function stringType(defaultVal) {
  return {
    type: String,
    default: defaultVal
  };
}
function numberType(defaultVal) {
  return {
    type: Number,
    default: defaultVal
  };
}
function booleanType(defaultVal) {
  return {
    type: Boolean,
    default: defaultVal
  };
}
function arrayType(defaultVal) {
  return {
    type: Array,
    default: defaultVal
  };
}
function objectType(defaultVal) {
  return {
    type: Object,
    default: defaultVal
  };
}
function functionType(defaultVal) {
  return {
    type: Function,
    default: defaultVal
  };
}
function anyType(defaultVal, required) {
  const type = { validator: () => true, default: defaultVal };
  return required ? type : type;
}
function vNodeType() {
  return { validator: () => true };
}
function someType(types, defaultVal) {
  return types ? { type: types, default: defaultVal } : anyType(defaultVal);
}
function eventType() {
  return { type: [Function, Array] };
}
function runEvent(event, ...args) {
  if (typeof event === "function")
    return event(...args);
  else if (Array.isArray(event))
    return event.map((e) => e(...args));
}
async function runAsyncEvent(event, ...args) {
  if (typeof event === "function")
    return await event(...args);
  else if (Array.isArray(event))
    return await Promise.all(event.map((e) => e(...args)));
}
function getEventValue(result, index = 0) {
  if (Array.isArray(result))
    return result[index];
  return result;
}

// src/vnode.ts
var import_vue = require("vue");
var getSlotsProps = (slots, props, key, ...args) => {
  if (key in slots && isFunction(slots[key])) {
    const slot = slots[key];
    return slot?.(...args);
  }
  if (key in props) {
    const prop = props[key];
    if (isFunction(prop))
      return prop(...args);
    return prop;
  }
  return null;
};
var hasSlotProps = (slots, props, key) => {
  if (key in slots && slots[key])
    return true;
  return !!(key in props && props[key]);
};
function isEmptyElement(c) {
  return c && (c.type === import_vue.Comment || c.type === import_vue.Fragment && c.children.length === 0 || c.type === import_vue.Text && c.children.trim() === "");
}
function filterEmpty(children = []) {
  const res = [];
  children.forEach((child) => {
    if (Array.isArray(child))
      res.push(...child);
    else if (child?.type === import_vue.Fragment)
      res.push(...filterEmpty(child.children));
    else
      res.push(child);
  });
  return res.filter((c) => !isEmptyElement(c));
}
function isNodeVShowFalse(vNode) {
  const showDir = vNode.dirs?.find(({ dir }) => dir === import_vue.vShow);
  return !!(showDir && showDir.value === false);
}
function getSlot(instance, slotName = "default", fallback = []) {
  const slots = instance?.$slots || instance.slots || {};
  const slot = slots[slotName];
  if (slot === void 0)
    return fallback;
  return slot();
}

// src/lodash.ts
var import_lodash = __toESM(require("lodash.clonedeep"), 1);
var import_lodash2 = __toESM(require("lodash.isequal"), 1);
var import_lodash3 = __toESM(require("lodash.merge"), 1);

// src/lib/hooks/cloned.ts
var import_vue2 = require("vue");
function cloneFnJSON(source) {
  return JSON.parse(JSON.stringify(source));
}
function useCloned(source, options = {}) {
  const cloned = (0, import_vue2.ref)({});
  const {
    manual,
    clone = cloneFnJSON,
    // watch options
    deep = true,
    immediate = true
  } = options;
  function sync() {
    cloned.value = clone((0, import_vue2.unref)(source));
  }
  if (!manual && (0, import_vue2.isRef)(source)) {
    (0, import_vue2.watch)(source, sync, {
      ...options,
      deep,
      immediate
    });
  } else {
    sync();
  }
  return { cloned, sync };
}

// src/lib/hooks/v-model.ts
var import_vue3 = require("vue");
function useVModel(props, key, emit, options = {}) {
  const {
    clone = false,
    passive = false,
    eventName,
    deep = false,
    defaultValue
  } = options;
  const vm = (0, import_vue3.getCurrentInstance)();
  const _emit = emit || vm?.emit || vm?.$emit?.bind(vm) || vm?.proxy?.$emit?.bind(vm?.proxy);
  let event = eventName;
  if (!key)
    key = "modelValue";
  event = eventName || event || `update:${key.toString()}`;
  const cloneFn = (val) => !clone ? val : isFunction(clone) ? clone(val) : cloneFnJSON(val);
  const getValue = () => isDef(props[key]) ? cloneFn(props[key]) : defaultValue;
  if (passive) {
    const initialValue = getValue();
    const proxy = (0, import_vue3.ref)(initialValue);
    (0, import_vue3.watch)(
      () => props[key],
      (v) => proxy.value = cloneFn(v)
    );
    (0, import_vue3.watch)(
      proxy,
      (v) => {
        if (v !== props[key] || deep)
          _emit(event, v);
      },
      { deep }
    );
    return proxy;
  } else {
    return (0, import_vue3.computed)({
      get() {
        return getValue();
      },
      set(value) {
        _emit(event, value);
      }
    });
  }
}

// src/lib/hooks/state.ts
var import_vue4 = require("vue");
var useState = (defaultValue) => {
  const destroyRef = (0, import_vue4.ref)(false);
  const state = (0, import_vue4.ref)();
  if (isFunction(defaultValue))
    state.value = defaultValue();
  else
    state.value = defaultValue;
  (0, import_vue4.onMounted)(() => {
    destroyRef.value = false;
  });
  (0, import_vue4.onBeforeUnmount)(() => {
    destroyRef.value = true;
  });
  const safeSetState = (nextValue, ignoreDestroy = false) => {
    if (ignoreDestroy && destroyRef.value)
      return;
    if (isFunction(nextValue))
      state.value = nextValue(state.value);
    else
      state.value = nextValue;
  };
  return [state, safeSetState];
};

// src/lib/hooks/clipboard.ts
var import_vue5 = require("vue");

// src/lib/clipboard.ts
function makeError() {
  return new DOMException("The request is not allowed", "NotAllowedError");
}
async function copyClipboardApi(text) {
  if (!navigator.clipboard)
    throw makeError();
  return navigator.clipboard.writeText(text);
}
async function copyExecCommand(text) {
  const span = document.createElement("span");
  span.textContent = text;
  span.style.whiteSpace = "pre";
  span.style.webkitUserSelect = "auto";
  span.style.userSelect = "all";
  document.body.appendChild(span);
  const selection = window.getSelection();
  const range = window.document.createRange();
  selection.removeAllRanges();
  range.selectNode(span);
  selection.addRange(range);
  let success = false;
  try {
    success = window.document.execCommand("copy");
  } finally {
    selection.removeAllRanges();
    window.document.body.removeChild(span);
  }
  if (!success)
    throw makeError();
}
async function clipboardCopy(text) {
  try {
    await copyClipboardApi(text);
  } catch (err) {
    try {
      await copyExecCommand(text);
    } catch (err2) {
      throw err2 || err || makeError();
    }
  }
}

// src/lib/hooks/clipboard.ts
var useClipboard = (delay = 3e3) => {
  const copied = (0, import_vue5.ref)(false);
  const copy = (text) => {
    const copyText = (0, import_vue5.unref)(text);
    clipboardCopy(copyText).then(() => {
      copied.value = true;
      const timer = setTimeout(() => {
        copied.value = false;
        clearTimeout(timer);
      }, delay);
    });
  };
  return {
    copied,
    copy
  };
};

// src/lib/hooks/create-injection-state.ts
var import_vue6 = require("vue");
function createInjectionState(composable) {
  const key = Symbol("InjectionState");
  const useProvidingState = (...args) => {
    const state = composable(...args);
    (0, import_vue6.provide)(key, state);
    return state;
  };
  const useInjectedState = (defaultState) => (0, import_vue6.inject)(key, defaultState);
  return [useProvidingState, useInjectedState];
}

// src/lib/can-use-dom.ts
function canUseDom() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
var can_use_dom_default = canUseDom;

// src/lib/class-names.ts
function classNames(...args) {
  const classes = [];
  for (let i = 0; i < args.length; i++) {
    const value = args[i];
    if (!value)
      continue;
    if (isString(value)) {
      classes.push(value);
    } else if (isArray(value)) {
      for (let i2 = 0; i2 < value.length; i2++) {
        const inner = classNames(value[i2]);
        if (inner)
          classes.push(inner);
      }
    } else if (isObject(value)) {
      for (const name in value) {
        if (value[name])
          classes.push(name);
      }
    }
  }
  return classes.join(" ");
}
var class_names_default = classNames;

// src/lib/safe-next-tick.ts
var delayTimer = async (delay = 0) => {
  return new Promise((resolve) => {
    const timer = setTimeout(() => {
      resolve(true);
      clearTimeout(timer);
    }, delay);
  });
};
async function safeNextick(fn, option) {
  await delayTimer(option?.delay);
  if (fn && isFunction(fn))
    fn();
}

// src/lib/hooks/create-global-state.ts
var import_vue7 = require("vue");
function createGlobalState(stateFactory) {
  let initialized = false;
  let state;
  const scope = (0, import_vue7.effectScope)(true);
  return () => {
    if (!initialized) {
      state = scope.run(stateFactory);
      initialized = true;
    }
    return state;
  };
}

// src/lib/hooks/create-shared-composable.ts
var import_vue9 = require("vue");

// src/lib/hooks/try-on-scope-dispose.ts
var import_vue8 = require("vue");
function tryOnScopeDispose(fn) {
  if ((0, import_vue8.getCurrentScope)()) {
    (0, import_vue8.onScopeDispose)(fn);
    return true;
  }
  return false;
}

// src/lib/hooks/create-shared-composable.ts
function createSharedComposable(composable) {
  let subscribers = 0;
  let state;
  let scope;
  const dispose = () => {
    subscribers -= 1;
    if (scope && subscribers <= 0) {
      scope.stop();
      state = void 0;
      scope = void 0;
    }
  };
  return (...args) => {
    subscribers += 1;
    if (!state) {
      scope = (0, import_vue9.effectScope)(true);
      state = scope.run(() => composable(...args));
    }
    tryOnScopeDispose(dispose);
    return state;
  };
}

// src/dom/find-dom-node.ts
var findDOMNode = (instance) => {
  let node = instance?.vnode?.el || instance && (instance.$el || instance);
  while (node && !node.tagName)
    node = node.nextSibling;
  return node;
};
var find_dom_node_default = findDOMNode;

// src/dom/is-visible.ts
var is_visible_default = (element) => {
  if (!element)
    return false;
  if (element instanceof Element) {
    if (element.offsetParent)
      return true;
    if (element.getBBox) {
      const { width, height } = element.getBBox();
      if (width || height)
        return true;
    }
    if (element.getBoundingClientRect) {
      const { width, height } = element.getBoundingClientRect();
      if (width || height)
        return true;
    }
  }
  return false;
};

// src/dom/contains.ts
function contains(root, n) {
  if (!root)
    return false;
  if (root.contains)
    return root.contains(n);
  let node = n;
  while (node) {
    if (node === root)
      return true;
    node = node.parentNode;
  }
  return false;
}

// src/dom/style-names.ts
function parserStyleString(styleString) {
  const styleObject = {};
  const styleArray = styleString.split(";");
  for (const style of styleArray) {
    if (!style)
      continue;
    const styleItem = style.split(":");
    if (!styleItem[0])
      continue;
    styleObject[styleItem[0]] = styleItem[1];
  }
  return styleObject;
}
function styleNames(...names) {
  if (names.length < 1)
    return void 0;
  const styleObject = {};
  for (const name of names) {
    if (!name)
      continue;
    if (isString(name)) {
      Object.assign(styleObject, parserStyleString(name));
    } else if (isArray(name)) {
      const style = styleNames(...name);
      if (style)
        Object.assign(styleObject, style);
    } else if (isObject(name)) {
      Object.assign(styleObject, name);
    }
  }
  return styleObject;
}

// src/dom/is-valid-element.ts
function isValidElement(element) {
  if (Array.isArray(element) && element.length === 1)
    element = element[0];
  return element && element.__v_isVNode && typeof element.type !== "symbol";
}

// src/dom/class.ts
function hasClass(node, className) {
  if (node.classList)
    return node.classList.contains(className);
  const originClass = node.className;
  return ` ${originClass} `.includes(` ${className} `);
}
function addClass(node, className) {
  if (node.classList) {
    node.classList.add(className);
  } else {
    if (!hasClass(node, className))
      node.className = `${node.className} ${className}`;
  }
}
function removeClass(node, className) {
  if (node.classList) {
    node.classList.remove(className);
  } else {
    if (hasClass(node, className)) {
      const originClass = node.className;
      node.className = ` ${originClass} `.replace(` ${className} `, " ");
    }
  }
}

// src/dom/css.ts
var PIXEL_PATTERN = /margin|padding|width|height|max|min|offset/;
var removePixel = {
  left: true,
  top: true
};
var floatMap = {
  cssFloat: 1,
  styleFloat: 1,
  float: 1
};
function getComputedStyle(node) {
  return node.nodeType === 1 ? node.ownerDocument.defaultView.getComputedStyle(node, null) : {};
}
function getStyleValue(node, type, value) {
  type = type.toLowerCase();
  if (value === "auto") {
    if (type === "height")
      return node.offsetHeight;
    if (type === "width")
      return node.offsetWidth;
  }
  if (!(type in removePixel))
    removePixel[type] = PIXEL_PATTERN.test(type);
  return removePixel[type] ? parseFloat(value) || 0 : value;
}
function getCss(node, name) {
  const length = arguments.length;
  const style = getComputedStyle(node);
  name = floatMap[name] ? "cssFloat" in node.style ? "cssFloat" : "styleFloat" : name;
  return length === 1 ? style : getStyleValue(node, name, style[name] || node.style[name]);
}
function setCss(node, name, value) {
  const length = arguments.length;
  name = floatMap[name] ? "cssFloat" in node.style ? "cssFloat" : "styleFloat" : name;
  if (length === 3) {
    if (typeof value === "number" && PIXEL_PATTERN.test(name))
      value = `${value}px`;
    node.style[name] = value;
    return value;
  }
  for (const x in name) {
    if (name.hasOwnProperty(x))
      setCss(node, x, name[x]);
  }
  return getComputedStyle(node);
}
function getOuterWidth(el) {
  if (el === document.body)
    return document.documentElement.clientWidth;
  return el.offsetWidth;
}
function getOuterHeight(el) {
  if (el === document.body)
    return window.innerHeight || document.documentElement.clientHeight;
  return el.offsetHeight;
}
function getDocSize() {
  const width = Math.max(document.documentElement.scrollWidth, document.body.scrollWidth);
  const height = Math.max(document.documentElement.scrollHeight, document.body.scrollHeight);
  return {
    width,
    height
  };
}
function getClientSize() {
  const width = document.documentElement.clientWidth;
  const height = window.innerHeight || document.documentElement.clientHeight;
  return {
    width,
    height
  };
}
function getScroll() {
  return {
    scrollLeft: Math.max(document.documentElement.scrollLeft, document.body.scrollLeft),
    scrollTop: Math.max(document.documentElement.scrollTop, document.body.scrollTop)
  };
}
function getOffset(node) {
  const box = node.getBoundingClientRect();
  const docElem = document.documentElement;
  return {
    left: box.left + (window.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || document.body.clientLeft || 0),
    top: box.top + (window.pageYOffset || docElem.scrollTop) - (docElem.clientTop || document.body.clientTop || 0)
  };
}

// src/dom/dynamic-css.ts
var APPEND_ORDER = "data-vc-order";
var MARK_KEY = "vc-util-key";
var containerCache = /* @__PURE__ */ new Map();
function getMark({ mark } = {}) {
  if (mark)
    return mark.startsWith("data-") ? mark : `data-${mark}`;
  return MARK_KEY;
}
function getContainer(option) {
  if (option.attachTo)
    return option.attachTo;
  const head = document.querySelector("head");
  return head || document.body;
}
function getOrder(prepend) {
  if (prepend === "queue")
    return "prependQueue";
  return prepend ? "prepend" : "append";
}
function findStyles(container) {
  return Array.from(
    (containerCache.get(container) || container).children
  ).filter((node) => node.tagName === "STYLE");
}
function injectCSS(css, option = {}) {
  if (!can_use_dom_default())
    return null;
  const { csp, prepend } = option;
  const styleNode = document.createElement("style");
  styleNode.setAttribute(APPEND_ORDER, getOrder(prepend));
  if (csp?.nonce)
    styleNode.nonce = csp?.nonce;
  styleNode.innerHTML = css;
  const container = getContainer(option);
  const { firstChild } = container;
  if (prepend) {
    if (prepend === "queue") {
      const existStyle = findStyles(container).filter(
        (node) => ["prepend", "prependQueue"].includes(node.getAttribute(APPEND_ORDER))
      );
      if (existStyle.length) {
        container.insertBefore(
          styleNode,
          existStyle[existStyle.length - 1].nextSibling
        );
        return styleNode;
      }
    }
    container.insertBefore(styleNode, firstChild);
  } else {
    container.appendChild(styleNode);
  }
  return styleNode;
}
function findExistNode(key, option = {}) {
  const container = getContainer(option);
  return findStyles(container).find(
    (node) => node.getAttribute(getMark(option)) === key
  );
}
function removeCSS(key, option = {}) {
  const existNode = findExistNode(key, option);
  if (existNode) {
    const container = getContainer(option);
    container.removeChild(existNode);
  }
}
function syncRealContainer(container, option) {
  const cachedRealContainer = containerCache.get(container);
  if (!cachedRealContainer || !contains(document, cachedRealContainer)) {
    const placeholderStyle = injectCSS("", option);
    const { parentNode } = placeholderStyle;
    containerCache.set(container, parentNode);
    container.removeChild(placeholderStyle);
  }
}
function clearContainerCache() {
  containerCache.clear();
}
function updateCSS(css, key, option = {}) {
  const container = getContainer(option);
  syncRealContainer(container, option);
  const existNode = findExistNode(key, option);
  if (existNode) {
    if (option.csp?.nonce && existNode.nonce !== option.csp?.nonce)
      existNode.nonce = option.csp?.nonce;
    if (existNode.innerHTML !== css)
      existNode.innerHTML = css;
    return existNode;
  }
  const newNode = injectCSS(css, option);
  newNode.setAttribute(getMark(option), key);
  return newNode;
}

// src/dom/focus.ts
function focusable(node, includePositive = false) {
  if (is_visible_default(node)) {
    const nodeName = node.nodeName.toLowerCase();
    const isFocusableElement = ["input", "select", "textarea", "button"].includes(nodeName) || node.isContentEditable || nodeName === "a" && !!node.getAttribute("href");
    const tabIndexAttr = node.getAttribute("tabindex");
    const tabIndexNum = Number(tabIndexAttr);
    let tabIndex = null;
    if (tabIndexAttr && !Number.isNaN(tabIndexNum))
      tabIndex = tabIndexNum;
    else if (isFocusableElement && tabIndex === null)
      tabIndex = 0;
    if (isFocusableElement && node.disabled)
      tabIndex = null;
    return tabIndex !== null && (tabIndex >= 0 || includePositive && tabIndex < 0);
  }
  return false;
}
function getFocusNodeList(node, includePositive = false) {
  const res = [...node.querySelectorAll("*")].filter((child) => {
    return focusable(child, includePositive);
  });
  if (focusable(node, includePositive))
    res.unshift(node);
  return res;
}
var lastFocusElement = null;
function saveLastFocusNode() {
  lastFocusElement = document.activeElement;
}
function clearLastFocusNode() {
  lastFocusElement = null;
}
function backLastFocusNode() {
  if (lastFocusElement) {
    try {
      lastFocusElement.focus();
    } catch (e) {
    }
  }
}
function limitTabRange(node, e) {
  if (e.keyCode === 9) {
    const tabNodeList = getFocusNodeList(node);
    const lastTabNode = tabNodeList[e.shiftKey ? 0 : tabNodeList.length - 1];
    const leavingTab = lastTabNode === document.activeElement || node === document.activeElement;
    if (leavingTab) {
      const target = tabNodeList[e.shiftKey ? tabNodeList.length - 1 : 0];
      target.focus();
      e.preventDefault();
    }
  }
}

// src/dom/style-checker.ts
var isStyleNameSupport = (styleName) => {
  if (can_use_dom_default() && window.document.documentElement) {
    const styleNameList = Array.isArray(styleName) ? styleName : [styleName];
    const { documentElement } = window.document;
    return styleNameList.some((name) => name in documentElement.style);
  }
  return false;
};
var isStyleValueSupport = (styleName, value) => {
  if (!isStyleNameSupport(styleName))
    return false;
  const ele = document.createElement("div");
  const origin = ele.style[styleName];
  ele.style[styleName] = value;
  return ele.style[styleName] !== origin;
};
function isStyleSupport(styleName, styleValue) {
  if (!Array.isArray(styleName) && styleValue !== void 0)
    return isStyleValueSupport(styleName, styleValue);
  return isStyleNameSupport(styleName);
}

// src/dom/support.ts
var animationEndEventNames = {
  WebkitAnimation: "webkitAnimationEnd",
  OAnimation: "oAnimationEnd",
  animation: "animationend"
};
var transitionEventNames = {
  WebkitTransition: "webkitTransitionEnd",
  OTransition: "oTransitionEnd",
  transition: "transitionend"
};
function supportEnd(names) {
  const el = document.createElement("div");
  for (const name in names) {
    if (names.hasOwnProperty(name) && el.style[name] !== void 0) {
      return {
        end: names[name]
      };
    }
  }
  return false;
}
var animation = can_use_dom_default() && supportEnd(animationEndEventNames);
var transition = can_use_dom_default() && supportEnd(transitionEventNames);

// src/warning.ts
var warned = {};
function warning(valid, message) {
  if (process.env.NODE_ENV !== "production" && !valid && console !== void 0)
    console.error(`Warning: ${message}`);
}
function note(valid, message) {
  if (process.env.NODE_ENV !== "production" && !valid && console !== void 0)
    console.warn(`Note: ${message}`);
}
function resetWarned() {
  warned = {};
}
function call(method, valid, message) {
  if (!valid && !warned[message]) {
    method(false, message);
    warned[message] = true;
  }
}
function warningOnce(valid, message) {
  call(warning, valid, message);
}
function noteOnce(valid, message) {
  call(note, valid, message);
}

// src/flatten.ts
var import_vue10 = require("vue");
function flatten(vNodes, filterCommentNode = true, result = []) {
  vNodes.forEach((vNode) => {
    if (vNode === null)
      return;
    if (typeof vNode !== "object") {
      if (typeof vNode === "string" || typeof vNode === "number")
        result.push((0, import_vue10.createTextVNode)(String(vNode)));
      return;
    }
    if (Array.isArray(vNode)) {
      flatten(vNode, filterCommentNode, result);
      return;
    }
    if (vNode.type === import_vue10.Fragment) {
      if (vNode.children === null)
        return;
      if (Array.isArray(vNode.children))
        flatten(vNode.children, filterCommentNode, result);
    } else if (vNode.type !== import_vue10.Comment) {
      result.push(vNode);
    }
  });
  return result;
}

// src/get.ts
var get = (obj, key) => {
  if (!obj)
    return void 0;
  const info = obj[key];
  const keys = key.split(".");
  if (info)
    return info;
  if (keys.length === 1)
    return void 0;
  const popKeys = (0, import_lodash.default)(keys);
  let objData;
  const objKeys = [];
  while (popKeys.length > 0) {
    const keyInfo = popKeys.pop();
    objKeys.unshift(keyInfo);
    const popKey = popKeys.join(".");
    const popInfo = obj[popKey];
    if (popInfo) {
      objData = popInfo;
      break;
    }
  }
  if (!objData)
    return void 0;
  if (objKeys.length === 1)
    return objData[objKeys[0]];
  const allKey = objKeys.join(".");
  const allData = objData[allKey];
  if (allData && isBaseType(allData))
    return allData;
  if (!objData[objKeys[0]])
    return get(objData, objKeys.join("."));
  while (objKeys.length > 1) {
    const firstKey = objKeys.shift();
    const info2 = objData[firstKey];
    if (info2 && isBaseType(info2))
      return info2;
    if (info2 && typeof info2 === "object")
      return get(info2, objKeys.join("."));
    if (objKeys.length === 0)
      break;
  }
  return info;
};
var getArr = (entity, path) => {
  let current = entity;
  for (let i = 0; i < path.length; i += 1) {
    if (current === null || current === void 0)
      return void 0;
    current = current[path[i]];
  }
  return current;
};

// src/set.ts
function internalSet(entity, paths, value, removeIfUndefined) {
  if (!paths.length)
    return value;
  const [path, ...restPath] = paths;
  let clone;
  if (!entity && typeof path === "number")
    clone = [];
  else if (Array.isArray(entity))
    clone = [...entity];
  else
    clone = { ...entity };
  if (removeIfUndefined && value === void 0 && restPath.length === 1)
    delete clone[path][restPath[0]];
  else
    clone[path] = internalSet(clone[path], restPath, value, removeIfUndefined);
  return clone;
}
function set(entity, paths, value, removeIfUndefined = false) {
  if (paths.length && removeIfUndefined && value === void 0 && !getArr(entity, paths.slice(0, -1)))
    return entity;
  return internalSet(entity, paths, value, removeIfUndefined);
}

// src/raf.ts
var raf = (callback) => setTimeout(callback, 16);
var caf = (num) => clearTimeout(num);
if (typeof window !== "undefined" && "requestAnimationFrame" in window) {
  raf = (callback) => window.requestAnimationFrame(callback);
  caf = (handle) => window.cancelAnimationFrame(handle);
}
var rafUUID = 0;
var rafIds = /* @__PURE__ */ new Map();
function cleanup(id) {
  rafIds.delete(id);
}
function wrapperRaf(callback, times = 1) {
  rafUUID += 1;
  const id = rafUUID;
  function callRef(leftTimes) {
    if (leftTimes === 0) {
      cleanup(id);
      callback();
    } else {
      const realId = raf(() => {
        callRef(leftTimes - 1);
      });
      rafIds.set(id, realId);
    }
  }
  callRef(times);
  return id;
}
wrapperRaf.cancel = (id) => {
  const realId = rafIds.get(id);
  cleanup(realId);
  return caf(realId);
};

// src/key-code.ts
var KeyCode = {
  /**
     * MAC_ENTER
     */
  MAC_ENTER: 3,
  /**
     * BACKSPACE
     */
  BACKSPACE: 8,
  /**
     * TAB
     */
  TAB: 9,
  /**
     * NUMLOCK on FF/Safari Mac
     */
  NUM_CENTER: 12,
  // NUMLOCK on FF/Safari Mac
  /**
     * ENTER
     */
  ENTER: 13,
  /**
     * SHIFT
     */
  SHIFT: 16,
  /**
     * CTRL
     */
  CTRL: 17,
  /**
     * ALT
     */
  ALT: 18,
  /**
     * PAUSE
     */
  PAUSE: 19,
  /**
     * CAPS_LOCK
     */
  CAPS_LOCK: 20,
  /**
     * ESC
     */
  ESC: 27,
  /**
     * SPACE
     */
  SPACE: 32,
  /**
     * PAGE_UP
     */
  PAGE_UP: 33,
  // also NUM_NORTH_EAST
  /**
     * PAGE_DOWN
     */
  PAGE_DOWN: 34,
  // also NUM_SOUTH_EAST
  /**
     * END
     */
  END: 35,
  // also NUM_SOUTH_WEST
  /**
     * HOME
     */
  HOME: 36,
  // also NUM_NORTH_WEST
  /**
     * LEFT
     */
  LEFT: 37,
  // also NUM_WEST
  /**
     * UP
     */
  UP: 38,
  // also NUM_NORTH
  /**
     * RIGHT
     */
  RIGHT: 39,
  // also NUM_EAST
  /**
     * DOWN
     */
  DOWN: 40,
  // also NUM_SOUTH
  /**
     * PRINT_SCREEN
     */
  PRINT_SCREEN: 44,
  /**
     * INSERT
     */
  INSERT: 45,
  // also NUM_INSERT
  /**
     * DELETE
     */
  DELETE: 46,
  // also NUM_DELETE
  /**
     * ZERO
     */
  ZERO: 48,
  /**
     * ONE
     */
  ONE: 49,
  /**
     * TWO
     */
  TWO: 50,
  /**
     * THREE
     */
  THREE: 51,
  /**
     * FOUR
     */
  FOUR: 52,
  /**
     * FIVE
     */
  FIVE: 53,
  /**
     * SIX
     */
  SIX: 54,
  /**
     * SEVEN
     */
  SEVEN: 55,
  /**
     * EIGHT
     */
  EIGHT: 56,
  /**
     * NINE
     */
  NINE: 57,
  /**
     * QUESTION_MARK
     */
  QUESTION_MARK: 63,
  // needs localization
  /**
     * A
     */
  A: 65,
  /**
     * B
     */
  B: 66,
  /**
     * C
     */
  C: 67,
  /**
     * D
     */
  D: 68,
  /**
     * E
     */
  E: 69,
  /**
     * F
     */
  F: 70,
  /**
     * G
     */
  G: 71,
  /**
     * H
     */
  H: 72,
  /**
     * I
     */
  I: 73,
  /**
     * J
     */
  J: 74,
  /**
     * K
     */
  K: 75,
  /**
     * L
     */
  L: 76,
  /**
     * M
     */
  M: 77,
  /**
     * N
     */
  N: 78,
  /**
     * O
     */
  O: 79,
  /**
     * P
     */
  P: 80,
  /**
     * Q
     */
  Q: 81,
  /**
     * R
     */
  R: 82,
  /**
     * S
     */
  S: 83,
  /**
     * T
     */
  T: 84,
  /**
     * U
     */
  U: 85,
  /**
     * V
     */
  V: 86,
  /**
     * W
     */
  W: 87,
  /**
     * X
     */
  X: 88,
  /**
     * Y
     */
  Y: 89,
  /**
     * Z
     */
  Z: 90,
  /**
     * META
     */
  META: 91,
  // WIN_KEY_LEFT
  /**
     * WIN_KEY_RIGHT
     */
  WIN_KEY_RIGHT: 92,
  /**
     * CONTEXT_MENU
     */
  CONTEXT_MENU: 93,
  /**
     * NUM_ZERO
     */
  NUM_ZERO: 96,
  /**
     * NUM_ONE
     */
  NUM_ONE: 97,
  /**
     * NUM_TWO
     */
  NUM_TWO: 98,
  /**
     * NUM_THREE
     */
  NUM_THREE: 99,
  /**
     * NUM_FOUR
     */
  NUM_FOUR: 100,
  /**
     * NUM_FIVE
     */
  NUM_FIVE: 101,
  /**
     * NUM_SIX
     */
  NUM_SIX: 102,
  /**
     * NUM_SEVEN
     */
  NUM_SEVEN: 103,
  /**
     * NUM_EIGHT
     */
  NUM_EIGHT: 104,
  /**
     * NUM_NINE
     */
  NUM_NINE: 105,
  /**
     * NUM_MULTIPLY
     */
  NUM_MULTIPLY: 106,
  /**
     * NUM_PLUS
     */
  NUM_PLUS: 107,
  /**
     * NUM_MINUS
     */
  NUM_MINUS: 109,
  /**
     * NUM_PERIOD
     */
  NUM_PERIOD: 110,
  /**
     * NUM_DIVISION
     */
  NUM_DIVISION: 111,
  /**
     * F1
     */
  F1: 112,
  /**
     * F2
     */
  F2: 113,
  /**
     * F3
     */
  F3: 114,
  /**
     * F4
     */
  F4: 115,
  /**
     * F5
     */
  F5: 116,
  /**
     * F6
     */
  F6: 117,
  /**
     * F7
     */
  F7: 118,
  /**
     * F8
     */
  F8: 119,
  /**
     * F9
     */
  F9: 120,
  /**
     * F10
     */
  F10: 121,
  /**
     * F11
     */
  F11: 122,
  /**
     * F12
     */
  F12: 123,
  /**
     * NUMLOCK
     */
  NUMLOCK: 144,
  /**
     * SEMICOLON
     */
  SEMICOLON: 186,
  // needs localization
  /**
     * DASH
     */
  DASH: 189,
  // needs localization
  /**
     * EQUALS
     */
  EQUALS: 187,
  // needs localization
  /**
     * COMMA
     */
  COMMA: 188,
  // needs localization
  /**
     * PERIOD
     */
  PERIOD: 190,
  // needs localization
  /**
     * SLASH
     */
  SLASH: 191,
  // needs localization
  /**
     * APOSTROPHE
     */
  APOSTROPHE: 192,
  // needs localization
  /**
     * SINGLE_QUOTE
     */
  SINGLE_QUOTE: 222,
  // needs localization
  /**
     * OPEN_SQUARE_BRACKET
     */
  OPEN_SQUARE_BRACKET: 219,
  // needs localization
  /**
     * BACKSLASH
     */
  BACKSLASH: 220,
  // needs localization
  /**
     * CLOSE_SQUARE_BRACKET
     */
  CLOSE_SQUARE_BRACKET: 221,
  // needs localization
  /**
     * WIN_KEY
     */
  WIN_KEY: 224,
  /**
     * MAC_FF_META
     */
  MAC_FF_META: 224,
  // Firefox (Gecko) fires this for the meta key instead of 91
  /**
     * WIN_IME
     */
  WIN_IME: 229,
  // ======================== Function ========================
  /**
     * whether text and modified key is entered at the same time.
     */
  isTextModifyingKeyEvent: function isTextModifyingKeyEvent(e) {
    const { keyCode } = e;
    if (e.altKey && !e.ctrlKey || e.metaKey || keyCode >= KeyCode.F1 && keyCode <= KeyCode.F12)
      return false;
    switch (keyCode) {
      case KeyCode.ALT:
      case KeyCode.CAPS_LOCK:
      case KeyCode.CONTEXT_MENU:
      case KeyCode.CTRL:
      case KeyCode.DOWN:
      case KeyCode.END:
      case KeyCode.ESC:
      case KeyCode.HOME:
      case KeyCode.INSERT:
      case KeyCode.LEFT:
      case KeyCode.MAC_FF_META:
      case KeyCode.META:
      case KeyCode.NUMLOCK:
      case KeyCode.NUM_CENTER:
      case KeyCode.PAGE_DOWN:
      case KeyCode.PAGE_UP:
      case KeyCode.PAUSE:
      case KeyCode.PRINT_SCREEN:
      case KeyCode.RIGHT:
      case KeyCode.SHIFT:
      case KeyCode.UP:
      case KeyCode.WIN_KEY:
      case KeyCode.WIN_KEY_RIGHT:
        return false;
      default:
        return true;
    }
  },
  /**
     * whether character is entered.
     */
  isCharacterKey: function isCharacterKey(keyCode) {
    if (keyCode >= KeyCode.ZERO && keyCode <= KeyCode.NINE)
      return true;
    if (keyCode >= KeyCode.NUM_ZERO && keyCode <= KeyCode.NUM_MULTIPLY)
      return true;
    if (keyCode >= KeyCode.A && keyCode <= KeyCode.Z)
      return true;
    if (window.navigator.userAgent.includes("WebKit") && keyCode === 0)
      return true;
    switch (keyCode) {
      case KeyCode.SPACE:
      case KeyCode.QUESTION_MARK:
      case KeyCode.NUM_PLUS:
      case KeyCode.NUM_MINUS:
      case KeyCode.NUM_PERIOD:
      case KeyCode.NUM_DIVISION:
      case KeyCode.SEMICOLON:
      case KeyCode.DASH:
      case KeyCode.EQUALS:
      case KeyCode.COMMA:
      case KeyCode.PERIOD:
      case KeyCode.SLASH:
      case KeyCode.APOSTROPHE:
      case KeyCode.SINGLE_QUOTE:
      case KeyCode.OPEN_SQUARE_BRACKET:
      case KeyCode.BACKSLASH:
      case KeyCode.CLOSE_SQUARE_BRACKET:
        return true;
      default:
        return false;
    }
  }
};
var key_code_default = KeyCode;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  KeyCode,
  addClass,
  animation,
  anyType,
  arrayType,
  backLastFocusNode,
  booleanType,
  call,
  canUseDom,
  classNames,
  clearContainerCache,
  clearLastFocusNode,
  cloneDeep,
  contains,
  createGlobalState,
  createInjectionState,
  createSharedComposable,
  delayTimer,
  eventType,
  filterEmpty,
  findDOMNode,
  findDomNode,
  flatten,
  functionType,
  get,
  getArr,
  getClientSize,
  getCss,
  getDocSize,
  getEventValue,
  getFocusNodeList,
  getOffset,
  getOuterHeight,
  getOuterWidth,
  getScroll,
  getSlot,
  getSlotsProps,
  hasClass,
  hasSlotProps,
  injectCSS,
  isArray,
  isBaseType,
  isBoolean,
  isDate,
  isDef,
  isEmptyElement,
  isEqual,
  isFunction,
  isNodeVShowFalse,
  isNull,
  isNumber,
  isObject,
  isString,
  isStyleSupport,
  isSymbol,
  isUndefined,
  isUrl,
  isValidElement,
  isVisible,
  limitTabRange,
  merge,
  note,
  noteOnce,
  numberType,
  objectType,
  omit,
  pick,
  raf,
  removeCSS,
  removeClass,
  resetWarned,
  runAsyncEvent,
  runEvent,
  safeNextick,
  saveLastFocusNode,
  set,
  setCss,
  someType,
  stringType,
  styleNames,
  toArray,
  transition,
  tryOnScopeDispose,
  tuple,
  tupleArr,
  tupleNum,
  tupleNumArr,
  updateCSS,
  useClipboard,
  useCloned,
  useState,
  useVModel,
  vNodeType,
  warning,
  warningOnce
});
