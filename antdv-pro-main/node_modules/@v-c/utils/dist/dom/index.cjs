var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/dom/index.ts
var dom_exports = {};
__export(dom_exports, {
  addClass: () => addClass,
  animation: () => animation,
  backLastFocusNode: () => backLastFocusNode,
  clearContainerCache: () => clearContainerCache,
  clearLastFocusNode: () => clearLastFocusNode,
  contains: () => contains,
  findDOMNode: () => find_dom_node_default,
  findDomNode: () => find_dom_node_default,
  getClientSize: () => getClientSize,
  getCss: () => getCss,
  getDocSize: () => getDocSize,
  getFocusNodeList: () => getFocusNodeList,
  getOffset: () => getOffset,
  getOuterHeight: () => getOuterHeight,
  getOuterWidth: () => getOuterWidth,
  getScroll: () => getScroll,
  hasClass: () => hasClass,
  injectCSS: () => injectCSS,
  isStyleSupport: () => isStyleSupport,
  isValidElement: () => isValidElement,
  isVisible: () => is_visible_default,
  limitTabRange: () => limitTabRange,
  removeCSS: () => removeCSS,
  removeClass: () => removeClass,
  saveLastFocusNode: () => saveLastFocusNode,
  setCss: () => setCss,
  styleNames: () => styleNames,
  transition: () => transition,
  updateCSS: () => updateCSS
});
module.exports = __toCommonJS(dom_exports);

// src/dom/find-dom-node.ts
var findDOMNode = (instance) => {
  let node = instance?.vnode?.el || instance && (instance.$el || instance);
  while (node && !node.tagName)
    node = node.nextSibling;
  return node;
};
var find_dom_node_default = findDOMNode;

// src/dom/is-visible.ts
var is_visible_default = (element) => {
  if (!element)
    return false;
  if (element instanceof Element) {
    if (element.offsetParent)
      return true;
    if (element.getBBox) {
      const { width, height } = element.getBBox();
      if (width || height)
        return true;
    }
    if (element.getBoundingClientRect) {
      const { width, height } = element.getBoundingClientRect();
      if (width || height)
        return true;
    }
  }
  return false;
};

// src/dom/contains.ts
function contains(root, n) {
  if (!root)
    return false;
  if (root.contains)
    return root.contains(n);
  let node = n;
  while (node) {
    if (node === root)
      return true;
    node = node.parentNode;
  }
  return false;
}

// src/base.ts
var isString = (val) => typeof val === "string";
var isArray = (val) => Array.isArray(val);
var isObject = (val) => Object.prototype.toString.call(val) === "[object Object]";

// src/dom/style-names.ts
function parserStyleString(styleString) {
  const styleObject = {};
  const styleArray = styleString.split(";");
  for (const style of styleArray) {
    if (!style)
      continue;
    const styleItem = style.split(":");
    if (!styleItem[0])
      continue;
    styleObject[styleItem[0]] = styleItem[1];
  }
  return styleObject;
}
function styleNames(...names) {
  if (names.length < 1)
    return void 0;
  const styleObject = {};
  for (const name of names) {
    if (!name)
      continue;
    if (isString(name)) {
      Object.assign(styleObject, parserStyleString(name));
    } else if (isArray(name)) {
      const style = styleNames(...name);
      if (style)
        Object.assign(styleObject, style);
    } else if (isObject(name)) {
      Object.assign(styleObject, name);
    }
  }
  return styleObject;
}

// src/dom/is-valid-element.ts
function isValidElement(element) {
  if (Array.isArray(element) && element.length === 1)
    element = element[0];
  return element && element.__v_isVNode && typeof element.type !== "symbol";
}

// src/dom/class.ts
function hasClass(node, className) {
  if (node.classList)
    return node.classList.contains(className);
  const originClass = node.className;
  return ` ${originClass} `.includes(` ${className} `);
}
function addClass(node, className) {
  if (node.classList) {
    node.classList.add(className);
  } else {
    if (!hasClass(node, className))
      node.className = `${node.className} ${className}`;
  }
}
function removeClass(node, className) {
  if (node.classList) {
    node.classList.remove(className);
  } else {
    if (hasClass(node, className)) {
      const originClass = node.className;
      node.className = ` ${originClass} `.replace(` ${className} `, " ");
    }
  }
}

// src/dom/css.ts
var PIXEL_PATTERN = /margin|padding|width|height|max|min|offset/;
var removePixel = {
  left: true,
  top: true
};
var floatMap = {
  cssFloat: 1,
  styleFloat: 1,
  float: 1
};
function getComputedStyle(node) {
  return node.nodeType === 1 ? node.ownerDocument.defaultView.getComputedStyle(node, null) : {};
}
function getStyleValue(node, type, value) {
  type = type.toLowerCase();
  if (value === "auto") {
    if (type === "height")
      return node.offsetHeight;
    if (type === "width")
      return node.offsetWidth;
  }
  if (!(type in removePixel))
    removePixel[type] = PIXEL_PATTERN.test(type);
  return removePixel[type] ? parseFloat(value) || 0 : value;
}
function getCss(node, name) {
  const length = arguments.length;
  const style = getComputedStyle(node);
  name = floatMap[name] ? "cssFloat" in node.style ? "cssFloat" : "styleFloat" : name;
  return length === 1 ? style : getStyleValue(node, name, style[name] || node.style[name]);
}
function setCss(node, name, value) {
  const length = arguments.length;
  name = floatMap[name] ? "cssFloat" in node.style ? "cssFloat" : "styleFloat" : name;
  if (length === 3) {
    if (typeof value === "number" && PIXEL_PATTERN.test(name))
      value = `${value}px`;
    node.style[name] = value;
    return value;
  }
  for (const x in name) {
    if (name.hasOwnProperty(x))
      setCss(node, x, name[x]);
  }
  return getComputedStyle(node);
}
function getOuterWidth(el) {
  if (el === document.body)
    return document.documentElement.clientWidth;
  return el.offsetWidth;
}
function getOuterHeight(el) {
  if (el === document.body)
    return window.innerHeight || document.documentElement.clientHeight;
  return el.offsetHeight;
}
function getDocSize() {
  const width = Math.max(document.documentElement.scrollWidth, document.body.scrollWidth);
  const height = Math.max(document.documentElement.scrollHeight, document.body.scrollHeight);
  return {
    width,
    height
  };
}
function getClientSize() {
  const width = document.documentElement.clientWidth;
  const height = window.innerHeight || document.documentElement.clientHeight;
  return {
    width,
    height
  };
}
function getScroll() {
  return {
    scrollLeft: Math.max(document.documentElement.scrollLeft, document.body.scrollLeft),
    scrollTop: Math.max(document.documentElement.scrollTop, document.body.scrollTop)
  };
}
function getOffset(node) {
  const box = node.getBoundingClientRect();
  const docElem = document.documentElement;
  return {
    left: box.left + (window.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || document.body.clientLeft || 0),
    top: box.top + (window.pageYOffset || docElem.scrollTop) - (docElem.clientTop || document.body.clientTop || 0)
  };
}

// src/lib/can-use-dom.ts
function canUseDom() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
var can_use_dom_default = canUseDom;

// src/dom/dynamic-css.ts
var APPEND_ORDER = "data-vc-order";
var MARK_KEY = "vc-util-key";
var containerCache = /* @__PURE__ */ new Map();
function getMark({ mark } = {}) {
  if (mark)
    return mark.startsWith("data-") ? mark : `data-${mark}`;
  return MARK_KEY;
}
function getContainer(option) {
  if (option.attachTo)
    return option.attachTo;
  const head = document.querySelector("head");
  return head || document.body;
}
function getOrder(prepend) {
  if (prepend === "queue")
    return "prependQueue";
  return prepend ? "prepend" : "append";
}
function findStyles(container) {
  return Array.from(
    (containerCache.get(container) || container).children
  ).filter((node) => node.tagName === "STYLE");
}
function injectCSS(css, option = {}) {
  if (!can_use_dom_default())
    return null;
  const { csp, prepend } = option;
  const styleNode = document.createElement("style");
  styleNode.setAttribute(APPEND_ORDER, getOrder(prepend));
  if (csp?.nonce)
    styleNode.nonce = csp?.nonce;
  styleNode.innerHTML = css;
  const container = getContainer(option);
  const { firstChild } = container;
  if (prepend) {
    if (prepend === "queue") {
      const existStyle = findStyles(container).filter(
        (node) => ["prepend", "prependQueue"].includes(node.getAttribute(APPEND_ORDER))
      );
      if (existStyle.length) {
        container.insertBefore(
          styleNode,
          existStyle[existStyle.length - 1].nextSibling
        );
        return styleNode;
      }
    }
    container.insertBefore(styleNode, firstChild);
  } else {
    container.appendChild(styleNode);
  }
  return styleNode;
}
function findExistNode(key, option = {}) {
  const container = getContainer(option);
  return findStyles(container).find(
    (node) => node.getAttribute(getMark(option)) === key
  );
}
function removeCSS(key, option = {}) {
  const existNode = findExistNode(key, option);
  if (existNode) {
    const container = getContainer(option);
    container.removeChild(existNode);
  }
}
function syncRealContainer(container, option) {
  const cachedRealContainer = containerCache.get(container);
  if (!cachedRealContainer || !contains(document, cachedRealContainer)) {
    const placeholderStyle = injectCSS("", option);
    const { parentNode } = placeholderStyle;
    containerCache.set(container, parentNode);
    container.removeChild(placeholderStyle);
  }
}
function clearContainerCache() {
  containerCache.clear();
}
function updateCSS(css, key, option = {}) {
  const container = getContainer(option);
  syncRealContainer(container, option);
  const existNode = findExistNode(key, option);
  if (existNode) {
    if (option.csp?.nonce && existNode.nonce !== option.csp?.nonce)
      existNode.nonce = option.csp?.nonce;
    if (existNode.innerHTML !== css)
      existNode.innerHTML = css;
    return existNode;
  }
  const newNode = injectCSS(css, option);
  newNode.setAttribute(getMark(option), key);
  return newNode;
}

// src/dom/focus.ts
function focusable(node, includePositive = false) {
  if (is_visible_default(node)) {
    const nodeName = node.nodeName.toLowerCase();
    const isFocusableElement = ["input", "select", "textarea", "button"].includes(nodeName) || node.isContentEditable || nodeName === "a" && !!node.getAttribute("href");
    const tabIndexAttr = node.getAttribute("tabindex");
    const tabIndexNum = Number(tabIndexAttr);
    let tabIndex = null;
    if (tabIndexAttr && !Number.isNaN(tabIndexNum))
      tabIndex = tabIndexNum;
    else if (isFocusableElement && tabIndex === null)
      tabIndex = 0;
    if (isFocusableElement && node.disabled)
      tabIndex = null;
    return tabIndex !== null && (tabIndex >= 0 || includePositive && tabIndex < 0);
  }
  return false;
}
function getFocusNodeList(node, includePositive = false) {
  const res = [...node.querySelectorAll("*")].filter((child) => {
    return focusable(child, includePositive);
  });
  if (focusable(node, includePositive))
    res.unshift(node);
  return res;
}
var lastFocusElement = null;
function saveLastFocusNode() {
  lastFocusElement = document.activeElement;
}
function clearLastFocusNode() {
  lastFocusElement = null;
}
function backLastFocusNode() {
  if (lastFocusElement) {
    try {
      lastFocusElement.focus();
    } catch (e) {
    }
  }
}
function limitTabRange(node, e) {
  if (e.keyCode === 9) {
    const tabNodeList = getFocusNodeList(node);
    const lastTabNode = tabNodeList[e.shiftKey ? 0 : tabNodeList.length - 1];
    const leavingTab = lastTabNode === document.activeElement || node === document.activeElement;
    if (leavingTab) {
      const target = tabNodeList[e.shiftKey ? tabNodeList.length - 1 : 0];
      target.focus();
      e.preventDefault();
    }
  }
}

// src/dom/style-checker.ts
var isStyleNameSupport = (styleName) => {
  if (can_use_dom_default() && window.document.documentElement) {
    const styleNameList = Array.isArray(styleName) ? styleName : [styleName];
    const { documentElement } = window.document;
    return styleNameList.some((name) => name in documentElement.style);
  }
  return false;
};
var isStyleValueSupport = (styleName, value) => {
  if (!isStyleNameSupport(styleName))
    return false;
  const ele = document.createElement("div");
  const origin = ele.style[styleName];
  ele.style[styleName] = value;
  return ele.style[styleName] !== origin;
};
function isStyleSupport(styleName, styleValue) {
  if (!Array.isArray(styleName) && styleValue !== void 0)
    return isStyleValueSupport(styleName, styleValue);
  return isStyleNameSupport(styleName);
}

// src/dom/support.ts
var animationEndEventNames = {
  WebkitAnimation: "webkitAnimationEnd",
  OAnimation: "oAnimationEnd",
  animation: "animationend"
};
var transitionEventNames = {
  WebkitTransition: "webkitTransitionEnd",
  OTransition: "oTransitionEnd",
  transition: "transitionend"
};
function supportEnd(names) {
  const el = document.createElement("div");
  for (const name in names) {
    if (names.hasOwnProperty(name) && el.style[name] !== void 0) {
      return {
        end: names[name]
      };
    }
  }
  return false;
}
var animation = can_use_dom_default() && supportEnd(animationEndEventNames);
var transition = can_use_dom_default() && supportEnd(transitionEventNames);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  addClass,
  animation,
  backLastFocusNode,
  clearContainerCache,
  clearLastFocusNode,
  contains,
  findDOMNode,
  findDomNode,
  getClientSize,
  getCss,
  getDocSize,
  getFocusNodeList,
  getOffset,
  getOuterHeight,
  getOuterWidth,
  getScroll,
  hasClass,
  injectCSS,
  isStyleSupport,
  isValidElement,
  isVisible,
  limitTabRange,
  removeCSS,
  removeClass,
  saveLastFocusNode,
  setCss,
  styleNames,
  transition,
  updateCSS
});
